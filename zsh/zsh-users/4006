From zsh-users-return-4006-mason-zsh=primenet.com.au@sunsite.dk Fri Jul 06 08:25:53 2001
Return-Path: <zsh-users-return-4006-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22939 invoked from network); 6 Jul 2001 08:25:51 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 6 Jul 2001 08:25:51 -0000
Received: (qmail 4769 invoked by alias); 6 Jul 2001 08:24:33 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4006
Received: (qmail 4744 invoked from network); 6 Jul 2001 08:24:32 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010706082447.ZM11356@candle.brasslantern.com>
Date: Fri, 6 Jul 2001 08:24:47 +0000
In-Reply-To: <20010706063230.6788.qmail@web10402.mail.yahoo.com>
Comments: In reply to Felix Rosencrantz <f_rosencrantz@yahoo.com>
        "Re: Using buffer for history-incremental-search-backward" (Jul  5, 11:32pm)
References: <20010706063230.6788.qmail@web10402.mail.yahoo.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Felix Rosencrantz <f_rosencrantz@yahoo.com>,
        zsh-users <zsh-users@sunsite.auc.dk>
Subject: Re: Using buffer for history-incremental-search-backward
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Jul 5, 11:32pm, Felix Rosencrantz wrote:
} Subject: Re: Using buffer for history-incremental-search-backward
}
} I was sort of under the impression that the completion system could
} only complete a single word at time, and not sets of words, like a
} previous command line would be.

It is pretty much oriented around completing the current single word.
However, if that word happens to be the first one on the line (or the
first one in a "command position") then you can safely use that word
as a search key to complete entire commands.  You just need to use the
-U option of compadd to cause that word to be erased and replaced by
the command that was looked up.

For example, this may be enough for your w2k F7 key widget; I confess
not to know how anything on w2k really works:

    #compdef -k menu-select \e[18~
    (( CURRENT == 1 && $#words == 1 )) &&
    compadd -QU "${(@)history[(R)*$words[CURRENT]*]}"

You can try it without the `&& $#words == 1' part, too, but note that
it only completes when the cursor is in the first word.

One problem with the above is that it bypasses the completion function
system, so you don't get the benefit of all the context analysis that
goes on in _main_complete et al.  For that you need to tie in:

    #compdef -k menu-select \e[18~
    # The following depends on the FUNCTION_ARGZERO option.
    # Use the file base name instead of $0 if that's not set.
    if [[ $_comps[-command-] != $0 ]]; then
        # We've not been called before, so:
	#  set a trap to restore state safely ...
	trap "_comps[-command-]='$_comps[-command-]'" EXIT INT
	#  make ourself be called for command words ...
	_comps[-command-]=$0
	#  and then call the regular completion system.
	_main_complete
    else
	# The completion system has called us back; add matches.
	compadd -QU "${(@)history[(R)*$words[CURRENT]*]}"
    fi

} But what if I had a command that only has long options that I
} wanted to complete all at once as a group ( for example for GNU tar
} "--extract --gzip --file archive" , "--create --gzip --file archive",
} etc.) Can the completion system handle that?

As long as what you need to replace is only one word, the thing that
replaces it can have more than one word.

} Thanks very much, Bart, for your help with the h-i-s-b, it works just
} like I want.

You're welcome!

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

