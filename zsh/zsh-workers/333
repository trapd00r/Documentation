From zsh-workers-request@math.gatech.edu  Sun Aug 20 09:52:32 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.mira.net.au (8.6.12/8.6.9) with SMTP id JAA06940 for <mason@werple.mira.net.au>; Sun, 20 Aug 1995 09:52:27 +1000
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA11857
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Sat, 19 Aug 1995 19:52:07 -0400
Received: by math (5.x/SMI-SVR4)
	id AA21711; Sat, 19 Aug 1995 19:47:10 -0400
Resent-Date: Sun, 20 Aug 1995 01:48:38 +0200 (MET DST)
Old-Return-Path: <hzoli@cs.elte.hu>
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199508192348.BAA29860@bolyai.cs.elte.hu>
Subject: unfunction fix
To: zsh-workers@math.gatech.edu (zsh-workers)
Date: Sun, 20 Aug 1995 01:48:38 +0200 (MET DST)
X-Mailer: ELM [version 2.4 PL24]
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"cDkzZ.0.9J5.zVdDm"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/333
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

unfunction was the same as unhash so far.  This means that for example
unfunction -m '*' removed everything from the command hash table not
only the functions.  The simple patch below fixes it.  It adds a new -f
optino to unhash, and unfunction is the same as unhash -f.

When a function is removed unhash will check if there is a command in the
path with the same name and if it finds one, it puts it into the hash table
if the HASH_CMDS option is set.

Zoltan

*** 1.27	1995/07/24 17:07:11
--- Src/builtin.c	1995/08/19 21:04:16
***************
*** 187,194 ****
      {"ulimit", bin_ulimit, 0, 1, 0, 0, "HSacdflmnopstv", NULL},
      {"umask", bin_umask, 0, 1, 0, 0, NULL, NULL},
      {"unalias", bin_unalias, 1, -1, 0, 0, "m", NULL},
!     {"unfunction", bin_unhash, 1, -1, 0, 0, "m", NULL},
!     {"unhash", bin_unhash, 1, -1, 0, 0, "m", NULL},
      {"unlimit", bin_unlimit, 0, -1, 0, 0, "h", NULL},
      {"unset", bin_unset, 1, -1, 0, 0, "m", NULL},
      {"unsetopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 1, "0123456789BCDEFGHIJKLMNOPQRSTUWXYZabefghjklmnopsuvwxy", NULL},
--- 187,194 ----
      {"ulimit", bin_ulimit, 0, 1, 0, 0, "HSacdflmnopstv", NULL},
      {"umask", bin_umask, 0, 1, 0, 0, NULL, NULL},
      {"unalias", bin_unalias, 1, -1, 0, 0, "m", NULL},
!     {"unfunction", bin_unhash, 1, -1, 0, 0, "m", "f"},
!     {"unhash", bin_unhash, 1, -1, 0, 0, "mf", NULL},
      {"unlimit", bin_unlimit, 0, -1, 0, 0, "h", NULL},
      {"unset", bin_unset, 1, -1, 0, 0, "m", NULL},
      {"unsetopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 1, "0123456789BCDEFGHIJKLMNOPQRSTUWXYZabefghjklmnopsuvwxy", NULL},
***************
*** 3784,3791 ****
  		for (t = 0; t < n; t++)
  		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
  			nchn = (Cmdnam) chn->next;
! 			if (domatch(chn->nam, com, 0) && !(chn->flags & BUILTIN))
! 			    cmdnamtab->freenode(cmdnamtab->removenode(cmdnamtab, chn->nam));
  		    }
  	    }
  	}
--- 3784,3797 ----
  		for (t = 0; t < n; t++)
  		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
  			nchn = (Cmdnam) chn->next;
! 			if (domatch(chn->nam, com, 0) &&
! 			    !(chn->flags & BUILTIN) &&
! 			    (!ops['f'] || chn->flags & SHFUNC)) {
! 			    dat = cmdnamtab->removenode(cmdnamtab, chn->nam);
! 			    if (ops['f'] && isset(HASHCMDS))
! 				hashcmd(chn->nam, path);
! 			    cmdnamtab->freenode(dat);
! 			}
  		    }
  	    }
  	}
***************
*** 3794,3800 ****
  	while (*argv) {
  	    if (!strncmp(*argv, "TRAP", 4))
  		unsettrap(getsignum(*argv + 4));
! 	    if ((dat = cmdnamtab->removenode(cmdnamtab, *argv++)))
  		cmdnamtab->freenode(dat);
  	}
      }
--- 3800,3815 ----
  	while (*argv) {
  	    if (!strncmp(*argv, "TRAP", 4))
  		unsettrap(getsignum(*argv + 4));
! 	    if (ops['f']) {
! 		Cmdnam chn = (Cmdnam) cmdnamtab->getnode(cmdnamtab, *argv);
! 
! 		if (chn->flags & SHFUNC) {
! 		    cmdnamtab->freenode(cmdnamtab->removenode(cmdnamtab, *argv));
! 		    if (isset(HASHCMDS))
! 			hashcmd(*argv, path);
! 		    argv++;
! 		}
! 	    } else if ((dat = cmdnamtab->removenode(cmdnamtab, *argv++)))
  		cmdnamtab->freenode(dat);
  	}
      }
*** 1.10	1995/07/10 18:27:53
--- Doc/zshbuiltins.1	1995/08/19 21:28:48
***************
*** 228,234 ****
  \-\fBm\fP flag the arguments are taken as patterns (should be quoted
  to preserve them from being taken as glob patterns) and all builtins
  matching these patterns are disabled.
- Actually the same as \fBunhash\fP.
  Builtins can be enabled with the \fBenable\fP command.
  .TP
  .PD 0
--- 228,233 ----
***************
*** 1010,1024 ****
  quoted) and all aliases with matching names are removed.
  .TP
  \fBunfunction\fP [ \-\fBm\fP ] \fIname\fP ...
! The function definition, if any, for each \fIname\fP is removed.
! If the \-\fBm\fP flag is specified the arguments are taken as patterns
! (should be quoted) and all functions with matching names are removed.
  .TP
! \fBunhash\fP [ \-\fBm\fP ] \fIname\fP ...
  The entry in the command hash table, if any, for each \fIname\fP
  is removed. If the \-\fBm\fP flag is given the arguments are taken as
  patterns (should be quoted) and all entries for commands with matching
! names will be removed.
  .TP
  \fBunlimit\fP [ \-\fBh\fP ] \fIresource\fP ...
  The resource limit for each \fIresource\fP is set to the hard limit.
--- 1009,1022 ----
  quoted) and all aliases with matching names are removed.
  .TP
  \fBunfunction\fP [ \-\fBm\fP ] \fIname\fP ...
! Same as \fBunhash \-f\fP.
  .TP
! \fBunhash\fP [ \-\fBfm\fP ] \fIname\fP ...
  The entry in the command hash table, if any, for each \fIname\fP
  is removed. If the \-\fBm\fP flag is given the arguments are taken as
  patterns (should be quoted) and all entries for commands with matching
! names will be removed.  With the \-\fBf\fP flag only function definitions
! are removed.
  .TP
  \fBunlimit\fP [ \-\fBh\fP ] \fIresource\fP ...
  The resource limit for each \fIresource\fP is set to the hard limit.

