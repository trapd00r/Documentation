From zsh-users-return-9735-mason-zsh=primenet.com.au@sunsite.dk Fri Dec 02 11:40:05 2005
Return-Path: <zsh-users-return-9735-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18924 invoked from network); 2 Dec 2005 11:40:02 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.0 (2005-09-13) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00,
	FORGED_RCVD_HELO autolearn=ham version=3.1.0
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 2 Dec 2005 11:40:02 -0000
Received: (qmail 69817 invoked from network); 2 Dec 2005 11:39:55 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 2 Dec 2005 11:39:55 -0000
Received: (qmail 28763 invoked by alias); 2 Dec 2005 11:39:48 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 9735
Received: (qmail 28754 invoked from network); 2 Dec 2005 11:39:47 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 2 Dec 2005 11:39:47 -0000
Received: (qmail 68753 invoked from network); 2 Dec 2005 11:39:47 -0000
Received: from cluster-c.mailcontrol.com (HELO rly20c.srv.mailcontrol.com) (168.143.177.190)
  by a.mx.sunsite.dk with SMTP; 2 Dec 2005 11:39:46 -0000
Received: from exchange03.csr.com (uuk202166.uk.customer.alter.net [62.189.241.194] (may be forged))
	by rly20c.srv.mailcontrol.com (MailControl) with ESMTP id jB2BZVi7012099
	for <zsh-users@sunsite.dk>; Fri, 2 Dec 2005 11:39:40 GMT
Received: from news01.csr.com ([10.103.143.38]) by exchange03.csr.com with Microsoft SMTPSVC(5.0.2195.6713);
	 Fri, 2 Dec 2005 11:38:05 +0000
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.1/8.12.11) with ESMTP id jB2Bc3F6018057
	for <zsh-users@sunsite.dk>; Fri, 2 Dec 2005 11:38:04 GMT
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.1/8.13.1/Submit) with ESMTP id jB2BbwdK018051
	for <zsh-users@sunsite.dk>; Fri, 2 Dec 2005 11:38:00 GMT
Message-Id: <200512021138.jB2BbwdK018051@news01.csr.com>
To: zsh-users@sunsite.dk (Zsh users list)
Subject: Functions using zsh/datetime
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="----- =_aaaaaaaaaa0"
Content-ID: <17826.1133523174.0@csr.com>
Date: Fri, 02 Dec 2005 11:37:56 +0000
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 02 Dec 2005 11:38:05.0732 (UTC) FILETIME=[DC5C3E40:01C5F734]
X-Scanned-By: MailControl A-05-40-01 (www.mailcontrol.com) on 10.67.0.130

------- =_aaaaaaaaaa0
Content-Type: text/plain; charset="us-ascii"
Content-ID: <17826.1133523174.1@csr.com>

Here are three functions that use the zsh/datetime module; one day they
may appear in Functions/Datetime but just in case I abandon them I
thought I'd better post them in the current fairly rough and not very
well documented state.

asched is an asynchronous version of the sched builtin.  The syntax is
the same.  It doesn't make use of jobs at the moment (jobs get created
anyway in a shell with the monitor option set, but the function uses
PIDs) since they're not that easy to access from a function (there's no
way to get the last job started in the background, unlike the last
process).

matchtime attempts to match a date string against a number of seconds
since the epoch (as returned by zsh/datetime's $EPOCHSECONDS).

calendar uses matchtime to implement the decreasingly standard
external command of the same name, with a few extensions including the
ability to use asched to create messages.

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


This message has been scanned for viruses by BlackSpider MailControl - www.blackspider.com

------- =_aaaaaaaaaa0
Content-Type: text/plain; name="asched"; charset="us-ascii"
Content-ID: <17826.1133523174.2@csr.com>
Content-Description: asched function

# Asynchronous variant of sched.
# The syntax is the same.
#
# TODO: would be better if we could use job handling directly
# but the programming interface to that isn't great, so currently
# it uses processes (though these will be in jobs if the monitor
# option is set).
emulate -L zsh
setopt extendedglob

zmodload -i zsh/datetime || return 1

integer -g ASCHED_JOB
typeset -ga asched_processes

local strtime proc
integer now=$EPOCHSECONDS hhour hour mminute minute diff time i procwid
local -a match mbegin mend

# Use guesswork to decide whether the process has been run.
for (( i = 1; i <= ${#asched_processes}; i++ )); do
  time=${${asched_processes[$i]##<-> #}%% *}
  if (( now > time )); then
    # it's all over
    asched_processes[$i]=
  fi
done

if [[ $1 = -(#b)(<->) ]]; then
  local killproc="${asched_processes[$match[1]]%% *}"
  if [[ -n $killproc ]]; then
    kill $killproc
    asched_processes[$match[1]]=
  else
    print -r "asched: no such asched job or time already past"
  fi
elif (( $# == 0 )); then
  # the width of the length of the array, for padding...
  procwid=${#:-${#asched_processes}}
  for (( i = 1; i <= ${#asched_processes}; i++ )); do
    proc=${asched_processes[$i]}
    if [[ -n $proc ]]; then
      print "${(l.$procwid.)i} ${proc##<-> #<-> #}"
    fi
  done
  return 0
elif [[ $1 != (#b)(+|)(<->):(<->) || $# -lt 2 ]]; then
  print "Usage: asched [+]HH:MM job
asched [ -<item> ]" >&2
  return 1
fi

shift
local job="$*"

hhour=$match[2]
mminute=$match[3]

if [[ -n $match[1] ]]; then
  # relative
  (( diff = (hhour * 60 + mminute) * 60 ))
else
  # absolute, so work out when now is.
  # assume today, so if it's in the past run job immediately.
  strftime -s hour %H $now
  strftime -s minute %M $now

  (( diff = ((hhour - hour) * 60 + mminute - minute) * 60 ))
  if (( diff < 0 )); then
    # do it in subshell since user expects this not to affect main shell
    (eval $job)
    return 0
  fi
fi

(( ASCHED_JOB++ ))
(( time = now + diff ))
strftime -s strtime "%a %b %d %H:%M:%S" $time

eval "(: asched job $ASCHED_JOB
sleep $diff; $job) &"
# Format: background task, Epoch time, string time, job name.
# The last two are for human consumption.
asched_processes[$ASCHED_JOB]="$! $time $strtime $job"

------- =_aaaaaaaaaa0
Content-Type: text/plain; name="matchtime"; charset="us-ascii"
Content-ID: <17826.1133523174.3@csr.com>
Content-Description: matchtime function

# Input: a line and an epoch time, which defaults to now.
# Returns: 0 if the line contains today's date, else 1.
# Tries various date formats: see comments below.
# (Should really be called matchdate, in fact.)
#
# TODO: can get confused about DAY MONTH YEAR and MONTH DAY YEAR,
# could use locale as some kind of hint.  (User can help by using
# 1st, 2nd, 3rd, 4th, ... for day, or by using ISOesque
# 2005-12-02.)
#
# If -t is passed, look for a time in the format HH:MM (must be in the 24-hour
# clock at the moment) attached to the date.  If it's greater than or equal
# to the epoch time, set REPLY to HH:MM.  This is intended to be used
# to set a job for the given time.

emulate -L zsh
setopt extendedglob

zmodload -i zsh/datetime || return 1

integer checktime
local opt

while getopts "t" opt; do
  case $opt in
    (t)
    checktime=1
    ;;
  esac
done
shift $(( OPTIND - 1 ))

local line=$1
integer now=${2:-$EPOCHSECONDS} stat=1 patstart patend
local -a match mbegin mend

local year monthnum monthname day hour minute hhour mminute

strftime -s year %Y $now
strftime -s monthnum %m $now
monthnum=${monthnum##0}
strftime -s monthname %b $now
strftime -s day %d $now
day=${day##0}
strftime -s hour %H $now
strftime -s minute %M $now

case $line in
  # Look for DAY[th/st/rd] MONTH[,] YEAR
  (*(#b)((#i)((#s)|[[:blank:]])0#${day}(|rd|st|th)[[:blank:]]##(${monthname}[a-z]#|0#${monthnum})[,[:blank:]]##(${year}|${year[-2,-1]})([[:blank:],\;:.]|(#e)))*)
  stat=0
  ;;

  # Look for MONTH DAY[th/st/rd][,] YEAR
  (*(#b)((#i)((#s)|[[:blank:]])(${monthname}[a-z]#|0#${monthnum})[[:blank:]]##0#${day}(|rd|st|th)[,[:blank:]]##(${year}|${year[-2,-1]})([[:blank:],\;:.]|(#e)))*)
  stat=0
  ;;

  # Look for YEAR[-]MONTH[-]DAY
  (*(#b)((#i)((#s)|[[:blank:]])(${year}|${year[-2,-1]})[-]#(${monthname}[a-z]#|0#${monthnum})[-]#0#${day}([[:blank:],\;:.]|(#e)))*)
  stat=0
  ;;
esac

(( stat != 0 )) && return 1

if (( checktime )); then
  REPLY=
  patstart=$mbegin[1]
  patend=$mend[1]
  if [[ $patstart -gt 1 && $line[1,$patstart-1] = *((#s)|[[:blank:]])(#b)(<->):(<->)[[:blank:],\;:.]# ]]; then
    hhour=$match[1]
    mminute=$match[2]
  elif [[ $patend -lt ${#line} && $line[$patend+1,-1] = [[:blank:],\;:.]#(#b)(<->):(<->)(|[[:blank:]]*) ]]; then
    hhour=$match[1]
    mminute=$match[2]
  fi

  # assume 24-hour clock for now
  if [[ -n $hhour$mminute ]] && (( hour < hhour || (hour == hhour && minute <= mminute ) )); then
    REPLY=${hhour}:${mminute}
  fi
fi

return 0

------- =_aaaaaaaaaa0
Content-Type: text/plain; name="calendar"; charset="us-ascii"
Content-ID: <17826.1133523174.4@csr.com>
Content-Description: calendar function

emulate -L zsh
setopt extendedglob

local line opt REPLY
local calendar sched showprog
integer time
local -a times

zmodload -i zsh/datetime || return 1
zmodload -i zsh/zutil || return 1

# Read the calendar file from the calendar-file style
zstyle -s ':datetime:calendar:' calendar-file calendar || calendar=~/calendar
# Read the programme to show the message from the show-prog style.
# (Requires option -a or -s to be useful.)
zstyle -s ':datetime:calendar:' show-prog showprog || showprog="print -r"

[[ -f $calendar ]] || return 1

while getopts "aC:sS:x" opt; do
  case $opt in
    # Use the "asched" function to generate a message asynchronously.
    (a)
    sched=asched
    ;;

    (C)
    # Pick the calendar file, overriding style and default.
    calendar=$OPTARG
    ;;

    (s)
    # Use the "sched" builtin to generate a message before a prompt.
    sched=sched
    ;;

    (S)
    # Explicitly specify a show programme, overriding style and default.
    showprog=$OPTARG
    ;;

    (x)
    # Use xmessage as the show programme.  Best used with -a.
    showprog=xmessage
    ;;

    (*)
    return 1
    ;;
  esac
done
shift $(( OPTIND - 1 ))

time=$EPOCHSECONDS
# search today and tomorrow
times=($time $(( time + 24*60*60 )))

autoload -Uz matchtime

while read -r line; do
  if matchtime -t $line $times[1]; then
    print -r $line
    if [[ -n $sched && -n $REPLY ]]; then
      # eval needed in place of closures on REPLY and line.
      # i like perl.
      eval "function sched_$REPLY {
	unfunction sched_$REPLY
	$showprog \"Calendar entry is now due: \" ${(q)line} >&$TTY
      }"
      $sched $REPLY sched_$REPLY
    fi
  else
    for time in ${times[2,-1]}; do
      matchtime -t $line $time && print -r $line && break
    done
  fi
done <$calendar

return 0

------- =_aaaaaaaaaa0--

