From zsh-workers-return-5329-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Feb 09 11:43:08 1999
Return-Path: <zsh-workers-return-5329-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8655 invoked from network); 9 Feb 1999 11:43:06 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Feb 1999 11:43:06 -0000
Received: (qmail 12810 invoked by alias); 9 Feb 1999 11:42:45 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5329
Received: (qmail 12803 invoked from network); 9 Feb 1999 11:42:43 -0000
Message-Id: <9902091126.AA65540@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: zsh-3.1.5-pws-7: yet more signames
In-Reply-To: ""Matt Armstrong""'s message of "Mon, 08 Feb 1999 23:01:14 NFT."
             <19990209070114.5787.qmail@hotmail.com> 
Date: Tue, 09 Feb 1999 12:26:23 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>

"Matt Armstrong" wrote:
> The signal.h on a cygwin system can be pretty much anywhere.  On my
> machine it is at
> /cygnus/cygwin-b20/H-i586-cygwin32/i586-cygwin32/include/sys/signal.h.

Yuk.  The trouble is, you definitely need the original list of names.
See below.

> Also, if the point is to support cross compiling, I don't think the
> fixed list of header locations in configure.in will cut it.

Yes, no argument here.

Plan #3 (which uses plan #2 of yesterday) goes one better by
#include'ing signal.h when configuring, and looking at what cpp
produces to find out what files are actually included.  This list is
then checked for signal definitions.  In principal this can fix
cross-compilation worries, though it requires that $CPP is set to a
preprocessor with the correct include path built into it, and that I
don't know about.  Also, we're at the mercy of output formats for
cpp. I've assumed that it will always look like
#<space or tab><anything>"<name here>"
--- does anyone know of a recalcitrant preprocessor?  Anyway, I left
the old list there as a backup, so we should be no worse off.

One other fix: now that we can rely on the signal number being
replaced only for real signals, I have widened the test in
signames1.awk so that it will match any #define SIG... without a
parenthesis next, and so long as that expands to a number later on we
get the signal.  Again, it's possible some very unfriendly definitions
can mess this about.  It requires, for example, that the `real'
definition comes first.  For example,

#define	SIGABRT    6	/* (*) abort process */
#define SIGIOT  SIGABRT /* abort (terminate) process */ 

still works OK because it gets to SIGABRT first and so doesn't try to
assign SIGIOT to signal 6.  (Arguably zsh should know that SIGIOT
should be a synonym for SIGABRT, but that's a different question.)

Another subtlety I found on SunOS:

#define _SIGRTMIN 38    /* first (highest-priority) realtime signal */
#define SIGRTMIN _sysconf(_SC_SIGRT_MIN)        /* first realtime signal */

Here, to get anything, we need to use the former --- this corresponds
with what's in the native csh.  I've allowed signames1.awk to use
_SIGXXX as if it were SIGXXX.  This used to happen before.  The first
definition encountered will be used.

I have had good results with this on: AIX 3.2, HPUX 10/20, IRIX 6.2,
SunOS 5.6 with the comment above (all, however, with gcc, though I
checked the form of the cc -E output), but it certainly needs testing
as widely as possible.

--- Src/signames1.awk.sn3	Mon Feb  8 18:07:02 1999
+++ Src/signames1.awk	Tue Feb  9 12:18:56 1999
@@ -1,9 +1,19 @@
+# This is an awk script which finds out what the possibilities for
+# the signal names are, and dumps them out so that cpp can turn them
+# into numbers.  Since we don't need to decide here what the
+# real signals are, we can afford to be generous about definitions,
+# in case the definitions are in terms of other definitions.
+# However, we need to avoid definitions with parentheses, which will
+# mess up the syntax.
 BEGIN { printf "#include <signal.h>\n\n" }
 
-/^[\t ]*#[\t ]*define[\t _]*SIG[A-Z][A-Z0-9]*[\t ]*[1-9][0-9]*/ { 
+/^[\t ]*#[\t ]*define[\t _]*SIG[A-Z][A-Z0-9]*[\t ][\t ]*[^(\t ]/ { 
     sigindex = index($0, "SIG")
     sigtail = substr($0, sigindex, 80)
     split(sigtail, tmp)
     signam = substr(tmp[1], 4, 20)
-    printf("XXNAMES XXSIG%s SIG%s\n", signam, signam)
+    if (substr($0, sigindex-1, 1) == "_")
+        printf("XXNAMES XXSIG%s _SIG%s\n", signam, signam)
+    else
+        printf("XXNAMES XXSIG%s SIG%s\n", signam, signam)
 }
--- configure.in.sn3	Mon Feb  8 10:43:29 1999
+++ configure.in	Tue Feb  9 12:03:49 1999
@@ -664,12 +664,27 @@
 
 dnl Where is <signal.h> located?  Needed as input for signals.awk
 AC_CACHE_CHECK(where signal.h is located, zsh_cv_path_signal_h,
-[for SIGNAL_H in /usr/include/bsd/sys/signal.h  dnl Next
-                 /usr/include/asm/signum.h      dnl alpha-Linux
-                 /usr/include/asm/signal.h      dnl Linux 1.3.0 and above
-                 /usr/include/linux/signal.h    dnl Linux up to 1.2.11
-                 /usr/include/sys/signal.h      dnl Almost everybody else
-                 /dev/null;                     dnl Just in case we fall through
+[dnl Look at the output from the preprocessor.
+dnl We should get lines of the form `# 1 "/usr/include/signal.h"'
+dnl The following assumes the real definitions are in a file which
+dnl contains the name `sig'; we could relax this if necessary,
+dnl but then you can get a rather long list of files to test.
+echo "#include <signal.h>" > nametmp.c
+sigfile_list="`$CPP nametmp.c | sed -n -e 's/^#[ 	].*\"\(.*\)\"/\1/p' |
+$AWK '{ if (\$1 ~ \"sig\") files[[\$1]] = \$1 }
+  END { for (var in files) print var }'`"
+rm -f nametmp.c
+if test -z "$sigfile_list"; then
+  dnl In case we don't get the stuff from the preprocesor, use the old
+  dnl list of standard places.
+  sigfile_list="/usr/include/bsd/sys/signal.h
+/usr/include/asm/signum.h
+/usr/include/asm/signal.h
+/usr/include/linux/signal.h
+/usr/include/sys/signal.h
+/dev/null"
+fi
+for SIGNAL_H in $sigfile_list
 do
   test -f $SIGNAL_H && \
   grep '#[ 	]*define[ 	][ 	]*SIG[0-9A-Z]*[ 	]*[0-9][0-9]*' $SIGNAL_H > /dev/null && \

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

