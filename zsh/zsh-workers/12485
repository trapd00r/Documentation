From zsh-workers-return-12485-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Aug 02 12:09:00 2000
Return-Path: <zsh-workers-return-12485-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21197 invoked from network); 2 Aug 2000 12:08:55 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 2 Aug 2000 12:08:55 -0000
Received: (qmail 8713 invoked by alias); 2 Aug 2000 12:08:46 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12485
Received: (qmail 8706 invoked from network); 2 Aug 2000 12:08:46 -0000
Date: Wed, 2 Aug 2000 14:08:42 +0200 (MET DST)
Message-Id: <200008021208.OAA11394@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 1 Aug 2000 15:09:53 +0000
Subject: Re: Open bugs and questions?


Bart Schaefer wrote:

> ...
> 
> } 12054, 12071
> }   There is no way to handle ^D at the beginning of the line with a
> }   widget, because the zle main loop deals with it directly.
> 
> It *is* possible to handle ^D at beginning of line:  stty eof undef
> permits it.  This is equivalent to having to turn off flow control in
> order to use ^S and ^Q in keybindings.
> 
> So maybe the right answer is that `setopt ignoreeof' should affect ZLE
> the same way that `setopt noflowcontrol' does.  An actual zero-byte
> read would still be handled as it currently is; only ^D in column zero
> would be different (actually invoke the ^D binding rather than print
> "zsh: use 'logout' to logout.").
> 
> THEN we could change delete-char-or-list to print that warning when there
> are no characters in the editor buffer, et voila: the default behavior is
> exactly as now.

I didn't even needed to mess with the tty settings, changing the test
for eofchar was enough.

I've put the message-display into the zle main loop, invoked for every 
widget that calls an internally implemented widget. Note that this
includes completion widgets (which call the widget mentioned in the
`zle -C' call). This should make it really independent of the widget
bound to ^D for everyone who hasn't bound a shell-function widget to
it.

But now we can do:

  my-eof() {
  if [[ -n "$PREBUFFER$BUFFER" ]]; then
    zle delete-char-or-list
  else
    (( ++exit_count == 5 )) && exit
    zle -M "$exit_count. time"
  fi
  }
  zle -N my-eof
  bindkey '^D' my-eof

Except that there should be a history-write before the exit. And the
counter should probably be reset in precmd or something.


The `use 'exit' to exit' message is displayed slightly differently:
below the prompt without displaying a new prompt. Is that ok?

Hm, because of that and the shell-function widget thing, I'll wait
before committing it.

Bye
 Sven

Index: Doc/Zsh/options.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/options.yo,v
retrieving revision 1.10
diff -u -r1.10 options.yo
--- Doc/Zsh/options.yo	2000/07/19 21:37:18	1.10
+++ Doc/Zsh/options.yo	2000/08/02 12:01:30
@@ -573,6 +573,11 @@
 of tt(exit) or tt(logout) instead.
 However, ten consecutive EOFs will cause the shell to exit anyway,
 to avoid the shell hanging if its tty goes away.
+
+Also, if this option is set and the Zsh Line Editor is used, widgets
+implemented by shell functions can be bound to EOF (normally
+Control-D) without printing the normal warning message.  This works
+only for normal widgets, not for completion widgets.
 )
 pindex(INC_APPEND_HISTORY)
 cindex(history, incremental appending to a file)
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.8
diff -u -r1.8 zle_main.c
--- Src/Zle/zle_main.c	2000/07/27 17:48:48	1.8
+++ Src/Zle/zle_main.c	2000/08/02 12:01:31
@@ -76,7 +76,10 @@
 /**/
 int insmode;
 
-static int eofchar, eofsent;
+/**/
+mod_export int eofchar;
+
+static int eofsent;
 static long keytimeout;
 
 #ifdef HAVE_SELECT
@@ -556,7 +559,7 @@
 	reselectkeymap();
 	selectlocalmap(NULL);
 	bindk = getkeycmd();
-	if (!ll && isfirstln && c == eofchar) {
+	if (!ll && isfirstln && unset(IGNOREEOF) && c == eofchar) {
 	    eofsent = 1;
 	    break;
 	}
@@ -630,26 +633,32 @@
     } else if((w = func->widget)->flags & (WIDGET_INT|WIDGET_NCOMP)) {
 	int wflags = w->flags;
 
-	if(!(wflags & ZLE_KEEPSUFFIX))
-	    removesuffix();
-	if(!(wflags & ZLE_MENUCMP)) {
-	    fixsuffix();
-	    invalidatelist();
+	if (keybuf[0] == eofchar && !keybuf[1] &&
+	    !ll && isfirstln && isset(IGNOREEOF)) {
+	    showmsg((!islogin) ? "use 'exit' to exit." : "use 'logout' to logout.");
+	    ret = 1;
+	} else {
+	    if(!(wflags & ZLE_KEEPSUFFIX))
+		removesuffix();
+	    if(!(wflags & ZLE_MENUCMP)) {
+		fixsuffix();
+		invalidatelist();
+	    }
+	    if (wflags & ZLE_LINEMOVE)
+		vilinerange = 1;
+	    if(!(wflags & ZLE_LASTCOL))
+		lastcol = -1;
+	    if (wflags & WIDGET_NCOMP) {
+		int atcurhist = histline == curhist;
+		compwidget = w;
+		ret = completecall(args);
+		if (atcurhist)
+		    histline = curhist;
+	    } else
+		ret = w->u.fn(args);
+	    if (!(wflags & ZLE_NOTCOMMAND))
+		lastcmd = wflags;
 	}
-	if (wflags & ZLE_LINEMOVE)
-	    vilinerange = 1;
-	if(!(wflags & ZLE_LASTCOL))
-	    lastcol = -1;
-	if (wflags & WIDGET_NCOMP) {
-	  int atcurhist = histline == curhist;
-	    compwidget = w;
-	    ret = completecall(args);
-	    if (atcurhist)
-		histline = curhist;
-	} else
-	    ret = w->u.fn(args);
-	if (!(wflags & ZLE_NOTCOMMAND))
-	    lastcmd = wflags;
 	r = 1;
     } else {
 	Eprog prog = getshfunc(w->u.fnnam);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

