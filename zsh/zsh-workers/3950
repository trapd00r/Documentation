From zsh-workers-request@math.gatech.edu Fri May 08 06:31:54 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21653 invoked from network); 8 May 1998 06:31:52 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 8 May 1998 06:31:52 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id CAA10558;
	Fri, 8 May 1998 02:25:43 -0400 (EDT)
Resent-Date: Fri, 8 May 1998 02:25:43 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199805080623.BAA02616@hzoli.home>
Subject: PATCH: set blocking read on stdin
To: zsh-workers@math.gatech.edu (Zsh hacking and development)
Date: Fri, 8 May 1998 01:23:15 -0500 (CDT)
X-Mailer: ELM [version 2.4ME+ PL31 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"SO0wu2.0.va2.0KgKr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3950
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

This patch sets blocking read on stdin when the shell reads commands from
there or when it is used by the read builtin.  This is required by POSIX.

Zoli


*** Src/builtin.c.orig	Fri May  8 01:04:12 1998
--- Src/builtin.c	Fri May  8 01:15:15 1998
*************** bin_read(char *name, char **args, char *
*** 3175,3181 ****
  static int
  zread(void)
  {
!     char cc;
  
      /* use zbuf if possible */
      if (zbuf)
--- 3175,3181 ----
  static int
  zread(void)
  {
!     char cc, retry = 0;
  
      /* use zbuf if possible */
      if (zbuf)
*************** zread(void)
*** 3186,3197 ****
  	    return zbuf++, STOUC(*zbuf++ ^ 32);
  	else
  	    return (*zbuf) ? STOUC(*zbuf++) : EOF;
!     /* read a character from readfd */
!     if (read(readfd, &cc, 1) != 1)
! 	/* on EOF, return EOF */
  	return EOF;
!     /* return the character read */
!     return STOUC(cc);
  }
  
  /* holds arguments for testlex() */
--- 3186,3207 ----
  	    return zbuf++, STOUC(*zbuf++ ^ 32);
  	else
  	    return (*zbuf) ? STOUC(*zbuf++) : EOF;
!     for (;;) {
! 	/* read a character from readfd */
! 	switch (read(readfd, &cc, 1)) {
! 	case 1:
! 	    /* return the character read */
! 	    return STOUC(cc);
! 	case -1:
! 	    if (!retry && errno == EWOULDBLOCK &&
! 		readfd == 0 && setblock_stdin()) {
! 		retry = 1;
! 		continue;
! 	    }
! 	    break;
! 	}
  	return EOF;
!     }
  }
  
  /* holds arguments for testlex() */
*** Src/init.c.orig	Sat May  2 03:45:37 1998
--- Src/init.c	Fri May  8 01:15:15 1998
*************** loop(int toplevel, int justonce)
*** 88,95 ****
      for (;;) {
  	freeheap();
  	errflag = 0;
! 	if (interact && isset(SHINSTDIN))
! 	    preprompt();
  	hbegin();		/* init history mech        */
  	intr();			/* interrupts on            */
  	lexinit();              /* initialize lexical state */
--- 88,98 ----
      for (;;) {
  	freeheap();
  	errflag = 0;
! 	if (isset(SHINSTDIN)) {
! 	    setblock_stdin();
! 	    if (interact)
! 		preprompt();
! 	}
  	hbegin();		/* init history mech        */
  	intr();			/* interrupts on            */
  	lexinit();              /* initialize lexical state */
*** Src/utils.c.orig	Sat May  2 03:47:05 1998
--- Src/utils.c	Fri May  8 01:18:58 1998
*************** zstrtol(const char *s, char **t, int bas
*** 1076,1081 ****
--- 1076,1099 ----
  
  /**/
  int
+ setblock_stdin(void)
+ {
+ #ifdef O_NONBLOCK
+     struct stat st;
+     long mode;
+ 
+     if (!fstat(0, &st) && !S_ISREG(st.st_mode)) {
+ 	mode = fcntl(0, F_GETFL);
+ 	if (mode != -1 && (mode & O_NONBLOCK) &&
+ 	    !fcntl(0, F_SETFL, mode & ~O_NONBLOCK))
+ 	    return 1;
+     }
+ #endif
+     return 0;
+ }
+ 
+ /**/
+ int
  checkrmall(char *s)
  {
      fprintf(shout, "zsh: sure you want to delete all the files in ");

