From zsh-workers-return-15509-mason-zsh=primenet.com.au@sunsite.dk Fri Jul 27 12:54:41 2001
Return-Path: <zsh-workers-return-15509-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28735 invoked from network); 27 Jul 2001 12:54:39 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Jul 2001 12:54:39 -0000
Received: (qmail 149 invoked by alias); 27 Jul 2001 12:54:32 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15509
Received: (qmail 138 invoked from network); 27 Jul 2001 12:54:31 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Fri, 27 Jul 2001 14:53:57 +0200 (MET DST)
Message-Id: <200107271253.OAA22242@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: About the new long/short options changes
In-Reply-To: <1010725174948.ZM18736@candle.brasslantern.com>

Bart Schaefer wrote:

> On Jul 25, 10:49am, Sven Wischnowsky wrote:
> } Subject: Re: About the new long/short options changes
> }
> } The result is the patch below, which is already quite satisfying, I
> } think.
> 
> Yes, this (plus the several followups) is quite good.  The only thing
> more I could wish for is that TAB would move down the columns in menu
> selection, rather than across, so that you don't get equivalent options
> offered consecutively.  But that's such a minor thing that it's likely
> not worth expending effort.

But then again it's the kind of extra nicety I like to offer to people
(almost on the same range as auto-removable suffixes).

The patch below does that and finally really cleans up the listpacked
code, making it shorter and much clearer (and not much slower, if at all
(without listrowsfirst it can even be faster)).  And now it can be sure
to always find one of the optimal layouts -- different from before,
that's why I started to fiddle with it.  (And that's the biggest part of
the patch.)

Maybe I'll work that into the 4.0.2 branch sometime (but it wasn't
really a `bug' -- it just sometimes didn't find the best solution).

> My only other suggestion at this point would be to change the default
> separator from `--' to one of `-', `=', or `:', but as it's configurable
> that is again an exceptionally minor issue.

Hm.  I like that at other places where we use the separator string...
but since I could change it for me, I wouldn't be against changing it if
enough people care enought about it to support a change.  Otherwise:
feel free to change it.


Bye
  Sven

Index: Completion/Base/Utility/_describe
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_describe,v
retrieving revision 1.7
diff -u -r1.7 _describe
--- Completion/Base/Utility/_describe	2001/07/25 17:40:31	1.7
+++ Completion/Base/Utility/_describe	2001/07/27 12:46:06
@@ -78,9 +78,9 @@
         fi
     
         if [[ -n $_mats ]]; then
-          compadd "$_opts[@]" "$_expl[@]" -O $_strs -D $_mats -s $_strs
+          compadd "$_opts[@]" "${(@)_expl:/-J/-2V}" -O $_strs -D $_mats -s $_strs
         else
-          compadd "$_opts[@]" "$_expl[@]" -O $_strs -a $_strs
+          compadd "$_opts[@]" "${(@)_expl:/-J/-2V}" -O $_strs -a $_strs
         fi
       done
       set - "$_argv[@]"
@@ -97,6 +97,7 @@
     while compdescribe -g csl2 _args _tmpm _tmpd; do
 
       compstate[list]="$csl $csl2"
+      [[ -n "$csl2" ]] && compstate[list]="${compstate[list]:s/rows//}"
 
       compadd "$_args[@]" -d _tmpd -a _tmpm && _ret=0
     done
Index: Src/Zle/compresult.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compresult.c,v
retrieving revision 1.39
diff -u -r1.39 compresult.c
--- Src/Zle/compresult.c	2001/07/25 08:52:34	1.39
+++ Src/Zle/compresult.c	2001/07/27 12:46:07
@@ -1588,214 +1588,142 @@
 			ylens[i] = ztrlen(*pp) + add;
 
 		    if (g->flags & CGF_ROWS) {
-			int count, tcol, first, maxlines = 0, llines;
-			int beg = columns / g->shortest, end = g->cols;
+                        int nth, tcol, len;
 
-			while (1) {
-			    tcols = (beg + end) >> 1;
+                        for (tcols = columns / (g->shortest + add); tcols > g->cols;
+                             tcols--) {
 
-			    for (nth = first = maxlen = width = maxlines =
-				     llines = tcol = 0,
-				     count = g->dcount;
-				 count > 0; count--) {
-				if (ylens[nth] > maxlen)
-				    maxlen = ylens[nth];
-				nth += tcols;
-				tlines++;
-				if (nth >= g->dcount) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcol++] = maxlen;
-				    maxlen = 0;
-				    nth = ++first;
-				    if (llines > maxlines)
-					maxlines = llines;
-				    llines = 0;
-				}
-			    }
-			    if (nth < yl) {
-				ws[tcol++] = maxlen;
-				width += maxlen;
-			    }
-			    if (!count && width <= columns &&
-				(tcols <= 0 || beg == end))
-				break;
-
-			    if (beg == end) {
-				beg--;
-				end--;
-			    } else if (width < columns) {
-				if ((end = tcols) == beg - 1)
-				    end++;
-			    } else {
-				if ((beg = tcols) - 1 == end)
-				    end++;
-			    }
-			}
-			if (tcols > g->cols)
-			    tlines = maxlines;
+                            memset(ws, 0, tcols * sizeof(int));
+
+                            for (width = nth = tcol = 0, tlines = 1;
+                                 width < columns && nth < g->dcount;
+                                 nth++, tcol++) {
+
+                                m = *p;
+
+                                if (tcol == tcols) {
+                                    tcol = 0;
+                                    tlines++;
+                                }
+                                len = ylens[nth];
+
+                                if (len > ws[tcol]) {
+                                    width += len - ws[tcol];
+                                    ws[tcol] = len;
+                                }
+                            }
+                            if (width < columns)
+                                break;
+                        }
 		    } else {
-			int beg = ((g->totl + columns) / columns);
-			int end = g->lins;
+                        int nth, tcol, tline, len;
 
-			while (1) {
-			    tlines = (beg + end) >> 1;
+                        for (tcols = columns / (g->shortest + add); tcols > g->cols;
+                             tcols--) {
 
-			    for (pp = g->ylist, nth = tline = width =
-				     maxlen = tcols = 0;
-				 *pp; pp++) {
-				if (ylens[nth] > maxlen)
-				    maxlen = ylens[nth];
-				if (++tline == tlines) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcols++] = maxlen;
-				    maxlen = tline = 0;
-				}
-				nth++;
-			    }
-			    if (tline) {
-				ws[tcols++] = maxlen;
-				width += maxlen;
-			    }
-			    if (nth == yl && width <= columns &&
-				(beg == end || tlines >= g->lins))
-				break;
-
-			    if (beg == end) {
-				beg++;
-				end++;
-			    } else if (width < columns) {
-				if ((end = tlines) == beg + 1)
-				    end--;
-			    } else {
-				if ((beg = tlines) + 1 == end)
-				    end--;
-			    }
-			}
-			if (tlines > g->lins)
-			    tlines = g->lins;
+                            if ((tlines = (g->dcount + tcols - 1) / tcols) <= 0)
+                                tlines = 1;
+
+                            memset(ws, 0, tcols * sizeof(int));
+
+                            for (width = nth = tcol = tline = 0;
+                                 width < columns && nth < g->dcount;
+                                 nth++, tline++) {
+
+                                m = *p;
+
+                                if (tline == tlines) {
+                                    tcol++;
+                                    tline = 0;
+                                }
+                                if (tcol == tcols) {
+                                    tcol = 0;
+                                    tlines++;
+                                }
+                                len = ylens[nth];
+
+                                if (len > ws[tcol]) {
+                                    width += len - ws[tcol];
+                                    ws[tcol] = len;
+                                }
+                            }
+                            if (width < columns)
+                                break;
+                        }
 		    }
 		}
 	    } else if (g->width) {
 		if (g->flags & CGF_ROWS) {
-		    int addlen, count, tcol, maxlines = 0, llines, i;
-		    int beg = columns / g->shortest, end = g->cols, fe = 1;
-		    Cmatch *first;
-
-		    while (1) {
-			tcols = (beg + end) >> 1;
-
-			p = first = skipnolist(g->matches, showall);
-			for (maxlen = width = maxlines = llines = tcol = 0,
-				 count = g->dcount;
-			     count > 0; count--) {
-			    m = *p;
-			    addlen = (mlens[m->gnum] +
-                                      (tcol == tcols - 1 ? 0 : add));
-			    if (addlen > maxlen)
-				maxlen = addlen;
-			    for (i = tcols; i && *p; i--)
-				p = skipnolist(p + 1, showall);
-
-			    llines++;
-			    if (!*p) {
-				if (llines > maxlines)
-				    maxlines = llines;
-				llines = 0;
-
-				if ((width += maxlen) >= columns)
-				    break;
-				ws[tcol++] = maxlen;
-				maxlen = 0;
-
-				p = first = skipnolist(first + 1, showall);
-			    }
-			}
-			if (tlines) {
-			    ws[tcol++] = maxlen;
-			    width += maxlen;
-			}
-			if (!count && width <= columns &&
-			    (tcols <= 0 || beg == end))
-			    break;
-
-			if (beg == end) {
-                            if (fe) {
-                                beg += 2;
-                                end += 2;
-                                fe = 0;
-                            } else {
-                                beg--;
-                                end--;
-                            }
-			} else if (width < columns) {
-			    if ((end = tcols) == beg - 1)
-				end++;
-			} else {
-			    if ((beg = tcols) - 1 == end)
-				end++;
+                    int nth, tcol, len;
+
+                    for (tcols = columns / (g->shortest + add); tcols > g->cols;
+                         tcols--) {
+
+                        memset(ws, 0, tcols * sizeof(int));
+
+                        for (width = nth = tcol = 0, tlines = 1,
+                             p = skipnolist(g->matches, showall);
+                             *p && width < columns && nth < g->dcount;
+                             nth++, p = skipnolist(p + 1, showall), tcol++) {
+
+                            m = *p;
+
+                            if (tcol == tcols) {
+                                tcol = 0;
+                                tlines++;
+                            }
+                            len = (mlens[m->gnum] +
+                                   (tcol == tcols - 1 ? 0 : add));
+
+                            if (len > ws[tcol]) {
+                                width += len - ws[tcol];
+                                ws[tcol] = len;
+                            }
                         }
-		    }
-		    if (tcols > g->cols)
-			tlines = maxlines;
+                        if (width < columns)
+                            break;
+                    }
 		} else {
-		    int addlen;
-		    int smask = ((showall ? 0 : (CMF_NOLIST | CMF_MULT)) |
-				 CMF_HIDE);
-		    int beg = ((g->totl + columns) / columns);
-		    int end = g->lins, fe = 1;
-
-		    while (1) {
-			tlines = (beg + end) >> 1;
-
-			for (p = g->matches, nth = tline = width =
-				 maxlen = tcols = 0;
-			     (m = *p); p++) {
-			    if (!(m->flags &
-				  (m->disp ? (CMF_DISPLINE | CMF_HIDE) :
-				   smask))) {
-				addlen = mlens[m->gnum] + add;
-				if (addlen > maxlen)
-				    maxlen = addlen;
-				if (++tline == tlines) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcols++] = maxlen;
-				    maxlen = tline = 0;
-				}
-				nth++;
-			    }
-			}
-			if (tline) {
-			    ws[tcols++] = maxlen;
-			    width += maxlen;
-			}
-			if (nth == g->dcount && width <= columns &&
-			    (beg == end || tlines >= g->lins))
-			    break;
-
-			if (beg == end) {
-                            if (fe) {
-                                beg -= 2;
-                                end -= 2;
-                                fe = 0;
-                            } else {
-                                beg++;
-                                end++;
-                            }
-			} else if (width < columns) {
-			    if ((end = tlines) == beg + 1)
-				end--;
-			} else {
-			    if ((beg = tlines) + 1 == end)
-				end--;
-			}
-		    }
-		    if (tlines > g->lins)
-			tlines = g->lins;
+                    int nth, tcol, tline, len;
+
+                    for (tcols = columns / (g->shortest + add); tcols > g->cols;
+                         tcols--) {
+
+                        if ((tlines = (g->dcount + tcols - 1) / tcols) <= 0)
+                            tlines = 1;
+
+                        memset(ws, 0, tcols * sizeof(int));
+
+                        for (width = nth = tcol = tline = 0,
+                             p = skipnolist(g->matches, showall);
+                             *p && width < columns && nth < g->dcount;
+                             nth++, p = skipnolist(p + 1, showall), tline++) {
+
+                            m = *p;
+
+                            if (tline == tlines) {
+                                tcol++;
+                                tline = 0;
+                            }
+                            if (tcol == tcols) {
+                                tcol = 0;
+                                tlines++;
+                            }
+                            len = (mlens[m->gnum] +
+                                   (tcol == tcols - 1 ? 0 : add));
+
+                            if (len > ws[tcol]) {
+                                width += len - ws[tcol];
+                                ws[tcol] = len;
+                            }
+                        }
+                        if (width < columns)
+                            break;
+                    }
 		}
 	    }
+            if (tcols <= g->cols)
+                tlines = g->lins;
 	    if (tlines == g->lins) {
 		zfree(ws, columns * sizeof(int));
 		g->widths = NULL;
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.69
diff -u -r1.69 computil.c
--- Src/Zle/computil.c	2001/07/25 12:18:24	1.69
+++ Src/Zle/computil.c	2001/07/27 12:46:08
@@ -74,6 +74,7 @@
 #define CRT_DESC   1
 #define CRT_SPEC   2
 #define CRT_DUMMY  3
+#define CRT_EXPL   4
 
 struct cdset {
     Cdset next;			/* guess what */
@@ -199,7 +200,9 @@
         VARARR(Cdstr, grps, lines);
         VARARR(int, wids, cd_state.maxg);
         Cdstr gs, gp, gn, *gpp;
-        int i, j;
+        int i, j, d;
+        Cdrun expl;
+        Cdstr *strp2;
 
         memset(wids, 0, cd_state.maxg * sizeof(int));
         strp = grps;
@@ -236,22 +239,59 @@
 
         qsort(grps, lines, sizeof(Cdstr), cd_sort);
 
-        for (i = lines, strp = grps; i; i--, strp++) {
-            for (j = 0, gs = *strp; gs->other; gs = gs->other, j++) {
-                *runp = run = (Cdrun) zalloc(sizeof(*run));
-                runp = &(run->next);
-                run->type = CRT_SPEC;
-                run->strs = gs;
-                gs->run = NULL;
-                run->count = 1;
-            }
+        expl =  (Cdrun) zalloc(sizeof(*run));
+        expl->type = CRT_EXPL;
+        expl->strs = grps[0];
+        expl->count = lines;
+
+        for (i = lines, strp = grps, strp2 = NULL; i; i--, strp++) {
+            str = *strp;
+            *strp = str->other;
+            if (strp2)
+                *strp2 = str;
+            strp2 = &(str->run);
+
             *runp = run = (Cdrun) zalloc(sizeof(*run));
             runp = &(run->next);
-            run->type = CRT_DUMMY + cd_state.maxg - j - 1;
-            run->strs = gs;
-            gs->run = NULL;
+            run->type = CRT_SPEC;
+            run->strs = str;
             run->count = 1;
         }
+        *strp2 = NULL;
+
+        for (i = cd_state.maxg - 1; i; i--) {
+            for (d = 0, j = lines, strp = grps; j; j--, strp++) {
+                if ((str = *strp)) {
+                    if (d) {
+                        *runp = run = (Cdrun) zalloc(sizeof(*run));
+                        runp = &(run->next);
+                        run->type = CRT_DUMMY;
+                        run->strs = expl->strs;
+                        run->count = d;
+                        d = 0;
+                    }
+                    *runp = run = (Cdrun) zalloc(sizeof(*run));
+                    runp = &(run->next);
+                    run->type = CRT_SPEC;
+                    run->strs = str;
+                    run->strs->run = NULL;
+                    run->count = 1;
+
+                    *strp = str->other;
+                } else
+                    d++;
+            }
+            if (d) {
+                *runp = run = (Cdrun) zalloc(sizeof(*run));
+                runp = &(run->next);
+                run->type = CRT_DUMMY;
+                run->strs = expl->strs;
+                run->count = d;
+            }
+        }
+        *runp = expl;
+        runp = &(expl->next);
+
         for (set = cd_state.sets; set; set = set->next) {
             for (i = 0, gs = NULL, gpp = &gs, str = set->strs;
                  str; str = str->next) {
@@ -528,6 +568,7 @@
                 opts[0] = ztrdup("-l");
                 break;
             }
+
         case CRT_SPEC:
             mats = (char **) zalloc(2 * sizeof(char *));
             dpys = (char **) zalloc(2 * sizeof(char *));
@@ -549,39 +590,56 @@
                 
             } else
                 opts[0] = ztrdup("-2V-default-");
-            csl = "packed rows";
+            csl = "packed";
             break;
+  
+        case CRT_DUMMY:
+            {
+                char buf[20];
+
+                sprintf(buf, "-E%d", run->count);
+
+                mats = (char **) zalloc(sizeof(char *));
+                dpys = (char **) zalloc(sizeof(char *));
+                mats[0] = dpys[0] = NULL;
+
+                opts = cd_arrdup(run->strs->set->opts);
+                opts[0] = ztrdup(buf);
 
-        default:
+                csl = "packed";
+            }
+            break;
+
+        case CRT_EXPL:
             {
                 int dlen = columns - cd_state.gpre - cd_state.slen;
                 VARARR(char, dbuf, dlen + cd_state.slen);
                 char buf[20];
-                int i = run->type - CRT_DUMMY;
+                int i = run->count;
 
-                sprintf(buf, "-E%d", i + 1);
+                sprintf(buf, "-E%d", i);
 
-                mats = (char **) zalloc(2 * sizeof(char *));
-                dpys = (char **) zalloc((3 + i) * sizeof(char *));
-                mats[0] = ztrdup(run->strs->match);
-                dpys[0] = ztrdup(run->strs->str);
-                for (dp = dpys + 1; i; i--, dp++)
-                    *dp = ztrdup("");
-                memset(dbuf + cd_state.slen, ' ', dlen - 1);
-                dbuf[dlen + cd_state.slen - 1] = '\0';
-                strcpy(dbuf, cd_state.sep);
-                memcpy(dbuf + cd_state.slen,
-                       run->strs->desc,
-                       (strlen(run->strs->desc) >= dlen ? dlen - 1 :
-                        strlen(run->strs->desc)));
-                *dp++ = ztrdup(dbuf);
-                mats[1] = *dp = NULL;
+                mats = (char **) zalloc(sizeof(char *));
+                dpys = (char **) zalloc((i + 1) * sizeof(char *));
 
+                for (dp = dpys, str = run->strs; str; str = str->run) {
+                    memset(dbuf + cd_state.slen, ' ', dlen - 1);
+                    dbuf[dlen + cd_state.slen - 1] = '\0';
+                    strcpy(dbuf, cd_state.sep);
+                    memcpy(dbuf + cd_state.slen,
+                           str->desc,
+                           (strlen(str->desc) >= dlen ? dlen - 1 :
+                            strlen(str->desc)));
+                    *dp++ = ztrdup(dbuf);
+                }
+                mats[0] = *dp = NULL;
+
                 opts = cd_arrdup(run->strs->set->opts);
                 opts[0] = ztrdup(buf);
 
-                csl = "packed rows";
+                csl = "packed";
             }
+            break;
         }
         setsparam(params[0], ztrdup(csl));
         setaparam(params[1], opts);

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

