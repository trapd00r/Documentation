From zsh-workers-return-9787-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Feb 18 09:14:12 2000
Return-Path: <zsh-workers-return-9787-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 646 invoked from network); 18 Feb 2000 09:14:10 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Feb 2000 09:14:10 -0000
Received: (qmail 28858 invoked by alias); 18 Feb 2000 09:13:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9787
Received: (qmail 28849 invoked from network); 18 Feb 2000 09:13:55 -0000
Date: Fri, 18 Feb 2000 10:13:50 +0100 (MET)
Message-Id: <200002180913.KAA30647@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Thu, 17 Feb 2000 18:39:39 +0000
Subject: Re: _expand


Peter Stephenson wrote:

> I have a more basic problem with _expand than Oliver's.
> 
> % bindkey '^i' complete-word
> % zstyle ':completion:*' completer _expand _complete
> % zstyle ':completion:*' glob 1
> % zstyle ':completion:*' substitute 1
> % foo=bar
> % echo $foo<TAB>
>  -> echo $foo _
> 
> Where's my bar?  This happens from zsh -f with compinit.

That's the problem I mentioned: If we are *in* the parameter
expression, the completion system doesn't get the whole string from
the C code, only the stuff after the `$' (or `${'). We decided to do
it this way some time ago, don't remember exactly when, because (if I
remember correctly) parsing such parameter expansions is quite
complicated in shell code.

The patch below makes it work with `${foo}<TAB>' again. Don't know
when this broke.

> Furthermore,
> 
> % echo `echo $foo`<TAB>
> 
> gives the error
> _expand:30: command not found: echo bar
> 
> Same using $(...).

Yep. bslashquote() didn't check for things like this and blindly
quoted special characters in there.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_expand Completion/Core/_expand
--- ../z.old/Completion/Core/_expand	Thu Feb 17 14:58:10 2000
+++ Completion/Core/_expand	Fri Feb 18 10:11:17 2000
@@ -34,9 +34,9 @@
 
 # If the array is empty, store the original string again.
 
-[[ -z "$exp" ]] && exp=("$word")
+(( $#exp )) || exp=("$word")
 
-subd="$exp"
+subd=("$exp[@]")
 
 # Now try globbing.
 
@@ -47,14 +47,15 @@
 # If we don't have any expansions or only one and that is the same
 # as the original string, we let other completers run.
 
-[[ $#exp -eq 0 ||
-   ( $#exp -eq 1 && "$exp[1]" = "$word"(|\(N\)) ) ]] && return 1
+(( $#exp )) || exp=("$subd[@]")
+
+[[ $#exp -eq 1 && "$exp[1]" = "$word"(|\(N\)) ]] && return 1
 
 # With subst-globs-only we bail out if there were no glob expansions,
 # regardless of any substitutions
+
 zstyle -s ":completion:${curcontext}:" subst-globs-only expr &&
-    [[ "${(e):-\$[$expr]}" -eq 1 ]] &&
-    [[ "$subd" = "$exp"(|\(N\)) ]] && return 1
+    [[ "${(e):-\$[$expr]}" -eq 1 && "$subd" = "$exp"(|\(N\)) ]] && return 1
 
 # Now add as matches whatever the user requested.
 
@@ -76,7 +77,7 @@
   _requested all-expansions expl 'all expansions' "o:$word" &&
       compadd "$expl[@]" -UQ -qS "$suf" - "$exp"
 
-  if _requested expansions; then
+  if [[ $#exp -gt 1 ]] && _requested expansions; then
     if [[ "$sort" = menu ]]; then
       _description expansions expl expansions "o:$word"
     else
diff -ru ../z.old/Src/utils.c Src/utils.c
--- ../z.old/Src/utils.c	Thu Feb 17 14:57:49 2000
+++ Src/utils.c	Fri Feb 18 10:07:34 2000
@@ -2819,6 +2819,39 @@
 	  }
 	  continue;
 	}
+	else if (*u == Tick || *u == Qtick) {
+	    char c = *u++;
+
+	    *v++ = c;
+	    while (*u && *u != c)
+		*v++ = *u++;
+	    *v++ = c;
+	    if (!*u)
+		u--;
+	    continue;
+	}
+	else if ((*u == String || *u == Qstring) &&
+		 (u[1] == Inpar || u[1] == Inbrack || u[1] == Inbrace)) {
+	    char c = (u[1] == Inpar ? Outpar : (u[1] == Inbrace ?
+						Outbrace : Outbrack));
+	    char beg = *u;
+	    int level = 0;
+
+	    *v++ = *u++;
+	    *v++ = *u++;
+	    while (*u && (*u != c || level)) {
+		if (*u == beg)
+		    level++;
+		else if (*u == c)
+		    level--;
+		*v++ = *u++;
+	    }
+	    if (*u)
+		*v++ = *u;
+	    else
+		u--;
+	    continue;
+	}
 	else if (ispecial(*u) &&
 		 ((*u != '=' && *u != '~') ||
 		  u == s ||

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

