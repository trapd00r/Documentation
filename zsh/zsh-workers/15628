From zsh-workers-return-15628-mason-zsh=primenet.com.au@sunsite.dk Tue Aug 14 16:05:28 2001
Return-Path: <zsh-workers-return-15628-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5192 invoked from network); 14 Aug 2001 16:05:27 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Aug 2001 16:05:27 -0000
Received: (qmail 25180 invoked by alias); 14 Aug 2001 16:05:20 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15628
Received: (qmail 25152 invoked from network); 14 Aug 2001 16:05:19 -0000
From: Bart Schaefer <schaefer@brasslantern.com>
Message-Id: <1010814160337.ZM8501@candle.brasslantern.com>
Date: Tue, 14 Aug 2001 16:03:36 +0000
In-Reply-To: <OF282F56AE.F70B2E05-ON80256AA8.002E05E6@uk.jpmorgan.com>
Comments: In reply to martin.ebourne@arcordia.com
        "PATCH: Re: Delaying menu completion" (Aug 14, 10:21am)
References: <OF282F56AE.F70B2E05-ON80256AA8.002E05E6@uk.jpmorgan.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: martin.ebourne@arcordia.com
Subject: Re: PATCH: Re: Delaying menu completion
Cc: zsh-workers@sunsite.dk
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Aug 14, 10:21am, martin.ebourne@arcordia.com wrote:
}
} Someone will need to check the patch because I don't fully understand
} what's going on - its a combination of cut & paste and trial & error coding
} in there. ;)

You don't want this line:

} +      [[ "$_old_match_string" = "$PREFIX$SUFFIX$HISTNO" &&

The _old_match_string variable is used only by the _match completer.
If you were to try using _approximate without _match, it would stop
working.  If you want this behavior, you should change the name to
_old_approx_string and also copy the code from _match that sets it.

} > } Problem 2
} > Unfortunately $compstate[old_list] is not available until after you
} > enter one of the completion widgets, so you're going to need a helper
} > function of some kind, that will be used as the non-menu completion
} > widget, and that sets a global variable that can be tested in place
} > of $compstate when you invoke _menu_or_down.
} 
} Ah, yes, that's what I needed.  [...]
} 
}    _is_completing() {
}      [[ $compstate[old_list] == shown ]] && _completing=1
}    }
}    zle -C is-completing complete-word _is_completing

I'd suggest

   _is_completing() {
     _completing=$compstate[old_list]
   }

That way you can differentiate "yes" and "shown" in case you don't have
autolist set, or are using bashautolist.

Also, I'm not entirely certain, but you may need/want to make it

   _is_completing() {
     _completing=$compstate[old_list]
     compstate[old_list]=keep
   }

The end result is probably the same, but keeping the old list will mean
that `zle menu-complete' doesn't have to recompute it.  (I'm actually
not entirely sure what happens to the list when you invoke a completion
widget from another zle widget, but the doc implies it'll be cleared
when the completion widget finishes if old_list is not keep.)

Also, setting old_list to keep causes the widget to correctly propagate
its exit status, should you end up wanting to test `if zle is-completing'
again at some point.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

