From zsh-workers-return-6817-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 24 07:07:22 1999
Return-Path: <zsh-workers-return-6817-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15677 invoked from network); 24 Jun 1999 07:07:21 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Jun 1999 07:07:21 -0000
Received: (qmail 3927 invoked by alias); 24 Jun 1999 07:06:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6817
Received: (qmail 3920 invoked from network); 24 Jun 1999 07:06:36 -0000
Date: Thu, 24 Jun 1999 09:06:35 +0200 (MET DST)
Message-Id: <199906240706.JAA07553@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Wed, 23 Jun 1999 12:36:55 +0200
	(MET DST)
Subject: PATHC: Re: autostart menu-select on cursor keys?


I wrote:

> Andrej Borsenkow wrote:
> 
> > I personally would prefer, if menu-select would be autostarted on cursor keys
> > (well, user-defined keys ...) In this case you could quickly cycle through a
> > couple of first matches; and if you happen to hit a really large list, have a
> > natural way to menu-select needed one.
> 
> Unless you want this only when menu-completion is active, you can
> always by unsetting ZLS_SELECT and bind menu-select to some key
> A. Then you can start menu-completion as normal and use A to enter
> menu-selection (and again leaving menu-selection should put you into
> normal menu-completion again).

Also, we could use the value of ZLS_SELECT. The patch below first of
all renames ZLS_SELECT to SELECTMIN (a la LISTMAX). Then it uses its
value and turns on menu-selection only if the number of matches is
greater than or equal to that value.

(This is a good thing, because now we have a reason for using a
parameter instead of an option. ;-)

Bye
 Sven

diff -u oos/Zle/comp.h Src/Zle/comp.h
--- oos/Zle/comp.h	Thu Jun 24 08:55:23 1999
+++ Src/Zle/comp.h	Thu Jun 24 08:55:35 1999
@@ -313,6 +313,16 @@
     char *dpar;			/* array to delete non-matches in (-D) */
 };
 
+/* Data given to hooks. */
+
+typedef struct chdata *Chdata;
+
+struct chdata {
+    Cmgroup matches;		/* the matches generated */
+    int num;			/* the number of matches */
+    Cmatch cur;			/* current match or NULL */
+};
+
 /* Flags for special parameters. */
 
 #define CPN_WORDS      0
diff -u oos/Zle/complist.c Src/Zle/complist.c
--- oos/Zle/complist.c	Thu Jun 24 08:55:23 1999
+++ Src/Zle/complist.c	Thu Jun 24 08:56:12 1999
@@ -283,9 +283,9 @@
  * of course. */
 
 static int
-complistmatches(Hookdef dummy, Cmgroup amatches)
+complistmatches(Hookdef dummy, Chdata dat)
 {
-    Cmgroup g;
+    Cmgroup amatches = dat->matches, g;
     Cmatch *p, m;
     Cexpl *e;
     int nlines = 0, ncols, nlist = 0, longest = 1, pnl = 0, opl = 0;
@@ -620,15 +620,17 @@
 };
 
 static int
-domenuselect(Hookdef dummy, Cmgroup amatches)
+domenuselect(Hookdef dummy, Chdata dat)
 {
     Cmatch **p;
-    Cmgroup *pg;
+    Cmgroup amatches = dat->matches, *pg;
     Thingy cmd;
     Menustack u = NULL;
     int i = 0;
+    char *s;
 
-    if (getcols(NULL) || (dummy && !getsparam("ZLS_SELECT")))
+    if (getcols(NULL) || (dummy && (!(s = getsparam("SELECTMIN")) ||
+				    dat->num < atoi(s))))
 	return 1;
 
     selectlocalmap(mskeymap);
diff -u oos/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- oos/Zle/zle_tricky.c	Thu Jun 24 08:55:25 1999
+++ Src/Zle/zle_tricky.c	Thu Jun 24 08:55:36 1999
@@ -1052,9 +1052,14 @@
     zsfree(qword);
     unmetafy_line();
 
-    if (menucmp && !omc)
-	runhookdef(MENUSTARTHOOK, (void *) amatches);
+    if (menucmp && !omc) {
+	struct chdata dat;
 
+	dat.matches = amatches;
+	dat.num = nmatches;
+	dat.cur = NULL;
+	runhookdef(MENUSTARTHOOK, (void *) &dat);
+    }
     return ret;
 }
 
@@ -7660,14 +7665,16 @@
     if ((menucmp && !minfo.we) || !movetoend)
 	cs = minfo.end;
     {
-	void *data[2];
 	Cmatch *om = minfo.cur;
+	struct chdata dat;
+
+	dat.matches = amatches;
+	dat.num = nmatches;
+	dat.cur = m;
 
 	if (menucmp)
 	    minfo.cur = &m;
-	data[0] = (void *) amatches;
-	data[1] = (void *) m;
-	runhookdef(INSERTMATCHHOOK, (void *) data);
+	runhookdef(INSERTMATCHHOOK, (void *) &dat);
 	minfo.cur = om;
     }
 }
@@ -7872,6 +7879,7 @@
 void
 listmatches(void)
 {
+    struct chdata dat;
 
 #ifdef DEBUG
     /* Sanity check */
@@ -7881,7 +7889,10 @@
     }
 #endif
 
-    runhookdef(LISTMATCHESHOOK, (void *) amatches);
+    dat.matches = amatches;
+    dat.num = nmatches;
+    dat.cur = NULL;
+    runhookdef(LISTMATCHESHOOK, (void *) &dat);
 }
 
 /**/

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

