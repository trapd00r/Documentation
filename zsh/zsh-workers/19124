From zsh-workers-return-19124-mason-zsh=primenet.com.au@sunsite.dk Mon Sep 22 19:28:33 2003
Return-Path: <zsh-workers-return-19124-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9814 invoked from network); 22 Sep 2003 19:28:32 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 22 Sep 2003 19:28:32 -0000
Received: (qmail 25226 invoked by alias); 22 Sep 2003 19:28:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 19124
Received: (qmail 25216 invoked from network); 22 Sep 2003 19:28:24 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 22 Sep 2003 19:28:24 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [192.54.253.222] by sunsite.dk (MessageWall 1.0.8) with SMTP; 22 Sep 2003 19:28:23 -0000
Received: by binome.blorf.net (Postfix, from userid 1000)
	id 8DC08306A; Mon, 22 Sep 2003 12:28:22 -0700 (PDT)
Date: Mon, 22 Sep 2003 12:28:22 -0700
From: Wayne Davison <wayned@users.sourceforge.net>
To: Peter Stephenson <pws@csr.com>
Cc: Zsh <zsh-workers@sunsite.dk>
Subject: Re: Problem with an exported array
Message-ID: <20030922192822.GD23145@binome.blorf.net>
References: <1030922142208.ZM19975@candle.brasslantern.com> <7352.1064245936@csr.com>
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="WIyZ46R2i8wDzkSu"
Content-Disposition: inline
In-Reply-To: <7352.1064245936@csr.com>
User-Agent: Mutt/1.5.4i


--WIyZ46R2i8wDzkSu
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

On Mon, Sep 22, 2003 at 04:52:16PM +0100, Peter Stephenson wrote:
> As I said before, there's nowhere in struct param to store the
> character; else it's not that hard.  Maybe you can see a trick.

Here's my trick: use "ct" (it's already multi-use).  A tied variable is
already excluded from being a special type of integer, so my change just
excludes the "ct" from being taken as a field width.  See if you can see
any problems with this.

I didn't document it yet, but the -S option currently takes an integer
because that was the only option-parsing currently supported.  If folks
like this kludge, that can be improved.

Example usage:

    typeset -T -S 32 PAGER pager

That would space-separate the $PAGER var from the $pager array.

..wayne..

--WIyZ46R2i8wDzkSu
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename="tiedarray.patch"

--- Src/builtin.c	11 Sep 2003 07:00:07 -0000	1.105
+++ Src/builtin.c	22 Sep 2003 19:21:29 -0000
@@ -121,7 +121,7 @@
     BUILTIN("trap", BINF_PSPECIAL, bin_trap, 0, -1, 0, NULL, NULL),
     BUILTIN("true", 0, bin_true, 0, -1, 0, NULL, NULL),
     BUILTIN("type", 0, bin_whence, 0, -1, 0, "ampfsw", "v"),
-    BUILTIN("typeset", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%TUZ:%afghi:%lprtuxm", NULL),
+    BUILTIN("typeset", BINF_PLUSOPTS | BINF_MAGICEQUALS | BINF_PSPECIAL, bin_typeset, 0, -1, 0, "AE:%F:%HL:%R:%S:%TUZ:%afghi:%lprtuxm", NULL),
     BUILTIN("umask", 0, bin_umask, 0, 1, 0, "S", NULL),
     BUILTIN("unalias", 0, bin_unhash, 1, -1, 0, "ms", "a"),
     BUILTIN("unfunction", 0, bin_unhash, 1, -1, 0, "m", "f"),
@@ -1718,7 +1718,7 @@
 	usepm = 0;
     }
 
-    /* attempting a type conversion, or making a tied colonarray? */
+    /* attempting a type conversion, or making a tied array? */
     tc = 0;
     if (usepm || newspecial != NS_NONE) {
 	int chflags = ((off & pm->flags) | (on & ~pm->flags)) &
@@ -1830,7 +1830,7 @@
 	pm->flags = (pm->flags | (on & ~PM_READONLY)) & ~(off | PM_UNSET);
 	/* This auxlen/pm->ct stuff is a nasty hack. */
 	if ((on & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z | PM_INTEGER |
-		   PM_EFLOAT | PM_FFLOAT)) &&
+		   PM_EFLOAT | PM_FFLOAT | PM_TIED)) &&
 	    auxlen)
 	    pm->ct = auxlen;
 	if (!(pm->flags & (PM_ARRAY|PM_HASHED))) {
@@ -1994,11 +1994,11 @@
     if (altpm && PM_TYPE(pm->flags) == PM_SCALAR) {
 	/*
 	 * It seems safer to set this here than in createparam(),
-	 * to make sure we only ever use the colonarr functions
+	 * to make sure we only ever use the tiedarr functions
 	 * when u.data is correctly set.
 	 */
-	pm->sets.cfn = colonarrsetfn;
-	pm->gets.cfn = colonarrgetfn;
+	pm->sets.cfn = tiedarrsetfn;
+	pm->gets.cfn = tiedarrgetfn;
 	pm->u.data = &altpm->u.arr;
     }
 
@@ -2168,6 +2168,9 @@
 	    return 1;
 	}
 
+	if (!auxlen)
+	    auxlen = ':';
+
 	if (!(asg = getasg(argv[0]))) {
 	    unqueue_signals();
 	    return 1;
@@ -2217,7 +2220,7 @@
 	    return 1;
 	}
 	/*
-	 * Create the tied colonarray.  We make it as a normal scalar
+	 * Create the tied array.  We make it as a normal scalar
 	 * and fix up the oddities later.
 	 */
 	if (!(pm=typeset_single(name, asg0.name,
--- Src/params.c	30 Aug 2003 19:00:20 -0000	1.72
+++ Src/params.c	22 Sep 2003 19:21:30 -0000
@@ -208,7 +208,7 @@
 IPDEF7("SPROMPT", &sprompt),
 IPDEF7("0", &argzero),
 
-#define IPDEF8(A,B,C,D) {NULL,A,D|PM_SCALAR|PM_SPECIAL,BR((void *)B),SFN(colonarrsetfn),GFN(colonarrgetfn),stdunsetfn,0,NULL,C,NULL,0}
+#define IPDEF8(A,B,C,D) {NULL,A,D|PM_SCALAR|PM_SPECIAL,BR((void *)B),SFN(tiedarrsetfn),GFN(tiedarrgetfn),stdunsetfn,':',NULL,C,NULL,0}
 IPDEF8("CDPATH", &cdpath, "cdpath", 0),
 IPDEF8("FIGNORE", &fignore, "fignore", 0),
 IPDEF8("FPATH", &fpath, "fpath", 0),
@@ -2584,15 +2584,15 @@
 
 /**/
 char *
-colonarrgetfn(Param pm)
+tiedarrgetfn(Param pm)
 {
     char ***dptr = (char ***)pm->u.data;
-    return *dptr ? zjoin(*dptr, ':', 1) : "";
+    return *dptr ? zjoin(*dptr, pm->ct, 1) : "";
 }
 
 /**/
 void
-colonarrsetfn(Param pm, char *x)
+tiedarrsetfn(Param pm, char *x)
 {
     char ***dptr = (char ***)pm->u.data;
 
@@ -2603,7 +2603,7 @@
      */
     if (*dptr)
 	freearray(*dptr);
-    *dptr = x ? colonsplit(x, pm->flags & PM_UNIQUE) :
+    *dptr = x ? tiedsplit(x, pm->ct, pm->flags & PM_UNIQUE) :
 	(pm->flags & PM_TIED) ? NULL : mkarray(NULL);
     if (pm->ename)
 	arrfixenv(pm->nam, *dptr);
@@ -3209,7 +3209,7 @@
      */
 
     if (pm->flags & PM_EXPORTED)
-	pm->env = addenv(s, t ? zjoin(t, ':', 1) : "", pm->flags);
+	pm->env = addenv(s, t ? zjoin(t, pm->ct, 1) : "", pm->flags);
 }
 
 
--- Src/subst.c	30 Aug 2003 19:12:18 -0000	1.36
+++ Src/subst.c	22 Sep 2003 19:21:31 -0000
@@ -1637,7 +1637,8 @@
 		 * Bet that's easier said than done.
 		 */
 		val = getstrvalue(v);
-		fwidth = v->pm->ct ? v->pm->ct : strlen(val);
+		fwidth = !(v->pm->flags & (PM_TIED|PM_SPECIAL)) && v->pm->ct?
+			 v->pm->ct : strlen(val);
 		switch (v->pm->flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
 		    char *t;
 		    unsigned int t0;
--- Src/utils.c	1 Aug 2003 16:29:21 -0000	1.53
+++ Src/utils.c	22 Sep 2003 19:21:32 -0000
@@ -1806,26 +1806,26 @@
     return ret;
 }
 
-/* Split a string containing a colon separated list *
+/* Split a string containing a "sep" separated list *
  * of items into an array of strings.               */
 
 /**/
 char **
-colonsplit(char *s, int uniq)
+tiedsplit(char *s, char sep, int uniq)
 {
     int ct;
     char *t, **ret, **ptr, **p;
 
-    for (t = s, ct = 0; *t; t++) /* count number of colons */
-	if (*t == ':')
+    for (t = s, ct = 0; *t; t++) /* count number of seps */
+	if (*t == sep)
 	    ct++;
     ptr = ret = (char **) zalloc(sizeof(char **) * (ct + 2));
 
     t = s;
     do {
 	s = t;
-        /* move t to point at next colon */
-	for (; *t && *t != ':'; t++);
+	/* move t to point at next sep */
+	for (; *t && *t != sep; t++);
 	if (uniq)
 	    for (p = ret; p < ptr; p++)
 		if (strlen(*p) == t - s && ! strncmp(*p, s, t - s))
--- Src/zsh.h	3 Sep 2003 10:15:36 -0000	1.49
+++ Src/zsh.h	22 Sep 2003 19:21:33 -0000
@@ -1191,24 +1191,25 @@
 #define PM_HIDE		(1<<14)	/* Special behaviour hidden by local        */
 #define PM_HIDEVAL	(1<<15)	/* Value not shown in `typeset' commands    */
 #define PM_TIED 	(1<<16)	/* array tied to colon-path or v.v.         */
+#define PM_TIED_SEP 	(1<<17)	/* Character to use when joining array.     */
 
 /* Remaining flags do not correspond directly to command line arguments */
-#define PM_LOCAL	(1<<17) /* this parameter will be made local        */
-#define PM_SPECIAL	(1<<18) /* special builtin parameter                */
-#define PM_DONTIMPORT	(1<<19)	/* do not import this variable              */
-#define PM_RESTRICTED	(1<<20) /* cannot be changed in restricted mode     */
-#define PM_UNSET	(1<<21)	/* has null value                           */
-#define PM_REMOVABLE	(1<<22)	/* special can be removed from paramtab     */
-#define PM_AUTOLOAD	(1<<23) /* autoloaded from module                   */
-#define PM_NORESTORE	(1<<24)	/* do not restore value of local special    */
-#define PM_HASHELEM     (1<<25) /* is a hash-element */
-#define PM_NAMEDDIR     (1<<26) /* has a corresponding nameddirtab entry    */
+#define PM_LOCAL	(1<<21) /* this parameter will be made local        */
+#define PM_SPECIAL	(1<<22) /* special builtin parameter                */
+#define PM_DONTIMPORT	(1<<23)	/* do not import this variable              */
+#define PM_RESTRICTED	(1<<24) /* cannot be changed in restricted mode     */
+#define PM_UNSET	(1<<25)	/* has null value                           */
+#define PM_REMOVABLE	(1<<26)	/* special can be removed from paramtab     */
+#define PM_AUTOLOAD	(1<<27) /* autoloaded from module                   */
+#define PM_NORESTORE	(1<<28)	/* do not restore value of local special    */
+#define PM_HASHELEM     (1<<29) /* is a hash-element */
+#define PM_NAMEDDIR     (1<<30) /* has a corresponding nameddirtab entry    */
 
 /* The option string corresponds to the first of the variables above */
-#define TYPESET_OPTSTR "aiEFALRZlurtxUhHT"
+#define TYPESET_OPTSTR "aiEFALRZlurtxUhHTS"
 
 /* These typeset options take an optional numeric argument */
-#define TYPESET_OPTNUM "LRZiEF"
+#define TYPESET_OPTNUM "LRZiEFS"
 
 /* Flags for extracting elements of arrays and associative arrays */
 #define SCANPM_WANTVALS   (1<<0)

--WIyZ46R2i8wDzkSu--

