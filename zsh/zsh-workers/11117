From zsh-workers-return-11117-mason-zsh=primenet.com.au@sunsite.auc.dk Wed May 03 13:04:24 2000
Return-Path: <zsh-workers-return-11117-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20228 invoked from network); 3 May 2000 13:04:23 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 3 May 2000 13:04:23 -0000
Received: (qmail 9774 invoked by alias); 3 May 2000 13:04:10 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11117
Received: (qmail 9747 invoked from network); 3 May 2000 13:04:08 -0000
Date: Wed, 3 May 2000 15:03:55 +0200 (MET DST)
Message-Id: <200005031303.PAA02427@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Wed, 3 May 2000 16:38:59 +0400
Subject: RE: PATCH: Re: Shell-word splitting (was: Re: Proposed _history completer)


Andrej Borsenkow wrote:

> > Anyway, here's the patch, implementing the (z) flag which makes the
> > parameter value be zplitted uzing zsh zhell zyntax. This works a bit
> > like the (s) flag (or the `=' before the name) and is done at the very
> > end, so to access words resulting from the splitting:
> 
> Why is it so similar ... is it not the same as was implemented for
> copy-prev-shell-word? I mean, in this case c-p-s-w may well be
> implemented as pure shell-level widget ... may be, it is not worth it
> now ...

For c-p-s-w bufferwords() does a bit more and a bit less. It also
reports the word the cursor is on (so that we can find the previous
word), but it doesn't add simple words like the special tokens (`;',
`&&' etc.).

> The only problem is, what happens if current line is incomplete? That
> is, is this modifier useful in widgets that deal with current line?
> Suppose, we have something like ``echo "foo '' - what will be the result
> of (z) modifier?

[hand hits forehead]

I had forgotten about this. It now includes the partial word in such a 
case. Different from c-p-s-w.


Peter Stephenson wrote:

> > Anyway, here's the patch, implementing the (z) flag which makes the
> > parameter value be zplitted uzing zsh zhell zyntax. This works a bit
> > like the (s) flag (or the `=' before the name) and is done at the very
> > end, so to access words resulting from the splitting:
> > 
> >   % foo='it says: "hello world"'
> >   % echo ${${(z)foo}[3]}
> >   "hello world"
> > 
> > We could probably move the code that does the splitting up somewhere
> > but it would then behave more differently from (s) and = than it does
> > now, so that would probably be a bad idea.
> 
> This is probably right, but it could do with mentioning explicitly,
> including in the rules for parameter substitution, otherwise it's a little
> non-obvious that you can't do e.g. ${(Qz)foo} to get rid of the quotes.
> You can do ${(Q)${(z)foo}}, so it's no problem as long as you know about
> it.

Ok.

Bye
 Sven

Index: Doc/Zsh/expn.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/expn.yo,v
retrieving revision 1.8
diff -u -r1.8 expn.yo
--- Doc/Zsh/expn.yo	2000/05/03 12:21:56	1.8
+++ Doc/Zsh/expn.yo	2000/05/03 13:03:02
@@ -679,6 +679,11 @@
 item(tt(z))(
 Split the result of the expansion into words using shell parsing to
 find the words, i.e. taking into account any quoting in the value.
+
+Note that this is done very lately, as for the `tt((s))' flag. So to
+access single words in the result, one has to use nested expansions as 
+in `tt(${${(z)foo}[2]}'. Likewise, to remove the quotes in the
+resulting words one would do: `tt(${(Q)${(z)foo}})'.
 )
 item(tt(t))(
 Use a string describing the type of the parameter where the value
@@ -839,7 +844,7 @@
 manner.
 )
 item(tt(8.) em(Forced Splitting))(
-If one of the `tt((s))' or `tt((f))' flags are present, or the `tt(=)'
+If one of the `tt((s))', `tt((f))' or `tt((z))' flags are present, or the `tt(=)'
 specifier was present (e.g. tt(${=)var(var)tt(})), the word is split on
 occurrences of the specified string, or (for tt(=) with neither of the two
 flags present) any of the characters in tt($IFS).
Index: Src/hist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/hist.c,v
retrieving revision 1.3
diff -u -r1.3 hist.c
--- Src/hist.c	2000/05/03 12:21:56	1.3
+++ Src/hist.c	2000/05/03 13:03:02
@@ -2102,6 +2102,11 @@
 	    cur = num - 1;
 	}
     } while (tok != ENDINPUT && tok != LEXERR);
+    if (buf && tok == LEXERR && tokstr && *tokstr) {
+	untokenize((p = dupstring(tokstr)));
+	addlinknode(list, p);
+	num++;
+    }
     if (cur < 0 && num)
 	cur = num - 1;
     noaliases = 0;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

