From zsh-workers-return-10210-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 23 09:44:14 2000
Return-Path: <zsh-workers-return-10210-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10690 invoked from network); 23 Mar 2000 09:44:13 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Mar 2000 09:44:13 -0000
Received: (qmail 5991 invoked by alias); 23 Mar 2000 09:44:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10210
Received: (qmail 5981 invoked from network); 23 Mar 2000 09:44:04 -0000
Date: Thu, 23 Mar 2000 10:43:58 +0100 (MET)
Message-Id: <200003230943.KAA23250@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: _next_tags


I wasn't happy with having to give _next_tags in the completer list to 
make it really work, so this makes it work without it. In other words: 
if you have it in your completer style, you better take it out before
trying completion after this patch...

This works by adding a $compprefuncs array, brother of $comppostfuncs.

Then it makes _next_tags be bound to ^Xn per default again.

Bye
 Sven

diff -ru ../z.old/Completion/Commands/_next_tags Completion/Commands/_next_tags
--- ../z.old/Completion/Commands/_next_tags	Thu Mar 23 10:01:14 2000
+++ Completion/Commands/_next_tags	Thu Mar 23 10:35:28 2000
@@ -1,49 +1,45 @@
-#autoload
+#compdef -k complete-word \C-xn
 
-# To use this, put _next_tags at the beginning of the completer style,
-# define it as a completion widget and bind it to a key, e.g.:
-#
-#  zle -C _next_tags complete-word _next_tags
-#  bindkey '^Xn' _next_tags
-#
-# Makes it be bound to ^Xn.
-
-
-# Main widget/completer.
+# Main widget.
 
 _next_tags() {
+  local comp
+
+  if [[ -z $compstate[old_list] ]]; then
+    comp=()
+  else
+    comp=(_complete)
+  fi
 
-  if [[ $#funcstack -gt 1 ]]; then
+  (( $+_sort_tags )) || _next_tags_not=
 
-    # Called as completer, probably `remove' our helper function. A better
-    # test would be nice, but I think one should still be able to edit the
-    # current word between attempts to complete it.
+  _sort_tags=_next_tags_sort
+  _next_tags_pre="${LBUFFER%${PREFIX}}"
+  _next_tags_not="$_next_tags_not $_lastcomp[tags]"
 
-    [[ $_next_tags_pre != ${LBUFFER%${PREFIX}} ]] && unset _sort_tags
+  _main_complete "$comp[@]"
 
-    return 1
-  else
-    local comp
+  [[ $compstate[insert] = automenu ]] &&
+     compstate[insert]=automenu-unambiguous
 
-    if [[ -z $compstate[old_list] ]]; then
-      comp=()
-    else
-      comp=(_next_tags _complete)
-    fi
+  compstate[insert]=''
+  compstate[list]='list force'
 
-    (( $+_sort_tags )) || _next_tags_not=
+  compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
+}
 
-    _sort_tags=_next_tags_sort
-    _next_tags_pre="${LBUFFER%${PREFIX}}"
-    _next_tags_not="$_next_tags_not $_lastcomp[tags]"
+# Pre-completion function.
 
-    _main_complete "$comp[@]"
+_next_tags_pre() {
 
-    [[ $compstate[insert] = automenu ]] &&
-       compstate[insert]=automenu-unambiguous
+  # Probably `remove' our sort function. A better test would be nice, but
+  # I think one should still be able to edit the current word between
+  # attempts to complete it.
 
-    compstate[insert]=''
-    compstate[list]='list force'
+  if [[ $_next_tags_pre != ${LBUFFER%${PREFIX}} ]]; then
+    unset _sort_tags
+  else
+    compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
   fi
 }
 
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Thu Mar 23 10:01:16 2000
+++ Completion/Core/_main_complete	Thu Mar 23 10:28:57 2000
@@ -19,7 +19,7 @@
 setopt localoptions nullglob rcexpandparam extendedglob
 unsetopt markdirs globsubst shwordsplit nounset ksharrays
 
-local ctxt post ret=1 tmp _compskip format _comp_ignore \
+local ctxt func funcs ret=1 tmp _compskip format _comp_ignore \
       _completers _completer _completer_num curtag \
       _matchers _matcher _matcher_num _comp_tags \
       context state line opt_args val_args curcontext="$curcontext" \
@@ -68,6 +68,14 @@
 _completers=( "$@" )
 _completer_num=1
 
+# Call the pre-functions.
+
+funcs=( "$compprefuncs[@]" )
+compprefuncs=()
+for func in "$funcs[@]"; do
+  "$func"
+done
+
 for _completer; do
   ctxt=":completion:${curcontext/::/:${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}:}:"
 
@@ -190,10 +198,11 @@
 
 # Now call the post-functions.
 
-for post in "$comppostfuncs[@]"; do
-  "$post"
-done
+funcs=( "$comppostfuncs[@]" )
 comppostfuncs=()
+for func in "$funcs[@]"; do
+  "$func"
+done
 
 _lastcomp=( "${(@kv)compstate}" )
 _lastcomp[completer]="$_completer"
diff -ru ../z.old/Completion/Core/compinit Completion/Core/compinit
--- ../z.old/Completion/Core/compinit	Thu Mar 23 10:01:18 2000
+++ Completion/Core/compinit	Thu Mar 23 10:26:40 2000
@@ -98,9 +98,10 @@
   _comp_dumpfile="${ZDOTDIR:-$HOME}/.zcompdump"
 fi
 
-# This can hold names of functions that are to be called after all
+# These can hold names of functions that are to be called before/after all
 # matches have been generated.
 
+compprefuncs=()
 comppostfuncs=()
 
 # Loading it now ensures that the `funcstack' parameter is always correct.
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Thu Mar 23 10:00:57 2000
+++ Doc/Zsh/compsys.yo	Thu Mar 23 10:29:26 2000
@@ -1581,12 +1581,6 @@
 called. If the return value is zero, no other completers are tried and the
 tt(_main_complete) function returns.
 
-Immediately before returning the tt(_main_complete) function calls all
-functions whose names are given in the tt(comppostfuncs) array and
-then resets it to an empty array. This can be used by completion
-functions or by other ZLE widgets calling completion to register code
-that is to be executed after all matches have been added.
-
 The following completer functions are contained in the distribution (users
 may write their own):
 
@@ -1979,6 +1973,14 @@
 generating matches all follow the convention of returning zero if they
 generated completions and non-zero if no matching completions could be 
 added.
+
+When writing completion functions or other ZLE widgets that call
+completion, it might be interesting to know about two more features
+offered by the tt(_main_complete) function. The arrays
+tt(compprefuncs) and tt(comppostfuncs) may be set to contain names of
+functions that are to be called immediately before or after completion 
+has been tried. The functions will only be called once, unless they
+put themselves into the array again.
 
 startitem()
 findex(_funcall)

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

