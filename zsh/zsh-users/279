From hzoli@cs.elte.hu Wed Jul 10 07:22:10 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3/2) with ESMTP id HAA08106 for <mason@werple.mira.net.au>; Wed, 10 Jul 1996 07:22:07 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id RAA29303; Tue, 9 Jul 1996 17:15:13 -0400 (EDT)
Resent-Date: Tue, 9 Jul 1996 17:07:56 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199607092107.XAA18460@bolyai.cs.elte.hu>
Subject: Re: Suggested "case" syntax extension
To: segal@morgan.com (Morris M. Siegel)
Date: Tue, 9 Jul 1996 23:07:21 +0200 (MET DST)
Cc: zsh-users@math.gatech.edu
In-Reply-To: <9607091609.ZM9713@morgan.com> from "Morris M. Siegel" at "Jul 9, 96 04:09:07 pm"
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL16 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"DB5dq1.0.X77.heiun"@euclid>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/279
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 3697
Status: OR

> > case foo in
> > (f*) echo yes;;
> > (*) echo no;;
> > esac
> >
> > works.
>
> I'm glad to learn this has already been implemented.  (The last time I tried it
> was with 2.6-beta20, I believe.)  However, I double-checked in the zsh-3.0-pre2
> distribution, and both man/man1/zshmisc.1 and Doc/zshmisc.man lack any mention
> of an optional leading '('.  This should be fairly easy to remedy.

Here it is.  It also improves parsing a little bit.

Zoltan


*** Src/parse.c	1996/07/08 01:56:51	2.16
--- Src/parse.c	1996/07/09 20:57:16
***************
*** 488,494 ****
      lists = newlinklist();
      for (;;) {
  	char *str;
- 	int barct;
  
  	while (tok == SEPER)
  	    yylex();
--- 488,493 ----
***************
*** 503,515 ****
  	    break;
  	}
  	str = tokstr;
- 	barct = 0;
  	yylex();
  	while (tok == BAR) {
  	    char *str2;
  	    int sl = strlen(str);
  
- 	    barct++;
  	    yylex();
  	    if (tok == OUTPAR) {
  		str2 = ncalloc(sl + 2);
--- 502,512 ----
***************
*** 532,538 ****
  	incmdpos = 1;
  	if (tok != OUTPAR) {
  	    /* POSIX allows (foo*) patterns */
! 	    if (barct || str[strlen(str)-1] != Outpar)
  		YYERRORV;
  	} else
  	    yylex();
--- 529,537 ----
  	incmdpos = 1;
  	if (tok != OUTPAR) {
  	    /* POSIX allows (foo*) patterns */
! 	    char *s = str;
! 
! 	    if (skipparens(Inpar, Outpar, &s) || *s)
  		YYERRORV;
  	} else
  	    yylex();
*** Doc/zshmisc.man	1996/07/07 16:00:21	2.10
--- Doc/zshmisc.man	1996/07/09 21:00:13
***************
*** 172,178 ****
  .PP
  .PD 0
  .TP
! \fBcase\fP \fIword\fP \fBin\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fBesac\fP
  Execute the \fIlist\fP associated with the first \fIpattern\fP
  that matches \fIword\fP, if any.  The form of the patterns
  is the same as that used for filename generation.  See
--- 172,178 ----
  .PP
  .PD 0
  .TP
! \fBcase\fP \fIword\fP \fBin\fP [ [\fB(\fP] \fIpattern\fP \fB)\fP \fIlist\fP ;; ] ...  \fBesac\fP
  Execute the \fIlist\fP associated with the first \fIpattern\fP
  that matches \fIword\fP, if any.  The form of the patterns
  is the same as that used for filename generation.  See
***************
*** 181,187 ****
  .PP
  .PD 0
  .TP
! \fBcase\fP \fIword\fP \fB{\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fB}\fP
  Another form of \fBcase\fP.
  .PD
  .PP
--- 181,187 ----
  .PP
  .PD 0
  .TP
! \fBcase\fP \fIword\fP \fB{\fP [ [\fB(\fP] \fIpattern\fP \fB)\fP \fIlist\fP ;; ] ...  \fB}\fP
  Another form of \fBcase\fP.
  .PD
  .PP
*** Doc/zsh.texi	1996/07/09 17:11:50	2.7
--- Doc/zsh.texi	1996/07/09 21:02:23
***************
*** 616,622 ****
  @item repeat @var{word} @var{sublist}
  This is a short form of @code{repeat}.
  
! @item case @var{word} in [ @var{pattern} ) @var{list} ;; ] @dots{} esac
  @findex case
  @cindex case selection
  @cindex selection, case
--- 616,622 ----
  @item repeat @var{word} @var{sublist}
  This is a short form of @code{repeat}.
  
! @item case @var{word} in [ [(] @var{pattern} ) @var{list} ;; ] @dots{} esac
  @findex case
  @cindex case selection
  @cindex selection, case
***************
*** 624,630 ****
  matches @var{word}, if any.  The form of the patterns is the same as
  that used for filename generation.  @xref{Filename Generation}.
  
! @item case @var{word} @{ [ @var{pattern} ) @var{list} ;; ] @dots{} @}
  Another form of @code{case}.
  
  @item select @var{name} [ in @var{word} @dots{} ]
--- 624,630 ----
  matches @var{word}, if any.  The form of the patterns is the same as
  that used for filename generation.  @xref{Filename Generation}.
  
! @item case @var{word} @{ [ [(] @var{pattern} ) @var{list} ;; ] @dots{} @}
  Another form of @code{case}.
  
  @item select @var{name} [ in @var{word} @dots{} ]


