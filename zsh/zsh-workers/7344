From zsh-workers-return-7344-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Aug 02 10:59:17 1999
Return-Path: <zsh-workers-return-7344-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24825 invoked from network); 2 Aug 1999 10:59:11 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 2 Aug 1999 10:59:11 -0000
Received: (qmail 2893 invoked by alias); 2 Aug 1999 10:58:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7344
Received: (qmail 2886 invoked from network); 2 Aug 1999 10:58:57 -0000
Date: Mon, 2 Aug 1999 12:58:55 +0200 (MET DST)
Message-Id: <199908021058.MAA12713@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Tanaka Akira's message of 27 Jul 1999 18:53:19 +0900
Subject: Re: Completion problems.


Tanaka Akira wrote:

> I found a problem about the conditional expression for completion.
> 
> is27e1u11% autoload -U compinit; compinit -D
> is27e1u11% _tst () { if [[ -prefix */ ]]; then compadd ../t; else compadd ../f; fi }
> is27e1u11% compdef _tst tst
> is27e1u11% tst ../<TAB>
> 
> Then, I get:
> 
> is27e1u11% tst ../f 
> 
> I think it should be "../t ".

Definitely, yes. The problem was that cond_str() always returned an
untokenized string. The patch gives a new argument to it which may be
non-zero to get the tokenized form. Then there were some missing tests 
for `if (mod)' in do_comp_vars() (mod says if the special parameters
should be modified). Some of the new tests are superfluous for the
condition codes we have now, but if someone once changes this, the
tests will already be there.

> Hm. compset -P is bit dangerous for quoted characters.
> 
> is27e1u11% autoload -U compinit; compinit -D
> is27e1u11% _tst () { compset -P '*/'; compadd tst }
> is27e1u11% compdef _tst tst
> is27e1u11% tst \#/<TAB>
> 
> Then, I get:
> 
> is27e1u11% tst \\\#/tst 

That's wrong, too. Again, this is a problem with the recently changed
quoting behaviour. The prefix is reported in quoted form and appended
and prepended to IPREFIX/ISUFFIX -- which will be quoted again when it 
is inserted.

Bye
 Sven

diff -u os/cond.c Src/cond.c
--- os/cond.c	Mon Aug  2 11:44:45 1999
+++ Src/cond.c	Mon Aug  2 11:56:31 1999
@@ -303,12 +303,13 @@
 
 /**/
 char *
-cond_str(char **args, int num)
+cond_str(char **args, int num, int raw)
 {
     char *s = args[num];
 
     singsub(&s);
-    untokenize(s);
+    if (!raw)
+	untokenize(s);
 
     return s;
 }
diff -u os/Zle/compctl.c Src/Zle/compctl.c
--- os/Zle/compctl.c	Mon Aug  2 11:44:52 1999
+++ Src/Zle/compctl.c	Mon Aug  2 12:51:28 1999
@@ -1888,7 +1888,7 @@
     char *tmp, sav = compprefix[l];
 
     compprefix[l] = '\0';
-    tmp = tricat(compiprefix, compprefix, "");
+    tmp = tricat(compiprefix, rembslash(compprefix), "");
     zsfree(compiprefix);
     compiprefix = tmp;
     compprefix[l] = sav;
@@ -1903,7 +1903,7 @@
     char *tmp, sav;
 
     l = strlen(compsuffix) - l;
-    tmp = tricat(compsuffix + l, compisuffix, "");
+    tmp = tricat(rembslash(compsuffix + l), compisuffix, "");
     zsfree(compisuffix);
     compisuffix = tmp;
     sav = compsuffix[l];
@@ -1947,8 +1947,8 @@
 
 	    if (compcurrent - 1 < na || compcurrent - 1 > nb)
 		return 0;
-
-	    restrict_range(na, nb);
+	    if (mod)
+		restrict_range(na, nb);
 	    return 1;
 	}
     case CVT_RANGEPAT:
@@ -1989,7 +1989,7 @@
 	    }
 	    if (e < b)
 		t = 0;
-	    if (t)
+	    if (t && mod)
 		restrict_range(b, e);
 	    return t;
 	}
@@ -2043,8 +2043,8 @@
 		}
 		if (!l)
 		    return 0;
-
-		ignore_prefix(p - compprefix);
+		if (mod)
+		    ignore_prefix(p - compprefix);
 	    } else {
 		int l, ol, add;
 		char *p;
@@ -2065,8 +2065,8 @@
 
 		if (!l)
 		    return 0;
-
-		ignore_suffix(ol - (p - compsuffix));
+		if (mod)
+		    ignore_suffix(ol - (p - compsuffix));
 	    }
 	    return 1;
 	}
@@ -2469,10 +2469,10 @@
 {
     if (comp_check()) {
 	if (a[1])
-	    return do_comp_vars(id, cond_val(a, 0), cond_str(a, 1),
+	    return do_comp_vars(id, cond_val(a, 0), cond_str(a, 1, 1),
 				0, NULL, 0);
 	else
-	    return do_comp_vars(id, -1, cond_str(a, 0), 0, NULL, 0);
+	    return do_comp_vars(id, -1, cond_str(a, 0, 1), 0, NULL, 0);
     }
     return 0;
 }
@@ -2481,8 +2481,8 @@
 static int
 cond_range(char **a, int id)
 {
-    return do_comp_vars(CVT_RANGEPAT, 0, cond_str(a, 0), 0,
-			(id ? cond_str(a, 1) : NULL), 0);
+    return do_comp_vars(CVT_RANGEPAT, 0, cond_str(a, 0, 1), 0,
+			(id ? cond_str(a, 1, 1) : NULL), 0);
 }
 
 static struct builtin bintab[] = {
--- Util/zsh-development-guide.old	Mon Aug  2 11:58:18 1999
+++ Util/zsh-development-guide	Mon Aug  2 11:59:03 1999
@@ -285,11 +285,12 @@
 no substitutions are performed on them and that they will be
 tokenized. There are three helper functions available:
 
-  - char *cond_str(args, num)
+  - char *cond_str(args, num, raw)
     The first argument is the array of strings the handler function
     got as an argument and the second one is an index into this array.
     The return value is the num'th string from the array with
-    substitutions performed and untokenized.
+    substitutions performed. If the last argument is zero, the string
+    will also be untokenized.
   - long cond_val(args, num)
     The arguments are the same as for cond_str(). The return value is
     the result of the mathematical evaluation of the num'th string

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

