From zsh-users-return-12477-mason-zsh=primenet.com.au@sunsite.dk Fri Jan 25 05:59:44 2008
Return-Path: <zsh-users-return-12477-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13646 invoked from network); 25 Jan 2008 05:59:41 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.4 (2008-01-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 25 Jan 2008 05:59:41 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 11834 invoked from network); 25 Jan 2008 05:59:30 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 25 Jan 2008 05:59:30 -0000
Received: (qmail 4130 invoked by alias); 25 Jan 2008 05:59:19 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 12477
Received: (qmail 4116 invoked from network); 25 Jan 2008 05:59:18 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 25 Jan 2008 05:59:18 -0000
Received: from vms048pub.verizon.net (vms048pub.verizon.net [206.46.252.48])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 0B52980190F6
	for <zsh-users@sunsite.dk>; Fri, 25 Jan 2008 06:59:14 +0100 (CET)
Received: from torch.brasslantern.com ([71.121.18.67])
 by vms048.mailsrvcs.net (Sun Java System Messaging Server 6.2-6.01 (built Apr
 3 2006)) with ESMTPA id <0JV6003RIRA238W2@vms048.mailsrvcs.net> for
 zsh-users@sunsite.dk; Thu, 24 Jan 2008 23:58:51 -0600 (CST)
Received: from torch.brasslantern.com (localhost.localdomain [127.0.0.1])
	by torch.brasslantern.com (8.13.1/8.13.1) with ESMTP id m0P5wnZ2019760; Thu,
 24 Jan 2008 21:58:49 -0800
Received: (from schaefer@localhost)	by torch.brasslantern.com
 (8.13.1/8.13.1/Submit) id m0P5wmie019759; Thu, 24 Jan 2008 21:58:48 -0800
Date: Thu, 24 Jan 2008 21:58:48 -0800
From: Bart Schaefer <schaefer@brasslantern.com>
Subject: Re: idea for new feature (was: Re: sticky-note and zle bindings)
In-reply-to: <13ed09c00801241017x1cd7c454lcbf9156b6bccd9bb@mail.gmail.com>
To: "Robert Knight" <robertknight@gmail.com>, zsh-users@sunsite.dk
Message-id: <080124215848.ZM19758@torch.brasslantern.com>
MIME-version: 1.0
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
Content-type: text/plain; charset=us-ascii
References: <13ed09c00801241017x1cd7c454lcbf9156b6bccd9bb@mail.gmail.com>
Comments: In reply to "Robert Knight" <robertknight@gmail.com>
 "Re: idea for new feature (was: Re: sticky-note and zle bindings)" (Jan 24,
 6:17pm)
X-Virus-Scanned: ClamAV 0.91.2/5548/Fri Jan 25 04:46:51 2008 on bifrost
X-Virus-Status: Clean

On Jan 24,  6:17pm, Robert Knight wrote:
}
} I think the SHELL_SESSION_COOKIE suggestion (perhaps
} SHELL_SESSION_ID?) would be best from my point of view as a Konsole
} developer.  The value should be a unique ID of a known format so that
} terminals don't end up generating pre-existing IDs by mistake.

So in this scheme the terminal emulator creates the SHELL_SESSION_ID
and places it in the environment when the shell is started?  I.e.,
Konsole would be responsible for telling the shell which session to
resume (or to start a new one)?

If that's not what you mean, can you be more specific?

} The only problem with this approach is that there needs to be a way
} for a particular session to be ended.

I'm not sure I follow the nuances here.  If a single window closes
before the user shuts his whole desktop session down, then the session
for that window ends, doesn't it?  Regardless of what application is
the creator of that window?

Is what you mean that the shell needs to find out when it can "garbage
collect" whatever data it has stored for a session that's never going
to be resumed?

} * End a session when an explicit command is sent to it
}   (eg. 'Ctrl+D' or 'exit')

Certainly the shell can clean up when it believes the session is not
going to be resumed.  Even if a terminal emulator later re-uses the
same session ID, the shell will just act as if a new session started.

Of course I may be completely in left field here.

} * Don't end sessions.  Instead keep data around for the last X sessions
}   (where X might be 5,10 or 20).

You'd have to do some kind of time limit rather than a number limit.
I sometimes have more than 20 shell windows open at a time.

} * Define a new escape code to end a session.

What does "escape code" mean here?  What sends it, and to who?

Here's a slightly different suggestion:  Instead of SHELL_SESSION_ID,
how about SHELL_SESSION_FILE ?  The terminal creates a file and puts
the path to it in the environment.  The shell can then choose to put
its session data in that file, or put it somewhere else and use the
file as a semaphore.  If the emulator (or the desktop session, even)
decides that the shell session has ended, it removes that file.  If
the shell stored its data in the file, the session is gone.  If it
used the file as a semaphore it can garbage-collect any session data
for which the file no longer exists.  (The file would have to be in a
predictable location (SHELL_SESSION_DIR ?) for the latter to work.)

