From zsh-workers-request@euclid.skiles.gatech.edu  Mon Jul 29 21:18:31 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.5/8.7.3) with ESMTP id VAA00389 for <mason@primenet.com.au>; Mon, 29 Jul 1996 21:18:25 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id HAA12604; Mon, 29 Jul 1996 07:07:17 -0400 (EDT)
Resent-Date: Mon, 29 Jul 1996 07:07:17 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199607291106.NAA01423@bolyai.cs.elte.hu>
Subject: isearch case sensitivity
To: zsh-workers@math.gatech.edu (Zsh workers list)
Date: Mon, 29 Jul 1996 13:06:22 +0200 (MET DST)
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL16 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"Jkhv_3.0.s43.bj9_n"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/1813
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

As you have probably noticed in 3.0-pre4 incremental-search zle functions
are case-insensitive if the search string does not have uppercase letters
like in emacs.  The patch below documents this behaviour and changes
isearch to be case insensitive only if no numeric argument was given.

Zoltan


rcsdiff -qc -kk -r2.21 -r2.22 Src/zle_hist.c
*** Src/zle_hist.c
--- Src/zle_hist.c	1996/07/28 19:50:55	2.22
***************
*** 662,668 ****
      char *s, *ibuf = halloc(80), *sbuf = ibuf + FIRST_SEARCH_CHAR;
      int sbptr = 0, cmd, top_spot = 0, pos, sibuf = 80;
      int nomatch = 0, skip_line = 0, skip_pos = 0;
!     int odir = dir, *obindtab = bindtab;
      static char *previous_search = NULL;
      static int previous_search_len = 0;
  
--- 662,668 ----
      char *s, *ibuf = halloc(80), *sbuf = ibuf + FIRST_SEARCH_CHAR;
      int sbptr = 0, cmd, top_spot = 0, pos, sibuf = 80;
      int nomatch = 0, skip_line = 0, skip_pos = 0;
!     int odir = dir, *obindtab = bindtab, sens = zmult == 1 ? 3 : 1;
      static char *previous_search = NULL;
      static int previous_search_len = 0;
  
***************
*** 701,708 ****
  		    skip_pos = 0;
  		}
  		if (!skip_line && ((sbuf[0] == '^') ?
! 		    (t = metadiffer(s, sbuf + 1, sbptr - 1) < 3 ? s : NULL) :
! 		    (t = hstrnstr(s, pos, sbuf, sbptr, dir)))) {
  		    setline(s);
  		    pos = t - s;
  		    cs = ztrsub(t, s) + (dir == 1? sbptr - (sbuf[0]=='^') : 0);
--- 701,708 ----
  		    skip_pos = 0;
  		}
  		if (!skip_line && ((sbuf[0] == '^') ?
! 		    (t = metadiffer(s, sbuf + 1, sbptr - 1) < sens ? s : NULL) :
! 		    (t = hstrnstr(s, pos, sbuf, sbptr, dir, sens)))) {
  		    setline(s);
  		    pos = t - s;
  		    cs = ztrsub(t, s) + (dir == 1? sbptr - (sbuf[0]=='^') : 0);
***************
*** 1074,1080 ****
  	if (*visrchstr == '^') {
  	    if (!strncmp(s, visrchstr + 1, t0 - 1))
  		break;
! 	} else if (hstrnstr(s, 0, visrchstr, t0, 1))
  	    break;
      }
      setline(s);
--- 1074,1080 ----
  	if (*visrchstr == '^') {
  	    if (!strncmp(s, visrchstr + 1, t0 - 1))
  		break;
! 	} else if (hstrnstr(s, 0, visrchstr, t0, 1, 1))
  	    break;
      }
      setline(s);
rcsdiff -qc -kk -r2.10 -r2.11 Src/zle_utils.c
*** Src/zle_utils.c
--- Src/zle_utils.c	1996/07/28 19:50:55	2.11
***************
*** 274,292 ****
  
  /**/
  char *
! hstrnstr(char *haystack, int pos, char *needle, int len, int dir)
  {
      char *s = haystack + pos;
  
      if (dir > 0) {
  	while (*s) {
! 	    if (metadiffer(s, needle, len) < 3)
  		return s;
  	    s += 1 + (*s == Meta);
  	}
      } else {
  	for (;;) {
! 	    if (metadiffer(s, needle, len) < 3)
  		return s;
  	    if (s == haystack)
  		break;
--- 274,292 ----
  
  /**/
  char *
! hstrnstr(char *haystack, int pos, char *needle, int len, int dir, int sens)
  {
      char *s = haystack + pos;
  
      if (dir > 0) {
  	while (*s) {
! 	    if (metadiffer(s, needle, len) < sens)
  		return s;
  	    s += 1 + (*s == Meta);
  	}
      } else {
  	for (;;) {
! 	    if (metadiffer(s, needle, len) < sens)
  		return s;
  	    if (s == haystack)
  		break;
rcsdiff -qc -kk -r2.6 -r2.7 Doc/zshzle.man
*** Doc/zshzle.man
--- Doc/zshzle.man	1996/07/29 11:00:52	2.7
***************
*** 180,191 ****
  (i.e. the one that isn't history yet).
  .TP
  \fBhistory-incremental-search-backward\fP (^R ^Xr) (unbound) (unbound)
! Search backward incrementally for a specified string.
! The string may begin with `^' to anchor the search to the
! beginning of the line. A restricted set of editing functions is available in
! the mini-buffer. An interrupt signal, as defined by the stty setting,  will
! stop the search and go back to the original line. An undefined key will have
! the same effect. The supported functions are:
  backward-delete-char, vi-backward-delete-char,
  clear-screen, redisplay,
  quoted-insert, vi-quoted-insert,
--- 180,192 ----
  (i.e. the one that isn't history yet).
  .TP
  \fBhistory-incremental-search-backward\fP (^R ^Xr) (unbound) (unbound)
! Search backward incrementally for a specified string.  The search is
! case-insensitive if the search string does not have uppercase letters and no
! numeric argument was given.  The string may begin with `^' to anchor the
! search to the beginning of the line. A restricted set of editing functions
! is available in the mini-buffer. An interrupt signal, as defined by the stty
! setting, will stop the search and go back to the original line. An undefined
! key will have the same effect. The supported functions are:
  backward-delete-char, vi-backward-delete-char,
  clear-screen, redisplay,
  quoted-insert, vi-quoted-insert,
***************
*** 209,218 ****
  executed.
  .TP
  \fBhistory-incremental-search-forward\fP (^S ^Xs) (unbound) (unbound)
! Search forward incrementally for a specified string.
! The string may begin with `^' to anchor the search to the
! beginning of the line. The functions available in the mini-buffer are the same
! as for \fBhistory-incremental-search-backward\fP.
  .TP
  \fBhistory-search-backward\fP (ESC-P ESC-p) (unbound) (unbound)
  Search backward in the history for a line beginning with the first
--- 210,220 ----
  executed.
  .TP
  \fBhistory-incremental-search-forward\fP (^S ^Xs) (unbound) (unbound)
! Search forward incrementally for a specified string.  The search is
! case-insensitive if the search string does not have uppercase letters and no
! numeric argument was given.  The string may begin with `^' to anchor the
! search to the beginning of the line. The functions available in the
! mini-buffer are the same as for \fBhistory-incremental-search-backward\fP.
  .TP
  \fBhistory-search-backward\fP (ESC-P ESC-p) (unbound) (unbound)
  Search backward in the history for a line beginning with the first

