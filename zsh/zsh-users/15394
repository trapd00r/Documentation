From zsh-users-return-15394-mason-zsh=primenet.com.au@zsh.org Sun Sep 12 19:02:36 2010
Return-Path: <zsh-users-return-15394-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1122 invoked by alias); 12 Sep 2010 19:02:36 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15394
Received: (qmail 18377 invoked from network); 12 Sep 2010 19:02:33 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100912120223.ZM17365@torch.brasslantern.com>
Date: Sun, 12 Sep 2010 12:02:23 -0700
In-reply-to: <20100910063544.45240@gmx.net>
Comments: In reply to "Dominik Vogt" <dominik.vogt@gmx.de>
 "Tesing a fifo without opening it?" (Sep 10,  8:35am)
References: <20100910063544.45240@gmx.net>  <20100910113632.GA4692@yahoo.fr>
	<20100910123616.114190@gmx.net>
In-reply-to: <20100910113632.GA4692@yahoo.fr>
Comments: In reply to Stephane Chazelas <stephane_chazelas@yahoo.fr>
 "Re: Tesing a fifo without opening it?" (Sep 10, 12:36pm)
In-reply-to: <20100910123616.114190@gmx.net>
Comments: In reply to "Dominik Vogt" <dominik.vogt@gmx.de>
 "Re: Tesing a fifo without opening it?" (Sep 10,  2:36pm)
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Tesing a fifo without opening it?
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 10,  8:35am, Dominik Vogt wrote:
}
} I'm writing a multi process scripting system in zsh:

Aside:  You need to be careful with this sort of thing; if at any point
the amount of data being written exceeds the kernel buffer size of the
fifo, the writer will block, and if the other process happens also to
be writing a reply, you end up with deadlock.  As long as you keep the
two in lock step alternating with builtin read/print, you're probably
OK, but with the "send exit to the sub scripts" addition you may be
venturing into more dangerous territory.
 
} So far, this works very well.  Note that reading from an writing to the
} pipes blocks (in the open() call) until the other end has also opened
} the pipe.  Also note that the main script may start many concurrent sub
} scripts and communicate with them through many different fifos.

Did you consider using the coproc mechanism for this?  That creates a
two-way socket instead of separate fifos in the filesystem.  If it's
important that the fifos be available to processes other than the
parent and child, then you can't use coproc, but otherwise it's much
easier to manage because (among other things) the coprocess starts with
the socket already open.

You can have multiple coprocesses by copying the magic 'p' descriptor
to another descriptor with the exec builtin:

    coproc ...
    exec {in}<&p {out}>&p

Now you can do (in the parent)

    read -u $in ...
    print -u $out ...

and you can start another command with coproc without the first one
getting EOF.  (You will need to stash the values of $in and $out
before re-using those names in another exec.)

} ---- sub script
} 01 read REQUEST < "$1"
} 02 echo answer > "$2"

Of course with the coproc, these are stdin/stdout so you don't need
$1 and $2 and redirections.  If for some reason you're counting on
the script to have inherited the parent's stdin/out, you can't use
coproc.

} 03 # do something
} 04 while true; do
} 05   if read -t REQUEST < "$1"; then
} 06     echo answer > $2
} 07     test x"$REQUEST" = xexit && exit
} 08   else
} 09     # do something else
} 10     ...
} 11   fi
} 12 done
} ----
} 
} Now, the problem is that input redirection in line 5 blocks until
} the main script also opens the fifo.

This problem disappears with a coproc, because stdin is already open.
Just "read -t REQUEST" and you're done.


On Sep 10, 12:36pm, Stephane Chazelas wrote:
} 
} : > "$1" & read...
} 
} though it would have other side effects.

Something is vaguely bothering me about that approach but I can't decide
exactly what.

