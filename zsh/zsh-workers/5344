From zsh-workers-return-5344-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 11 17:56:09 1999
Return-Path: <zsh-workers-return-5344-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17663 invoked from network); 11 Feb 1999 17:56:07 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Feb 1999 17:56:07 -0000
Received: (qmail 9908 invoked by alias); 11 Feb 1999 17:55:32 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5344
Received: (qmail 9792 invoked from network); 11 Feb 1999 17:53:05 -0000
Message-Id: <9902111708.AA58097@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk
Subject: Re: Tar file and Re: Bad interaction between -iprefix and -string 
In-Reply-To: "Sven Wischnowsky"'s message of "Thu, 11 Feb 1999 16:27:38 NFT."
             <199902111527.QAA05726@beta.informatik.hu-berlin.de> 
Date: Thu, 11 Feb 1999 18:08:34 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>

Sven Wischnowsky wrote:
> If Peter sends us his autoloading stuff, maybe we can join all the
> nice ideas both of us had.

You've done a good bit more than I have; most of my time was spent
constructing replacement functions.  I found a couple of problems.
One was that autoloaded arrays needed an extra "" around to allow null
elements to be passed through; I found this from complist -H 0 ''
which was dropping the last part.  Another was that for some reason

for i in "$patcomps[@]"; do

was being called when patcomps was empty (should it really do that?)
when was calling all sorts of bother, so I added a (( $#patcomps ))
test.

>   - I also added support for Peter-like (sorry ;-) special completion
>     keys, see the comment in `init'

I think this could be a bit neater: in the patch, the widget defined
now has the same name as the file with the #key-array or #key-function
in it.  This was easy, it just needed $keycomps to be an assoc array.
This would be a limitation if you wanted to have widgets of a
different type (e.g. listing instead of completing) associated with
the same function; we could concatenate the names in that case.  I
vaguely thought of some extension to allow binding of multiple keys at
once by this, either
  #key-array \e/ \M/ history-complete
or perhaps better
  #key-array history-complete \e/ \M/
but I haven't done that here.

--- Misc/Completion/init	Thu Feb 11 16:16:40 1999
+++ /home/user2/pws/bin/comp/init	Thu Feb 11 17:38:02 1999
@@ -56,7 +56,7 @@
 # are the names of the command, the values are names of functions or variables
 # that are to be used to generate the matches.
 # Pattern completions will be stored in an normal array named `patcomps'.
-# Completion definitions bound directly to keys are store in an array
+# Completion definitions bound directly to keys are store in an assoc array
 # named `keycomps'.
 
 typeset -A comps
@@ -166,7 +166,7 @@
   if [[ ${(P)+def} -eq 1 ]]; then
     # It is a parameter name, call complist directly.
 
-    complist ${(@P)def}
+    complist "${(@P)def}"
   else
     # Otherwise it's a function name, call this function.
 
@@ -177,9 +177,10 @@
 
 # Now we make the files automatically autoloaded.
 
-local dir file line key=1
+local dir file line
 
 for dir in $fpath; do
+  [[ $dir = . ]] && continue
   for file in $dir/__*~*~(N); do
     read -rA line < $file
     if [[ $line[1] = '#function' ]]; then
@@ -191,16 +192,16 @@
     elif [[ $line[1] = '#pattern-array' ]]; then
       defcomp " $file" "$line[2]"
     elif [[ $line[1] = '#key-function' ]]; then
-      zle -C __complete_key_$key $line[3] __main_key_complete
-      bindkey "$line[2]" __complete_key_$key
+      (( ${+keycomps} )) || typeset -A keycomps
+      zle -C ${file:t} $line[3] __main_key_complete
+      bindkey "$line[2]" ${file:t}
       autoload ${file:t}
-      keycomps[key]=${file:t}
-      (( key++ ))
+      keycomps[${file:t}]=${file:t}
     elif [[ $line[1] = '#key-array' ]]; then
-      zle -C __complete_key_$key $line[3] __main_key_complete
-      bindkey "$line[2]" __complete_key_$key
-      keycomps[key]=" $file"
-      (( key++ ))
+      (( ${+keycomps} )) || typeset -A keycomps
+      zle -C ${file:t} $line[3] __main_key_complete
+      bindkey "$line[2]" ${file:t}
+      keycomps[${file:t}]=" $file"
     elif [[ $line[1] = '#helper' ]]; then
       autoload ${file:t}
     fi
--- Misc/Completion/__normal	Thu Feb 11 16:06:29 1999
+++ /home/user2/pws/bin/comp/__normal	Thu Feb 11 17:45:47 1999
@@ -23,13 +23,15 @@
 
 # See if there are any matching pattern completions.
 
-for i in "$patcomps[@]"; do
-  pat="${i% *}"
-  val="${i#* }"
-  if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]]; then
-    callcomplete patcomps "$pat" "$@" || return 1
-  fi
-done
+if (( $#patcomps )); then
+  for i in "$patcomps[@]"; do
+    pat="${i% *}"
+    val="${i#* }"
+    if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]]; then
+      callcomplete patcomps "$pat" "$@" || return 1
+    fi
+  done
+fi
 
 # Now look up the two names in the normal completion array.
 
-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

