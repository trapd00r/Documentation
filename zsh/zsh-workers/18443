From zsh-workers-return-18443-mason-zsh=primenet.com.au@sunsite.dk Tue Apr 15 17:03:04 2003
Return-Path: <zsh-workers-return-18443-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9031 invoked from network); 15 Apr 2003 17:03:04 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 15 Apr 2003 17:03:04 -0000
Received: (qmail 22285 invoked by alias); 15 Apr 2003 17:02:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 18443
Received: (qmail 22277 invoked from network); 15 Apr 2003 17:02:54 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 15 Apr 2003 17:02:54 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [212.125.75.4] by sunsite.dk (MessageWall 1.0.8) with SMTP; 15 Apr 2003 17:2:54 -0000
Received: (qmail 8239 invoked from network); 15 Apr 2003 17:02:52 -0000
Received: from iris.logica.co.uk (158.234.9.163)
  by server-20.tower-1.messagelabs.com with SMTP; 15 Apr 2003 17:02:52 -0000
Received: from gmcs3.logica.co.uk ([158.234.142.61])
	by iris.logica.co.uk (8.9.3/8.9.3/Debian 8.9.3-21) with ESMTP id SAA02670
	for <zsh-workers@sunsite.dk>; Tue, 15 Apr 2003 18:02:51 +0100
X-Authentication-Warning: iris.logica.co.uk: Host [158.234.142.61] claimed to be gmcs3.logica.co.uk
Received: from gmcs3.logica.co.uk (localhost [127.0.0.1])
	by gmcs3.logica.co.uk (8.11.6/8.11.6/SuSE Linux 0.5) with ESMTP id h3FH2bf11925
	for <zsh-workers@sunsite.dk>; Tue, 15 Apr 2003 19:02:38 +0200
X-VirusChecked: Checked
From: Oliver Kiddle <okiddle@yahoo.co.uk>
To: Zsh workers <zsh-workers@sunsite.dk>
Subject: PATCH: new dcop completion
Date: Tue, 15 Apr 2003 19:02:37 +0200
Message-ID: <11923.1050426157@gmcs3.logica.co.uk>

I think the latest version adds a dcopquit and options to dcop so I'll
add those at a later point. I'm not too sure about the latter arguments
to dcopstart. The documentation is quite lacking and to even get this far,
I had to look at the source.

Oliver

#compdef dcop dcopstart dcopfind dcopref dcopclient dcopobject

local curcontext="$curcontext" desc vals arg base max=0 ret=1
local app obj fun
local -a state line expl

case $service in
  dcop(client|object))
    state=( dcopref )
    max=2
  ;;
  dcopref) max=3 ;;
  dcopstart)
    if (( CURRENT > 2 )); then
      _urls && return
    fi
  ;;
  dcopfind)
    local cmd=$words[1]
    _arguments -C \
      '-a[print application id instead of DCOPRef]' \
      '-l[if object not found, run dcopstart and retry]' \
      '*::args:->args' && ret=0
    unset state
    words=( $cmd $words )
    (( CURRENT++ ))
  ;;
esac

if (( max && CURRENT > max )); then
  _message 'no more arguments'
  return 1
fi

if [[ -z "$state" ]]; then
  state=(application object function)
  [[ $words[2] = DCOPRef* && CURRENT -ne 2 ]]
  base=$?
  state=( ${state[CURRENT-base]:-arg} )

  [[ $state[1] = application && $service = dcop(|find) ]] && state+=( dcopref )
fi

while (( $#state )); do
  unset app obj fun

  if [[ $words[2] = (#b)DCOPRef*\(([^,]#)((#e)|,)([^\\\)]#)(*) ]]; then
    if [[ -n $match[2] ]]; then
      app=$match[1]
      if [[ -n $match[4] ]]; then
        obj=$match[3]
	[[ -n $words[3] && CURRENT -gt 3 ]] && fun=$words[3]
      fi
    fi
  else
    case $CURRENT in
      <5->) fun="$words[4]" ;&
      4) obj="$words[3]" ;&
      3) app="$words[2]" ;;
    esac
  fi
  vals=( ${(f)"$(_call_program dcop-$state[1]s ${(M)words[1]##*/}dcop $app $obj 2>/dev/null)"} )

  case "$state[1]" in
    application|object)
      [[ -n ${(M)vals:#*\(default\)} ]] && vals+=( default )
      _wanted dcop-$state[1]s expl $state[1] compadd "$@" - ${vals% \(default\)} && ret=0
    ;;

    function)
      [[ $service = dcopfind ]] && vals=( ${(M)vals:#bool *} )
      _wanted dcop-$state[1]s expl $state[1] compadd "$@" - ${${vals#* }%\(*} && ret=0
    ;;

    arg)
      arg=${${${(M)vals:#*$fun\(*}#*\(}%\)*},
      arg=${${(s.,.)arg}[CURRENT-base-3]}
      if [[ -n $arg ]]; then
	if [[ $arg = (Q(|C)String|*int )* || $arg != *\ * ]]; then
	  # don't mention the argument's type
	  desc="${arg##* }"
	else
	  desc="${arg##* } (${arg% *})"
	fi
	case $arg in
	  bool*) _wanted argument expl "$desc" compadd true false && return ;;
	  (#i)*(file|path|dir)*) _wanted argument expl "$desc" _files && return ;;
	  (#i)*url*) _wanted argument expl "$desc" _urls && return ;;
	  *) _message -e argument "$desc" ;;
	esac
      else
	_message 'no more arguments'
      fi
    ;;

    dcopref)
      if ! compset -P '*\('; then
	_wanted dcoprefs expl 'dcop ref' compadd -S '' 'DCOPRef(' && ret=0
      elif compset -P '*,'; then
        if compset -S '(|\\)\)*'; then
	  set -- -S '' "$@"
	else
	  set -- "$@" -S"${${QIPREFIX:+)}:-\)}$compstate[quote] "
	fi
        state+=( object )
      else
        if compset -S ',*'; then
	  set -- "$@" -S ''
	else
	  set -- "$@" -S ,
	fi
        state+=( application )
      fi
    ;;
  esac
  shift state
done

return ret

