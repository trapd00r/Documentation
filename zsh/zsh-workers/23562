From zsh-workers-return-23562-mason-zsh=primenet.com.au@sunsite.dk Fri Jun 15 10:11:42 2007
Return-Path: <zsh-workers-return-23562-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11612 invoked from network); 15 Jun 2007 10:11:36 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.1 (2007-05-02) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.1
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 15 Jun 2007 10:11:36 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 87100 invoked from network); 15 Jun 2007 10:11:29 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 15 Jun 2007 10:11:29 -0000
Received: (qmail 14303 invoked by alias); 15 Jun 2007 10:11:25 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 23562
Received: (qmail 14293 invoked from network); 15 Jun 2007 10:11:23 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 15 Jun 2007 10:11:23 -0000
Received: (qmail 86751 invoked from network); 15 Jun 2007 10:11:23 -0000
Received: from cluster-c.mailcontrol.com (168.143.177.190)
  by a.mx.sunsite.dk with SMTP; 15 Jun 2007 10:11:18 -0000
Received: from cameurexb01.EUROPE.ROOT.PRI ([62.189.241.200])
	by rly14c.srv.mailcontrol.com (MailControl) with ESMTP id l5FA6H3C003538
	for <zsh-workers@sunsite.dk>; Fri, 15 Jun 2007 11:10:54 +0100
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.1830);
	 Fri, 15 Jun 2007 11:09:06 +0100
Date: Fri, 15 Jun 2007 11:09:06 +0100
From: Peter Stephenson <pws@csr.com>
To: "zsh workers" <zsh-workers@sunsite.dk>
Subject: Re: Change in FIGNORE behavior
Message-ID: <20070615110906.04ab8685@news01.csr.com>
In-Reply-To: <200706051419.l55EJZSh013059@news01.csr.com>
References: <20a807210705291856qe306eeds250f4f9d5f4dd33f@mail.gmail.com>
	<200705300945.l4U9jUbE009607@news01.csr.com>
	<20070530112934.3950357b@news01.csr.com>
	<070530035810.ZM29792@torch.brasslantern.com>
	<200705301127.l4UBROR5010814@news01.csr.com>
	<20070530135436.410e11ff@news01.csr.com>
	<20070604104901.276f7d83@news01.csr.com>
	<070604095654.ZM17620@torch.brasslantern.com>
	<200706051419.l55EJZSh013059@news01.csr.com>
Organization: CSR
X-Mailer: Claws Mail 2.9.1 (GTK+ 2.10.8; i386-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-OriginalArrivalTime: 15 Jun 2007 10:09:06.0902 (UTC) FILETIME=[357F6F60:01C7AF35]
X-Scanned-By: MailControl A-07-07-10 (www.mailcontrol.com) on 10.67.0.124

On Tue, 05 Jun 2007 15:19:34 +0100
Peter Stephenson <pws@csr.com> wrote:
> Bart Schaefer wrote:
> > } I think the ideal case would be that a failed (R) returned an
> > index off the } beginning of the array.
> >=20
> > That would be ideal for (I) as well, and in the absence of
> > KSH_ARRAYS it would sort of be possible.  Maybe what we need is
> > (sigh) yet another flag that controls the behavior of index zero.
> >=20
> > Given such a flag (and possibly even without it), we could make it
> > an error to assign to array[0] (treat it as an invalid identifier)
> > when the KSH_ARRAYS option is not in effect.
>=20
> If that's possible, that would be great; I could back off the previous
> patch.  I was figuring it's such long-standing behaviour that that
> won't work.  However, it's not a feature you actually need, just one
> to stop old shells falling over.
>=20
> We could introduce an option KSH_INDEX_ZERO, or something.

I've called it KSH_ZERO_SUBSCRIPT because perusal of the documentation
suggests we don't tend to use the word "index".  I've made it off
by default and removed my previous hacks.  In summary (see the new tests
for examples):

  array=3D(one two three)

With KSH_ZERO_SUBSCRIPT set (old behaviour):
  $array[0]               -> one
  array[(R)notfound]      -> one
  $array[0,2]             -> one two
  array[0]=3Dzero           array -> (zero two three)
  array[0,2]=3D(new)        array -> (new three)

With KSH_ZERO_SUBSCRIPT not set:
  $array[0]               -> [empty]
  array[(R)notfound]      -> [empty]
  $array[0,2]             -> one two
  array[0]=3Dzero           Error
  array[0,2]=3D(new)        array -> (new three)

The behaviour with scalar subscripts corresponds exactly (the subscript
code that changed is common to both).  The behaviour with KSH_ARRAYS
set shouldn't have changed at all.  Indices returned by (i) and (I)
haven't changed either.

This is obviously more consistent, but actually it's in many ways safer
than either the original code or my hacked attempts at fixing (R).
array[(R)notfound,(r)notfound] once again refers to the entire array:
the indexes start before the start of the array and finish after the end,
but cover a valid range, so this is not an error.  Also,  code
like
  (( array[unsetval++] =3D 1 ))
  (( array[unsetval++] =3D 2 ))
(which is presumably intended to refer to the first two elements of array,
but doesn't) is trapped before it does any damage.  As this shows, There's
a very good chance that code using this "feature" is actually buggy.

Note on implementation:  when retrieving a range it was enough to set
the range to one with no elements to get this to work.  However, there
are hacks in the code when setting arrays such that there wasn't a clean
way of trapping an invalid range when setting an element, so I
introduced a flag in the value structure indicating an invalid range.
Code simply retrieving values shouldn't need to test it.


Index: README
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/README,v
retrieving revision 1.47
diff -u -r1.47 README
--- README	29 May 2007 17:01:08 -0000	1.47
+++ README	15 Jun 2007 09:59:53 -0000
@@ -45,6 +45,31 @@
 applies to expressions with forced splitting such as ${=3D1+"$@"}, but
 otherwise the case where SH_WORD_SPLIT is not set is unaffected.
=20
+In previous versions of the shell it was possible to use index 0 in an
+array or string subscript to refer to the same element as index 1 if the
+option KSH_ARRAYS was not in effect.  This was a limited approximation to
+the full KSH_ARRAYS handling and so was not very useful.  In this version
+of the shell, this behaviour is only provided when the option
+KSH_ZERO_SUBSCRIPT is set.  Note that despite the name this does not provi=
de
+true compatibility with ksh or other shells and KSH_ARRAYS should still be
+used for that purpose.  By default, the option is not set; an array
+subscript that evaluates to 0 returns an empty string or array element and
+attempts to write to an array or string range including only a zero
+subscript are treated as an error.  Writes to otherwise valid ranges that
+also include index zero are allowed; hence for example the assignment
+  array[(R)notfound,(r)notfound]=3D()
+(where the string "notfound" does not match an element in $array) sets the
+entire array to be empty, as in previous versions of the shell.
+KSH_ZERO_SUBSCRIPT is irrelevant when KSH_ARRAYS is set.  Also as in previ=
ous
+versions, attempts to write to non-existent elements at the end of an array
+cause the array to be suitably extended.  This difference means that, for
+example
+  array[(R)notfound]=3D(replacement)
+is an error if KSH_ZERO_SUBSCRIPT is not set (new behaviour), while
+  array[(r)notfound]=3D(replacement)
+causes the given value to be appended to the array (same behaviour as
+previous versions).
+
 The "exec" precommand modifier now takes various options for compatibility
 with other shells.  This means that whereas "exec -prog" previously
 tried to execute a command name "-prog", it will now report an error
@@ -77,10 +102,6 @@
 $search starts with "%" considers the "%" to be part of the search
 string as before.
=20
-Parameter subscripts of the form ${array[(R)test]} now return the
-empty string if they fail to match.  The previous longstanding behaviour
-was confusing and useless.
-
 The MULTIBYTE option is on by default where it is available; this
 causes many operations to recognise characters as in the current locale.
 Older versions of the shell always assumed a character was one byte.
Index: Doc/Zsh/options.yo
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/options.yo,v
retrieving revision 1.54
diff -u -r1.54 options.yo
--- Doc/Zsh/options.yo	1 May 2007 22:05:05 -0000	1.54
+++ Doc/Zsh/options.yo	15 Jun 2007 09:59:55 -0000
@@ -1244,6 +1244,31 @@
 word splitting after command and parameter expansion in arguments of an
 assignment; with it, word splitting does not take place in those cases.
 )
+pindex(KSH_ZERO_SUBSCRIPT)
+cindex(arrays, behaviour of index zero)
+item(tt(KSH_ZERO_SUBSCRIPT))(
+Treat use of a subscript of value zero in array or string expressions as a
+reference to the first element, i.e. the element that usually has the
+subscript 1.  Ignored if tt(KSH_ARRAYS) is also set.
+
+If neither this option nor tt(KSH_ARRAYS) is set, accesses to an element of
+an array or string with subscript zero return an empty element or string,
+while attempts to set element zero of an array or string are treated as an
+error.  However, attempts to set an otherwise valid subscript range that
+includes zero will succeed.  For example, if tt(KSH_ZERO_SUBSCRIPT) is not
+set,
+
+example(array[0]=3D(element))
+
+is an error, while
+
+example(array[0,1]=3D(element))
+
+is not and will replace the first element of the array.
+
+This option is for compatibility with older versions of the shell and
+is not recommended in new code.
+)
 pindex(POSIX_BUILTINS)
 item(tt(POSIX_BUILTINS) <K> <S>)(
 When this option is set the tt(command) builtin can be used to execute
Index: Doc/Zsh/params.yo
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/params.yo,v
retrieving revision 1.38
diff -u -r1.38 params.yo
--- Doc/Zsh/params.yo	12 Jun 2007 22:01:38 -0000	1.38
+++ Doc/Zsh/params.yo	15 Jun 2007 09:59:57 -0000
@@ -96,6 +96,14 @@
 option is set, the braced form is the only one that works, as bracketed
 expressions otherwise are not treated as subscripts.
=20
+If the tt(KSH_ARRAYS) option is not set, then by default accesses to
+an array element with a subscript that evaluates to zero return an
+empty string, while an attempt to write such an element is treated as
+an error.  For backward compatibility the tt(KSH_ZERO_SUBSCRIPT)
+option can be set to cause subscript values 0 and 1 to be equivalent; see
+the description of the option in ifzman(zmanref(zshoptions))\
+ifnzman(noderef(Description of Options)).
+
 The same subscripting syntax is used for associative arrays, except that
 no arithmetic expansion is applied to var(exp).  However, the parsing
 rules for arithmetic expressions still apply, which affects the way that
@@ -233,26 +241,22 @@
 item(tt(R))(
 Like `tt(r)', but gives the last match.  For associative arrays, gives
 all possible matches. May be used for assigning to ordinary array
-elements, but not for assigning to associative arrays.
-On failure the empty string is returned.
+elements, but not for assigning to associative arrays.  On failure, for
+normal arrays this has the effect of returning the element corresponding to
+subscript 0; this is empty unless one of the options tt(KSH_ARRAYS) or
+tt(KSH_ZERO_SUBSCRIPT) is in effect.
 )
 item(tt(i))(
 Like `tt(r)', but gives the index of the match instead; this may not be
 combined with a second argument.  On the left side of an assignment,
 behaves like `tt(r)'.  For associative arrays, the key part of each pair
 is compared to the pattern, and the first matching key found is the
-result.
-
-On failure, a value one past the end of the array or string is returned.
+result.  On failure substitutes one more than the last currently
+valid index, as discussed under the description of `tt(r)'.
 )
 item(tt(I))(
 Like `tt(i)', but gives the index of the last match, or all possible
-matching keys in an associative array.
-
-On failure the value 0 is returned.  If the option tt(KSH_ARRAYS) is in
-effect, the subscript is still 0 for a failed match; this cannot be
-distinguished from a successful match without testing tt(${array[0]})
-against the pattern.
+matching keys in an associative array.  On failure substitutes 0.
 )
 item(tt(k))(
 If used in a subscript on an associative array, this flag causes the keys
Index: Src/exec.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/exec.c,v
retrieving revision 1.116
diff -u -r1.116 exec.c
--- Src/exec.c	3 Jun 2007 17:44:20 -0000	1.116
+++ Src/exec.c	15 Jun 2007 09:59:58 -0000
@@ -3662,7 +3662,10 @@
 	fprintf(xtrerr, " ))\n");
 	fflush(xtrerr);
     }
-    errflag =3D 0;
+    if (errflag) {
+	errflag =3D 0;
+	return 2;
+    }
     /* should test for fabs(val.u.d) < epsilon? */
     return (val.type =3D=3D MN_INTEGER) ? val.u.l =3D=3D 0 : val.u.d =3D=
=3D 0.0;
 }
Index: Src/glob.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/glob.c,v
retrieving revision 1.58
diff -u -r1.58 glob.c
--- Src/glob.c	21 Jan 2007 22:47:41 -0000	1.58
+++ Src/glob.c	15 Jun 2007 09:59:59 -0000
@@ -1470,7 +1470,7 @@
 		    v.isarr =3D SCANPM_WANTVALS;
 		    v.pm =3D NULL;
 		    v.end =3D -1;
-		    v.inv =3D 0;
+		    v.flags =3D 0;
 		    if (getindex(&s, &v, 0) || s =3D=3D os) {
 			zerr("invalid subscript");
 			restore_globstate(saved);
Index: Src/options.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/options.c,v
retrieving revision 1.36
diff -u -r1.36 options.c
--- Src/options.c	1 May 2007 22:05:05 -0000	1.36
+++ Src/options.c	15 Jun 2007 09:59:59 -0000
@@ -153,9 +153,10 @@
 {{NULL, "interactivecomments",OPT_BOURNE},		 INTERACTIVECOMMENTS},
 {{NULL, "ksharrays",	      OPT_EMULATE|OPT_BOURNE},	 KSHARRAYS},
 {{NULL, "kshautoload",	      OPT_EMULATE|OPT_BOURNE},	 KSHAUTOLOAD},
-{{NULL, "kshglob",            OPT_EMULATE|OPT_KSH},      KSHGLOB},
+{{NULL, "kshglob",	      OPT_EMULATE|OPT_KSH},	 KSHGLOB},
 {{NULL, "kshoptionprint",     OPT_EMULATE|OPT_KSH},	 KSHOPTIONPRINT},
-{{NULL, "kshtypeset",         OPT_EMULATE|OPT_KSH},	 KSHTYPESET},
+{{NULL, "kshtypeset",	      OPT_EMULATE|OPT_KSH},	 KSHTYPESET},
+{{NULL, "kshzerosubscript",   0},			 KSHZEROSUBSCRIPT},
 {{NULL, "listambiguous",      OPT_ALL},			 LISTAMBIGUOUS},
 {{NULL, "listbeep",	      OPT_ALL},			 LISTBEEP},
 {{NULL, "listpacked",	      0},			 LISTPACKED},
Index: Src/params.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/params.c,v
retrieving revision 1.130
diff -u -r1.130 params.c
--- Src/params.c	12 Jun 2007 15:43:16 -0000	1.130
+++ Src/params.c	15 Jun 2007 10:00:00 -0000
@@ -520,7 +520,7 @@
 	    return;
     }
     v.isarr =3D (PM_TYPE(v.pm->node.flags) & (PM_ARRAY|PM_HASHED));
-    v.inv =3D 0;
+    v.flags =3D 0;
     v.start =3D 0;
     v.end =3D -1;
     paramvals[numparamvals] =3D getstrvalue(&v);
@@ -1298,7 +1298,7 @@
 		    (*ta || ((v->isarr & SCANPM_MATCHMANY) &&
 			     (v->isarr & (SCANPM_MATCHKEY | SCANPM_MATCHVAL |
 					  SCANPM_KEYMATCH))))) {
-		    *inv =3D v->inv;
+		    *inv =3D (v->flags & VALFLAG_INV) ? 1 : 0;
 		    *w =3D v->end;
 		    return 1;
 		}
@@ -1317,19 +1317,6 @@
 			if (pprog && pattry(pprog, *p) && !--num)
 			    return r;
 		    }
-		    /*
-		     * Failed to match.
-		     * If we're returning an index, return 0 to show
-		     * we've gone off the start.  Unfortunately this
-		     * is ambiguous with KSH_ARRAYS set, but we're
-		     * stuck with that now.
-		     *
-		     * If the index is to be turned into an element,
-		     * return an index that does not point to a valid
-		     * element (since 0 is treated the same as 1).
-		     */
-		    if (!ind)
-			r =3D len + 1;
 		} else
 		    for (r =3D 1 + beg, p =3D ta + beg; *p; r++, p++)
 			if (pprog && pattry(pprog, *p) && !--num)
@@ -1549,13 +1536,7 @@
 		    }
 		}
 	    }
-	    /*
-	     * Failed to match.
-	     * If the argument selects an element rather than
-	     * its index, ensure the element is empty.
-	     * See comments on the array case above.
-	     */
-	    return (down && ind) ? 0 : slen + 1;
+	    return down ? 0 : slen + 1;
 	}
     }
     return r;
@@ -1563,13 +1544,14 @@
=20
 /**/
 int
-getindex(char **pptr, Value v, int dq)
+getindex(char **pptr, Value v, int flags)
 {
     int start, end, inv =3D 0;
     char *s =3D *pptr, *tbrack;
=20
     *s++ =3D '[';
-    s =3D parse_subscript(s, dq);	/* Error handled after untokenizing */
+    /* Error handled after untokenizing */
+    s =3D parse_subscript(s, flags & SCANPM_DQUOTED);
     /* Now we untokenize everything except inull() markers so we can check=
 *
      * for the '*' and '@' special subscripts.  The inull()s are removed  *
      * in getarg() after we know whether we're doing reverse indexing.    =
*/
@@ -1654,7 +1636,7 @@
 	    if (start > 0 && (isset(KSHARRAYS) || (v->pm->node.flags & PM_HASHED)=
))
 		start--;
 	    if (v->isarr !=3D SCANPM_WANTINDEX) {
-		v->inv =3D 1;
+		v->flags |=3D VALFLAG_INV;
 		v->isarr =3D 0;
 		v->start =3D start;
 		v->end =3D start + 1;
@@ -1686,7 +1668,32 @@
 	    if (start > 0)
 		start -=3D startprevlen;
 	    else if (start =3D=3D 0 && end =3D=3D 0)
-		end =3D startnextlen;
+	    {
+		/*
+		 * Strictly, this range is entirely off the
+		 * start of the available index range.
+		 * This can't happen with KSH_ARRAYS; we already
+		 * altered the start index in getarg().
+		 * Are we being strict?
+		 */
+		if (isset(KSHZEROSUBSCRIPT)) {
+		    /*
+		     * We're not.
+		     * Treat this as accessing the first element of the
+		     * array.
+		     */
+		    end =3D startnextlen;
+		} else {
+		    /*
+		     * We are.  Flag that this range is invalid
+		     * for setting elements.  Set the indexes
+		     * to a range that returns empty for other accesses.
+		     */
+		    v->flags |=3D VALFLAG_EMPTY;
+		    start =3D -1;
+		    com =3D 1;
+		}
+	    }
 	    if (s =3D=3D tbrack) {
 		s++;
 		if (v->isarr && !com &&
@@ -1755,7 +1762,7 @@
 	else
 	    v =3D (Value) hcalloc(sizeof *v);
 	v->pm =3D argvparam;
-	v->inv =3D 0;
+	v->flags =3D 0;
 	v->start =3D ppar - 1;
 	v->end =3D ppar;
 	if (sav)
@@ -1786,11 +1793,11 @@
 		v->isarr =3D SCANPM_MATCHMANY;
 	}
 	v->pm =3D pm;
-	v->inv =3D 0;
+	v->flags =3D 0;
 	v->start =3D 0;
 	v->end =3D -1;
 	if (bracks > 0 && (*s =3D=3D '[' || *s =3D=3D Inbrack)) {
-	    if (getindex(&s, v, (flags & SCANPM_DQUOTED))) {
+	    if (getindex(&s, v, flags)) {
 		*pptr =3D s;
 		return v;
 	    }
@@ -1830,7 +1837,7 @@
     if (!v)
 	return hcalloc(1);
=20
-    if (v->inv && !(v->pm->node.flags & PM_HASHED)) {
+    if ((v->flags & VALFLAG_INV) && !(v->pm->node.flags & PM_HASHED)) {
 	sprintf(buf, "%d", v->start);
 	s =3D dupstring(buf);
 	return s;
@@ -1911,7 +1918,7 @@
 	return arrdup(nular);
     else if (IS_UNSET_VALUE(v))
 	return arrdup(&nular[1]);
-    if (v->inv) {
+    if (v->flags & VALFLAG_INV) {
 	char buf[DIGBUFSIZE];
=20
 	s =3D arrdup(nular);
@@ -1943,7 +1950,7 @@
 {
     if (!v)
 	return 0;
-    if (v->inv)
+    if (v->flags & VALFLAG_INV)
 	return v->start;
     if (v->isarr) {
 	char **arr =3D getarrvalue(v);
@@ -1970,7 +1977,7 @@
=20
     if (!v) {
 	mn.u.l =3D 0;
-    } else if (v->inv) {
+    } else if (v->flags & VALFLAG_INV) {
 	mn.u.l =3D v->start;
     } else if (v->isarr) {
 	char **arr =3D getarrvalue(v);
@@ -2000,7 +2007,7 @@
 	if (emulation =3D=3D EMULATE_KSH /* isset(KSHARRAYS) */) {
 	    struct value v;
 	    v.isarr =3D 1;
-	    v.inv =3D 0;
+	    v.flags =3D 0;
 	    v.start =3D 0;
 	    v.end =3D -1;
 	    val =3D getstrvalue(&v);
@@ -2037,6 +2044,11 @@
 	zsfree(val);
 	return;
     }
+    if (v->flags & VALFLAG_EMPTY) {
+	zerr("%s: assignment to invalid subscript range", v->pm->node.nam);
+	zsfree(val);
+	return;
+    }
     v->pm->node.flags &=3D ~PM_UNSET;
     switch (PM_TYPE(v->pm->node.flags)) {
     case PM_SCALAR:
@@ -2051,7 +2063,7 @@
=20
 	    z =3D dupstring(v->pm->gsu.s->getfn(v->pm));
 	    zlen =3D strlen(z);
-	    if (v->inv && unset(KSHARRAYS))
+	    if ((v->flags & VALFLAG_INV) && unset(KSHARRAYS))
 		v->start--, v->end--;
 	    if (v->start < 0) {
 		v->start +=3D zlen;
@@ -2176,6 +2188,11 @@
 	     v->pm->node.nam);
 	return;
     }
+    if (v->flags & VALFLAG_EMPTY) {
+	zerr("%s: assignment to invalid subscript range", v->pm->node.nam);
+	freearray(val);
+	return;
+    }
     if (v->start =3D=3D 0 && v->end =3D=3D -1) {
 	if (PM_TYPE(v->pm->node.flags) =3D=3D PM_HASHED)
 	    arrhashsetfn(v->pm, val, 0);
@@ -2194,7 +2211,7 @@
 		 v->pm->node.nam);
 	    return;
 	}
-	if (v->inv && unset(KSHARRAYS)) {
+	if ((v->flags & VALFLAG_INV) && unset(KSHARRAYS)) {
 	    if (v->start > 0)
 		v->start--;
 	    v->end--;
Index: Src/subst.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/subst.c,v
retrieving revision 1.77
diff -u -r1.77 subst.c
--- Src/subst.c	2 Apr 2007 11:00:43 -0000	1.77
+++ Src/subst.c	15 Jun 2007 10:00:00 -0000
@@ -2008,7 +2008,7 @@
 	    v->isarr =3D isarr;
 	    v->pm =3D pm;
 	    v->end =3D -1;
-	    if (getindex(&s, v, qt) || s =3D=3D os)
+	    if (getindex(&s, v, qt ? SCANPM_DQUOTED : 0) || s =3D=3D os)
 		break;
 	}
 	/*
@@ -2025,8 +2025,11 @@
 	 * in the subexp stuff or immediately above.
 	 */
 	if ((isarr =3D v->isarr)) {
-	    /* No way to get here with v->inv !=3D 0, so getvaluearr() *
-	     * is called by getarrvalue(); needn't test PM_HASHED.   */
+	    /*
+	     * No way to get here with v->flags & VALFLAG_INV, so
+	     * getvaluearr() is called by getarrvalue(); needn't test
+	     * PM_HASHED.
+	     */
 	    if (v->isarr =3D=3D SCANPM_WANTINDEX) {
 		isarr =3D v->isarr =3D 0;
 		val =3D dupstring(v->pm->node.nam);
@@ -2048,8 +2051,9 @@
 		int tmplen =3D arrlen(v->pm->gsu.a->getfn(v->pm));
=20
 		if (v->start < 0)
-		    v->start +=3D tmplen + v->inv;
-		if (!v->inv && (v->start >=3D tmplen || v->start < 0))
+		    v->start +=3D tmplen + ((v->flags & VALFLAG_INV) ? 1 : 0);
+		if (!(v->flags & VALFLAG_INV) &&
+		    (v->start >=3D tmplen || v->start < 0))
 		    vunset =3D 1;
 	    }
 	    if (!vunset) {
Index: Src/zsh.h
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/zsh.h,v
retrieving revision 1.115
diff -u -r1.115 zsh.h
--- Src/zsh.h	28 May 2007 22:57:41 -0000	1.115
+++ Src/zsh.h	15 Jun 2007 10:00:00 -0000
@@ -585,12 +585,17 @@
 struct value {
     int isarr;
     Param pm;		/* parameter node                      */
-    int inv;		/* should we return the index ?        */
+    int flags;		/* flags defined below                 */
     int start;		/* first element of array slice, or -1 */
     int end;		/* 1-rel last element of array slice, or -1 */
     char **arr;		/* cache for hash turned into array */
 };
=20
+enum {
+    VALFLAG_INV =3D	0x0001,	/* We are performing inverse subscripting */
+    VALFLAG_EMPTY =3D	0x0002	/* Subscripted range is empty */
+};
+
 #define MAX_ARRLEN    262144
=20
 /********************************************/
@@ -1725,6 +1730,7 @@
     KSHGLOB,
     KSHOPTIONPRINT,
     KSHTYPESET,
+    KSHZEROSUBSCRIPT,
     LISTAMBIGUOUS,
     LISTBEEP,
     LISTPACKED,
Index: Src/Modules/mapfile.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/Modules/mapfile.c,v
retrieving revision 1.9
diff -u -r1.9 mapfile.c
--- Src/Modules/mapfile.c	28 May 2007 22:57:41 -0000	1.9
+++ Src/Modules/mapfile.c	15 Jun 2007 10:00:01 -0000
@@ -149,7 +149,7 @@
 	    for (hn =3D ht->nodes[i]; hn; hn =3D hn->next) {
 		struct value v;
=20
-		v.isarr =3D v.inv =3D v.start =3D 0;
+		v.isarr =3D v.flags =3D v.start =3D 0;
 		v.end =3D -1;
 		v.arr =3D NULL;
 		v.pm =3D (Param) hn;
Index: Src/Modules/parameter.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/Modules/parameter.c,v
retrieving revision 1.41
diff -u -r1.41 parameter.c
--- Src/Modules/parameter.c	28 May 2007 22:57:41 -0000	1.41
+++ Src/Modules/parameter.c	15 Jun 2007 10:00:01 -0000
@@ -180,7 +180,7 @@
 	    Cmdnam cn =3D zshcalloc(sizeof(*cn));
 	    struct value v;
=20
-	    v.isarr =3D v.inv =3D v.start =3D 0;
+	    v.isarr =3D v.flags =3D v.start =3D 0;
 	    v.end =3D -1;
 	    v.arr =3D NULL;
 	    v.pm =3D (Param) hn;
@@ -341,7 +341,7 @@
 	for (hn =3D ht->nodes[i]; hn; hn =3D hn->next) {
 	    struct value v;
=20
-	    v.isarr =3D v.inv =3D v.start =3D 0;
+	    v.isarr =3D v.flags =3D v.start =3D 0;
 	    v.end =3D -1;
 	    v.arr =3D NULL;
 	    v.pm =3D (Param) hn;
@@ -701,7 +701,7 @@
 	    struct value v;
 	    char *val;
=20
-	    v.isarr =3D v.inv =3D v.start =3D 0;
+	    v.isarr =3D v.flags =3D v.start =3D 0;
 	    v.end =3D -1;
 	    v.arr =3D NULL;
 	    v.pm =3D (Param) hn;
@@ -1325,7 +1325,7 @@
 	    struct value v;
 	    char *val;
=20
-	    v.isarr =3D v.inv =3D v.start =3D 0;
+	    v.isarr =3D v.flags =3D v.start =3D 0;
 	    v.end =3D -1;
 	    v.arr =3D NULL;
 	    v.pm =3D (Param) hn;
@@ -1554,7 +1554,7 @@
 	    struct value v;
 	    char *val;
=20
-	    v.isarr =3D v.inv =3D v.start =3D 0;
+	    v.isarr =3D v.flags =3D v.start =3D 0;
 	    v.end =3D -1;
 	    v.arr =3D NULL;
 	    v.pm =3D (Param) hn;
Index: Src/Zle/complete.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/Zle/complete.c,v
retrieving revision 1.37
diff -u -r1.37 complete.c
--- Src/Zle/complete.c	29 May 2007 17:01:09 -0000	1.37
+++ Src/Zle/complete.c	15 Jun 2007 10:00:02 -0000
@@ -1139,7 +1139,7 @@
 	    for (cp =3D compkparams,
 		 pp =3D compkpms; cp->name; cp++, pp++)
 		if (!strcmp(hn->nam, cp->name)) {
-		    v.isarr =3D v.inv =3D v.start =3D 0;
+		    v.isarr =3D v.flags =3D v.start =3D 0;
 		    v.end =3D -1;
 		    v.arr =3D NULL;
 		    v.pm =3D (Param) hn;
Index: Test/C01arith.ztst
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Test/C01arith.ztst,v
retrieving revision 1.11
diff -u -r1.11 C01arith.ztst
--- Test/C01arith.ztst	12 Feb 2007 16:43:42 -0000	1.11
+++ Test/C01arith.ztst	15 Jun 2007 10:00:02 -0000
@@ -91,8 +91,13 @@
 >3.5
 >4
=20
-  (( newarray[unsetvar]++ ))
-  (( newarray[unsetvar]++ ))
+  (( newarray[unsetvar] =3D 1 ))
+2:error using unset variable as index
+?(eval):1:  assignment to invalid subscript range
+
+  integer setvar=3D1
+  (( newarray[setvar]++ ))
+  (( newarray[setvar]++ ))
   print ${(t)newarray} ${#newarray} ${newarray[1]}
 0:setting array elements in math context
 >array 1 2
Index: Test/D05array.ztst
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Test/D05array.ztst,v
retrieving revision 1.2
diff -u -r1.2 D05array.ztst
--- Test/D05array.ztst	30 Mar 2004 16:35:38 -0000	1.2
+++ Test/D05array.ztst	15 Jun 2007 10:00:02 -0000
@@ -30,12 +30,12 @@
 >..
=20
   echo .$foo[0].
-0:Treat 0 like 1
->.a.
+0:Treat 0 as empty
+>..
=20
   echo .$foo[0,0].
-0:Treat 0,0 like 1,1.
->.a.
+0:Treat 0,0 as empty
+>..
=20
   echo .$foo[0,1].
 0:Another weird way to access the first element
Index: Test/D06subscript.ztst
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Test/D06subscript.ztst,v
retrieving revision 1.10
diff -u -r1.10 D06subscript.ztst
--- Test/D06subscript.ztst	21 May 2007 09:30:26 -0000	1.10
+++ Test/D06subscript.ztst	15 Jun 2007 10:00:02 -0000
@@ -182,3 +182,56 @@
   echo X${${l##*}[-1]}X
 0:Negative index applied to substition result from empty array
 >XX
+
+  array=3D(one two three four)
+  print X$array[0]X
+0:Element zero is empty if KSH_ZERO_SUBSCRIPT is off.
+>XX
+
+  array[0]=3Dfumble
+1:Can't set element zero if KSH_ZERO_SUBSCRIPT is off.
+?(eval):1: array: assignment to invalid subscript range
+
+  print X$array[(R)notfound]X
+0:(R) returns empty if not found if KSH_ZERO_SUBSCRIPT is off.
+>XX
+
+  setopt KSH_ZERO_SUBSCRIPT
+  print X$array[0]X
+0:Element zero is element one if KSH_ZERO_SUBSCRIPT is on.
+>XoneX
+
+  array[0]=3Dfimble
+  print $array
+0:Can set element zero if KSH_ZERO_SUBSCRIPT is on.
+>fimble two three four
+
+  print X$array[(R)notfound]X
+0:(R) yuckily returns the first element on failure withe KSH_ZERO_SUBSCRIPT
+>XfimbleX
+
+  unsetopt KSH_ZERO_SUBSCRIPT
+  array[(R)notfound,(r)notfound]=3D(help help here come the seventies retr=
eads)
+  print $array
+0:[(R)notfound,(r)notfound] replaces the whole array
+>help help here come the seventies retreads
+
+  string=3D"Why, if it isn't Officer Dibble"
+  print "[${string[0]}][${string[1]}][${string[0,3]}]"
+0:String subscripts with KSH_ZERO_SUBSCRIPT unset
+>[][W][Why]
+
+  setopt KSH_ZERO_SUBSCRIPT
+  print "[${string[0]}][${string[1]}][${string[0,3]}]"
+0:String subscripts with KSH_ZERO_SUBSCRIPT set
+>[W][W][Why]
+
+  unsetopt KSH_ZERO_SUBSCRIPT
+  string[0,3]=3D"Goodness"
+  print $string
+0:Assignment to chunk of string ignores element 0
+>Goodness, if it isn't Officer Dibble
+
+  string[0]=3D!
+1:Can't set only element zero of string
+?(eval):1: string: assignment to invalid subscript range
Index: Test/D07multibyte.ztst
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Test/D07multibyte.ztst,v
retrieving revision 1.17
diff -u -r1.17 D07multibyte.ztst
--- Test/D07multibyte.ztst	29 May 2007 14:50:29 -0000	1.17
+++ Test/D07multibyte.ztst	15 Jun 2007 10:00:02 -0000
@@ -87,7 +87,7 @@
   s=3D=C3=A9
   print A${s[-2]}A B${s[-1]}B C${s[0]}C D${s[1]}D E${s[2]}E
 0:Out of range subscripts with multibyte characters
->AA B=C3=A9B C=C3=A9C D=C3=A9D EE
+>AA B=C3=A9B CC D=C3=A9D EE
=20
   print ${a[(i)=C3=A9]} ${a[(I)=C3=A9]} ${a[${a[(i)=C3=A9]},${a[(I)=C3=A9]=
}]}
 0:Reverse indexing with multibyte characters
Index: Test/E01options.ztst
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Test/E01options.ztst,v
retrieving revision 1.20
diff -u -r1.20 E01options.ztst
--- Test/E01options.ztst	29 May 2007 14:50:29 -0000	1.20
+++ Test/E01options.ztst	15 Jun 2007 10:00:03 -0000
@@ -521,7 +521,7 @@
 >one one[2]
 >one two three
 >one two three two
->one one two three
+>one two three
=20
   fpath=3D(.)
   echo >foo 'echo foo loaded; foo() { echo foo run; }'


--=20
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


To access the latest news from CSR copy this link into a web browser:  http=
://www.csr.com/email_sig.php

To get further information regarding CSR, please visit our Investor Relatio=
ns page at http://ir.csr.com/csr/about/overview

