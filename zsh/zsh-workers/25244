From zsh-workers-return-25244-mason-zsh=primenet.com.au@sunsite.dk Tue Jun 24 16:05:46 2008
Return-Path: <zsh-workers-return-25244-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5675 invoked from network); 24 Jun 2008 16:05:43 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.4 (2008-01-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 24 Jun 2008 16:05:43 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 27709 invoked from network); 24 Jun 2008 16:05:40 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 24 Jun 2008 16:05:40 -0000
Received: (qmail 2354 invoked by alias); 24 Jun 2008 16:05:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 25244
Received: (qmail 2343 invoked from network); 24 Jun 2008 16:05:38 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 24 Jun 2008 16:05:38 -0000
Received: from cluster-d.mailcontrol.com (cluster-d.mailcontrol.com [217.69.20.190])
	by bifrost.dotsrc.org (Postfix) with ESMTPS id 0B0CD8084FA1
	for <zsh-workers@sunsite.dk>; Tue, 24 Jun 2008 18:05:33 +0200 (CEST)
Received: from cameurexb01.EUROPE.ROOT.PRI ([193.128.72.68])
	by rly26d.srv.mailcontrol.com (MailControl) with ESMTP id m5OG58Ef023752
	for <zsh-workers@sunsite.dk>; Tue, 24 Jun 2008 17:05:17 +0100
Received: from news01 ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.3959);
	 Tue, 24 Jun 2008 17:05:12 +0100
Date: Tue, 24 Jun 2008 17:05:11 +0100
From: Peter Stephenson <pws@csr.com>
To: "Zsh Hackers' List" <zsh-workers@sunsite.dk>
Subject: Re: Camel case word navigation?
Message-ID: <20080624170511.74281d71@news01>
In-Reply-To: <20080624121449.5034e912@news01>
References: <54c0a1810806222241t47f04d53lf2780f48fc7ee2d2@mail.gmail.com>
	<200806230916.m5N9GH2L003761@news01.csr.com>
	<20080624121449.5034e912@news01>
Organization: CSR
X-Mailer: Claws Mail 3.4.0 (GTK+ 2.12.8; i386-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-OriginalArrivalTime: 24 Jun 2008 16:05:12.0019 (UTC) FILETIME=[1501D230:01C8D614]
X-Scanned-By: MailControl A-08-50-03 (www.mailcontrol.com) on 10.68.0.136
X-Virus-Scanned: ClamAV 0.92.1/7550/Tue Jun 24 16:52:37 2008 on bifrost
X-Virus-Status: Clean

While I'm thinking about it, this generalises to use a given set of
characters as the start of a subword (the default is "[:upper:]", but you
could have, say, "[:upper:]/").

Also a couple of misleading bits of documentation in other functions I
happened to notice.

Index: Doc/Zsh/contrib.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/contrib.yo,v
retrieving revision 1.82
diff -u -r1.82 contrib.yo
--- Doc/Zsh/contrib.yo	24 Jun 2008 11:18:40 -0000	1.82
+++ Doc/Zsh/contrib.yo	24 Jun 2008 16:00:52 -0000
@@ -463,7 +463,11 @@
 the same effect but with subword matching turned on.  In this case, words
 with upper case characters are treated specially: each separate run of
 upper case characters, or an upper case character followed by any number of
-other characters, is considered a word.
+other characters, is considered a word.  The style tt(subword-range)
+can supply an alternative character range to the default `tt([:upper:])';
+the value of the style is treated as the contents of a `tt([)var(...)tt(])'
+pattern (note that the outer brackets should not be supplied, only
+those surrounding named ranges).
 
 More control can be obtained using the tt(zstyle) command, as described in
 ifzman(zmanref(zshmodules))\
@@ -591,6 +595,7 @@
 sitem(tt(-s))(var(skip-chars))
 sitem(tt(-c))(var(word-class))
 sitem(tt(-C))(var(word-chars))
+sitem(tt(-r))(var(subword-range))
 endsitem()
 
 For example, tt(match-words-by-style -w shell -c 0) may be used to
Index: Functions/Zle/match-words-by-style
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/match-words-by-style,v
retrieving revision 1.7
diff -u -r1.7 match-words-by-style
--- Functions/Zle/match-words-by-style	24 Jun 2008 11:18:41 -0000	1.7
+++ Functions/Zle/match-words-by-style	24 Jun 2008 16:00:52 -0000
@@ -69,14 +69,14 @@
 
 local wordstyle spacepat wordpat1 wordpat2 opt charskip wordchars wordclass
 local match mbegin mend pat1 pat2 word1 word2 ws1 ws2 ws3 skip
-local nwords MATCH MBEGIN MEND
+local nwords MATCH MBEGIN MEND subwordrange
 
 local curcontext=${curcontext:-:zle:match-words-by-style}
 
 autoload -U match-word-context
 match-word-context
 
-while getopts "w:s:c:C:" opt; do
+while getopts "w:s:c:C:r:" opt; do
   case $opt in
     (w)
     wordstyle=$OPTARG
@@ -94,6 +94,10 @@
     wordchars=$OPTARG
     ;;
 
+    (r)
+    subwordrange=$OPTARG
+    ;;
+
     (*)
     return 1
     ;;
@@ -190,6 +194,10 @@
 ws1=$match[2]
 
 if [[ $wordstyle = *subword* ]]; then
+  if [[ -z $subwordrange ]] &&
+    ! zstyle -s $curcontext subword-range subwordrange; then
+    subwordrange='[:upper:]'
+  fi
   # The rule here is that a word boundary may be an upper case letter
   # followed by a lower case letter, or an upper case letter at
   # the start of a group of upper case letters.  To make
@@ -199,10 +207,10 @@
   # Here the initial "*" will match greedily, so we get the
   # last such match, as we want.
   integer epos
-  if [[ $word1 = (#b)(*)([[:upper:]][^[:upper:]]*) ]]; then
+  if [[ $word1 = (#b)(*)([${~subwordrange}][^${~subwordrange}]*) ]]; then
     (( epos = ${#match[1]} ))
   fi
-  if [[ $word1 = (#b)(*[^[:upper:]])([[:upper:]]*) ]]; then
+  if [[ $word1 = (#b)(*[^${~subwordrange}])([${~subwordrange}]*) ]]; then
     (( ${#match[1]} > epos ))  &&  (( epos = ${#match[1]} ))
   fi
   if (( epos > 0 )); then
@@ -226,14 +234,15 @@
   # Do we have a group of upper case characters at the start
   # of word2 (that don't form the entire word)?
   # Again, rely on greedy matching of first pattern.
-  if [[ $word2 = (#b)([[:upper:]][[:upper:]]##)(*) && -n $match[2] ]]; then
+  if [[ $word2 = (#b)([${~subwordrange}][${~subwordrange}]##)(*) &&
+	  -n $match[2] ]]; then
     # Yes, so the last one is new word boundary.
     (( epos = ${#match[1]} - 1 ))
     # Otherwise, do we have upper followed by non-upper not
     # at the start?  Ignore the initial character, we already
     # know it's a word boundary so it can be an upper case character
     # if it wants.
-  elif [[ $word2 = (#b)(?[^[:upper:]]##)[[:upper:]]* ]]; then
+  elif [[ $word2 = (#b)(?[^${~subwordrange}]##)[${~subwordrange}]* ]]; then
     (( epos = ${#match[1]} ))
   else
     (( epos = 0 ))
Index: Functions/Zle/modify-current-argument
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/modify-current-argument,v
retrieving revision 1.1
diff -u -r1.1 modify-current-argument
--- Functions/Zle/modify-current-argument	15 Dec 2006 11:44:29 -0000	1.1
+++ Functions/Zle/modify-current-argument	24 Jun 2008 16:00:52 -0000
@@ -4,10 +4,10 @@
 # cursor with that.  Ensure the expression is suitable quoted.
 #
 # For example, to uppercase the entire shell argument:
-#   modify-current-word '${(U)ARG}'
+#   modify-current-argument '${(U)ARG}'
 # To strip the current quoting from the word (whether backslashes or
 # single, double or dollar quotes) and use single quotes instead:
-#   modify-current-word '${(qq)${(Q)ARG}}'
+#   modify-current-argument '${(qq)${(Q)ARG}}'
 
 # Retain most options from the calling function for the eval.
 # Reset some that might confuse things.
Index: Functions/Zle/split-shell-arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/split-shell-arguments,v
retrieving revision 1.1
diff -u -r1.1 split-shell-arguments
--- Functions/Zle/split-shell-arguments	15 Dec 2006 11:44:29 -0000	1.1
+++ Functions/Zle/split-shell-arguments	24 Jun 2008 16:00:52 -0000
@@ -7,9 +7,6 @@
 # Hence ${reply[$REPLY][$REPLY2]} is the character under the cursor.
 #
 # reply, REPLY, REPLY2 should therefore be local to the enclosing function.
-#
-# The following formula replaces the current shell word, or previous word
-# if the cursor is on whitespace, by uppercasing all characters.
 
 emulate -L zsh
 setopt extendedglob

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070

