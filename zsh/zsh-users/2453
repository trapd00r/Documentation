From zsh-users-return-2453-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jul 20 07:08:56 1999
Return-Path: <zsh-users-return-2453-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11490 invoked from network); 20 Jul 1999 07:08:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Jul 1999 07:08:54 -0000
Received: (qmail 17201 invoked by alias); 20 Jul 1999 07:08:29 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 2453
Received: (qmail 17194 invoked from network); 20 Jul 1999 07:08:29 -0000
Date: Tue, 20 Jul 1999 09:08:24 +0200 (MET DST)
Message-Id: <199907200708.JAA00727@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-users@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Mon, 19 Jul 1999 17:38:13 +0000
Subject: Re: Getting completion to tell the user what to do


Bart Schaefer wrote:

> This ought to be an easy one in the new 3.1.6 completion system, but I just
> can't get it to work.
> 
> I'm trying to complete "subject string goes here" as in
> 
> 	mail -s "subject string goes here"
> 
> What I want is to offer no completions at all, because the subject is free-
> form text, but print a hint to the user as to what he's supposed to type.
> 
> The following almost works (inside a completion function the rest of which
> is not interesting):
> 
>   compadd -S '' -X 'Please enter the subject of the message' ''
> 
> but because there's a unique completion, the explanation is printed only
> when the user types ^D, and there's no beep to let him know why tab isn't
> doing anything.  OK, I thought, I can force a listing:
> 
>   compadd -S '' -X 'Please enter the subject of the message' ''
>   compstate[list]=list
>   compstate[force_list]=yes
>   compstate[restore]=no
> 
> but that doesn't work -- there's still no explanation printed.
> 
> What obvious thing have I forgotten/overlooked here?  Is there an entirely
> better alternative to using compadd -X ?

Time for dirty tricks:

  compadd -UX 'Please...' -n ''
  compstate[insert]=''
  compstate[list]=list
  compstate[force_list]=yes

You need the -U because otherwise the empty string never matches
what's on the line (not even the empty string on the line). Then we
can switch of insertion completely.

If you want the string to be listed only on a TAB with an empty string 
you can do `compadd -X "Please..." -n dummy' -- i.e. add a string with 
matching.

The -n, of course, is just to be sure that the matches are not visible.

Is that good enough?

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

