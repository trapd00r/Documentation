" $Id: .vimrc,v 1.1 2002/09/27 02:13:02 dope Exp dope $
"
" Informations 
"    File: $HOME/.vimrc
"  Author: Christian Schneider <strcat(at)gmx.net>
" Purpose: setup file for the editor "vim"
"     URL: <http://strcat.de/vimrc> || <http://www.vim.org/>
"    Size: This file is about 50K in size and has 1,600+ lines.
" Notices: This file is based on Sven Guckes http://www.guckes.net/vimrc.forall
"    Note: If your read this then please send me an email! I welcome all
"          feedback on this file - especially with new ideas such as abbreviations
"          and mappings.
"     Tip: Open this file with 'vim -c 'set foldmethod=marker' this-file' or -
"          if Vim already runnig - type ':set foldmethod=marker' for a /better/
"          oversight ;)
" Version: This setup file uses a lot of features of Vim-6. If you are still
"          using Vim-5 (or an even older version) then you should upgrade - it
"          is really worth the effort!
" Warning: Download instead view+save! So if you are viewing this file with a
"          web browser then do *not* "save" this file because the contents 
"          have already been interpreted - including the control characters. 
"          Instead, you must *download* this file to preserve them.
"
" Structure of this file:
"       First up is the settings that I use. They are ordered alphabetically
"       to make it easier to access a specific item. Basically a simple way
"       to sort data :-) These are not all the possible settings, but the ones
"       that I have found relevant to control. (:h options)
"
"       There are three kinds of things which are defined in this file:
"       Mappings ("map"), settings ("set"), and abbreviations ("ab").
"               - Settings affect the behaviour of commands.
"               - Mappings maps a key sequence to a command.
"               - Abbreviations define words which are replaced right 
"                 *after* they are typed in.
"       Here is an overview of map commands and in which mode they work:
"         ,----
"         | :map               Normal, Visual and Operator-pending
"         | :vmap              Visual
"         | :nmap              Normal
"         | :omap              Operator-pending
"         | :map!              Insert and Command-line
"         | :imap              Insert
"         | :cmap              Command-line
"         `----
"       Lines starting with an inverted comma (") are comments. Furthermore,
"       's within the line starts a comment unless it is preceeded by a backslash (\").
"       VIM allows to give special characters by writing them in a special notation.
"       The notation encloses descriptive words in angle brackets (<>).
"       Read all about it with ":help <>".
"          The characters you will most often are:
"               - <C-M> for control-m
"               - <C-V> for control-v which quotes the following character
"               - <ESC> for the escape character.
"               - <Fn>  for F1, F2, ..
"               - <C-n> for control-n (i. e. strg-a, strg-k, ..)
"       $VIMRUNTIME == /usr/local/share/vim/vim61f
"
" setting description:
" [global] ... global setting
" [buffer] ... local to a buffer
" [window] ... settings for a window
" [glo-lo] ... global or local (buffer) setting. :setlocal for local value
" 
" Some mappings and options are commented out. Remove the comment to enable them.
" 
" All control characters have been replaced to use the angle notation
" so you should be able to read this filw without problems.
" (OK, I left some tabs [control-i] in the file. ;-)
"
" ~/.vim/
"     +---> colors/     # color scheme files
"     +---> doc/        # documentations
"     +---> forms/      # submittals
"     +---> ftplugin/   # filetype plugins
"     +---> macros/     # macros common to both versions of VIM
"     +---> plugin/     # plugins common to both versions of VIM
"     +---> syntax/     # syntax files
"     +---> templates/  # Own template files
"
" To learn VIM:
"   -> run "vimtutor" from your Unix/Linux-prompt and go through it
"   -> RTFM - read the f****** - ah - FINE manual ;-)
"   -> visit the websites mentioned in this document
"       * <http://www.vim.org/>                    - vim-homepage
"       * <http://www.guckes.net/vim/>             - Sven's Vim Page
"       * <http://hermitte.free.fr/vim/>           - Luc's Hermitte
"       * <http://www.liacs.nl/~jvhemert/vim/>     - Jano's Vim Macro Page
"       * <http://users.erols.com/astronaut/vim/>  - Dr Chip's Vim Page
"       * <http://www.thomer.com/vi/vi.html>       - VI Lover's Homepage
"       * <http://www.rayninfo.co.uk/vimtips.html> - Best of Vim Tips
"       * <news:de.comp.editoren>                  - german newsgroup with topic editors
"       * <news:comp.editors>                      - international newsgroup with topic editors
"   -> Try the documentation »:help your_keyword«
"               WHAT                   PREPEND    EXAMPLE
"               Normal mode commands  (nothing)   :help x
"               Visual mode commands      v_      :help v_u
"               Insert mode commands      i_      :help i_<Esc>
"               command-line commands     :       :help :quit
"               command-line editing      c_      :help c_<Del>
"               Vim command arguments     -       :help -r
"               options                   '       :help 'textwidth'
"
"  To use this setup file, copy it to
"            Linux/Unix:  ~/.vimrc
"                  OS/2:  ~/.vimrc or $VIM/.vimrc (or _vimrc)
"             for Amiga:  s:.vimrc or $VIM/.vimrc
"  for MS-DOS and Win32:  $VIM\_vimrc or $VIM/_vimrc
"           for OpenVMS:  sys$login:.vimrc
" 
" There are many options for Vim - over 200:
" »grep -c '{".*P_' src/option.c«
"       Release dates given in format "yymmdd":
"         - VIM-5.4   [990726] 218 options.
"         - VIM-5.7   [000624] 219 options.
"         - VIM-6.0ae [010504] 283 options.
"         - VIM-6.1   [020324] 310 options.
"         - VIM-6.2f  [030323] 322 options.
"         - VIM-6.3   [040607] 314 options.
"         - VIM-7.0   [050120] 333 options.
"
" Powered by OpenBSD 3.4 / Slackware 9.1, VIM - Vi IMproved 6.3, RedBull, Samson Halfzware
" Shag and Metallica.
" 
"  ,----[ $ vim --version ]
"  | VIM - Vi IMproved 6.3 (2004 June 7, compiled Jun 19 2004 02:58:45)
"  | Compiled by Christan Schneider <strcat@gmx.net>
"  | Huge version without GUI.  Features included (+) or not (-):
"  | +arabic +autocmd -balloon_eval -browse ++builtin_terms +byte_offset +cindent
"  | -clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments
"  | +cryptv +cscope +dialog_con +diff +digraphs -dnd -ebcdic +emacs_tags +eval
"  | +ex_extra +extra_search +farsi +file_in_path +find_in_path +folding -footer
"  | +fork() -gettext -hangul_input +iconv +insert_expand +jumplist +keymap +langmap
"  |  +libcall +linebreak +lispindent +listcmds +localmap +menu +mksession
"  | +modify_fname +mouse -mouseshape +mouse_dec +mouse_gpm -mouse_jsbterm
"  | +mouse_netterm +mouse_xterm +multi_byte +multi_lang -netbeans_intg -osfiletype
"  | +path_extra -perl +postscript +printer -python +quickfix +rightleft -ruby
"  | +scrollbind +signs +smartindent -sniff +statusline -sun_workshop +syntax
"  | +tag_binary +tag_old_static -tag_any_white -tcl +terminfo +termresponse
"  | +textobjects +title -toolbar +user_commands +vertsplit +virtualedit +visual
"  | +visualextra +viminfo +vreplace +wildignore +wildmenu +windows +writebackup
"  | -X11 -xfontset -xim -xsmp -xterm_clipboard -xterm_save
"  |    system vimrc file: "$VIM/vimrc"
"  |      user vimrc file: "$HOME/.vimrc"
"  |       user exrc file: "$HOME/.exrc"
"  |   fall-back for $VIM: "/usr/local/share/vim"
"  | Compilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2
"  | Linking: gcc   -L/usr/local/lib -o vim       -lncurses -lgpm -ldl
"  `----
"  It was also compiled with:
"   | ./configure --without-x --with-compiledby='Christan Schneider <strcat@gmx.net>' \
"   |             --with-features=huge
"
"  ,----[ Why Vim and not Emacs ]
"  | $ time vim -c ":q"
"  |  Real: 0.10s User: 0.03s System: 0.00s Percent: 29% Cmd: vim -c ":q"
"  | $ time emacs -kill
"  |  Real: 2.28s User: 0.21s System: 0.12s Percent: 14% Cmd: emacs -kill
"  `----
" 

" Options initiating with »a« 
" [global] |'aleph'| ASCII code of the letter Aleph (Hebrew)
" set al=224

" [global] |'allowrevins'| allow CTRL-_ in Insert and Command-line mode
" set noari

" [global] |'altkeymap'| for default second language (Farsi/Hebrew)
" set noakm

" [buffer] |'autoindent'| off as I usually do not write code 
set ai

" [global] |'autowrite'| on saves a lot of trouble
set aw

" [global] |'autowriteall'| as 'autowrite', but works with more commands
" set noawa

" [glo-lo] |'autoread'| autom. read file when changed outside of Vim
set ar
" 

" Options initiating with »b« 
" [global] |'background'| "dark" or "light", used for highlight colors
 set bg=dark 

" [global] |'backspace'| how backspace works at start of line
set bs=2

" [global] |'backup'| Make a backup (i. e. 'file~') and save it.
set bk

" [global] |'backupdir'| write backup into special directory if it exists, otherwise create 
"          it.
if has("unix")
        if !isdirectory(expand("~/tmp/."))
                !mkdir -p ~/tmp/
        endif
endif
set bdir=~/tmp

" [global] |'backupcopy'| make backup as a copy, don't rename the file
" set bkc=yes

" [global] |'backupskip'| no backup for files that match these patterns
set bsk=/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*

" [global] |'ballondelay'| delay in mS before a balloon may pop up
" set bdlay=600

" [global] |'balloneval'| switch on balloon evaluation
" set beval

" [buffer] |'binary'| read/write/edit file in binary mode
" set nobinary

" [global] |'bioskey'| MS-DOS: use bios calls for input characters
" set biosk

" [buffer] |'bomb'| prepend a Byte Order Mark to the file
" set bomb

" [global] |'breakat'| characters that may cause a line break
" set brk=\ \!@*-+_;:,./?

" [global] |'browsedir'| which directory to start browsing in
" set bsdir=last

" [buffer] |'bufhidden'| what to do when buffer is no longer in window
" set bh=

" [buffer] |'buflisted|' whether the buffer shows up in the buffer list
" set bl

" [buffer] |'buftype'| special type of buffer
" set bt=
" 

" Options initiating with »c« 
" [global] |'cdpath'| list of directories searched with ":cd"
" set cd=,,

" [global] |'cedit'| key used to open the command-line window
" set cedit=<C-F>

" [global] |'charconvert'| expression for character encoding conversion
" set ccv=

" [buffer] |'cindent'|  do C program indenting
" set nocin

" [buffer] |'cinkeys'| keys that trigger indent when 'cindent' is set
" set cink=0{,0},:,0#,!,o,O,e

" [buffer] |'cinoptions'| how to do indenting when 'cindent' is set
" set cino=

" [buffer] |'cinwords'| words where 'si' and 'cin' add an indent
" set cinw=if,else,while,do,for,switch

" [global] |'clipboard'| use the clipboard as the unnamed register
" set cb=autoselect,exclude:\\\|linux

" [global] |'cmdwinheight'| height of the command-line window
" set cwh=7

" [global] |'columns'| number of columns in the display
" set co=80

" [buffer] |'comments'| comments default: sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
" set comments=b:#,:%,fb:-,n:>,n:)
"                       b:\" repeats " , requires blank
"   Strings that        b:#  repeats # , requires blank after #.
"   start a             :%   repeats %
"   comment line        fb:- first line only , requires blank
"                       fbn:* first line only , requires blank, nests
"                       n:>  repeats > , nesting allowed   eg "> > >"
"                       n:)  repeats ) , nesting allowed   eg ") > )"  
"                                               Note the >     ^^^^^
set com=b:\",b:#,:%,fbn:-,fb:*,n:>,n:),:\[---\ snip,:--\

" [global] |'cpo'|  flags for Vi-compatible behavior
set cpoptions=aABceFsJWy

" [global] |'cp'| compatible to vi? Hey. If i want Vi, i'm *using* Vi and not Vim.
set nocompatible

" [global] |'cmdheight'| Disable the 'Press RETURN...' - Messages
set ch=2

" [global] |'cscopepathcomp'|  how many components of the path to show
" set cspc=0

" [global] |'cscopeprg'| command to execute cscope
" set csprg=cscope

" [global] |'cscopetag'| use cscope for tag commands
" set nocst

" [global] |'cscopetagorder'|  determines ":cstag" search order
" set csto=0

" [global] |'cscopeverbose'| give messages when adding a cscope database
" set nocsverb
" 

" Options initiating with »d« 
" [global] |'debug'| set to "msg" to see all error messages
" set debug=

" [glo-lo] |'def'| pattern to be used to find a macro definition
" set def=^#\s*define

" [global] |'delcombine'| delete combining characters on their own
" set nodeco

" [global] |'digraph'| required for those umlauts
set dg

" [glo-lo] |'dictionary'| list of file names used for keyword completion
set dict=/usr/share/dict/words

" [window] |'diff'| use diff mode for the current window
" set nodiff

" [global] |'diffexpr|' expression used to obtain a diff file
" set dex=

" [global] |'diffopt'| options for using diff mode
set dip=filler,context:4,iwhite

" [global] |'directory'| list of directory names for the swap file
" set dir=.,~/tmp,/var/tmp,/tmp

" [global] |'display'| to display as much as possible of the last line in a window instead
"                      of displaying the '@' symbols.
set dy=lastline
" 

" Options initiating with »e« 
" [global] |'eadirection'| in which direction 'equalalways' works
" set ead=both

" [global] |'edcompatible'| toggle flags of ":substitute" command
" set noed
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,latin1
" [global] |'encoding'| encoding used internally
" set enc=latin1
"--------------------------------------------------
" if has("multi_byte")
" 	set encoding=utf-8
" 	setglobal fileencoding=utf-8
" 	set bomb
" 	set termencoding=iso-8859-15
" 	set fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
" endif
"-------------------------------------------------- 

" [buffer] |'endofline'| write <EOL> for last line in file
" set eol

" [global] |'equalalways'| windows are automatically made the same size
" set ea

" [glo-lo] |'equalprg'| external program to use for "=" command
" set ep=

" [global] |'esckeys'| allows cursor keys within insert mode only on SunOS
if has("unix") && system('uname')=='SunOS'
    set ek
endif

" [global] |'errorfile'| name of the errorfile for the QuickFix mode
set ef=error.err

" [glo-lo] |'errorformat'| description of the lines in the error file
set efm+=%f:%l:\ %m,%Dmake[%*\\d]:\ Entering\ directory\ `%f',%Dmake[%*\\d]:\ Leaving\ directory\ `%f'

" [global] |'eventignore'| autocommand events that are ignored
" set ei=

" [global] |'exrc'|  read .vimrc and .exrc in the current directory
" set noex

" [global] |'errorbells'|  be quiet
set noeb

" [buffer] |'expandtab'| Expand Tabs? Rather not.
set noet
" 

" Options initiating with »f« 
" [window] |'foldmethod'| Folding is evil ;)
if has("folding")
        set fdm=manual
endif

" [global] |'fileformats'| automatically detected values for 'fileformat'
" set ffs=unix,dos

" [buffer] |'filetype'| type of file, used for autocommands
" set ft=

" [global] |'fillchars'| characters to use for displaying special items
" set fcs=vert:\|,fold:-
set fillchars=vert:\ ,fold:\ " 

" [global] |'fkmap'| Farsi keyboard mapping
" set nofk

" [global] |'foldclose'| close a fold when the cursor leaves it
" set fcl=

" [window] |'foldcolumn'| width of the column used to indicate folds
" set fdc=0

" [window] |'foldenable'| set to display all folds open
" set nofen

" [window] |'foldexpr'| expression used when 'foldmethod' is "expr"
" set fde=0

" [window] |'foldignore'| ignore lines when 'foldmethod' is "indent"
" set fdi=#

" [window] |'foldlevel'| close folds with a level higher than this
" set fdl=0

" [global] |'foldlevelstart'| when startng to edit a file
" set fdls=-1

" [window] |'foldminlines'| minimum number of lines for a fold to be closed
" set fml=1

" [window] |'foldnestmax'| maximum fold depth
" set fdn=20

" [global] |'foldopen'| for which commands a fold will be opened
" set fdo=block,hor,mark,percent,quickfix,search,tag,undo

" [window] |'foldtext'| expression used to display for a closed fold
" set fdt=foldtext()

" [global] |'formatprg'| name of external program used with "gq" command
" set fp=

" [window] |'foldmarker'| markers used when 'foldmethod' is "marker"
" set fmr=,

" [buffer] |'fileencoding'| file encoding for multi-byte text
" set fenc=ansi

" [global] |'fileencodings'| automatically detected character encodings
" set fencs=ascii,ucs-bom,utf-8,unicode,big5,sjis,latin1

" [global] |'fileformat'| The Right Way(tm)
set ff=unix

" [buffer] |'formatoptions'| Options for text format
"               - »c«: autowrap coments _with_ leader
"               - »q«: use leader when formatting (gq or mapped Q)
"               - »r«: insert the current comment leader automatically
"               - »t«: use textwidth
"               - »2«: use 2nd line's indentation for rest of paragraph
set fo=cqrtc2
" 

" Options initiating with »g« 
" [global] |'gdefault'| the ":substitute" flag 'g' is default on
" set nogd

" [global] |'grepformat'| format of 'grepprg' output
" set gfm=%f:%l%m,%f\ \ %l%m

" [glo-lo] |'grepprg'| program to use for ":grep"
" set gp=grep\ -n\ $*\ /dev/null
set grepprg=grep\ -nH\ $*
" 

" Options initiating with »h« 
" [global] |'helpfile'| name of this help file
" set hf="$VIMRUNTIME/doc/help.txt.gz"

" [global] |'helpheight'| the mindestheight for ':help'
set hh=20

" [global] |'hid'| dont close changed window
set hidden

" [global] |'highlight'| sets highlighting mode for various occasions
" set nohl

" [global] |'hkmap'| Hebrew keyboard mapping
" set nohk

" [global] |'hkmapp'| phonetic Hebrew keyboard mapping
" set nohkp

" [global] |'hi'| make the history longer
set history=500

" [global] |'hlsearch'| Stop the highlighting for the 'hlsearch' option (simple press <F4> instead).
set nohls
" 

" Options initiating with »i« 
" [global] |'incsearch'| dont highlight searchresults
set is

" [global] |'imactivatekey'| key that activates the X input method
" set imak=
 
" [global] |'imcmdline'| use IM when starting to edit a command line
" set noimc

" [global] |'imdisable'| wheter to use IM at all -- XXX
" set noimd

" [buffer] |'iminsert'| use :lmap or IM in Insert mode
" set imi=0

" [buffer] |'imsearch'| use :lmap or IM when typing a search pattern
" set ims=0

" [glo-lo] |'include'| pattern to be used to find an include file
" set inc=^#\\s*include

" [buffer] |'includeexpr'| expression used to process an include line
" set inex=

" [global] |ignorecase'| ignore the case in search patterns? Nope.
"          Note: If you want to ignore case for one specific pattern, you can do this 
"                by prepending the "\c" string.  Using "\C" will make the pattern to 
"                match case.
set noic

" [global] |'icon'| let Vim set the text of the window icon? icon? *rofl*
set noicon

" [global] |'iconstring'| {not available when compiled without the
"                         |+statusline| feature}. uninteresting.. icons on a
"                         terminal .. *rofl*.
" set iconstring

" [buffer] |'indentexpr'| expression used to obtain the indent of a line
" set inde=

" [buffer] |'indentkeys'| keys that trigger indenting with 'indentexpr'
" set indk=0{,0},:,0#,!^F,o,O,e

" [buffer] |'infercase'| adjust case of match for keyword completion
" set noinf

" [global] |'insertmode'| start the edit of a file in Insert mode
" set noim

" When started as "evim", evim.vim will already have done these settings.
" Note: If you want to go to Normal mode to be able to type a sequence of
"       commands, use CTRL-L.
if v:progname =~? "evim"
       finish 
endif

" [global] |'isfname'| characters included in file names and pathnames
" set isf=@,48-57,/,.,-,_,+,,,$,~

" [global] |'isident'| characters included in identifiers
" set isi=@,48-57,_,192-255

" [buffer] |'iskeyword'| enable the search for @, ., _ and -
set isk=@,48-57,_,192-255,-,.,@-@

" [global] |'isprint'| printable characters
" set isp=@,161-255
" 

" Options initiating with »j« 
" [global] |'joinspaces'| two spaces after a period with a join command
" set js
" 

" Options initiating with »k« 
" [buffer] |'key'| encryption key
" set key=

" [buffer] |'keymap'| name of a keyboard mappping
" set kmp=

" [global] |'keymodel'| enable starting/stopping selection with keys
" set km=

" [global] |'keywordprg'| program to use for the "K" command
set kp=man

" 

" Options initiating with »l« 
"  [global] |'langmap'| alphabetic characters for other language mode
" set lmap=

" [global] |'langmenu'| language to be used for the menus
" set lm=

" [global] |'laststatus'| show statusline
set ls=2

" [global] |'lazyredraw'| no screenupdate during macro
set nolz

" [window] |'linebreak'| If on Vim will wrap long lines at a character in 'breakat' rather 
"                        than at the last character that fits on the screen.      
set lbr

" [window] |'list'| show <Tab> and <EOL>
set list

" [global] |'lines'| number of lines in the display
" set lines=24

" [global] |'linespace'| number of pixel lines to use between characters
" set lsp=0

" [buffer] |'lisp'| automatic indenting for Lisp
" set nolisp

" [global] |'lispwords'| words that change how lisp indenting works
" set lw=

" This tells Vim which characters to show for expanded TABs, trailing whitespace, 
" end-of-lines, ...
" [window] |'listchars'| Strings to use in 'list' mode
:set lcs=tab:>-,trail:-

" [global] |'loadplugins'| load plugin scripts when starting up
" set lpl
" 

" Options initiating with »m« 
" [global] |'magic'| Set 'magic' patterns ;)
" Examples:
"  \v       \m       \M       \V         matches ~
"  $        $        $        \$         matches end-of-line
"  .        .        \.       \.         matches any character
"  *        *        \*       \*         any number of the previous atom
"  ()       \(\)     \(\)     \(\)       grouping into an atom
"  |        \|       \|       \|         separating alternatives
"  \a       \a       \a       \a         alphabetic character
"  \\       \\       \\       \\         literal backslash
"  \.       \.       .        .          literal dot
"  \{       {        {        {          literal '{'
"  a        a        a        a          literal 'a'
set magic

" [global] |'makeef'| name of the errorfile for ":make"
set mef="~/tmp/vim##.err"

" [glo-lo] |'makeprg'| program to use for the ":make" command
" set mp="make"

" [global] |'matchtime'| tenths of a second to show matching paren
" set mat=5

" [global] |'maxfuncdepth'| maximum recursive depth for user functions
" set mfd=100

" [global] |'maxmapdepth'| maximum recursive depth for mapping
" set mmd=1000

" [global] |'maxmem'| maximum memory (in Kbyte) used for one buffer
" set mm=512

" [global] |'maxmemtot'| maximum memory (in Kbyte) used for all buffers
" set mmt=2048

" [global] |'menuitems'| maximum number of items in a menu
" set mis=25

" [global] |'modelines'| number of lines checked for modelines
"  set mls=1

" [buffer] |'modifiable'| changes to the text are not possible
" set ma

" [buffer] |'modified'| buffer has been modified
" set nomod

" [buffer] |'modeline'| disable modeline
set ml

" [global] |'more'| pause listings when the whole screen is filled
" set more

" [global] |'mouse'| enable the use of mouse clicks
" set mouse=

" [global] |'mousefocus'| keyboard focus follows the mouse
" set nomousef

" [global] |'mousehide'| hide mouse pointer while typing
" set mh

" [global] |'mousemodel'| changes meaning of mouse buttons
" set mousem=extend

" [global] |'mouseshape'| shape of the mouse pointer in different modes
" set mouses=i:beam,r:beam,s:updown,sd:cross,m:no,v:rightup-arrow

" [global] |'mousetime'| max time between mouse double-click
" set mouset=500

" [buffer] |'matchpairs'| pairs of characters that "%" can match
set mps=(:),[:],{:},<:>
" 

" Options initiating with »n« 
" [buffer] |'nrformats'| number formats recognized for CTRL-A command
set nf=hex

" [window] |'number'| print the line number in front of each line
" set nonu
" 

" Options initiating with »o« 
" [buffer] |'osfiletype'| operating system-specific filetype information
" set oft=
" 

" Options initiating with »p« 
" [global] |'paragraphs'| nroff macros that separate paragraphs
" set para=IPLPPPQPP\ LIpplpipbp

" [global] |'paste'| allow pasting text
" set nopaste

" [global] |'pastetoggle'| exit paste-mode (<F7>)
set pt=<F2>

" [global] |'patchexpr'| expression used to patch a file
" set pex=

" [global] |'patchmode'| keep the oldest version of a file
" set pm=

" [glo-lo] |'path'| The list of directories to search when you specify a file with an edit
"                   command (~/new is my dir with www pages)
set pa=.,,/usr/include,~/new/*/,$VIM/syntax,~/.vim/*

" [global] |'previewheight'| height of the preview window
" set pvh=12

" [window] |'previewwindow'| identifies the preview window
" set nopvw

" set [global] |'printdevice'| name of the printer to be used for :hardcopy
" set pdev=

" [global] |'printoptions'| controls the format of :hardcopy output
set popt=paper:letter,number:y,portrait:y

" [global] |'printfont'| name of the font to be used for :hardcopy
" set pfn=courier

" [global] |'printheader'| format of the header used for :hardcopy
set pheader=%<%f%=Christian\ Schneider\ (strcat@gmx.net)\ %N
" 

" Options initiating with »r« 
" [buffer] |'readonly'| disallow writing the buffer
" set noro

" [global] |'remap'| allow mappings to work recursively
" set remap

" [global] |'report'| always report changes
set report=0

" [global] |'restorescreen'| Win32: restore screen when exiting
" set rs

" [global] |revins'| inserting characters will work backwards
" set nori

" [window] |'rightleft'| window is right-to-left oriented
" set norl

" [global] |'ruler'| show cursor line and column in the status line
" set ru

" [global] |'rulerformat'| custom format for the ruler
" set ruf=%l,%c%V%=%P

" [global] |'runtimepath'| This is a list of directories which will be searched for runtime files:
set rtp=~/.vim,$VIMRUNTIME
" 

" Options initiating with »s« 
" [window] |'scroll'| lines to scroll with CTRL-U and CTRL-D
" set scr=0

" [window] |'scrollbind'| scroll in window as other windows scroll
" set noscb

" [global] |'scrolljump'| minimum number of lines to scroll
" set sj=1

" [global] |'scrolloff'| minimum nr. of lines above and below cursor
  set so=1

" [global] |'scrollopt'| how 'scrollbind' should behave
" set sbo=ver,jump

" [global] |'sections'| nroff macros that separate sections
" set sect=SHNHH\ HUnhsh

" [global] |'suffixes'| ignore this suffixes while ':edit'
set su=.aux,.bak,.dvi,.gz,.idx,.log,.ps,.swp,.tar,.tgz,.tar,.zip

" [buffer] |'suffixesadd'| suffixes added when searching for a file
" set sua=

" [global] |'splitbelow'| splitting a window will put the new window below the current one
set nosb

" [global] |'startofline'| commands listed below move the cursor to the first blank of the line
set nosol

" [global] |'shell'| Execute ':!<command>' with Zsh. I use Zsh, Ksh and Sh. In this
"                    order! No Bash, no Tcsh and no other toys. -l is equivalent to 
"                    --login (See zsh --help for details)
" start the zsh as a login shell:
if has("unix")
        let &sh="zsh \-l"
endif

" [global] |'shellcmdflag'| flag to shell to execute one command
" set shcf=-l

" [global] |'shellpipe'| string to put output of ":make" in error file
" set sp=2>&1\|\ tee

" [global] |'shellquote'| quote character(s) for around shell command
" set shq=

" [global] |'shellredir'| string to put output of filter in a temp file
" set srr=>%s\ 2>&1

" [global] |'shellslash'| use forward slash for shell file names
" set nossl

" [global] |'shelltype'| Amiga: influences how to use a shell
" set st=0

" [global] |'shellxquote'| like 'shellquote', but include redirection
" set sxq=

" [global] |'secure'| trust this current file, but no other
set secure

" [buffer] |'shiftwidth'| eight spaces are one TAB
set sw=8 

" [global] |'shortmess'| list of flags, reduce length of messages
set shm=atIT

" [buffer] |'shortname'| non-MS-DOS: Filenames assumed to be 8.3 chars
" set nosn

" [global] |'shiftround'| round indent to multiple of shiftwidth
set sr

" [global] |'showbreak'| String to put at the start of lines that have been wrapped
set sbr=+

" [global] |'showcmd'| Show (partial) command in status line
set sc

" [global] |'showmatch'|  when a bracket is inserted, briefly jump to the matching one 
set sm

" [global] |'showfulltag'| show full tag pattern when completing tag
" set nosft

" [global] |'showmode'| display current mode
set smd

" [global] |'sidescroll'| minimum number of columns to scroll horizontal
" set ss=0

" [global] |'sidescrolloff'| min. nr. of columns to left and right of cursor
set siso=4

" [global] |'smartcase'| Override the 'ignorecase' option if the search pattern contains
"                        upper case characters.
set scs

" [global] |'smarttab'| When on, a <Tab> in front of a line inserts blanks according to 
"                       'shiftwidth'.  'tabstop' is used in other places.
set sta

"  [buffer] |'smartindent'| smart autoindenting for C programs
" set nosi

" [buffer] |'softtabstop'| Number of spaces that a <Tab> counts for while performing editing
"                          operations
set sts=8

" [global] |'splitbelow'| new window from split is below the current one
" set nosb

" [global] |'splitright'| new window is put right of the current one
" set nospr

" [global] |'statusline'| custom format for the status line. See >:h statusline< for more details
"--------------------------------------------------
" :if has('statusline')
"     " Status line detail: (from Rafael Garcia-Suarez)
"     " %ffile path
"     " %yfile type between braces (if defined)
"     " %([%R%M]%)read-only, modified and modifiable flags between braces
"     " %{'!'[&ff=='default_file_format']}
"     "shows a '!' if the file format is not the platform
"     "default
"     " %{'$'[!&list]}shows a '*' if in list mode
"     " %{'~'[&pm=='']}shows a '~' if in patchmode
"     " (%{synIDattr(synID(line('.'),col('.'),0),'name')})
"     "only for debug : display the current syntax item name
"     " %=right-align following items
"     " #%nbuffer number
"     " %l/%L,%c%Vline number, total number of lines, and column number
"     function SetStatusLineStyle()
"         if &stl == '' || &stl =~ 'synID'
"             let &stl="%f %y%([%R%M]%)%{'!'[&ff=='".&ff."']}%{'$'[!&list]}%{'~'[&pm=='']}%=#%n %l/%L,%c "
"         else
"             let &stl="%f %y%([%R%M]%)%{'!'[&ff=='".&ff."']}%{'$'[!&list]} (%{synIDattr(synID(line('.'),col('.'),0),'name')})%=#%n %l/%L,%c "
"         endif
"     endfunc
" 
"     call SetStatusLineStyle()
"     if has('title')
"         set titlestring=%t%(\ [%R%M]%)
"     endif
" :endif
"-------------------------------------------------- 

"--------------------------------------------------
" function MyStatusLine()
"     let s = '%9* %* ' " pad the edges for better vsplit seperation
"     let s .= '%3*' " User highlighting
"     let s .= '%%%n '
"     if bufname('') != '' " why is this such a pain in the ass? FIXME: there's a bug in here somewhere. Test with a split with buftype=nofile
"         let s .= "%{ pathshorten(fnamemodify(expand('%F'), ':~:.')) }" " short-hand path of of the current buffer (use :ls to see more info)
"     else
"         let s .= '%f' " an empty filename doesn't make it through the above filters
"     endif
"     let s .= '%*' " restore normal highlighting
"     let s .= '%2*' " User highlighting
"     let s .= '%m' " modified
"     let s .= '%r' " read-only
"     let s .= '%w' " preview window
"     let s .= '%*' " restore normal highlighting
"     let s .= ' %<' " start truncating from here if the window gets too small
"     " FIXME: this doens't work well with multiple windows...
"     if bufname('#') != '' " if there's an alternate buffer, display the name
"         let s .= '%4*' " user highlighting
"         let s .= '(#' . bufnr('#') . ' '
"         let s .= fnamemodify(bufname('#'), ':t')
"         let s .= ')'
"         let s .= '%* ' " restore normal highlighting
"     endif
"     let s .= '%5*' " User highlighting
"     let s .= '%y' " file-type
"     let s .= '%*' " restore normal highlighting
"     let s .= ' <'
"     let s .= '%8*' " User highlighting
"     let s .= '%{&fileencoding}' " fileencoding NOTE: this doesn't always display, needs more testing
"     let s .= '%*,' " restore normal highlighting
"     let s .= '%6*' " User highlighting
"     let s .= '%{&fileformat}' " line-ending type
"     let s .= '%*' " restore normal highlighting
"     let s .= '>'
"     let s .= '%a' " (args of total)
"     let s .= '  %9*' " user highlighting
"     let s .= '%=' " seperate right- from left-aligned
"     let s .= '%*' " restore normal highlighting
"     let s .= '%7*' " user highlighting
"     let s .= '%*' " restore normal highlighting
"     let s .= '%1*' " User highlighting
"     let s .= '%l' " current line number
"     let s .= '%*' " restore normal highlighting
"     let s .= ',%c' " column number
"     let s .= '%V' " virtual column number (doesn't count indentation)
"     let s .= ' %1*' " User highlighting
"     let s .= 'of %L' " total line numbers
"     let s .= '%* ' " restore normal highlighting
"     let s .= '%3*' " user highlighting
"     let s .= '%P' " Percentage through file
"     let s .= '%*' " restore normal highlighting
"     let s .= ' %9* %*' " pad the edges for better vsplit seperation
"     return s
" endfunction
" set statusline=%!MyStatusLine()
"-------------------------------------------------- 

"--------------------------------------------------
" fu! FileTime()
"         let ext=tolower(expand("%:e"))
"         let fname=tolower(expand('%<'))
"         let filename=fname . '.' . ext
"         let msg=""
"         let msg=msg." ".strftime("(Modified %b,%d %y %H:%M:%S)",getftime(filename))
"         return msg
" endf
" 
" fu! CurTime()
"         let ftime=""
"         let ftime=ftime." ".strftime("%b,%d %y %H:%M:%S")
"         return ftime
" endf 
" set statusline=%<%F%<\ (ft=%Y)%{FileTime()}%<%h%m%r%=%-20.(line=%03l\ col=%02c\ %V\ totlines=%L%)\%h%m%r%=%-30(,BfNm=%n%)\%P\*%=%{CurTime()}
" set rulerformat=%15(%c%V\ %p%%%) 
"-------------------------------------------------- 
set stl=%<[%n]\ %F\ \ Filetype=\%Y\ \ %r\ %1*%m%*%w%=%(Line:\ %l%)%4(%)Column:\ %5(%c%V/%{strlen(getline(line('.')))}%)\ %4(%)%p%%
" set statusline=[%n]\ %<%f\ %((%1*%M%*%R%Y)%)\ %=%-19(\LINE\ [%3l/%3L]\ COL\ [%02c%03V]%)\ %P
" set statusline=\ %m%r\ \ (Vim\ %{Version()})\ [%02n]\ %t\ [%{Fileformat()}]\ %=(%Y)\ L:%l/%L\ C:%c\ P:%p\ \ \ [%{strftime\(\"\%R\"\)}]\%<\ \ \
" set statusline=-%m%r-----(Vim\ %{Version()})\ [%02n]\ %t\ %=(%Y)\ %l/%L,%c\ \ [%{strftime\(\"\%R\"\)}]\%<---------
" set statusline=[%n]\ %<%f\ %((%1*%M%*%R%Y)%)\ %=%-19(\LINE\ [%3l/%3L]\ COL\ [%02c%03V]%)\ ascii['%02b']\ %P
" set statusline=%<[%n]\ %F\ \ Filetype=\%Y\ \ Fileformat=%{Fileformat()}\ \ %r\ %1*%m%*%w%=%(Column:\ %c%V%)%4(%)%-10(Line:\ %l%)\ %4(%)%p%% 
" set statusline=%4*%m%3*%<%F%3*%=Christian\ Schneider\ %5*\ Line\et

" [global] |'selection'| what type of selection to use
" set sel=inclusive

" [global] |'selectmode'| when to use Select mode instead of Visual mode
" set slm=

" [global] |'sessionoptions'| options for |:mksession|
" set ssop=buffers,winsize,options,help,blank

" [buffer] |'swapfile'| whether to use a swapfile for a buffer
" set swf

" [global] |'swapsync'| how to sync the swap file
" set sws=fsync

" [global] |'switchbuf'| This option controls the behavior when switching between buffers. 
set swb=useopen
" 

" Options initiating with »t« 
" [glo-lo] |'tags'| :help tags Read it + understand it = add it!
set tag=./tags,tags

" [global] |'tagbsearch'| use binary searching in tags files
" set tbs

" [global] |'taglength'| number of significant characters for a tag
" set tl=0

" [global] |'tagrelative'| file names in tag file are relative
" set tr

" [global] |'tagstack'| push tags onto the tag stack
" set tgst

" [buffer] |'textwidth'| maximum width of text that is being inserted
set tw=72

" [global] |'ttyfast'| are we using a fast terminal? Yeppa!!!!11
set tf

" [buffer] |'tabstop'| number of spaces that a <Tab> in the file counts for
set ts=8

" [global] |'title'| When on, the title of the window will be set to the value of
"                    'titlestring' (if it is not empty)
set notitle

" [global] |'term'| name of the terminal
" set term=$TERM

" [global] |'termencoding'| character encoding used by the terminal
" set tenc=

" [global] |'terse'| shorten some messages
" set noterse

" [global] |'ttybuiltin'| When on, the builtin termcaps are searched before the external ones.
set tbi

" [glo-lo] |'thesaurus'| list of thesaurus files for keyword completion
" set tsr=

" [global] |'tildeop'| tilde command "~" behaves like an operator
" set notop

" [global] |'timeout'| time out on mappings and key codes
" set to

" [global] |'timeoutlen'| time out time in milliseconds
" set tm=1000

" [global] |'title'| let Vim set the title of the window
" set title

" [global] |'titlelen'| percentage of 'columns' used for window title
" set titlelen=85

" [global] |'titleold'| old title, restored when exiting
" set titleold=Thanks\ for\ flying\ Vim

" [global] |'titlestring'| string to use for the Vim window title
" set titlestring=

" [global] |'ttimeout'| time out on mappings
" set nottimeout

" [global] |'ttimeoutlen'| time out time for key codes in milliseconds
" set ttm=-1

" [global] |'ttyscroll'| Maximum number of lines to scroll the screen.
set tsl=999

" [global] '|t_vb'| visualbell: Use visual bell instead of beeping. Very usefull if you
"                   don't like sound or try to keep your neighbours friendly ;-)
"--------------------------------------------------
" set t_vb=
"-------------------------------------------------- 

" [global] |'ttytype'| Alias for 'term',
set tty=screen
" 

" Options initiating with »u« 
" [global] |'undolevels'| undoing 1000 changes should be enough
set ul=1000

" [global] |'updatecount'| write swap file to disk after each 150 characters
set uc=150

" [global] |'updatetime'| write swap file to disk after 5 inactive seconds
set ut=5000
" 

" Options initiating with »v« 
" [global] |'verbose'| give informative messages
" set vbs=0

" [global] |'viewdir'| directory where to store files with :mkview
" set vdir=$HOME/etc/vim/view

" [global] |'viewoptions'| specifies what to save for :mkview
" set vop=folds,options,cursor

" [global] |'viminfo'| use .viminfo file upon startup and exiting
"set vi=%,'150,\"100,:100,n~/.viminfo
"--------------------------------------------------
" set vi=!,%,'5000,\"10000,:10000,/10000,n~/.viminfo
"-------------------------------------------------- 
set viminfo=!,\"500,'50,/50,:500,@500,h
"viminfo help:
" ! - Save and restore global variables that start with uppercase and does not have lower case characters.
" " - Maximum number of lines saved for each register.
" % - Save and restore buffer list.
" ' - Maximum number of edited files for which the marks are remembered.
" / - Maximum number of items in search pattern history.
" : - Maximum number of items in command-line history.
" @ - Maximum number of items in input-line history.
" c - Convert viminfo text from/to 'encoding'.
" f - Whether file marks need to be stored.
" h - Disable the effect of 'hlsearch' when loading viminfo file.
" n - Name of the viminfo file.
" r - Removable media. List of pathes for which no marks will be saved.


" [global] |'visualbell'| visual bell instead of beeping.. or nothing ;)
set novisualbell

" [global] |'virtualedit'| when to use virtual editing
set ve=block

" YES. I've a OpenVMS VAX V7.2 :-)
" | VIM - Vi IMproved 6.2 (2003 Jun 1, compiled Jan 15 2004 11:53:14)
" | OpenVMS version
" | Included patches: 1-181
if has("unix")
        let vimrc='~/.vimrc'
else
        " for my VMS-Box (i. e. »if has("vms")«):
        let vimrc='sys$login:.vimrc'
endif
" 

" Options initiating with »w« 
" [global] |'warn'| warn for shell command when buffer was changed
" set warn

" [global] |'weirdinvert'| for terminals that have weird inversion method
"--------------------------------------------------
"  set nowi
"-------------------------------------------------- 

" [global] |'wildchar'| type to start wildcard expansion in the command-line
set wc=<TAB>

" [global] |'writebackup'| make a backup before overwriting a file? no... thats for weenies ;)
set nowb

" [global] |'weirdinvert'| delay this many msec for each char (for debug)
" set wd=0

" [window] |'wrap'| this option changes how text is displayed
set nowrap

" [global] |'wildcharm'| like 'wildchar' but also works when mapped
" set wcm=0

" [global] |'wildmenu'| When 'wildmenu' is on, command-line completion operates in an
"                       enhanced mode. 
set wmnu

" [global] |'wildmenu'| files matching these patterns are not completed
" set wig=

" [global] |'wildmode'| have command-line completion <Tab> (for filenames, help topics, option
"                       names) first list the available options and complete the longest common 
"                       part, then have further <Tab>s cycle through the possibilities:
set wim=list:longest,full

" [global] |'whichwrap'| specified keys that move the cursor left/right to wrap
set ww=<,>,h,l

" [global] |'whichwrap'| minimum number of lines for the current window
set wh=5

" [global] |'winaltkeys'| when the windows system handles ALT keys
" set wak=menu

" [global] |'winminheight'| minimum number of lines for any window
" set wmh=1

" [global] |'winminwidth'| minimal number of columns for any window
" set wmw=4

" [global] |'winwidth'| minimal number of columns for current window
" set wiw=20

" [buffer] |'wrapmargin'| chars from the right where wrapping starts
" set wm=0

" [global] |'wrapmargin'| searches wrap around the end of the file
" set nows

" [global] |'write'| writing to a file is allowed
" set write

" [global] |'writeany'| write to file with no need for "!" override
" set nowa
" 

" Source some Files 
" Note: The "expand" is necessary to evaluate ~dope
"
" File: VBlockquote.vim (Insert (Quote) stuff the way some emacs people do)
let VBLOCK=expand("~/.vim/macros/VBlockquote.vim")
if filereadable(VBLOCK)
        exec "source " VBLOCK
endif

" File: browser_launcher.vim (Vim script to launch/control browsers.)
let BLAUNCH=expand("~/.vim/ftplugin/browser_launcher.vim")
if filereadable(BLAUNCH)
        exec "source " BLAUNCH
endif

" File: a.vim (foo.c -> foo.h)
" :A switches to the header file corresponding to the current file being edited (or vise versa)
" :AS splits and switches
" :AV vertical splits and switches
let AFILE=expand("~/.vim/macros/a.vim")
if filereadable(AFILE)
        exe "source " AFILE
endif

" File: tetris.vim ;-)
" Start a new game with »\te« (see »:h <Leader>« for details).
let TETRIS=expand("~/.vim/macros/tetris.vim")
if filereadable(TETRIS)
        exec "source " TETRIS
endif

"--------------------------------------------------
" " File: abbreviations.vim (often used abbreviations ;-))
" let IABS=expand("~/.vim/macros/abbreviations.vim")
" if filereadable(IABS)
"         exec "source " IABS
" endif
"-------------------------------------------------- 
" 

" Misc Options 
" [buffer] ":syntax enable" will keep your current color settings.
"--------------------------------------------------
syntax on
" 
" [buffer] type of file, used for autocommands
filetype plugin on
filetype indent on

"-------------------------------------------------- 
" Use my own colorscheme
"colorscheme anotherdark 
"--------------------------------------------------
" colorscheme dante
"-------------------------------------------------- 
"--------------------------------------------------
" colorscheme lettuce
"-------------------------------------------------- 
"colorscheme painless
colorscheme wargrey
"--------------------------------------------------
" colorscheme kaltex
"-------------------------------------------------- 
"--------------------------------------------------
" colorscheme pablo
"-------------------------------------------------- 

" Let's be friendly :)
autocmd VimEnter * echo "Welcome back Chris :)"
autocmd VimLeave * echo "Cya in Hell."

" When editing a file, always jump to the last cursor position.
"autocmd BufReadPost * if line("'\"") && line("'\"") <= line("$") | exe "normal `\"" | endif
autocmd BufReadPost *
			\ if expand("<afile>:p:h") !=? $TEMP | 
			\ if line("'\"") > 0 && line("'\"") <= line("$") | 
			\ exe "normal g`\"" | 
			\ let b:doopenfold = 1 | 
			\ endif | 
			\ endif 
" Need to postpone using "zv" until after reading the modelines. 
autocmd BufWinEnter *
			\ if exists("b:doopenfold") | 
			\ unlet b:doopenfold | 
			\ exe "normal zv" | 
			\ endif
" 

" terminal stuff 
"-------------------------------------------------- 
"--------------------------------------------------
" if &term=="rxvt"
"         set term=xterm
" endif
"-------------------------------------------------- 
if &term=="xterm" || &term=="xterm-256color" || &term=="rxvt" || &term=="screen" || &term=="screen-256color"
        set t_Co=256
        set t_Sf=[3%dm
        set t_Sb=[4%dm
        if !has("xterm_save")
                set t_ti=[?47h
                set t_te=[?47l
        endif
endif
"--------------------------------------------------
" 

" Options for Vim 7.0 
"-------------------------------------------------- 
if version >= 700
	let loaded_matchparen = 1
	" turn spelling on by default
	set nospell
	"--------------------------------------------------
	set spellfile=~/.vim/spellfile.add
	" set spellfile=/home/dope/.vim/de.utf-8.spl
	"-------------------------------------------------- 
	" change to german
	set spelllang=de
	set pumheight=7
	map <Leader>tn :tabnew<CR>
	map <Leader>tc :tabclose<CR>
	map <Leader>tw :tabnext<CR>
	" toggle spelling with F2 key
	map <F2> :set spell!<CR><Bar>:echo "Spell Check: " . strpart("OffOn", 3 * &spell, 3)<CR>
	" they were using white on white
	" highlight PmenuSel ctermfg=black ctermbg=lightgray
	" limit it to just the top 10 items
	set sps=best,10
	au InsertEnter * hi StatusLine term=reverse ctermbg=5 gui=undercurl guisp=Magenta
	au InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=2 gui=bold,reverse
endif
" 

" Mappings 
"
" /* shameless stolen from Sven Guckes */
" 2005-03-10 coloring whitespace,
" ie trailing spaces and tabs:
  highlight TrailSpace cterm=inverse ctermfg=magenta
  syn match TrailSpace /  *$/
" substitute the less-than and greater-than characters
" with their HTML equivalents in the current line:
" vmap ,,< :s/</\&lt;/g<CR>gv:s/>/\&gt;/g<CR>
" 2006-10-26 fadenkreuz an/aus
  map <esc><esc> :set cul! cuc!<cr>
hi cursorline    term=none ctermbg=blue
hi cursorcolumn  term=none ctermbg=red

" Fix trailing spaces <http://vim.wikia.com/wiki/VimTip878>
function TrimWhiteSpace() 
	: %s/\s*$// 
	: '' 
:endfunction 

" ,u = update by reading this file
 map ,u :source ~/.vimrc<CR>
" When .vimrc is edited, reload it
"autocmd! bufwritepost .vimrc source ~/.vimrc

" Toggle linenumbers with F5
nmap <F5> :set invnumber number?<CR>

" <http://www.michael-prokop.at/computer/config/.centericq/external>
" 030511 log all messages arriving when online
" -> then process them for example in vim [very usefull if receiving some source!]
" put the following into your "~/.vimrc":
map   ##i :e ~/.centericq/icq_log_<C-R>=strftime("%y%m%d")<CR>

" This is mapping to uuencode and uudecode in BASE64: 
" supports normal mode and visual mode. 
nnoremap <silent> <Leader>ue :%!uuencode -m /dev/stdout<CR> 
nnoremap <silent> <Leader>ud :%!uudecode -o /dev/stdout<CR> 
vnoremap <silent> <Leader>ue !uuencode -m /dev/stdout<CR> 
vnoremap <silent> <Leader>ud !uudecode -o /dev/stdout<CR>

" Load ~/.vim/macros/vimdiff.vim
  map ;LD :source ~/.vim/macros/vimdiff.vim<CR>
" Load ~/.vim/macros/morse.vim
  map ;LM :source ~/.vim/macros/morse.vim<CR>
" Load ~/.vim/macros/vimspell.vim
  map ;LS :source ~/.vim/macros/vimspell.vim<CR>

" Fix a diff, making it easier to review.
" Add a blank line before each '@@ ... hunk line info ...@@' and each 'diff',
" making it easier to jump around using { and }
fun! ReviewDiff()
    let oldreg_val = getreg('d')
    let oldreg_type = getregtype('d')
    call setreg('d', '', 'V')
    g/^diff/put! d
    g/^@@/put! d
    call setreg('d', oldreg_val, oldreg_type)
endfun

" narf .. some morons insert more then one space in any text   and  i don't
" like it. This map's will runs of two or more space to a single space.
nmap <ESC>j vip:s/  \+/ /g<CR>
vmap <ESC>j    :s/  \+/ /g<CR>

" Quick insertion of an empty line
nmap <CR> o<ESC>

" trim blanks
map ,tr :%s/\s\+$//gic<CR>

" list files in current directory.
map ,ls :!/bin/ls<CR>

" Change into directory of current file
nmap ,cd :exe 'cd ' . expand ("%:p:h")<CR>:pwd<CR>

" Disable ZZ (too dangerous, might be typed when all I meant was zz)
map ZZ :"Sorry. no 'ZZ' today. Please stop cyring and piss off."<CR>

" Delete lines in insert-mode.
"--------------------------------------------------
" map! <C-k> <Esc>ddi
"-------------------------------------------------- 
set <C-Right>=f
set <C-Left>=[1;5D
map <C-Left> b
map <C-Right> w

" Fxx Keys
" <F3> saves current buffer
nmap <F3> :w<CR>
imap <F3> <C-O>:w<CR>

" toggle highlight search (folke)
noremap <F4>  :if 1 == &hls \| noh \| else \| set hls \| endif \| <CR>

" Scroll in insert-mode
inoremap <C-E> <C-X><C-E>
inoremap <C-Y> <C-X><C-Y>

" Undo in insert mode.
imap <c-z> <c-o>u

" Nice Feature ;)
" Type (in the insert-mode) 4+4<C-B> and you will get the result.
"  Note: '<C-A>' won't work under screen because C-A C-A is a default
"        Keybinding of screen *g*
" '*' == sum            |       '+' == product
" '-' == difference     |       '/' == quotient
" '%' == remainder      |       '^' == scale(a^b) = min(scale(a)*b
inoremap <C-B> <C-O>yiW<End>=<C-R>=<C-R>0<CR>

" Press <Strg>_ and it will tell you the word under the cursor, and how long
" it is.
nmap <C-_> :echo 'word' expand("<cword>") '  wordlen =' strlen(expand("<cword>"))<CR>
vmap <C-_> "-y:echo 'word' @- '  wordlen =' strlen(@-)<CR>

" <F10>: quit buffer but prompt if changes have been made
nmap <F10> :confirm q<CR>
imap <F10> <Esc>:confirm q<CR>

" <C-F12> list all errors
nmap [24^ :clist!<CR>

" Esc is too hard to reach, so remap it. 
" Note: i use english keyboard layout, i mapped capslock to esc, this mapping
"       is only for some fucking german keyboards in my network :/
inoremap jj <esc>

" Quick change buffers
imap <c-n> <ESC>:bNext<CR>
nmap <c-n> :bNext<CR>

" Often used filenames - only needed these on the command line:
" »:e _Mrc« == »:e /home/$USER/.muttrc«
cab Mrc ~/.muttrc
cab Src ~/.slrnrc
cab Zrc ~/.zshrc
cab Erc ~/.exrc
cab Vrc ~/.vimrc
cab Frc ~/.fvwmrc
cab Irc ~/.irssi/config
cab SRc ~/.screenrc
cab Nrc ~/.vim/macros/MailNews.vim
cab Spe ~/.vim/macros/vimspell.vim
" 

" boxes mappings 
" 030219 Call boxes - with some funny box-styles ;o)
" Shameless stolen from Michael Prokop's ~/.vimrc
" (http:////michael-prokop.at/computer/config/.vimrc>)
map ;0 <ESC>:'<,'>!/home/dope/bin/boxes
map ;1 <ESC>:'<,'>!/home/dope/bin/boxes -d boxquote
map ;2 <ESC>:'<,'>!/home/dope/bin/boxes -d peek -a c -s 40x5
map ;3 <ESC>:'<,'>!/home/dope/bin/boxes -d c-cmt
map ;4 <ESC>:'<,'>!/home/dope/bin/boxes -d dog -a c
map ;5 <ESC>:'<,'>!/home/dope/bin/boxes -d simple -a jr
map ;6 <ESC>:'<,'>!/home/dope/bin/boxes -d headline
" See <http://boxes.thomasjensen.com/> for details ;-)
autocmd BufEnter * nmap ,mc !!/home/dope/bin/boxes -d pound-cmt<CR>
autocmd BufEnter * vmap ,mc !/home/dope/bin/boxes -d pound-cmt<CR>
autocmd BufEnter * nmap ,xc !!/home/dope/bin/boxes -d pound-cmt -r<CR>
autocmd BufEnter * vmap ,xc !/home/dope/bin/boxes -d pound-cmt -r<CR>
" html
autocmd BufEnter *.html nmap ,mc !!/home/dope/bin/boxes -d html-cmt<CR>
autocmd BufEnter *.html vmap ,mc !/home/dope/bin/boxes -d html-cmt<CR>
autocmd BufEnter *.html nmap ,xc !!/home/dope/bin/boxes -d html-cmt -r<CR>
autocmd BufEnter *.html vmap ,xc !/home/dope/bin/boxes -d html-cmt -r<CR>
" c
autocmd BufEnter *.[chly],*.[pc]c nmap ,mc !!/home/dope/bin/boxes -d c-cmt<CR>
autocmd BufEnter *.[chly],*.[pc]c vmap ,mc !/home/dope/bin/boxes -d c-cmt<CR>
autocmd BufEnter *.[chly],*.[pc]c nmap ,xc !!/home/dope/bin/boxes -d c-cmt -r<CR>
autocmd BufEnter *.[chly],*.[pc]c vmap ,xc !/home/dope/bin/boxes -d c-cmt -r<CR>
" java/c++ standard comment
autocmd BufEnter *.C,*.cpp,*.java nmap ,mc !!/home/dope/bin/boxes -d java-cmt<CR>
autocmd BufEnter *.C,*.cpp,*.java vmap ,mc !/home/dope/bin/boxes -d java-cmt<CR>
autocmd BufEnter *.C,*.cpp,*.java nmap ,xc !!/home/dope/bin/boxes -d java-cmt -r<CR>
autocmd BufEnter *.C,*.cpp,*.java vmap ,xc !/home/dope/bin/boxes -d java-cmt -r<CR>
" java/c++ section comment
autocmd BufEnter *.C,*.cpp,*.java nmap ,ms !!/home/dope/bin/boxes -d java-sect<CR>
autocmd BufEnter *.C,*.cpp,*.java vmap ,ms !/home/dope/bin/boxes -d java-sect<CR>
autocmd BufEnter *.C,*.cpp,*.java nmap ,xs !!/home/dope/bin/boxes -d java-sect -r<CR>
autocmd BufEnter *.C,*.cpp,*.java vmap ,xs !/home/dope/bin/boxes -d java-sect -r<CR>
" rc
autocmd BufEnter .vimrc*,.exrc,.javarc,.texrc,.f77rc,.mlrc,.gvimrc,.muttvimrc,*.vim nmap ,mc !!/home/dope/bin/boxes -d vim-cmt<CR>
autocmd BufEnter .vimrc*,.exrc,.javarc,.texrc,.f77rc,.mlrc,.gvimrc,.muttvimrc,*.vim vmap ,mc !/home/dope/bin/boxes -d vim-cmt<CR>
autocmd BufEnter .vimrc*,.exrc,.javarc,.texrc,.f77rc,.mlrc,.gvimrc,.muttvimrc,*.vim nmap ,xc !!/home/dope/bin/boxes -d vim-cmt -r<CR>
autocmd BufEnter .vimrc*,.exrc,.javarc,.texrc,.f77rc,.mlrc,.gvimrc,.muttvimrc,*.vim vmap ,xc !/home/dope/bin/boxes -d vim-cmt -r<CR>
" tex slrnrc
autocmd BufEnter *.tex,.slrnrc nmap ,mc !!/home/dope/bin/boxes -d tex-cmt<CR>
autocmd BufEnter *.tex,.slrnrc vmap ,mc !/home/dope/bin/boxes -d tex-cmt<CR>
autocmd BufEnter *.tex,.slrnrc nmap ,xc !!/home/dope/bin/boxes -d tex-cmt -r<CR>
autocmd BufEnter *.tex,.slrnrc vmap ,xc !/home/dope/bin/boxes -d tex-cmt -r<CR>
" 

" Some function()'s 
func! Umlaute()
        exec "%s/ä/ae/gic"
        exec "%s/ö/oe/gic"
        exec "%s/ü/ue/gic"
        exec "%s/ß/ss/gic"
        exec "%s/Ä/Ae/gic"
        exec "%s/Ö/Oe/gic"
        exec "%s/Ü/Ue/gic"
endfunc

" VimTip 70: running a command on all buffers
" :call AllBuffers("%s/string1/string2/g")
" :call AllBuffers("%s/foo/bar/ge|update")
function AllBuffers(cmnd)
	let cmnd = a:cmnd
	let i = 1
	while (i <= bufnr("$"))
		if bufexists(i)
			execute "buffer" i
			execute cmnd
		endif
		let i = i+1
	endwhile
endfunction
"
" Removes those bloody ^M's
" :call RmCR()
fun RmCR()
    let oldLine=line('.')
    exe ":%s/\r//gic"
    exe ':' . oldLine
endfun


" Function for changing folding method.
if version >= 600
        function! ChangeFoldMethod() abort
                let choice = confirm("Which fold method?", "&manual\n&indent\n&expr\nma&rker\n&syntax", 2)
                if choice == 1
                        set foldmethod=manual
                elseif choice == 2
                        set foldmethod=indent
                elseif choice == 3
                        set foldmethod=expr
                elseif choice == 4
                        set foldmethod=marker
                elseif choice == 5
                        set foldmethod=syntax
                else
                endif
        endfunction
endif

" tabs
function MyTabLine()
	let s = ''
	let i = 1
	" loop over all tab pages
	while i <= tabpagenr('$')
	  " start of i-th tab
	  let s .= '%' . i . 'T'
	  " highlight current tab in TabLineSel, others in TabLine
	  if i == tabpagenr()
		let s .= '%#TabLineSel#'
	  else
		let s .= '%#TabLine#'
	  endif
	  let s .= ' '
	  " filename for current window in tab, without path
	  let b = fnamemodify(
		\ bufname(tabpagebuflist(i )[tabpagewinnr(i ) - 1]),
		\ ':t')
	  " if empty, display [No Name]
	  if b == ''
		let b = '[No Name]'
	  endif
	  let s .= b
	  " end of tab
	  let s .= ' %T|'
	  let i = i + 1
	endwhile
	" highlight 'elastic' part in TabLineFill,
	" then X (close current tab) in TabLine
	let s .= '%#TabLineFill#%=%#TabLine#%999XX'
	return s
  endfunction
  set tabline=%!MyTabLine()



" For the lastmod augroup 
function! LastMod()
        if line("$") > 1000
                let l = 1000
        else
                let l = line("$")
        endif
        exe "1," . l . "s/Last modified: .*/Last modified: " .  strftime("[ %Y-%m-%d %T ]") . "/e"
endfunction

" Fnord!
function DamnedWQ()
        let x = confirm("Current Mode ==  Insert-Mode!\n Would you like ':wq'?"," &Yes \n &No (yes means no and no means yes)",1,1)
        if x == 1
                silent! :wq
        else
                "???
        endif
endfun
iab wq <bs><esc>:call DamnedWQ()<CR>
" 

" Abbreviations 
" date'n'time
" See strftime(3), date(1), printf(1), ctime(3),  getenv(3),
" printf(3), strptime(3) and so on for details.
" 22:28 
  iab Ytime <C-R>=strftime("%H:%M")<CR>
" 2003-09-25 22:28:38 
  iab _YDT   <C-R>=strftime("%Y-%m-%d %T")<CR>
" Thu 25 Sep 2003, 22:28:46 CEST 
  iab YDATe <C-R>=strftime("%a %d %b %Y, %T %Z")<CR>
" 2003-09-25 22:28:53 CEST 
  iab YDATE <C-R>=strftime("%Y-%m-%d %T %Z")<CR>
" 030925 
  iab Ydate <C-R>=strftime("%y%m%d")<CR>
" 030925 22:29:03  
  iab YDT   <C-R>=strftime("%y%m%d %T")<CR> 
" Saturday - July 12th 
  iab MDATE <C-R>=strftime("%A - %B %dth")<CR>
" [2003-07-12] 
  iab TST   <C-R>=strftime("[%Y-%m-%d]")<CR>
" July 12, 2003 (Saturday, 21:26h) 
  iab Y_DAT <C-R>=strftime("%B %d, %Y (%A, %H:%Mh)")<CR>
" I use this format in <http://strcat.de/papers.html>
  iab YHP <C-R>=strftime("%D")<CR>

" My personal homepages (Thx to Winfried Neessen for the webspace!)
  iab EMstrcat    strcat@gmx.net
  iab HPneessen   http://strcat.neessen.net/
  iab HPme        http://www.strcat.de/
  iab HPblog      http://www.strcat.de/blog/
  iab HPpebcak    http://strcat.pebcak.de/
  iab HPgpg       http://strcat.de/chris.gpg
  iab HPirssi     http://strcat.de/irssi/
  iab HPvim       http://strcat.de/vim/
  iab HPslrn      http://strcat.de/slrn/
  iab HPmutt      http://strcat.de/mutt/
  iab HPusenet    http://strcat.de/usenet.html
  iab HPhacks     http://strcat.de/hacks/
  iab HPpapers    http://strcat.de/papers.html
  iab HPzsh       http://strcat.de/zsh/
  iab HPscreen    http://strcat.de/screen/
  iab HPfvwm      http://strcat.de/fvwm/
  iab HPmisc      http://strcat.de/oth.html
  iab HPdau       http://strcat.de/logs/
  iab HPmfilter   http://strcat.de/mailfilter/
  iab HPrtfm      http://strcat.de/images/google.png

" Some simple example of the "expand modifiers":
" insert the current filename *with* path: »/home/dope/.vimrc«
  iab Ypathfile <C-R>=expand("%:p")<cr>
" insert the current filename *without* path: ».vimrc«
  iab Yfile <C-R>=expand("%:t:r")<cr>
" 

" Formatoptions 
" Formatoptions for asciidoc (<http://www.methods.co.nz/asciidoc/>) 
autocmd BufNewFile,BufRead ~/scripts/Asciidoc/*.txt
	\ setlocal autoindent expandtab tabstop=8 softtabstop=2 shiftwidth=2
	\ | setlocal tabstop=8 softtabstop=2 shiftwidth=2 filetype=asciidoc
	\ | set textwidth=70 wrap formatoptions=tcqn 
	\ | set formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\\|^\\s*<\\d\\+>\\s\\+\\\\|^\\s*[a-zA-Z.]\\.\\s\\+\\\\|^\\s*[ivxIVX]\\+\\.\\s\\+
	\ | set comments=s1:/*,ex:*/,://,b:#,:%,:XCOMM,fb:-,fb:*,fb:+,fb:.,fb:> 
	\ | nnoremap Q gq}
	\ | set ft=asciidoc
	\ | source ~/.vim/macros/abbreviations.vim
	\ | nmap <F2> :make<CR>
	\ | inoremap <F2> <ESC>:make<CR><CR>a
	\ | set makeprg=asciidoc\ -b\ xhtml11\ -d\ book\ -v\ --unsafe\ -a\ toc\ -a\ icons\ -a\ badges\ -f\ ~/.asciidoc/asciidoc.conf\ %

autocmd BufNewFile,BufRead ~/.tmux.conf set ft=tmux

" C(++) 
function CInsert()
    let x = confirm("Which template?\n"," &Linux-Like \n &Unix-Like",1,1)
    if x == 1
    silent! 0r ~/.vim/templates/template-Linux.c
    else
    0r ~/.vim/templates/template-Unix.c
    endif
endfunc
autocmd BufRead *.c set tw=0
augroup c
    autocmd!
    autocmd BufNewFile,BufRead *.c,*.h,*.cc,*.cpp so $VIMRUNTIME/syntax/c.vim
    autocmd BufNewFile,BufRead *.c,*.h,*.cc,*.cpp set com=sr:/*,mb:*,ex:*/ 
    autocmd BufRead,BufNewFile *.c,*.h,*.cc,*.cpp  setlocal cindent
    autocmd BufRead,BufNewFile *.c,*.h,*.cc,*.cpp  setlocal cinoptions=>4,e0,n0,f0,{0,}0,^0,:4,=4,p4,t4,c3,+4,(2s,u1s,)20,*30,g4,h4
    autocmd BufRead,BufNewFile *.c,*.h,*.cc,*.cpp  setlocal cinkeys=0{,0},:,0#,!<C-F>,o,O,e
    "autocmd BufNewFile *.c call CInsert()
    autocmd BufWritePre,FileWritePre *.c  exec("normal ms")|call LastMod()|exec("normal `s")
augroup END
" 

" LaTeX 
"au BufNewFile *.tex :0r ~/.vim/templates/template.tex | 
"--------------------------------------------------
" au FileType tex so ~/.vim/ftplugin/latex.vim
"-------------------------------------------------- 
au FileType tex set dict+=~/.vim/dic/LaTeX.dic sw=2 sts=2 ai com=:% | syn sync maxlines=200 | syn sync minlines=50
augroup tex
    " <F5>:  Comment/uncomment current line
function! LaTeXCommentUncomment()
        if getline('.') =~ '^%'
                execute("normal |")
                execute("normal x")
                execute(line('.')+1)
        else
                execute("normal |")
                execute("normal i%")
                execute(line('.')+1)
        endif
endfunction " LaTeXCommentUncomment()

" <S-F5>:  Make the target corresponding to the current file (strips off
" the .tex extension;  if editing video.tex, will call make video
    autocmd FileType tex map  <S-F5> :execute(":make ".strpart(expand("%"), 0, match(expand("%"), ".tex")))<cr>
    autocmd FileType tex imap <S-F5> <Esc>:execute(":make ".strpart(expand("%"), 0, match(expand("%"), ".tex")))<cr>
augroup END
" 

" HTML 
function HTMLInsert()
   let x = confirm("Which Template?\n"," &Light \n &Dark",1,1)
   if x == 1
   silent! 0r ~/.vim/templates/template-light.html
   else
   0r ~/.vim/templates/template-dark.html
   endif
endfunc
augroup html
  autocmd!
  autocmd  BufNewFile,BufRead *.html,*.shtml hi htmlLink ctermfg=Black ctermbg=Cyan cterm=underline
  autocmd  BufNewFile,BufRead *.html,*.shtml so $VIMRUNTIME/syntax/html.vim 
  autocmd  BufNewFile,BufRead *.html,*.shtml set tw=100 nowrap
  " autocmd  BufNewFile *.html,*.shtml,*.htm call HTMLInsert()
  autocmd  BufWritePre,FileWritePre *.html,*.shtml exec("normal ms")|call LastMod()|exec("normal `s")
augroup END
" 

" XML 
map <Leader>x :set filetype=xml<CR>
  \:source $VIMRUNTIME/syntax/xml.vim<CR>
  \:set foldmethod=syntax<CR>
"  \:source $VIMRUNTIME/syntax/syntax.vim<CR>
  \:colors peachpuff<CR>
  \:source $ADDED/xml.vim<CR>
  \:iunmap <buffer> <Leader>.<CR>
  \:iunmap <buffer> <Leader>><CR>
  \:inoremap \> ><CR>
  " no imaps for <Leader>
  "\:inoremap \. ><CR>


" catalog should be set up
nmap <Leader>l <Leader>cd:%w !xmllint --valid --noout -<CR>
nmap <Leader>r <Leader>cd:%w !rxp -V -N -s -x<CR>
nmap <Leader>d4 :%w !xmllint --dtdvalid 
 \"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" --noout -<CR>

vmap <Leader>px !xmllint --format -<CR>
nmap <Leader>px !!xmllint --format -<CR>
nmap <Leader>pxa :%!xmllint --format -<CR>
nmap <Leader>i :%!xsltlint<CR>
" 

" CSS 
function CSSInsert()
   let x = confirm("Which Template?\n"," &Light \n &Dark",1,1)
   if x == 1
   silent! 0r ~/.vim/templates/template-light.css
   else
   silent 0r ~/.vim/templates/template-dark.css
   endif
endfunc
augroup css
  autocmd!
  autocmd  BufNewFile,BufRead *.css so $VIMRUNTIME/syntax/css.vim
  autocmd  BufNewFile,BufRead *.css set tw=0 nowrap
  " autocmd  BufNewFile         *.css call CSSInsert()
  autocmd  BufWritePre,FileWritePre *.css exec("normal ms")|call LastMod()|exec("normal `s")
augroup END
" 

" For CRUX Pkgfiles 
autocmd BufNewFile Pkgfile 0r ~/.vim/templates/Pkgfile
" 

" Mail and News 
au FileType mail so ~/.vim/macros/MailNews.vim
if has("autocmd")
        au BufRead ~/.followup so ~/.vim/macros/message-nowplaying.vim | set spell
        au BufRead ~/tmp/mutt-* so ~/.vim/macros/msgid.vim
	au BufRead ~/tmp/mutt* set ft=mail | set spell | syntax on
	au BufRead ~/.article* so ~/.vim/macros/message-nowplaying.vim | set spell | syntax on
endif

" Checking attachments in edited emails for use in Mutt: warns user when
" exiting
" by Hugo Haas <hugo@larve.net> - 20 June 2004
" based on an idea by The Doctor What explained at
" <mid:caq406$rq4$1@FreeBSD.csie.NCTU.edu.tw>
" <http://www.vim.org/scripts/download_script.php?src_id=3165>
autocmd BufUnload mutt-* call CheckAttachments()
function! CheckAttachments()
	let l:english = 'attach\(ing\|ed\|ment\)\?'
	let l:french = 'attach\(e\|er\|Ã©e\?s\?\|ement\|ant\)'
	let l:ic = &ignorecase
	if (l:ic == 0)
		set ignorecase
	endif
	if (search('^\([^>|].*\)\?\<\(re-\?\)\?\(' . l:english . '\|' . l:french . '\)\>', "w") != 0)
		let l:temp = inputdialog("Do you want to attach a file? [Hit return] ")
	endif
	if (l:ic == 0)
		set noignorecase
	endif
	echo
endfunction

" 

" Slang 
augroup slang
        autocmd BufRead *.sl,~/.slrnrc set ft=slang | set modeline
        autocmd BufRead *.sl,~/.slrnrc set com=sr:%,mb:%,ex:%
        autocmd BufRead ~/.slang/score set ft=slrnsc | set modeline
        autocmd BufRead ~/.slang/score nmap ;as oSubject: ^\<\><ESC>F\i | nmap ;as oSubject: \<\><ESC>F\i
        autocmd BufRead ~/.slang/score nmap ;af oFrom: ^\<\><ESC>F\i | nmap ;af oFrom: \<\><ESC>F\i
        autocmd BufRead ~/.slang/score nmap ;au oUser-Agent: ^\<\><ESC>F\i | nmap ;au oUser-Agent: \<\><ESC>F\i
        autocmd BufWritePre,FileWritePre *.sl,*.slrnrc  exec("normal ms")|call LastMod()|exec("normal `s")
augroup END
" 

" Changelogs 
augroup Changelog
  autocmd!
  autocmd BufNewFile,BufRead  Changelog     so ~/.vim/macros/Changelog.vim
  autocmd BufNewFile,BufRead  Changelog     set tw=72 nowrap
  autocmd BufNewFile,BufRead  Changelog     so $VIMRUNTIME/syntax/changelog.vim
augroup END
" 

" Perl 
au FileType perl set cink=0{,0},!,o,O
                \ | set cinw=if,else,elsif,while,do,foreach,switch,sub
                \ | set com=b:#
                \ | set kp=perldoc\ -f
                \ | set smartindent
                \ | set makeprg=$HOME/bin/vimparse.pl\ %\ $*
                \ | set errorformat=%f:%l:%m
augroup pl 
  autocmd!
  autocmd BufNewFile,BufRead *.pl,*.pm let perl_want_scope_in_variables=1
  autocmd BufNewFile,BufRead *.pl,*.pm let perl_extended_vars=1
  autocmd BufNewFile,BufRead *.pl,*.pm so $VIMRUNTIME/syntax/perl.vim
  autocmd BufNewFile,BufRead *.pl,*.pm set tw=0 nowrap 
  " autocmd BufNewFile         *.pl,*.pm 0r ~/.vim/templates/template.pl
  autocmd BufNewFile,BufRead *.pl,*.pm map <F1> :Perldoc<CR>
  autocmd BufNewFile,BufRead *.pl,*.pm setf perl
  autocmd BufNewFile,BufRead *.pl,*.pm let g:perldoc_program='/usr/local/bin/perldoc'
  autocmd BufNewFile,BufRead *.pl,*.pm source ~/.vim/ftplugin/perl_doc.vim
  autocmd BufWritePre,FileWritePre *.pl,*.pm  exec("normal ms")|call LastMod()|exec("normal `s")
  autocmd BufWrite           *.pl    !chmod +x %
  augroup END
" 

" I use this to soon i edit my ~/.sigs/own-stuff 
autocmd BufRead  ~/.sigs/own-stuff  set tw=80
autocmd BufRead  ~/.sigs/own-stuff  setlocal listchars=tab:»·,trail:*
autocmd BufWrite ~/.sigs/own-stuff  call LastMod()
" 

" Compressed files 
augroup gzip
  au!
   autocmd BufReadPre,FileReadPre     *.gz,*.bz2 set bin
   autocmd BufReadPost,FileReadPost   *.gz call GZIP_read("gunzip")
   autocmd BufReadPost,FileReadPost   *.bz2 call GZIP_read("bunzip2")
   autocmd BufWritePost,FileWritePost *.gz call GZIP_write("gzip")
   autocmd BufWritePost,FileWritePost *.bz2 call GZIP_write("bzip2")
   autocmd FileAppendPre              *.gz call GZIP_appre("gunzip")
   autocmd FileAppendPre              *.bz2 call GZIP_appre("bunzip2")
   autocmd FileAppendPost             *.gz call GZIP_write("gzip")
   autocmd FileAppendPost             *.bz2 call GZIP_write("bzip2")
fun! GZIP_read(cmd)
   let ch_save = &ch
       set ch=2
       execute "'[,']!" . a:cmd
       set nobin
   let &ch = ch_save
       execute ":doautocmd BufReadPost " . expand("%:r")
endfun
fun! GZIP_write(cmd)
     if rename(expand("<afile>"), expand("<afile>:r")) == 0
        execute "!" . a:cmd . " <afile>:r"
     endif
endfun
fun! GZIP_appre(cmd)
     execute "!" . a:cmd . " <afile>"
      call rename(expand("<afile>:r"), expand("<afile>"))
endfun
augroup END

" Remove all bzip2 autocommands
augroup bzip2 
  au!
  autocmd BufReadPre,FileReadPre     *.bz2 set bin
  autocmd BufReadPre,FileReadPre     *.bz2 let ch_save = &ch|set ch=2
  autocmd BufReadPost,FileReadPost   *.bz2 |'[,']!bunzip2
  autocmd BufReadPost,FileReadPost   *.bz2 let &ch = ch_save|unlet ch_save
  autocmd BufReadPost,FileReadPost   *.bz2 execute ":doautocmd BufReadPost " . expand("%:r")
  autocmd BufWritePost,FileWritePost *.bz2 !mv <afile> <afile>:r
  autocmd BufWritePost,FileWritePost *.bz2 !bzip2 <afile>:r
  autocmd FileAppendPre              *.bz2 !bunzip2 <afile>
  autocmd FileAppendPre              *.bz2 !mv <afile>:r <afile>
  autocmd FileAppendPost             *.bz2 !mv <afile> <afile>:r
  autocmd FileAppendPost             *.bz2 !bzip2 -9 --repetitive-best <afile>:r
augroup END
" 

" Shell 
function SHInsert()
  let x = confirm("Which Template?\n"," &Sh \n &Zsh",1,1)
  if x == 1
  silent 0r ~/.vim/templates/template-Sh.sh
  else
  0r ~/.vim/template/template-Sh.sh
  endif
endfunc
augroup sh
  autocmd!
  autocmd BufNewFile,BufRead  *.sh,*.zsh,*.csh,*.ksh  so $VIMRUNTIME/syntax/sh.vim
  autocmd BufNewFile,BufRead  *.sh,*.zsh,*.csh,*.ksh  set tw=0 nowrap ft=sh
"  autocmd BufNewFile          *.sh,*.zsh,*.csh,*.ksh  call SHInsert()
  autocmd BufWrite,FileWritePre *.sh,*.zsh,*.csh,*.ksh  exec("normal ms")|call LastMod()|exec("normal `s")
  autocmd BufWritePre,FileWritePre ~/.xinitrc,~/.zshrc  exec("normal ms")|call LastMod()|exec("normal `s")
  autocmd BufWrite            *.sh,*.zsh,*.ksh  !chmod +x %
  autocmd BufNewFile,BufRead  *.sh,*.zsh,*.csh,*.ksh  set com=sr:#,mb:#,ex:#/ cindent fo+=r
augroup END
" 

" Vim Files  
augroup vim
  autocmd!
  autocmd BufWritePre,FileWritePre *.vim exec("normal ms")|call LastMod()|exec("normal `s")
  autocmd BufNewFile,BufRead *.vim,*.vimrc set tw=180 nowrap ft=vim
  autocmd BufNewFile,BufRead *.vim,*.vimrc set com=sr:\",b:\",mb:* cindent fo+=r
  autocmd BufNewFile,BufRead *.vim,*.vimrc so $VIMRUNTIME/syntax/vim.vim
"  autocmd BufNewFile         *.vim 0r ~/.vim/templates/template.vim
augroup END
" 

" Modeline 
" vim:ft=vim:foldmethod=marker
