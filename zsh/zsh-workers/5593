From zsh-workers-return-5593-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 01 17:24:56 1999
Return-Path: <zsh-workers-return-5593-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 944 invoked from network); 1 Mar 1999 17:24:55 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 1 Mar 1999 17:24:55 -0000
Received: (qmail 29243 invoked by alias); 1 Mar 1999 17:24:30 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5593
Received: (qmail 29235 invoked from network); 1 Mar 1999 17:24:28 -0000
Date: Mon, 1 Mar 1999 18:23:45 +0100 (MET)
Message-Id: <199903011723.SAA16270@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: _path_files again...


There was still a bug with _path_files -W if given a non-empty array
(in fact, this completely stopped working).

Bye
 Sven

diff -u oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Mon Mar  1 15:55:39 1999
+++ Completion/Core/_path_files	Mon Mar  1 18:22:15 1999
@@ -178,26 +178,26 @@
 matchflags=""
 _match_pattern _path_files patstr matchflags
 
+# We almost expect the pattern to have changed `..' into `*.*.', `/.' into
+# `/*.', and probably to contain two or more consecutive `*'s. Since these
+# have special meaning for globbing, we remove them. But before that, we
+# add the pattern for matching any characters before a slash.
+
+patstr="$patstr:gs-/-*/-:gs/*.*.//:gs-/*.-/.-:gs/**/*/"
+
 # First we skip over all pathname components in `str' which really exist in
 # the file-system, so that `/usr/lib/l<TAB>' doesn't offer you `lib' and
 # `lib5'. Pathname components skipped this way are taken from `orig' and added
 # to `donepath'.
 
 while [[ "$orig" = */* ]] do
-  tmp1=($realpath$donepath${orig%%/*}/${~patstr#*/})
+  tmp1=( ${~matchflags}$realpath$donepath${orig%%/*}/${~patstr#*/}$^pats )
   [[ $#tmp1 -gt 0 && -e "$realpath$donepath${orig%%/*}" ]] || break
   donepath="$donepath${orig%%/*}/"
   orig="${orig#*/}"
   patstr="${patstr#*/}"
 done
 
-# We almost expect the pattern to have changed `..' into `*.*.', `/.' into
-# `/*.', and probably to contain two or more consecutive `*'s. Since these
-# have special meaning for globbing, we remove them. But before that, we
-# add the pattern for matching any characters before a slash.
-
-patstr="$patstr:gs-/-*/-:gs/*.*.//:gs-/*.-/.-:gs/**/*/"
-
 # Finally, generate the matches. First we loop over all the paths from `-W'.
 # Note that in this loop `str' is used as a modifyable version of `patstr'
 # and `testpath' is a modifyable version of `donepath'.
@@ -206,6 +206,8 @@
   str="$patstr"
   testpath="$donepath"
   ostr="$orig"
+
+  [[ -z "$prepath" || "$prepath[-1]" = / ]] || prepath="${prepath}/"
 
   # The second loop tests the components of the path in `str' to get the
   # possible matches.

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

