Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Tue, 26 Jan 1999 16:47:39 +0100 (MET)
Message-Id: <199901261547.QAA19696@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Mon, 25 Jan 1999 11:57:20 +0100
Subject: Re: PATCH: suggestion for new condition
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5022


Peter Stephenson wrote:

>
>...
> 
> You can't do this at the moment, but maybe a more flexible way would
> be to create another ${(...)} flag --- looks like t is still usable
> --- and make ${(t)param} print out the type of param, so you can do
> [[ ${(t)param} = (array|association)* ]], and things like that.  It's
> maybe a little more transparent, and the information can be used
> outside conditions.  It's a little more complicated in that you have
> to have a list like "array left unique", or whatever, but if the basic
> type always comes first maybe it's obvious enough.  It could return a
> blank for unset.  Of course [[ ${(t)param} = *export* ]] is less
> efficient than [[ -v param export ]], but I don't think that's a major
> worry.  It should be reasonably easy --- the question is always quite
> how to insert any new code into paramsubst(), it's a bit like deciding
> where to put a needle in a haystack.

The patch below implements the `(t)' flag. `${(t)param}' will expand
to a string describing the type of parameter. When param is unset, it
will expand to `-', otherwise it contains the keywords I used for the
-v condition separated by hyphens (just to avoid any trouble with
spaces).

The patch will conflict with the one for the -v condition only in
`new-completion-examples', but I think you will want to remove that
patch anyway (or haven't applied it).

Bye
 Sven

--- os/subst.c	Tue Jan 26 14:24:14 1999
+++ Src/subst.c	Tue Jan 26 16:06:54 1999
@@ -702,6 +702,7 @@
     int whichlen = 0;
     int chkset = 0;
     int vunset = 0;
+    int wantt = 0;
     int spbreak = isset(SHWORDSPLIT) && !ssub && !qt;
     char *val = NULL, **aval = NULL;
     unsigned int fwidth = 0;
@@ -902,6 +903,10 @@
 		    hvals = SCANPM_WANTVALS;
 		    break;
 
+		case 't':
+		    wantt = 1;
+		    break;
+
 		default:
 		  flagerr:
 		    zerr("error in flags", NULL, 0);
@@ -978,9 +983,47 @@
 	*s = sav;
 	v = (Value) NULL;
     } else {
-	if (!(v = fetchvalue(&s, (unset(KSHARRAYS) || inbrace) ? 1 : -1,
+	if (!(v = fetchvalue(&s, (wantt ? -1 :
+				  ((unset(KSHARRAYS) || inbrace) ? 1 : -1)),
 			     hkeys|hvals)))
 	    vunset = 1;
+
+	if (wantt) {
+	    if (v) {
+		int f = v->pm->flags;
+
+		switch (PM_TYPE(f)) {
+		case PM_SCALAR:  val = "scalar"; break;
+		case PM_ARRAY:   val = "array"; break;
+		case PM_INTEGER: val = "integer"; break;
+		case PM_HASHED:  val = "association"; break;
+		}
+		val = dupstring(val);
+		if (f & PM_LEFT)
+		    val = dyncat(val, "-left");
+		if (f & PM_RIGHT_B)
+		    val = dyncat(val, "-right_blanks");
+		if (f & PM_RIGHT_Z)
+		    val = dyncat(val, "-right_zeros");
+		if (f & PM_LOWER)
+		    val = dyncat(val, "-lower");
+		if (f & PM_UPPER)
+		    val = dyncat(val, "-upper");
+		if (f & PM_READONLY)
+		    val = dyncat(val, "-readonly");
+		if (f & PM_TAGGED)
+		    val = dyncat(val, "-tag");
+		if (f & PM_EXPORTED)
+		    val = dyncat(val, "-export");
+		if (f & PM_UNIQUE)
+		    val = dyncat(val, "-unique");
+	    } else
+		val = dupstring("-");
+
+	    v = NULL;
+	    vunset = 0;
+	    isarr = 0;
+	}
     }
     while (v || ((inbrace || (unset(KSHARRAYS) && vunset)) && isbrack(*s))) {
 	if (!v) {
--- od/Zsh/expn.yo	Mon Jan 25 14:36:26 1999
+++ Doc/Zsh/expn.yo	Tue Jan 26 16:30:36 1999
@@ -602,6 +602,46 @@
 Split the result of the expansion to lines. This is a shorthand
 for `tt(ps:\n:)'.
 )
+item(tt(t))(
+Don't work on the value of the parameter, but on a string describing
+the type of the parameter. This string consists of keywords separated
+by hyphens (`tt(-)'). The first keyword in the string describes the
+main type, it can be one of `tt(scalar)', `tt(array)', `tt(integer)',
+or `tt(association)'. The other keywords describe the type in more
+detail:
+
+startitem()
+item(`tt(left)')(
+for left justified parameters
+)
+item(`tt(right_blanks)')(
+for right justified parameters with leading blanks
+)
+item(`tt(right_zeros)')(
+for right justified parameters with leading zeros
+)
+item(`tt(lower)')(
+for parameters whose value is converted to all lower case when it is
+expanded
+)
+item(`tt(upper)')(
+for parameters whose value is converted to all upper case when it is
+expanded
+)
+item(`tt(readonly)')(
+for readonly parameters
+)
+item(`tt(tag)')(
+for tagged parameters
+)
+item(`tt(export)')(
+for exported parameters
+)
+item(`tt(unique)')(
+for arrays which keep only the first occurrence of duplicated values
+)
+enditem()
+)
 enditem()
 
 The following flags are meaningful with the tt(${)...tt(#)...tt(}),
--- om/new-completion-examples	Tue Jan 26 15:16:53 1999
+++ Misc/new-completion-examples	Tue Jan 26 16:41:13 1999
@@ -43,7 +43,7 @@
     shift
     autoload "$1"
   fi
-  if [[ ${+patcomps} == 1 ]] then
+  if (( $+patcomps )) then
     patcomps=("$patcomps[@]" "$2 $1" )
   else
     patcomps=( "$2 $1" )
@@ -78,10 +78,10 @@
   local var
 
   eval var\=\$\{\+$1\}
-  if [[ "$var" == 0 ]] then
-    "$@"
-  else
+  if (( var )); then
     eval complist \$\{${1}\[\@\]\}
+  else
+    "$@"
   fi
 }
 
@@ -323,8 +323,11 @@
 
 defcomp __subscr --subscr--
 __subscr() {
+  local t
+
+  eval t\=\$\{\(t\)$COMMAND\}
   compalso --math-- "$@"
-  # ...probably other stuff
+  [[ $t = assoc* ]] && eval complist -k \"\(\$\{\(k\)$COMMAND\}\)\"
 }
 
 # Do sub-completion for pre-command modifiers.
@@ -368,9 +371,6 @@
 defcomp __bjobs bg
 __bjobs=(-z -P '%')
 
-defcomp wait
-__wait=(-j -P '%' + -s '`ps -x | tail +2 | cut -c1-5`')
-
 defcomp __arrays shift
 __arrays=(-A)
 
@@ -536,6 +536,12 @@
     complist -P '%' -j
     complist -y killfunc -s '`ps -x 2>/dev/null | tail +2 | cut -c1-5`'
   fi
+}
+
+defcomp wait
+__wait() {
+  complist -P '%' -j
+  complist -y killfunc -s '`ps -x 2>/dev/null | tail +2 | cut -c1-5`'
 }
 
 defcomp cd

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

