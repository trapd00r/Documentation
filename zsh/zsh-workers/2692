From zsh-workers-request@euclid.skiles.gatech.edu Wed Jan 01 20:15:52 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 11934 invoked from network); 1 Jan 1997 20:15:48 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 1 Jan 1997 20:15:48 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id PAA18217; Wed, 1 Jan 1997 15:19:47 -0500 (EST)
Resent-Date: Wed, 1 Jan 1997 15:19:47 -0500 (EST)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199701012013.VAA02305@hzoli.ppp.cs.elte.hu>
Subject: Remove option union initialisation hack
To: zsh-workers@math.gatech.edu (Zsh hacking and development)
Date: Wed, 1 Jan 1997 21:13:08 +0100 (MET)
X-Mailer: ELM [version 2.4ME+ PL17 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"62e7B1.0.XS4.YRioo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2692
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

This patch removes the union from struct optname.  It uses int optno.  Note
that because of allignment short here would not save memory.  The patch
also changes option aliases to use optno instead of the option string.
This should be applied to zsh-3.1.1-test1.

There are still some assumptions about the machines in the code.  It is
assumed that int is at least 32 bit wide (that's not really a big
assumption), and dupstruct and freestruct assumes that sizeof(void*) is a
multiple of sizeof(int), and if sizeof(void*) > sizeof(int) and a void*
element comes after an int in a struct, the pointer is alligned to
sizeof(void*). I.e. when sizeof(int) == 4 and sizeof(void*) == 8 then
struct { int i; void *p; } and struct { int i,j; void *p; } has the same
size.  That's at least true on Alpha.

Zoltan


*** Src/options.c	1996/12/30 21:09:35	3.1.1.7
--- Src/options.c	1997/01/01 19:49:44
***************
*** 39,48 ****
      HashNode next;		/* next in hash chain */
      char *nam;			/* hash data */
      int flags;
!     union {
! 	char *text;		/* alias text if OPT_ALIAS */
! 	long optno;		/* option number */
!     } u;
  };
  
  HashTable optiontab;
--- 39,45 ----
      HashNode next;		/* next in hash chain */
      char *nam;			/* hash data */
      int flags;
!     int optno;			/* option number */
  };
  
  HashTable optiontab;
***************
*** 66,77 ****
  
  #define defset(X) (!!((X)->flags & emulation))
  
! static struct {
!     HashNode next;
!     char *nam;
!     int flags;
!     long optno;
! } optns[] = {
  {NULL, "allexport",	      0,			 ALLEXPORT},
  {NULL, "alwayslastprompt",    OPT_ALL,			 ALWAYSLASTPROMPT},
  {NULL, "alwaystoend",	      0,			 ALWAYSTOEND},
--- 63,69 ----
  
  #define defset(X) (!!((X)->flags & emulation))
  
! static struct optname optns[] = {
  {NULL, "allexport",	      0,			 ALLEXPORT},
  {NULL, "alwayslastprompt",    OPT_ALL,			 ALWAYSLASTPROMPT},
  {NULL, "alwaystoend",	      0,			 ALWAYSTOEND},
***************
*** 176,194 ****
  {NULL, "verbose",	      0,			 VERBOSE},
  {NULL, "xtrace",	      0,			 XTRACE},
  {NULL, "zle",		      OPT_SPECIAL,		 USEZLE},
! {NULL, NULL, 0, 0}
! };
! static struct {
!     HashNode next;
!     char *nam;
!     int flags;
!     char *text;
! } optals[] = {
! /* ksh compatibility option aliases */
! {NULL, "braceexpand",	OPT_ALIAS, "noignorebraces"},
! {NULL, "physical",	OPT_ALIAS, "chaselinks"},
! {NULL, "stdin",		OPT_ALIAS, "shinstdin"},
! {NULL, "trackall",	OPT_ALIAS, "hashcmds"},
  {NULL, NULL, 0, 0}
  };
  
--- 168,177 ----
  {NULL, "verbose",	      0,			 VERBOSE},
  {NULL, "xtrace",	      0,			 XTRACE},
  {NULL, "zle",		      OPT_SPECIAL,		 USEZLE},
! {NULL, "braceexpand",	      OPT_ALIAS,		 -IGNOREBRACES},
! {NULL, "physical",	      OPT_ALIAS,		 CHASELINKS},
! {NULL, "stdin",		      OPT_ALIAS,		 SHINSTDIN},
! {NULL, "trackall",	      OPT_ALIAS,		 HASHCMDS},
  {NULL, NULL, 0, 0}
  };
  
***************
*** 377,385 ****
      optiontab->freenode    = NULL;
      optiontab->printnode   = printoptionnode;
  
!     for (on = (Optname) optns; on->nam; on++)
! 	optiontab->addnode(optiontab, on->nam, on);
!     for (on = (Optname) optals; on->nam; on++)
  	optiontab->addnode(optiontab, on->nam, on);
  }
  
--- 360,366 ----
      optiontab->freenode    = NULL;
      optiontab->printnode   = printoptionnode;
  
!     for (on = optns; on->nam; on++)
  	optiontab->addnode(optiontab, on->nam, on);
  }
  
***************
*** 387,402 ****
  printoptionnode(HashNode hn, int set)
  {
      Optname on = (Optname) hn;
  
!     if (on->flags & OPT_ALIAS)
! 	printf("%s is an alias to %s\n", on->nam, on->u.text);
!     else if (isset(KSHOPTIONPRINT)) {
  	if (defset(on))
! 	    printf("no%-20s%s\n", on->nam, isset(on->u.optno) ? "off" : "on");
  	else
! 	    printf("%-22s%s\n", on->nam, isset(on->u.optno) ? "on" : "off");
!     } else if (set == (isset(on->u.optno) ^ defset(on))) {
! 	if (set ^ isset(on->u.optno))
  	    fputs("no", stdout);
  	puts(on->nam);
      }
--- 368,384 ----
  printoptionnode(HashNode hn, int set)
  {
      Optname on = (Optname) hn;
+     int optno = on->optno;
  
!     if (optno < 0)
! 	optno = -optno;
!     if (isset(KSHOPTIONPRINT)) {
  	if (defset(on))
! 	    printf("no%-20s%s\n", on->nam, isset(optno) ? "off" : "on");
  	else
! 	    printf("%-22s%s\n", on->nam, isset(optno) ? "on" : "off");
!     } else if (set == (isset(optno) ^ defset(on))) {
! 	if (set ^ isset(optno))
  	    fputs("no", stdout);
  	puts(on->nam);
      }
***************
*** 435,441 ****
      if (!(on->flags & OPT_ALIAS) &&
  	((fully && !(on->flags & OPT_SPECIAL)) ||
  	 (on->flags & OPT_EMULATE)))
! 	opts[on->u.optno] = defset(on);
  }
  
  /* setopt, unsetopt */
--- 417,423 ----
      if (!(on->flags & OPT_ALIAS) &&
  	((fully && !(on->flags & OPT_SPECIAL)) ||
  	 (on->flags & OPT_EMULATE)))
! 	opts[on->optno] = defset(on);
  }
  
  /* setopt, unsetopt */
***************
*** 524,533 ****
  static void
  setoption(HashNode hn, int value)
  {
!     Optname on = (Optname) hn;
! 
!     dosetopt(on->flags & OPT_ALIAS ? optlookup(on->u.text) : on->u.optno,
! 	     value, 0);
  }
  
  /* Identify an option name */
--- 506,512 ----
  static void
  setoption(HashNode hn, int value)
  {
!     dosetopt(((Optname) hn)->optno, value, 0);
  }
  
  /* Identify an option name */
***************
*** 553,563 ****
      /* look up name in the table */
      if (s[0] == 'n' && s[1] == 'o' &&
  	(n = (Optname) optiontab->getnode(optiontab, s + 2))) {
! 	return n->flags & OPT_ALIAS ? -optlookup(n->u.text) : -n->u.optno;
      } else if ((n = (Optname) optiontab->getnode(optiontab, s)))
! 	return n->flags & OPT_ALIAS ? optlookup(n->u.text) : n->u.optno;
      else
! 	return 0;
  }
  
  /* Identify an option letter */
--- 532,542 ----
      /* look up name in the table */
      if (s[0] == 'n' && s[1] == 'o' &&
  	(n = (Optname) optiontab->getnode(optiontab, s + 2))) {
! 	return -n->optno;
      } else if ((n = (Optname) optiontab->getnode(optiontab, s)))
! 	return n->optno;
      else
! 	return OPT_INVALID;
  }
  
  /* Identify an option letter */

