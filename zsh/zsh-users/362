From zsh-workers-request@euclid.skiles.gatech.edu  Mon Aug 19 06:00:31 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.5/8.7.3) with ESMTP id GAA02540 for <mason@primenet.com.au>; Mon, 19 Aug 1996 06:00:28 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id QAA11067; Sun, 18 Aug 1996 16:01:42 -0400 (EDT)
Resent-Date: Sun, 18 Aug 1996 16:00:47 -0400 (EDT)
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <960818130128.ZM23990@candle.brasslantern.com>
Date: Sun, 18 Aug 1996 13:01:28 -0700
In-Reply-To: "Timothy J. Luoma" <luomat@nerc.com>
        "zsh 3.0 still intolerably slow on NeXTStep 3.2" (Aug 16,  2:44am)
References: <199608160644.CAA19311@nerc.com>
Reply-To: schaefer@nbn.com
X-Mailer: Z-Mail (4.0b.729 29jul96)
To: luomat@nerc.com, zsh-users@math.gatech.edu
Subject: Re: zsh 3.0 still intolerably slow on NeXTStep 3.2
Cc: comp-sys-next-software@antigone.com
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"3ebmK1.0.Fi2.kPt5o"@euclid>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/362
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Aug 16,  2:44am, Timothy J. Luoma wrote:
} Subject: zsh 3.0 still intolerably slow on NeXTStep 3.2
}
} The drawing of the prompt (right and left) is still terribly slow,  
} and if I go into a long command (ie a find command) and type, I can  
} see the cursor jump to the beginning of the line and then back  
} again.
} 
} Anyone have any clues what could be causing this?

Does it make any difference whether your prompt is on the last line of
the terminal?

Does it make any difference if you `unset RPROMPT RPS1`?

There are only two new hunks of refresh() in zle_refresh.c that I can see
making any difference here.  First:

    for (;;) {
+	if (*nl && nl[1] == ol[1])	/* skip only if second chars match */
	/* skip past all matching characters */
	    for (; *nl && (*nl == *ol); nl++, ol++, ccs++) ;

This seems to assume that when ol="ab..." and nl="ac..." that it's faster
to go ahead and insert the string "ac" rather than move one character to
the right and then insert "c".  This is not necessarily an optimization
if the cursor is already positioned at or to the right of the "a" position,
is it, Geoff?  Especially if "move to column x" is implemented as "move to
column 0 and then move right x columns" by the terminal?

Tim, try deleting that line from refresh() and see what happens.

Second:

+		    /* if we've pushed off the right, truncate oldline */
+			for (j = ccs - i, p1 = ol; *p1 && j + char_ins < winw;
+			     p1++, j++);
+			if (j + char_ins == winw)
+			    *p1 = '\0';
+			p1 = ol;

Am I confused, or will this always cause the remainder of nl (anything off
the right side of the current screen line?) to be reprinted (on the next
cycle around the refresh() loop) followed by a clear-to-end-of-line, even
if it hasn't changed?

I think its safe to delete that chunk as well, if deleting the first one
doesn't make any difference; but I can't guarantee it.

-- 
Bart Schaefer                             Brass Lantern Enterprises
http://www.well.com/user/barts            http://www.nbn.com/people/lantern

New male in /home/schaefer:
>N  2 Justin William Schaefer  Sat May 11 03:43  53/4040  "Happy Birthday"

