From zsh-users-return-2524-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Aug 26 16:25:55 1999
Return-Path: <zsh-users-return-2524-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3281 invoked from network); 26 Aug 1999 16:25:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Aug 1999 16:25:53 -0000
Received: (qmail 7574 invoked by alias); 26 Aug 1999 16:25:29 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 2524
Received: (qmail 7566 invoked from network); 26 Aug 1999 16:25:29 -0000
Date: Thu, 26 Aug 1999 12:24:56 -0400
From: Sweth Chandramouli <sweth@gwu.edu>
To: zsh-users@sunsite.auc.dk
Subject: Re: listing all executables matching 'foo'
Message-ID: <19990826122456.A7914@cj952583-b.alex1.va.home.com>
Mail-Followup-To: zsh-users@sunsite.auc.dk
References: <19990823152219.I32224@hp.com> <19990823233551.B31064@drizzt.ihug.com.au> <19990823160716.M32224@hp.com> <19990823110321.A1724@cj952583-b.alex1.va.home.com> <19990825154631.C2803@ritz.math.fu-berlin.de>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailer: Mutt 0.95i
In-Reply-To: <19990825154631.C2803@ritz.math.fu-berlin.de>
Sender: sweth@cj952583-b.alex1.va.home.com

On Wed, Aug 25, 1999 at 03:46:32PM +0200, Sven Guckes wrote:
> _listall () {
>    if [[ $# = 0 ]]
>    then
>      echo "Usage:    $0 program"
>      echo "Example:  $0 zsh"
>      echo "Lists all occurrences of program in the current PATH."
>    else
>      for program in `which -a $1`
>      do
>        ls -lL $program
>      done
>    fi
> }
> 
> Comments?
	i've got a similar function i use called lall.  it figures out
whether each command returned by whence -a is an executable, an
alias, a function, or a builtin, and then returns more info based
on that decision--an ls for executables, a whence -f for functions,
or an ls of the core command of the expanded alias for aliases.
it's actually pretty cool, if i do say so myself:

(cj952583-b)~: lall ll
ll is an alias for ls -lF:
   ls is /bin/ls:
      -r-xr-xr-x   1 bin      bin        18120 Oct  6  1998 /bin/ls
   ls is /usr/bin/ls:
      -r-xr-xr-x   1 bin      bin        18120 Oct  6  1998 /usr/bin/ls
   ls is /usr/xpg4/bin/ls:
      -r-xr-xr-x   1 bin      bin        18128 Sep  1  1998 /usr/xpg4/bin/ls
   ls is /usr/ucb/ls:
      -rwxr-xr-x   1 bin      bin        13776 Sep  1  1998 /usr/ucb/ls
(cj952583-b)~: lall cd
cd is a shell builtin
cd is /bin/cd:
   -r-xr-xr-x  17 bin      bin          131 Oct  6  1998 /bin/cd
cd is /usr/bin/cd:
   -r-xr-xr-x  17 bin      bin          131 Oct  6  1998 /usr/bin/cd
(cj952583-b)~: lall xbuffy
xbuffy is a shell function:
   undefined xbuffy () { }
xbuffy is /usr/local/bin/xbuffy:
   lrwxrwxrwx   1 root     other         22 Jul 21 16:18 /usr/local/bin/xbuffy
-> /opt/xbuffy/bin/xbuffy
(cj952583-b)~: lall chunk
chunk is a shell function:
   chunk () {
        local LENGTH=$(( ${LINES:-20}/2-2 ))
        local START=${LENGTH}
        if [[ ${1#-} != ${1} ]]
        then
                START=${(R)1#-}
                shift
        fi
        tail -${START} ${@} | head -${LENGTH}
   }
(cj952583-b)~: cat .zfunc/lall
#!/usr/local/bin/zsh -f

# lall -- function to List ALL commands that might be run given the
# current environment, and give info about them if possible.

lall () {

   # extremely verbose whence; lall is just a wrapper to iterate it across
   # the positional params.
   v_whence () {
      for CMD in ${(f)"$(builtin whence -av ${1})"} ; do 

         # this matches any executables found and does an ls on them.
         # the (|.) is the zsh version of ?(.), it seems; i use it to
         # match things in the current directory, too, since i am one of
         # those unsecure folks with CWD (.) at the end of my path.
         if [[ ${CMD%%(|.)/*} != ${CMD} ]] ; then
            builtin echo "${CMD}:"
            builtin echo "   $(ls -l ${(M)CMD%%(|.)/*})"

         # this matches functions and gives their expansion.
         elif [[ ${CMD%%function} != ${CMD} ]] ; then
            builtin echo "${CMD}:"
            # using sed would be much cleaner, but i like zsh-only functions.
            # would that ls were a builtin...
            for LINE in ${(f)"$(builtin whence -f ${1})"} ; do
               builtin echo "   ${LINE}"
            done

         # okay, so this is a bit excessive.  if it's an alias, we actually
         # say so and then start over by running v_whence on the first 
         # token of the expanded alias.  (some days i scare myself.)
         elif [[ ${CMD##*alias for } != ${CMD} ]] ; then
            builtin echo "${CMD}:"
            for LINE in ${(f)"$(v_whence ${${CMD##*alias for }%% *})"} ; do
               builtin echo "   ${LINE}"
            done

         # if it still isn't matched, it's a shell builtin.
         else
            builtin echo "${CMD}"
         fi
      done
   }
   
   for WORD in "${@}" ; do
      v_whence ${WORD}
   done
}

	other than the hideous "for LINE in ..." kludge, of which i've grown
unreasonably fond, any suggestions for improvement?  i thought about doing a
whence -avf initially to obviate the need for it later if a function was
matched, but the formatting became much more convoluted then, so i gave up
on it.  i've also thought about making it accept a -v flag, to make it
even more verbose--maybe run file on the executables as well, or something
like that.

	-- sweth.

-- 
Sweth Chandramouli ; <sweth@gwu.edu>
<a href="http://astaroth.nit.gwu.edu/resume/">Will Work For Food.</a>
<a href="http://astaroth.nit.gwu.edu/~sweth/disc.html">*</a>

