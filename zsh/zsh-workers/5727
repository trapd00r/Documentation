From zsh-workers-return-5727-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 10 09:47:32 1999
Return-Path: <zsh-workers-return-5727-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1188 invoked from network); 10 Mar 1999 09:47:26 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Mar 1999 09:47:26 -0000
Received: (qmail 27586 invoked by alias); 10 Mar 1999 09:47:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5727
Received: (qmail 27571 invoked from network); 10 Mar 1999 09:47:02 -0000
Date: Wed, 10 Mar 1999 10:44:29 +0100 (MET)
Message-Id: <199903100944.KAA16241@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Tue, 9 Mar 1999 19:28:05 +0300
Subject: Re: _path_files and completeinword


Andrej Borsenkow wrote:

> cp /t/s/z/D/zi
>              ^ cursor here (before `i')
> bor@itsrm2:~> cp /tools/src/zsh-3.1.5-pws-11/Doc/z<== cursor here; no `i'
> If I _now_ add `i' and do the same - I get zsh.texi

`_path_files' does the matching itself -- and sometimes things get too 
hard for it.
To allow `-g ...' patterns, it has to append these patterns to the
string from the line and then use that to generate filenames. Now you
might say that with `-f', no pattern is really needed. If you change:

  f)     sopt="${sopt}f"
         pats=("$pats[@]" '*')
	 ;;

to

  f)     sopt="${sopt}f"
         pats=("$pats[@]" '')
	 ;;

and

  if [[ -z "$gopt" ]]; then
    sopt='-f'
    pats=('*')

to

  if [[ -z "$gopt" ]]; then
    sopt='-f'
    pats=('')

you get what you expected. The same could be done for `-/' (this is
left as an exercise to the reader). I don't want to produce a patch
for this, though, because if we change it, the behavior will differ
from the behavior you get with things like `-g "*.(tex|TEX)"'. Here
the `*' in the pattern makes in-word completion fail in the way you
described.
Maybe this is another entry to the list of things I suggested the
`compstyle' parameter for.

> (I'm comparing to ways of life - how can I replace globcomplete. Is it
> possible to have the second binding with explcit globcomplete set? Sven, I
> think, it belongs to compstate as well. In this way I could have the second
> bindings that sets compstate[glob] and calls standard completion.

I'm not fully sure that I understand what you mean here. If you would
like to know if it possible to get a second key binding using the
completion code, but with `globcomplete'-behavior turned on, this is
simple:

- First solution: add a function

    _glob_complete() {
      compstate[pattern_match]=yes
      _main_complete
    }

  add a widget for it and bind that to a key. (Hey, you could get all
  this automatically by adding a file `_glob_complete' with the first
  line `#defkeycomp complete-word \C-xg' and the body above.)

- Second solution: modify your `_main_complete' by adding something
  like

    [[ $WIDGET = glob_complete ]] && compstate[pattern_match]=yes

  at the top. Then define a widget

    zle -C glob_complete complete-word _main_complete

  and that should do the job, too.

> Actually,
> I think, _all_ options that modify completion belong to compstate. The quick
> workaround is to save globcomplete, and reset it before exit, sure).

That's part of the things we are working on. I once had the idea to
make `compstate' get keys with the names of the options, but then
decided against it because some of them have multiple effects and I
wanted to do this in a cleaner way. Setting/resetting options in
cmpletion widgets, btw, will only seldom have an effect on the post-
processing, exactly for the reason, that this is now controlled by
`compstate'.


Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

