From zsh-workers-return-8335-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Oct 19 19:29:15 1999
Return-Path: <zsh-workers-return-8335-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14761 invoked from network); 19 Oct 1999 19:29:13 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 19 Oct 1999 19:29:13 -0000
Received: (qmail 17043 invoked by alias); 19 Oct 1999 19:27:28 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8335
Received: (qmail 16965 invoked from network); 19 Oct 1999 19:25:25 -0000
Message-ID: <380CC25A.BC019EC7@u.genie.co.uk>
Date: Tue, 19 Oct 1999 20:11:22 +0100
From: Oliver Kiddle <opk@u.genie.co.uk>
X-Mailer: Mozilla 4.7 [en] (Win95; I)
X-Accept-Language: en
MIME-Version: 1.0
To: Zsh workers <zsh-workers@sunsite.auc.dk>
Subject: PATCH: New prompt themes
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

I've just had a look at the new prompt theme stuff. It seems to be a
very neat system for quickly switching between different prompts.

I came across one problem when writing my own prompt setup scripts.
Basically, the prompt_subst option is disabled in my setup but was
required by a prompt which I wanted to create. I know I could just
change my own setup but I think that the system should be independant
of people's options. The trouble is that the prompt function uses
emulate -L so I can't set options in my prompt setup function. The
following patch is a possible solution. It uses an associative array to
return the prompt options to a wrapper function which sets them. For
example, you can do:
prompt_opts=( subst set percent set bang unset )

The sickly colours of some of the example prompts also made me wonder
whether we should maybe separate the colour control from the prompt
content. One method would be to use an associative array which would
map a name for the content style onto the colour attributes. At a basic
level, there would be a content style corresponding to the prompt, line
editor and command output. Other ones could be used for components to
prompts - hostname, clock, current directory etc. If the different
prompt themes used the same content style names then colour schemes
could be selected independant of the prompt style.

Incidentally, I also think that Misc/colors should use associative
arrays - it would be useful to be able to do $fg[$color]. I'm not even
sure how to do this at the moment.

I've also added to the patch my main prompt (not the one which needs
prompt_subst) which you may want to add to the examples. I mainly
included it because I was wondering if anyone knows a better way to
match the hostnames to the array. I have an array ($normal_hosts)
listing hosts for which I don't want to include the hostname in the
prompt. It'd be nice if this array could be treated as a list of
patterns to be matched instead of fixed strings.

Oliver Kiddle

--- Functions/Prompts/promptinit.bak	Tue Oct 19 16:24:29 1999
+++ Functions/Prompts/promptinit	Tue Oct 19 17:38:30 1999
@@ -36,10 +36,14 @@
 }
 
 prompt () {
-  emulate -L zsh
-  local opt preview theme usage old_theme
+  local -A prompt_opts
+  local opt
 
-  usage='Usage: prompt <options>
+  set_prompt() {
+    emulate -L zsh
+    local opt preview theme usage old_theme
+
+    usage='Usage: prompt <options>
 Options:
     -l              List currently available prompt themes
     -p [<themes>]   Preview given themes (defaults to all)
@@ -47,63 +51,81 @@
     -s <theme>      Set and save theme
     <theme>         Switch to new theme immediately (changes not saved)'
 
-  getopts "hlps" opt
-  case "$opt" in
-    h) if [[ -n "$2" && -n $prompt_themes[(r)$2] ]]; then
-         if functions prompt_$2_help >/dev/null; then
-	   print "Help for $2 theme:\n"
-           prompt_$2_help
-         else
-           print "No help available for $2 theme"
-         fi
-       else
-         print "$usage"
-       fi
-       ;;
-    l) print Currently available prompt themes:
-       print $prompt_themes
-       return
-       ;;
-    p) if (( ! $+prompt_theme )); then
-         print "Cannot preview; current prompt is non-themeable and would"
-	 print "be destroyed."
-	 return
-       fi
-       preview=( $prompt_themes )
-       [[ -n "$2" && -n $prompt_themes[(r)$2] ]] && preview=( $*[2,-1] )
-       for theme in $preview; do
-         [[ $theme == $prompt_theme[1] ]] && continue
-         print "\nTheme: $theme"
-         prompt_${theme}_setup
-	 precmd
-	 print -n -P "${PS1}"
-	 preexec
-	 print "command arg1 arg2 ... argn"
-       done
-       print
-       prompt_${prompt_theme}_setup
-       ;;
-    s) print "Set and save not yet implemented.  Please ensure your ~/.zshrc"
-       print "contains something similar to the following:\n"
-       print "  autoload -U promptinit"
-       print "  promptinit"
-       print "  prompt $*[2,-1]"
-       ;;
-    *) if [[ -z "$1" || -z $prompt_themes[(r)$1] ]]; then
-         print "$usage"
-         return
-       fi
-       prompt_$1_setup $*[2,-1]
-       prompt_theme=( $* )
-
-       # Avoid screwing up the environment listing
-       PSZZZZ=$reset_color
-       RPSZZZZ=$reset_color
-       PROMPTZZZZ=$reset_color
-       RPROMPTZZZZ=$reset_color
-       promptzzzz=$reset_color
-       ;;
-  esac
+    getopts "hlps" opt
+    case "$opt" in
+      h)
+        if [[ -n "$2" && -n $prompt_themes[(r)$2] ]]; then
+          if functions prompt_$2_help >/dev/null; then
+	    print "Help for $2 theme:\n"
+            prompt_$2_help
+          else
+            print "No help available for $2 theme"
+          fi
+	else
+          print "$usage"
+	fi
+      ;;
+      l)
+        print Currently available prompt themes:
+	print $prompt_themes
+	return
+      ;;
+      p)
+        if (( ! $+prompt_theme )); then
+          print "Cannot preview; current prompt is non-themeable and would"
+	  print "be destroyed."
+	  return
+	fi
+	preview=( $prompt_themes )
+	[[ -n "$2" && -n $prompt_themes[(r)$2] ]] && preview=( $*[2,-1] )
+	for theme in $preview; do
+          [[ $theme == $prompt_theme[1] ]] && continue
+          print "\nTheme: $theme"
+          prompt_${theme}_setup
+	  precmd
+	  print -n -P "${PS1}"
+	  preexec
+	  print "command arg1 arg2 ... argn"
+	done
+	print
+	prompt_${prompt_theme}_setup
+      ;;
+      s)
+        print "Set and save not yet implemented.  Please ensure your ~/.zshrc"
+	print "contains something similar to the following:\n"
+	print "  autoload -U promptinit"
+	print "  promptinit"
+	print "  prompt $*[2,-1]"
+      ;;
+      *)
+        if [[ -z "$1" || -z $prompt_themes[(r)$1] ]]; then
+          print "$usage"
+          return
+	fi
+	prompt_$1_setup $*[2,-1]
+	prompt_theme=( $* )
+
+	# Avoid screwing up the environment listing
+	PSZZZZ=$reset_color
+	RPSZZZZ=$reset_color
+	PROMPTZZZZ=$reset_color
+	RPROMPTZZZZ=$reset_color
+	promptzzzz=$reset_color
+      ;;
+    esac
+  }
+
+  set_prompt "$@"
+
+  # Set prompt options
+  for opt in ${(k)prompt_opts}; do
+    if [[ $prompt_opts[$opt] != (|un)set ]]; then
+      echo "${0##*/}: value of prompt option must be 'set' or 'unset'" >&2
+      return 1
+    else
+      $prompt_opts[$opt]opt prompt$opt
+    fi
+  done
 }
 
 promptinit "$@"
--- /dev/null	Tue Oct 19 04:01:01 1999
+++ Functions/Prompts/prompt_oliver_setup	Tue Oct 19 19:20:32 1999
@@ -0,0 +1,35 @@
+# oliver prompt theme
+
+prompt_oliver_help() {
+  cat - <<ENDHELP
+With this prompt theme, the prompt contains the current directory,
+history number and the previous command\'s exit code (if non-zero)
+and a final character which depends on priviledges.
+
+The colour of the prompt depends on two associative arrays -
+\$pcolour and $\tcolour. Each array is indexed by the name of the
+local host. Alternatively, the colour can be set with parameters
+to prompt.
+
+The hostname and username are also included unless they are in the
+\$normal_hosts or \$normal_users array.
+ENDHELP
+}
+
+prompt_oliver_setup() {
+  prompt_opts=( percent set )
+  
+  local pcol=$'\e['${1:-${pcolour[${HOST:=`hostname`}]:-33}}m
+  local tcol=$'\e['${2:-${tcolour[$HOST]:-37}}m
+  local a host="%M:" user="%n "
+  for a in $normal_hosts; do
+    [[ $HOST == $a ]] && host=""
+  done
+  for a in root $normal_users; do
+    [[ ${USER:-`whoami`} == $a ]] && user=""
+  done
+
+  PS1="%{$pcol%}$user$host%~ [%h%0(?..:%?)]%# %{$tcol%}"
+}
+
+prompt_oliver_setup "$@"

