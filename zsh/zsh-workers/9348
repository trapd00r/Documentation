From zsh-workers-return-9348-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jan 18 12:00:58 2000
Return-Path: <zsh-workers-return-9348-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1684 invoked from network); 18 Jan 2000 12:00:56 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Jan 2000 12:00:56 -0000
Received: (qmail 6424 invoked by alias); 18 Jan 2000 12:00:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9348
Received: (qmail 6417 invoked from network); 18 Jan 2000 12:00:41 -0000
Date: Tue, 18 Jan 2000 13:00:39 +0100 (MET)
Message-Id: <200001181200.NAA30972@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: regex stuff in zutil


I started this because I got some warnings because of the return value 
of duparray(). The it got a bit out-of-hand... but these are only
cosmetic changes, indentation and this kind of stuff.

Tanaka: have you seen that there is now a pattryrefs() which allows
one to get at the brace positions without having to fiddle with
$mbegin, etc.?

Bye
 Sven

diff -ru ../z.old/Src/Modules/zutil.c Src/Modules/zutil.c
--- ../z.old/Src/Modules/zutil.c	Tue Jan 18 12:37:21 2000
+++ Src/Modules/zutil.c	Tue Jan 18 12:56:03 2000
@@ -752,17 +752,20 @@
 connectstates(LinkList out, LinkList in)
 {
     LinkNode outnode, innode, ln;
-    for(outnode = firstnode(out); outnode; outnode = nextnode(outnode)) {
+
+    for (outnode = firstnode(out); outnode; outnode = nextnode(outnode)) {
 	RParseBranch *outbranch = getdata(outnode);
-	for(innode = firstnode(in); innode; innode = nextnode(innode)) {
+
+	for (innode = firstnode(in); innode; innode = nextnode(innode)) {
 	    RParseBranch *inbranch = getdata(innode);
 	    RParseBranch *br = ncalloc(sizeof(*br));
+
 	    br->state = inbranch->state;
 	    br->actions = newlinklist();
-	    for(ln = firstnode(outbranch->actions); ln; ln = nextnode(ln))
-	      addlinknode(br->actions, getdata(ln));
-	    for(ln = firstnode(inbranch->actions); ln; ln = nextnode(ln))
-	      addlinknode(br->actions, getdata(ln));
+	    for (ln = firstnode(outbranch->actions); ln; ln = nextnode(ln))
+		addlinknode(br->actions, getdata(ln));
+	    for (ln = firstnode(inbranch->actions); ln; ln = nextnode(ln))
+		addlinknode(br->actions, getdata(ln));
 	    addlinknode(outbranch->state->branches, br);
 	}
     }
@@ -774,42 +777,41 @@
     int l;
     char *s = *rparseargs;
 
-    if(!s)
+    if (!s)
         return 1;
 
-    switch(s[0]) {
+    switch (s[0]) {
     case '/': {
 	RParseState *st;
 	RParseBranch *br;
 	char *pattern, *lookahead;
 	int patternlen, lookaheadlen;
+
 	l = strlen(s);
-	if(!((2 <= l && s[l - 1] == '/') ||
-	     (3 <= l && s[l - 2] == '/' && (s[l - 1] == '+' ||
-					    s[l - 1] == '-'))))
+	if (!((2 <= l && s[l - 1] == '/') ||
+	      (3 <= l && s[l - 2] == '/' && (s[l - 1] == '+' ||
+					     s[l - 1] == '-'))))
 	    return 1;
 	st = ncalloc(sizeof(*st));
 	st->branches = newlinklist();
 	st->cutoff = s[l - 1];
-	if(s[l - 1] == '/') {
+	if (s[l - 1] == '/') {
 	    pattern = s + 1;
 	    patternlen = l - 2;
-	}
-	else {
+	} else {
 	    pattern = s + 1;
 	    patternlen = l - 3;
 	}
 	rparseargs++;
-	if((s = *rparseargs) && s[0] == '%' &&
+	if ((s = *rparseargs) && s[0] == '%' &&
 	   2 <= (l = strlen(s)) && s[l - 1] == '%') {
 	    rparseargs++;
 	    lookahead = s + 1;
 	    lookaheadlen = l - 2;
-	}
-	else {
+	} else {
 	    lookahead = NULL;
 	}
-	if(patternlen == 2 && !strncmp(pattern, "[]", 2))
+	if (patternlen == 2 && !strncmp(pattern, "[]", 2))
 	    st->pattern = NULL;
 	else {
 	    char *cp;
@@ -823,7 +825,7 @@
 	    cp += patternlen;
 	    strcpy(cp, ")");
 	    cp += 1;
-	    if(lookahead) {
+	    if (lookahead) {
 		strcpy(cp, "(#B)");
 		cp += 4;
 		strcpy(cp, lookahead);
@@ -832,23 +834,21 @@
 	    strcpy(cp, "*");
 	}
 	st->patprog = NULL;
-	if((s = *rparseargs) && *s == '-') {
+	if ((s = *rparseargs) && *s == '-') {
 	    rparseargs++;
 	    l = strlen(s);
 	    st->guard = ncalloc(l);
 	    memcpy(st->guard, s + 1, l - 1);
 	    st->guard[l - 1] = '\0';
-	}
-	else
+	} else
 	    st->guard = NULL;
-	if((s = *rparseargs) && *s == ':') {
+	if ((s = *rparseargs) && *s == ':') {
 	    rparseargs++;
 	    l = strlen(s);
 	    st->action = ncalloc(l);
 	    memcpy(st->action, s + 1, l - 1);
 	    st->action[l - 1] = '\0';
-	}
-	else
+	} else
 	    st->action = NULL;
 	result->nullacts = NULL;
 	result->in = newlinklist();
@@ -864,13 +864,13 @@
 	break;
     }
     case '(':
-	if(s[1])
+	if (s[1])
 	    return 1;
 	rparseargs++;
-	if(rparsealt(result, perr))
+	if (rparsealt(result, perr))
 	    longjmp(*perr, 2);
 	s = *rparseargs;
-	if(!s || s[0] != ')' || s[1] != '\0')
+	if (!s || s[0] != ')' || s[1] != '\0')
 	    longjmp(*perr, 2);
 	rparseargs++;
         break;
@@ -884,12 +884,12 @@
 static int
 rparseclo(RParseResult *result, jmp_buf *perr)
 {
-    if(rparseelt(result, perr))
+    if (rparseelt(result, perr))
 	return 1;
 
-    if(*rparseargs && !strcmp(*rparseargs, "#")) {
+    if (*rparseargs && !strcmp(*rparseargs, "#")) {
 	rparseargs++;
-	while(*rparseargs && !strcmp(*rparseargs, "#"))
+	while (*rparseargs && !strcmp(*rparseargs, "#"))
 	    rparseargs++;
 
 	connectstates(result->out, result->in);
@@ -902,9 +902,11 @@
 prependactions(LinkList acts, LinkList branches)
 {
     LinkNode aln, bln;
-    for(bln = firstnode(branches); bln; bln = nextnode(bln)) {
+
+    for (bln = firstnode(branches); bln; bln = nextnode(bln)) {
 	RParseBranch *br = getdata(bln);
-	for(aln = lastnode(acts); aln != (LinkNode)acts; aln = prevnode(aln))
+
+	for (aln = lastnode(acts); aln != (LinkNode)acts; aln = prevnode(aln))
 	    pushnode(br->actions, getdata(aln));
     }
 }
@@ -913,9 +915,10 @@
 appendactions(LinkList acts, LinkList branches)
 {
     LinkNode aln, bln;
-    for(bln = firstnode(branches); bln; bln = nextnode(bln)) {
+    for (bln = firstnode(branches); bln; bln = nextnode(bln)) {
 	RParseBranch *br = getdata(bln);
-	for(aln = firstnode(acts); aln; aln = nextnode(aln))
+
+	for (aln = firstnode(acts); aln; aln = nextnode(aln))
 	    addlinknode(br->actions, getdata(aln));
     }
 }
@@ -931,36 +934,37 @@
     result->in = newlinklist();
     result->out = newlinklist();
 
-    while(1) {
-	if((s = *rparseargs) && s[0] == '{' && s[(l = strlen(s)) - 1] == '}') {
+    while (1) {
+	if ((s = *rparseargs) && s[0] == '{' && s[(l = strlen(s)) - 1] == '}') {
 	    char *action = ncalloc(l - 1);
 	    LinkNode ln;
+
 	    rparseargs++;
 	    memcpy(action, s + 1, l - 2);
 	    action[l - 2] = '\0';
-	    if(result->nullacts)
+	    if (result->nullacts)
 		addlinknode(result->nullacts, action);
-	    for(ln = firstnode(result->out); ln; ln = nextnode(ln)) {
+	    for (ln = firstnode(result->out); ln; ln = nextnode(ln)) {
 		RParseBranch *br = getdata(ln);
 		addlinknode(br->actions, action);
 	    }
 	}
-        else if(!rparseclo(&sub, perr)) {
+        else if (!rparseclo(&sub, perr)) {
 	    connectstates(result->out, sub.in);
 
-	    if(result->nullacts) {
+	    if (result->nullacts) {
 		prependactions(result->nullacts, sub.in);
 		insertlinklist(sub.in, lastnode(result->in), result->in);
 	    }
-	    if(sub.nullacts) {
+	    if (sub.nullacts) {
 		appendactions(sub.nullacts, result->out);
 		insertlinklist(sub.out, lastnode(result->out), result->out);
-	    }
-	    else
+	    } else
 		result->out = sub.out;
 
-	    if(result->nullacts && sub.nullacts)
-		insertlinklist(sub.nullacts, lastnode(result->nullacts), result->nullacts);
+	    if (result->nullacts && sub.nullacts)
+		insertlinklist(sub.nullacts, lastnode(result->nullacts),
+			       result->nullacts);
 	    else
 		result->nullacts = NULL;
 	}
@@ -975,16 +979,16 @@
 {
     RParseResult sub;
 
-    if(rparseseq(result, perr))
+    if (rparseseq(result, perr))
 	return 1;
 
-    while(*rparseargs && !strcmp(*rparseargs, "|")) {
+    while (*rparseargs && !strcmp(*rparseargs, "|")) {
 	rparseargs++;
-	if(rparseseq(&sub, perr))
+	if (rparseseq(&sub, perr))
 	    longjmp(*perr, 2);
-	if(!result->nullacts && sub.nullacts) {
+	if (!result->nullacts && sub.nullacts)
 	    result->nullacts = sub.nullacts;
-	}
+
 	insertlinklist(sub.in, lastnode(result->in), result->in);
 	insertlinklist(sub.out, lastnode(result->out), result->out);
     }
@@ -1004,11 +1008,12 @@
     setiparam(var1, point1);
     setiparam(var2, point2);
 
-    if(!*subj) {
-	if(sm->nullacts)
-	    for(ln = firstnode(sm->nullacts); ln; ln = nextnode(ln)) {
+    if (!*subj) {
+	if (sm->nullacts)
+	    for (ln = firstnode(sm->nullacts); ln; ln = nextnode(ln)) {
 	        char *action = getdata(ln);
-		if(action)
+
+		if (action)
 		    execstring(action, 1, 0);
 	    }
 	return 0;
@@ -1020,84 +1025,102 @@
     do {
 	char **savematch1, **savembegin1, **savemend1;
 	char **savematch2, **savembegin2, **savemend2;
+
 	PERMALLOC {
-	  savematch1 = duparray(getaparam("match"), (VFunc) dupstring);
-	  savembegin1 = duparray(getaparam("mbegin"), (VFunc) dupstring);
-	  savemend1 = duparray(getaparam("mend"), (VFunc) dupstring);
+	    savematch1 = arrdup(getaparam("match"));
+	    savembegin1 = arrdup(getaparam("mbegin"));
+	    savemend1 = arrdup(getaparam("mend"));
 	} LASTALLOC;
-	for(ln = firstnode(nexts); ln; ln = nextnode(ln)) {
+
+	for (ln = firstnode(nexts); ln; ln = nextnode(ln)) {
 	    int i;
 	    RParseState *next;
+
 	    br = getdata(ln);
 	    next = br->state;
-	    if(next->pattern && !next->patprog) {
+	    if (next->pattern && !next->patprog) {
 	        tokenize(next->pattern);
-		if(!(next->patprog = patcompile(next->pattern, 0, NULL))) {
+		if (!(next->patprog = patcompile(next->pattern, 0, NULL)))
 		    return 2;
-		}
 	    }
-	    if(next->pattern && pattry(next->patprog, subj) &&
-	       (!next->guard || (execstring(next->guard, 1, 0), !lastval))) {
+	    if (next->pattern && pattry(next->patprog, subj) &&
+		(!next->guard || (execstring(next->guard, 1, 0), !lastval))) {
 		LinkNode aln;
 		char **mend = getaparam("mend");
 		int len = atoi(mend[0]);
-		for(i = len; i; i--)
-		  if(*subj++ == Meta)
+
+		for (i = len; i; i--)
+		  if (*subj++ == Meta)
 		    subj++;
+
 		PERMALLOC {
-		  savematch2 = duparray(getaparam("match"), (VFunc) dupstring);
-		  savembegin2 = duparray(getaparam("mbegin"), (VFunc) dupstring);
-		  savemend2 = duparray(getaparam("mend"), (VFunc) dupstring);
+		    savematch2 = arrdup(getaparam("match"));
+		    savembegin2 = arrdup(getaparam("mbegin"));
+		    savemend2 = arrdup(getaparam("mend"));
 		} LASTALLOC;
-		if(savematch1) setaparam("match", savematch1);
-		if(savembegin1) setaparam("mbegin", savembegin1);
-		if(savemend1) setaparam("mend", savemend1);
-		for(aln = firstnode(br->actions); aln; aln = nextnode(aln)) {
+
+		if (savematch1)
+		    setaparam("match", savematch1);
+		if (savembegin1)
+		    setaparam("mbegin", savembegin1);
+		if (savemend1)
+		    setaparam("mend", savemend1);
+
+		for (aln = firstnode(br->actions); aln; aln = nextnode(aln)) {
 		    char *action = getdata(aln);
-		    if(action)
+
+		    if (action)
 			execstring(action, 1, 0);
 		}
-		if(savematch2) setaparam("match", savematch2);
-		if(savembegin2) setaparam("mbegin", savembegin2);
-		if(savemend2) setaparam("mend", savemend2);
+		if (savematch2)
+		    setaparam("match", savematch2);
+		if (savembegin2)
+		    setaparam("mbegin", savembegin2);
+		if (savemend2)
+		    setaparam("mend", savemend2);
+
 		point2 += len;
 		setiparam(var2, point2);
 		st = br->state;
 		nexts = st->branches;
-		if(next->cutoff == '-' || (next->cutoff == '/' && len)) {
-		  nextslist = newlinklist();
-		  point1 = point2;
-		  setiparam(var1, point1);
+		if (next->cutoff == '-' || (next->cutoff == '/' && len)) {
+		    nextslist = newlinklist();
+		    point1 = point2;
+		    setiparam(var1, point1);
 		}
 		addlinknode(nextslist, nexts);
 		break;
 	    }
 	}
-	if(!ln) {
-	    if(savematch1) freearray(savematch1);
-	    if(savembegin1) freearray(savembegin1);
-	    if(savemend1) freearray(savemend1);
+	if (!ln) {
+	    if (savematch1)
+		freearray(savematch1);
+	    if (savembegin1)
+		freearray(savembegin1);
+	    if (savemend1)
+		freearray(savemend1);
 	}
-    } while(ln);
+    } while (ln);
 
-    if(!comp && !*subj)
-	for(ln = firstnode(sm->out); ln; ln = nextnode(ln)) {
+    if (!comp && !*subj)
+	for (ln = firstnode(sm->out); ln; ln = nextnode(ln)) {
 	    br = getdata(ln);
-	    if(br->state == st) {
-		for(ln = firstnode(br->actions); ln; ln = nextnode(ln)) {
+	    if (br->state == st) {
+		for (ln = firstnode(br->actions); ln; ln = nextnode(ln)) {
 		    char *action = getdata(ln);
-		    if(action)
+
+		    if (action)
 			execstring(action, 1, 0);
 		}
 		return 0;
 	    }
 	}
 
-    for(lnn = firstnode(nextslist); lnn; lnn = nextnode(lnn)) {
+    for (lnn = firstnode(nextslist); lnn; lnn = nextnode(lnn)) {
 	nexts = getdata(lnn);
-	for(ln = firstnode(nexts); ln; ln = nextnode(ln)) {
+	for (ln = firstnode(nexts); ln; ln = nextnode(ln)) {
 	    br = getdata(ln);
-	    if(br->state->action)
+	    if (br->state->action)
 		execstring(br->state->action, 1, 0);
 	}
     }
@@ -1130,17 +1153,16 @@
     HEAPALLOC {
 	pushheap();
         rparsestates = newlinklist();
-	if(setjmp(rparseerr) || rparsealt(&result, &rparseerr) || *rparseargs) {
-	    if(*rparseargs)
+	if (setjmp(rparseerr) || rparsealt(&result, &rparseerr) || *rparseargs) {
+	    if (*rparseargs)
 		zwarnnam(nam, "invalid regex : %s", *rparseargs, 0);
 	    else
 		zwarnnam(nam, "not enough regex arguments", NULL, 0);
 	    ret = 3;
-	}
-	else
+	} else
 	    ret = 0;
 
-	if(!ret)
+	if (!ret)
 	    ret = rmatch(&result, subj, var1, var2, ops['c']);
         popheap();
     } LASTALLOC;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

