From zsh-workers-return-16494-mason-zsh=primenet.com.au@sunsite.dk Fri Jan 25 13:03:46 2002
Return-Path: <zsh-workers-return-16494-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1577 invoked from network); 25 Jan 2002 13:03:45 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 25 Jan 2002 13:03:45 -0000
Received: (qmail 13886 invoked by alias); 25 Jan 2002 13:03:12 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16494
Received: (qmail 13733 invoked from network); 25 Jan 2002 13:02:52 -0000
Date: Fri, 25 Jan 2002 05:02:45 -0800
From: Derek Peschel <dpeschel@eskimo.com>
To: zsh-workers@sunsite.dk
Subject: PATCH: 4.0.2: new behavior for %_ and new %^ escape
Message-ID: <20020125050245.E7661@eskimo.eskimo.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailer: Mutt 1.0i

As with my rprompt2 patch, this is a small feature being carried to its
logical extreme.

%_ no longer treats negative integers like zero, but instead extracts
leading (outermost) words.  Maybe someone somewhere cares more about
the outer state than the inner state.

%^ works like %_ (including the behavior described above) but after
the words are selected they are printed in reverse order.  Try using %^
in RPS2.

I picked ^ because it comes before _ in ASCII.

The documentation in this patch refers to RPS2, so this patch depends
on my "rprompt2" patch (unless someone changes the documentation).

Comments welcome (I just started using zsh and I have no idea if anyone
else will find these patches useful).

-- Derek



--- Src/prompt.c.orig	Thu Jan 24 16:05:05 2002
+++ Src/prompt.c	Thu Jan 24 18:34:44 2002
@@ -559,15 +559,54 @@
 	    case 'E':
                 tsetcap(TCCLEAREOL, 1);
 		break;
+	    case '^':
+		if (cmdsp) {
+		    if (arg >= 0) {
+			if (arg > cmdsp || arg == 0)
+			    arg = cmdsp;
+			for (t0 = cmdsp - 1; arg--; t0--) {
+			    stradd(cmdnames[cmdstack[t0]]);
+			    if (arg) {
+				addbufspc(1);
+				*bp++=' ';
+			    }
+			}
+		    } else {
+			arg = -arg;
+			if (arg > cmdsp)
+			    arg = cmdsp;
+			for (t0 = arg - 1; arg--; t0--) {
+			    stradd(cmdnames[cmdstack[t0]]);
+			    if (arg) {
+				addbufspc(1);
+				*bp++=' ';
+			    }
+			}
+		    }
+		}
+		break;
 	    case '_':
 		if (cmdsp) {
-		    if (arg > cmdsp || arg <= 0)
-			arg = cmdsp;
-		    for (t0 = cmdsp - arg; arg--; t0++) {
-			stradd(cmdnames[cmdstack[t0]]);
-			if (arg) {
-			    addbufspc(1);
-			    *bp++=' ';
+		    if (arg >= 0) {
+			if (arg > cmdsp || arg == 0)
+			    arg = cmdsp;
+			for (t0 = cmdsp - arg; arg--; t0++) {
+			    stradd(cmdnames[cmdstack[t0]]);
+			    if (arg) {
+				addbufspc(1);
+				*bp++=' ';
+			    }
+			}
+		    } else {
+			arg = -arg;
+			if (arg > cmdsp)
+			    arg = cmdsp;
+			for (t0 = 0; arg--; t0++) {
+			    stradd(cmdnames[cmdstack[t0]]);
+			    if (arg) {
+				addbufspc(1);
+				*bp++=' ';
+			    }
 			}
 		    }
 		}
--- Doc/Zsh/prompt.yo.orig	Thu Jan 24 19:33:07 2002
+++ Doc/Zsh/prompt.yo	Thu Jan 24 20:02:51 2002
@@ -130,13 +130,18 @@
 item(tt(%?))(
 The return code of the last command executed just before the prompt.
 )
+item(tt(%^))(
+Exactly like tt(%_) except that the words are printed in the reverse order.
+)
 item(tt(%_))(
 The status of the parser, i.e. the shell constructs (like `tt(if)' and
-`tt(for)') that have been started on the command line. If given an integer
-number that many strings will be printed; zero or negative or no integer means
-print as many as there are.  This is most useful in prompts tt(PS2) for
-continuation lines and tt(PS4) for debugging with the tt(XTRACE) option; in
-the latter case it will also work non-interactively.
+`tt(for)') that have been started on the command line.  If an integer
+follows the `tt(%)', it specifies a number of trailing (inner) words
+to show; zero means all words.  A negative integer specifies leading
+(outer) words, i.e. tt(%-1_) specifies the outermost word.  This is
+most useful in prompts tt(PS2) and tt(RPS2) for continuation lines,
+and tt(PS4) for debugging with the tt(XTRACE) option; in the latter case
+it will also work non-interactively.
 )
 item(tt(%E))(
 Clears to end of line.

