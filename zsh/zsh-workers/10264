From zsh-workers-return-10264-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 27 08:48:29 2000
Return-Path: <zsh-workers-return-10264-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1836 invoked from network); 27 Mar 2000 08:48:28 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Mar 2000 08:48:28 -0000
Received: (qmail 19051 invoked by alias); 27 Mar 2000 08:48:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10264
Received: (qmail 19043 invoked from network); 27 Mar 2000 08:48:22 -0000
Date: Mon, 27 Mar 2000 10:48:21 +0200 (MET DST)
Message-Id: <200003270848.KAA03225@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: #autoload <option>


Bart suggested this some time ago.

This allows to give options after the #autoload tag (and makes use of
it in _call).

And then it fixes to uses of compstate[force_list] in i-c-w and
predict-on. Dunno how they survived.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_call Completion/Core/_call
--- ../z.old/Completion/Core/_call	Mon Mar 27 10:25:29 2000
+++ Completion/Core/_call	Mon Mar 27 10:42:48 2000
@@ -1,4 +1,4 @@
-#autoload
+#autoload +X
 
 local tmp
 
diff -ru ../z.old/Completion/Core/compdump Completion/Core/compdump
--- ../z.old/Completion/Core/compdump	Mon Mar 27 10:25:32 2000
+++ Completion/Core/compdump	Mon Mar 27 10:42:48 2000
@@ -46,6 +46,12 @@
 done >> $_d_file
 print ")" >> $_d_file
 
+print "\n_compautos=(" >> $_d_file
+for _d_f in "${(ok@)_compautos}"; do
+  print -r - "${(q)_d_f}" "${(q)_compautos[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
+
 print >> $_d_file
 
 # Now dump the key bindings. We dump all bindings for zle widgets
@@ -82,18 +88,24 @@
 
 # print them out:  about five to a line looks neat
 
+_i=5
+print -n autoload -U >> $_d_file
 while (( $#_d_als )); do
-  print -n autoload -U
-  for (( _i = 0; _i < 5; _i++ )); do
-    if (( $#_d_als )); then
-      print -n " $_d_als[1]"
-      shift _d_als
+  if (( ! $+_compautos[$_d_als[1]] )); then
+    print -n " $_d_als[1]"
+    if (( _i-- && $#_d_als > 1 )); then
+      _i=5
+      print -n '\nautoload -U'
     fi
-  done
-  print
+  fi
+  shift _d_als
 done >> $_d_file
 
 print >> $_d_file
+
+for _i in "${(ok@)_compautos}"; do
+  print "autoload -U $_compautos[$_i] $_i" >> $_d_file
+done
 
 mv $_d_file ${_d_file%.$HOST.$$}
 
diff -ru ../z.old/Completion/Core/compinit Completion/Core/compinit
--- ../z.old/Completion/Core/compinit	Mon Mar 27 10:25:32 2000
+++ Completion/Core/compinit	Mon Mar 27 10:45:04 2000
@@ -16,7 +16,7 @@
 #     for commands whose name matches <pattern>. Note that only one pattern
 #     may be given.
 #
-#   `#compdef -k <style> [ <key-sequence> ... ]
+#   `#compdef -k <style> [ <key-sequence> ... ]'
 #     This is used to bind special completions to all the given
 #     <key-sequence>(s). The <style> is the name of one of the built-in
 #     completion widgets (complete-word, delete-char-or-list,
@@ -27,7 +27,7 @@
 #     rather than by the context.  The widget has the same name as
 #     the autoload file and can be bound using bindkey in the normal way.
 #
-#   `#compdef -K <widget-name> <style> <key-sequence> [ ... ]
+#   `#compdef -K <widget-name> <style> <key-sequence> [ ... ]'
 #     This is similar to -k, except it takes any number of sets of
 #     three arguments.  In each set, the widget <widget-name> will
 #     be defined, which will behave as <style>, as with -k, and will
@@ -38,10 +38,12 @@
 #     clearest), but is otherwise arbitrary.  It can be tested in the
 #     function by the parameter $WIDGET.
 #
-#   `#autoload'
-#     this is for helper functions that are not used to
+#   `#autoload [ <options> ]'
+#     This is for helper functions that are not used to
 #     generate matches, but should automatically be loaded
-#     when they are called
+#     when they are called. The <options> will be given to the
+#     autoload builtin when making the function autoloaded. Note
+#     that this need not include `-U'.
 #
 # Note that no white space is allowed between the `#' and the rest of
 # the string.
@@ -81,9 +83,10 @@
 
 # The associative array containing the definitions for the commands.
 # Definitions for patterns will be stored in the associations `_patcomps'
-# and `_postpatcomps'.
+# and `_postpatcomps'. `_compautos' contains the names and options
+# for autoloaded functions that get options.
 
-typeset -gA _comps _patcomps _postpatcomps
+typeset -gA _comps _patcomps _postpatcomps _compautos
 
 # The associative array use to report information about the last
 # cmpletion to the outside.
@@ -483,7 +486,8 @@
 	fi
 	;;
       (\#autoload)
-	autoload -U ${_i_file:t}
+	autoload -U "$_i_line[@]" ${_i_file:t}
+	[[ "$_i_line" != \ # ]] && _compautos[${_i_file:t}]="$_i_line"
 	;;
       esac
     done
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Mon Mar 27 10:27:14 2000
+++ Doc/Zsh/compsys.yo	Mon Mar 27 10:46:40 2000
@@ -185,11 +185,16 @@
 (all on one line) defines a widget tt(_foo_complete) for completion, bound
 to `tt(^X^C)', and a widget tt(_foo_list) for listing, bound to `tt(^X^D)'.
 )
-item(tt(#autoload))(
+item(tt(#autoload) [ var(options) ])(
 This is used for files defining utility function that are not to be
 called directly as completion functions but should be loaded automatically
 when invoked.  Typically they are to be called from within one of the
 completion functions.
+
+The var(options) will be given to the tt(autoload) builtin command
+when making the function autoloaded. Note that the tt(-U) flag is
+always used. Most often, this will be tt(+X) to force the function
+being loaded immediately.
 )
 enditem()
 
diff -ru ../z.old/Functions/Zle/incremental-complete-word Functions/Zle/incremental-complete-word
--- ../z.old/Functions/Zle/incremental-complete-word	Mon Mar 27 10:25:58 2000
+++ Functions/Zle/incremental-complete-word	Mon Mar 27 10:42:48 2000
@@ -115,10 +115,8 @@
 
   if [[ compstate[list_lines]+BUFFERLINES+1 -gt LINES ]]; then
     compstate[list]='list explanations'
-    if [[ compstate[list_lines]+BUFFERLINES+1 -gt LINES ]]; then
-      compstate[list]=''
-      compstate[force_list]=yes
-    fi
+    [[ compstate[list_lines]+BUFFERLINES+1 -gt LINES ]] && compstate[list]=''
+
     toolong='...'
   fi
 }
diff -ru ../z.old/Functions/Zle/predict-on Functions/Zle/predict-on
--- ../z.old/Functions/Zle/predict-on	Mon Mar 27 10:25:59 2000
+++ Functions/Zle/predict-on	Mon Mar 27 10:42:48 2000
@@ -130,10 +130,9 @@
 	    compstate[nmatches] > compstate[list_max] ) ))
   then
     compstate[list]=''
-    compstate[force_list]=yes
   elif zstyle -t ":completion:::predict::" list always
   then
-    compstate[force_list]=yes
+    compstate[list]='force list'
   fi
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

