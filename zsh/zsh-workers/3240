From zsh-workers-request@euclid.skiles.gatech.edu Fri Jun 13 17:38:39 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 4599 invoked from network); 13 Jun 1997 17:38:34 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 13 Jun 1997 17:38:34 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id MAA10603; Fri, 13 Jun 1997 12:55:26 -0400 (EDT)
Resent-Date: Fri, 13 Jun 1997 12:55:26 -0400 (EDT)
Date: Fri, 13 Jun 1997 17:59:15 +0100 (BST)
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <20267.199706131659@stone.dcs.warwick.ac.uk>
Subject: rlimits
X-Patch: 258
Resent-Message-ID: <"gBTsS.0.cb2.-jNep"@euclid>
To: zsh-workers@math.gatech.edu
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3240
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

In 3.1.2, the rlimits module is built only if resource limits are
available.  However, the module can be compiled into the executable
anyway, and the cap module is always built even if capabilities are
not available.  This patch makes rlimits be built anyway, so that
the builtins it provides are consistently available, and changes its
handling of systems that don't do resource limits to match the cap module.
They can actually share the code for the unavailable builtin, which I
therefore moved into the main executable.

 -zefram

 *** configure.in	1997/06/12 00:00:38	1.41
 --- configure.in	1997/06/12 10:06:54
 ***************
 *** 603,615 ****
   dnl We are using it any time we have getrlimit, though if the macros were
   dnl not found we simply awk through /dev/null and fail to find them.
   dnl Thus, limit won't work, but at least the shell will compile.
 - if test $zsh_cv_path_rlimit_h = /dev/null ||
 -    test $ac_cv_func_getrlimit = no; then
 -   R=N
 - else
 -   R=R
 - fi
 - AC_SUBST(R)dnl
   AC_SUBST(RLIMITS_INC_H)dnl
   
   dnl ------------------
 --- 603,608 ----
 *** Src/builtin.c	1997/06/12 00:44:23	1.84
 --- Src/builtin.c	1997/06/12 09:55:49
 ***************
 *** 3363,3365 ****
 --- 3363,3375 ----
       umask(um);
       return 0;
   }
 + 
 + /* Generic builtin for facilities not available on this OS */
 + 
 + /**/
 + int
 + bin_notavail(char *nam, char **argv, char *ops, int func)
 + {
 +     zwarnnam(nam, "not available on this system", NULL, 0);
 +     return 1;
 + }
 *** Src/Builtins/Makefile.in	1997/06/12 00:01:39	1.3
 --- Src/Builtins/Makefile.in	1997/06/12 09:53:42
 ***************
 *** 108,129 ****
   ZHDRS = ../globals.h ../hashtable.h ../prototypes.h ../signals.h \
   ../signames.h ../system.h ../zsh.h ../ztype.h ../../config.h
   
 - RLIMITS_MODULE = rlimits.so
 - RLIMITS_OBJ = rlimits.o
 - RLIMITS_DOBJ = rlimits..o
 - NLIMITS_MODULE =
 - NLIMITS_OBJ =
 - NLIMITS_DOBJ =
 - 
   # generated prototypes
   PROTO = rlimits.pro sched.pro
   
   # target modules
 ! MODULES = $(@R@LIMITS_MODULE) sched.so
   
   # object files
 ! OBJS = $(@R@LIMITS_OBJ) sched.o
 ! DOBJS = $(@R@LIMITS_DOBJ) sched..o
   
   ALLOBJS = $(OBJS) $(DOBJS)
   
 --- 108,122 ----
   ZHDRS = ../globals.h ../hashtable.h ../prototypes.h ../signals.h \
   ../signames.h ../system.h ../zsh.h ../ztype.h ../../config.h
   
   # generated prototypes
   PROTO = rlimits.pro sched.pro
   
   # target modules
 ! MODULES = rlimits.so sched.so
   
   # object files
 ! OBJS = rlimits.o sched.o
 ! DOBJS = rlimits..o sched..o
   
   ALLOBJS = $(OBJS) $(DOBJS)
   
 *** Src/Builtins/rlimits.c	1997/06/12 00:01:40	1.4
 --- Src/Builtins/rlimits.c	1997/06/12 10:09:06
 ***************
 *** 32,45 ****
   #include "zsh.h"
   #include "rlimits.pro"
   
 ! #ifdef HAVE_GETRLIMIT
   
   /* Generated rec array containing limits required for the limit builtin.     *
    * They must appear in this array in numerical order of the RLIMIT_* macros. */
   
 ! #include "rlimits.h"
   
 ! #if defined(RLIM_T_IS_QUAD_T) || defined(RLIM_T_IS_UNSIGNED)
   static rlim_t
   zstrtorlimt(const char *s, char **t, int base)
   {
 --- 32,45 ----
   #include "zsh.h"
   #include "rlimits.pro"
   
 ! #if defined(HAVE_GETRLIMIT) && defined(RLIM_INFINITY)
   
   /* Generated rec array containing limits required for the limit builtin.     *
    * They must appear in this array in numerical order of the RLIMIT_* macros. */
   
 ! # include "rlimits.h"
   
 ! # if defined(RLIM_T_IS_QUAD_T) || defined(RLIM_T_IS_UNSIGNED)
   static rlim_t
   zstrtorlimt(const char *s, char **t, int base)
   {
 ***************
 *** 64,72 ****
   	*t = (char *)s;
       return ret;
   }
 ! #else
 ! # define zstrtorlimt(a, b, c)	zstrtol((a), (b), (c))
 ! #endif
   
   /* Display resource limits.  hard indicates whether `hard' or `soft'  *
    * limits should be displayed.  lim specifies the limit, or may be -1 *
 --- 64,72 ----
   	*t = (char *)s;
       return ret;
   }
 ! # else /* !RLIM_T_IS_QUAD_T && !RLIM_T_IS_UNSIGNED */
 ! #  define zstrtorlimt(a, b, c)	zstrtol((a), (b), (c))
 ! # endif /* !RLIM_T_IS_QUAD_T && !RLIM_T_IS_UNSIGNED */
   
   /* Display resource limits.  hard indicates whether `hard' or `soft'  *
    * limits should be displayed.  lim specifies the limit, or may be -1 *
 ***************
 *** 215,221 ****
       else
   	printf("%ld\n", (long)limit);
   }
 - #endif /* HAVE_GETRLIMIT */
   
   /* limit: set or show resource limits.  The variable hard indicates *
    * whether `hard' or `soft' resource limits are being set/shown.    */
 --- 215,220 ----
 ***************
 *** 224,234 ****
   static int
   bin_limit(char *nam, char **argv, char *ops, int func)
   {
 - #ifndef HAVE_GETRLIMIT
 -     /* limit builtin not appropriate to this system */
 -     zwarnnam(nam, "not available on this system", NULL, 0);
 -     return 1;
 - #else
       char *s;
       int hard, limnum, lim;
       rlim_t val;
 --- 223,228 ----
 ***************
 *** 330,336 ****
   	    ret++;
       }
       return ret;
 - #endif /* HAVE_GETRLIMIT */
   }
   
   /* unlimit: remove resource limits.  Much of this code is the same as *
 --- 324,329 ----
 ***************
 *** 340,350 ****
   static int
   bin_unlimit(char *nam, char **argv, char *ops, int func)
   {
 - #ifndef HAVE_GETRLIMIT
 -     /* unlimit builtin not appropriate to this system */
 -     zwarnnam(nam, "not available on this system", NULL, 0);
 -     return 1;
 - #else
       int hard, limnum, lim;
       int ret = 0;
       uid_t euid = geteuid();
 --- 333,338 ----
 ***************
 *** 400,406 ****
   	}
       }
       return ret;
 - #endif /* HAVE_GETRLIMIT */
   }
   
   /* ulimit: set or display resource limits */
 --- 388,393 ----
 ***************
 *** 409,419 ****
   static int
   bin_ulimit(char *name, char **argv, char *ops, int func)
   {
 - #ifndef HAVE_GETRLIMIT
 -     /* builtin not appropriate */
 -     zwarnnam(name, "not available on this system", NULL, 0);
 -     return 1;
 - #else
       int res, resmask = 0, hard = 0, soft = 0, nres = 0;
       char *options;
   
 --- 396,401 ----
 ***************
 *** 578,585 ****
   	if (resmask & 1)
   	    printulimit(res, hard, nres > 1);
       return 0;
 - #endif /* HAVE_GETRLIMIT */
   }
   
   static struct binlist bintab[] = {
       {"limit", 0, bin_limit, 0, -1, 0, "sh", NULL, 0},
 --- 560,574 ----
   	if (resmask & 1)
   	    printulimit(res, hard, nres > 1);
       return 0;
   }
 + 
 + #else /* !HAVE_GETRLIMIT || !RLIM_INFINITY */
 + 
 + # define bin_limit   bin_notavail
 + # define bin_ulimit  bin_notavail
 + # define bin_unlimit bin_notavail
 + 
 + #endif /* !HAVE_GETRLIMIT || !RLIM_INFINITY */
   
   static struct binlist bintab[] = {
       {"limit", 0, bin_limit, 0, -1, 0, "sh", NULL, 0},
 *** Src/Modules/cap.c	1997/06/12 00:01:42	1.5
 --- Src/Modules/cap.c	1997/06/12 09:54:57
 ***************
 *** 111,123 ****
   
   #else /* !HAVE_CAP_INIT */
   
 - static int
 - bin_notavail(char *nam, char **argv, char *ops, int func)
 - {
 -     zwarnnam(nam, "not available on this system", NULL, 0);
 -     return 1;
 - }
 - 
   # define bin_cap    bin_notavail
   # define bin_getcap bin_notavail
   # define bin_setcap bin_notavail
 --- 111,116 ----

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia
Charset: ascii

iQEVAwUBM5/N0Jmk9GeOHh7BAQGXuQf/ZV+Zx4Gg11X57cn8XVdL7jXru3EfebLi
Y1RFMzemAP/rNtSxkIteD42/seQNUypU4t8d2NZuBflPSg3fdbXlzqu+FymJ6Xey
FTWzOx4hw8OtsRedzYQeZuNZyhCPX0CbgWOyD93YHm043Ml7VQzy8iKYZ8Hz1Rnk
FuIuwy0sFiGWHHpawA5ITcukIXZJL4B4LlPOSOmLZ6hqku1vb8kinNJBLt4gji5V
A4lWaFQGB8bJkxZ6DmkO1Z8dyUWHYq/FxnOSbro8DzSPa6ZjpqMLvHDZT3I+GVIp
l+CHLPHrCTQ1HG82XQrUXdWk58zE2Xp/LebMRwTP7bX0QpY6m7VDcQ==
=93pN
-----END PGP SIGNATURE-----

