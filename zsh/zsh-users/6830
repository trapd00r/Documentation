From zsh-users-return-6830-mason-zsh=primenet.com.au@sunsite.dk Wed Dec 03 05:10:56 2003
Return-Path: <zsh-users-return-6830-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18542 invoked from network); 3 Dec 2003 05:10:55 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 3 Dec 2003 05:10:55 -0000
Received: (qmail 3837 invoked by alias); 3 Dec 2003 05:10:43 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 6830
Received: (qmail 3782 invoked from network); 3 Dec 2003 05:10:43 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 3 Dec 2003 05:10:43 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [4.11.8.53] by sunsite.dk (MessageWall 1.0.8) with SMTP; 3 Dec 2003 5:10:42 -0000
Received: (from schaefer@localhost)
	by candle.brasslantern.com (8.11.6/8.11.6) id hB35AfA11535
	for zsh-users@sunsite.dk; Tue, 2 Dec 2003 21:10:41 -0800
X-Authentication-Warning: candle.brasslantern.com: schaefer set sender to schaefer@closedmail.com using -f
From: Bart Schaefer <schaefer@brasslantern.com>
Message-Id: <1031203051040.ZM11532@candle.brasslantern.com>
Date: Wed, 3 Dec 2003 05:10:40 +0000
In-Reply-To: <20031202171109.GW1814@DervishD>
Comments: In reply to DervishD <raul@pleyades.net>
        "Advice for filesystem operations under Zsh" (Dec  2,  6:11pm)
References: <20031202171109.GW1814@DervishD>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Zsh Users <zsh-users@sunsite.dk>
Subject: Re: Advice for filesystem operations under Zsh
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

On Dec 2,  6:11pm, DervishD wrote:
}
}     Hello all :))

Hello, Ra=FAl ...

}     The file list is stored in an array parameter, and in order to
} avoid reading from disk, the check is performed reading every 'list
} file' and comparing its contents (lines that are filenames) against
} the entire array

I don't see what disk read you're avoiding by this, but it probably
isn't important.

} deleting the corresponding entry if found. That
} way, at the end of iterations, the array contains all 'orphan' files.

When to delete an entry will depend on what else you need to do with
each entry, of course.

} [...] I want to extend the
} shell function so that, in one run, it outputs:
} =

}     - Orphan files in file descriptor 3
}     - Dangling symlinks in file descriptor 4
}     - Setuid binaries in file descriptor 5
}     - Duplicate files in file descriptor 6
}     - Empty directories in file descriptor 7
}     - etc...

I'm not precisely sure what you mean by "duplicate files".  Names that
appear in the array more than once?  Or files with different names but
identical contents?  Or names that appear in more than one of the "list
files"?  Or ...?

}     Under Zsh is pretty easy to find all dangling symlinks
} (**/*(@-)), setuid files (**/*(s)), etc... and I can do all that in
} just one travel through the filesystem, since glob qualifiers work
} too with filenames withouth globbing characters.

I'm not following the order of operations here, probably because I have
no idea what "FSlint" is or how it works.  Do you want to create the
array of file names by scanning the file system, or do you already have
the names and now you want to learn things about those specific files?

} My problems are:
} =

}     - finding dupes. I've tried to use 'I' subscript flag, but this
} only return all matching keys in an associative array, not in normal
} ones. The only solution seems to be deleting the match and search
} again...

This sounds like you want to find duplicate entries in the array.
Something like this:

    for element in $array
    do
      if [[ "${${(@M)array:#$element}}" =3D $element ]]
      then
	print $element is unique
      else
	print $element is a duplicate
      fi
    done

}     - finding empty directories.

We went over this once before, did we not?  However, the best approach
in this instance may depend on whether you're scanning the filesystem
anyway, or whether you are testing names obtained some other way.

}     - doing all that in one run of the array. Since the 'orphans'
} check destroys the contents of the array, I need to dupe it, or
} convert it to a associative array

Or just check for orphans last of anything, so that you don't need
the elements for other tests any more?

} I cannot find a solution for empty files.

Empty files wasn't on the list above, but isn't it **/*(L0)?

