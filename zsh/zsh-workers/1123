From heading_anthony@jpmorgan.com Thu May 23 04:30:39 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3) with ESMTP id EAA01987 for <mason@werple.mira.net.au>; Thu, 23 May 1996 04:30:37 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id NAA23854; Wed, 22 May 1996 13:36:49 -0400 (EDT)
Resent-Date: Wed, 22 May 1996 13:36:49 -0400 (EDT)
Date: Wed, 22 May 1996 18:35:24 +0100
Message-Id: <199605221735.SAA20576@et-sun4.uk.jpmorgan.com>
From: Anthony Heading <heading_anthony@jpmorgan.com>
To: zsh-workers@math.gatech.edu
Subject: popd patch
Resent-Message-ID: <"9-iyd3.0.cq5.m2ren"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/1123
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 2754
Status: O

A bit later than intended, but this should fix the problem with popd.
I think this bit of the code should be commented better, but I've left
that out in the interests of the clarity of the patch.

For anyone interested in how this is supposed to work:

The key variable is "dir" in cd_get_dest.  It either points to an
element of the dirlist (e.g. from cd +5), or is null. The latter
*always* implies a new item on the top of the dirlist: either
the path argument to cd (e.g. cd /tmp) or a default (e.g $HOME).
This convention hopefully makes it reasonably straightforward to
keep the dirstack consistent and unwindable.

The current code screwed up by always changing to the targetted directory,
even though popd wants that directory simply to be discarded.

Any problems, please shout.

Anthony

*** builtin.c.orig	Tue May 21 19:00:23 1996
--- builtin.c	Wed May 22 18:08:37 1996
***************
*** 968,974 ****
  cd_get_dest(char *nam, char **argv, char *ops, int func)
  {
      LinkNode dir = NULL;
!     int newtxt = 0;
      char *dest;
  
      if (!argv[0]) {
--- 968,974 ----
  cd_get_dest(char *nam, char **argv, char *ops, int func)
  {
      LinkNode dir = NULL;
!     LinkNode target;
      char *dest;
  
      if (!argv[0]) {
***************
*** 1019,1032 ****
  	doprintdir++;
      }
  
!     if (!dir) {
! 	if (!(newtxt = (func != BIN_POPD))) {
  	    zsfree(getlinknode(dirstack));
  	}
  	dir = firstnode(dirstack);
      }
      if (!(dest = cd_do_chdir(nam, getdata(dir)))) {
! 	if (newtxt)
  	    zsfree(getlinknode(dirstack));
  	return NULL;
      }
--- 1019,1039 ----
  	doprintdir++;
      }
  
!     target = dir;
!     if (func == BIN_POPD) {
! 	if (!dir) {
  	    zsfree(getlinknode(dirstack));
+ 	    target = dir = firstnode(dirstack);
+ 	} else if (dir != firstnode(dirstack)) {
+ 	    return dir;
  	}
+ 	dir = nextnode(dir);
+     }
+     if (!dir) {
  	dir = firstnode(dirstack);
      }
      if (!(dest = cd_do_chdir(nam, getdata(dir)))) {
! 	if (!target)
  	    zsfree(getlinknode(dirstack));
  	return NULL;
      }
***************
*** 1034,1040 ****
  	zsfree(getdata(dir));
  	setdata(dir, dest);
      }
!     return dir; 
  }
  
  /* Change to given directory, if possible.  This function works out  *
--- 1041,1047 ----
  	zsfree(getdata(dir));
  	setdata(dir, dest);
      }
!     return target ? target : dir;
  }
  
  /* Change to given directory, if possible.  This function works out  *
***************
*** 1211,1217 ****
  	zsfree(getlinknode(dirstack));
  
      if (isset(CHASELINKS)) {
! s = new_pwd;
  	new_pwd = findpwd(s);
  	zsfree(s);
      }
--- 1218,1224 ----
  	zsfree(getlinknode(dirstack));
  
      if (isset(CHASELINKS)) {
! 	s = new_pwd;
  	new_pwd = findpwd(s);
  	zsfree(s);
      }


