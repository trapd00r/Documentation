<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>Git Magic</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
alink="#0000FF">
  <div lang="en" class="book" title="Git Magic">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="idp24557216" id=
          "idp24557216"></a>Git Magic</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="firstname">Ben</span>
            <span class="surname">Lynn</span></h3>
          </div>
        </div>

        <div>
          <div class="revhistory">
            <table border="1" width="100%" summary=
            "Revision history">
              <tr>
                <th align="left" valign="top" colspan="3">
                <b>Revision History</b></th>
              </tr>

              <tr>
                <td align="left"></td>

                <td align="left">August 2007</td>

                <td align="left">BL</td>
              </tr>
            </table>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Table of Contents</b></p>

      <dl>
        <dt><span class="preface"><a href=
        "#_preface">Preface</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_thanks">Thanks!</a></span></dt>

            <dt><span class="section"><a href=
            "#_license">License</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_introduction">1.
        Introduction</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#_work_is_play">Work
            is Play</a></span></dt>

            <dt><span class="section"><a href=
            "#_version_control">Version Control</a></span></dt>

            <dt><span class="section"><a href=
            "#_distributed_control">Distributed
            Control</a></span></dt>

            <dt><span class="section"><a href=
            "#_a_silly_superstition">A Silly
            Superstition</a></span></dt>

            <dt><span class="section"><a href=
            "#_merge_conflicts">Merge Conflicts</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_basic_tricks">2. Basic
        Tricks</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_saving_state">Saving State</a></span></dt>

            <dt><span class="section"><a href=
            "#_add_delete_rename">Add, Delete,
            Rename</a></span></dt>

            <dt><span class="section"><a href=
            "#_advanced_undo_redo">Advanced
            Undo/Redo</a></span></dt>

            <dt><span class="section"><a href=
            "#_reverting">Reverting</a></span></dt>

            <dt><span class="section"><a href=
            "#_changelog_generation">Changelog
            Generation</a></span></dt>

            <dt><span class="section"><a href=
            "#_downloading_files">Downloading Files</a></span></dt>

            <dt><span class="section"><a href=
            "#_the_bleeding_edge">The Bleeding Edge</a></span></dt>

            <dt><span class="section"><a href=
            "#_instant_publishing">Instant
            Publishing</a></span></dt>

            <dt><span class="section"><a href=
            "#_what_have_i_done">What Have I Done?</a></span></dt>

            <dt><span class="section"><a href=
            "#_exercise">Exercise</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_cloning_around">3.
        Cloning Around</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_sync_computers">Sync Computers</a></span></dt>

            <dt><span class="section"><a href=
            "#_classic_source_control">Classic Source
            Control</a></span></dt>

            <dt><span class="section"><a href=
            "#_secret_source">Secret Source</a></span></dt>

            <dt><span class="section"><a href=
            "#_bare_repositories">Bare repositories</a></span></dt>

            <dt><span class="section"><a href=
            "#_push_versus_pull">Push versus pull</a></span></dt>

            <dt><span class="section"><a href=
            "#_forking_a_project">Forking a Project</a></span></dt>

            <dt><span class="section"><a href=
            "#_ultimate_backups">Ultimate Backups</a></span></dt>

            <dt><span class="section"><a href=
            "#_light_speed_multitask">Light-Speed
            Multitask</a></span></dt>

            <dt><span class="section"><a href=
            "#_guerilla_version_control">Guerilla Version
            Control</a></span></dt>

            <dt><span class="section"><a href=
            "#_mercurial">Mercurial</a></span></dt>

            <dt><span class="section"><a href=
            "#_bazaar">Bazaar</a></span></dt>

            <dt><span class="section"><a href="#_why_i_use_git">Why
            I use Git</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_branch_wizardry">4.
        Branch Wizardry</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#_the_boss_key">The
            Boss Key</a></span></dt>

            <dt><span class="section"><a href="#_dirty_work">Dirty
            Work</a></span></dt>

            <dt><span class="section"><a href="#_quick_fixes">Quick
            Fixes</a></span></dt>

            <dt><span class="section"><a href=
            "#_merging">Merging</a></span></dt>

            <dt><span class="section"><a href=
            "#_uninterrupted_workflow">Uninterrupted
            Workflow</a></span></dt>

            <dt><span class="section"><a href=
            "#_reorganizing_a_medley">Reorganizing a
            Medley</a></span></dt>

            <dt><span class="section"><a href=
            "#_managing_branches">Managing Branches</a></span></dt>

            <dt><span class="section"><a href=
            "#_temporary_branches">Temporary
            Branches</a></span></dt>

            <dt><span class="section"><a href=
            "#_work_how_you_want">Work How You Want</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_lessons_of_history">5.
        Lessons of History</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_i_stand_corrected">I Stand Corrected</a></span></dt>

            <dt><span class="section"><a href=
            "#_8230_and_then_some">… And Then Some</a></span></dt>

            <dt><span class="section"><a href=
            "#_local_changes_last">Local Changes
            Last</a></span></dt>

            <dt><span class="section"><a href=
            "#_rewriting_history">Rewriting History</a></span></dt>

            <dt><span class="section"><a href=
            "#_making_history">Making History</a></span></dt>

            <dt><span class="section"><a href=
            "#_where_did_it_all_go_wrong">Where Did It All Go
            Wrong?</a></span></dt>

            <dt><span class="section"><a href=
            "#_who_made_it_all_go_wrong">Who Made It All Go
            Wrong?</a></span></dt>

            <dt><span class="section"><a href=
            "#_personal_experience">Personal
            Experience</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_multiplayer_git">6.
        Multiplayer Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#_who_am_i">Who Am
            I?</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_over_ssh_http">Git Over SSH,
            HTTP</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_over_anything">Git Over Anything</a></span></dt>

            <dt><span class="section"><a href=
            "#_patches_the_global_currency">Patches: The Global
            Currency</a></span></dt>

            <dt><span class="section"><a href=
            "#_sorry_we_8217_ve_moved">Sorry, We’ve
            Moved</a></span></dt>

            <dt><span class="section"><a href=
            "#_remote_branches">Remote Branches</a></span></dt>

            <dt><span class="section"><a href=
            "#_multiple_remotes">Multiple Remotes</a></span></dt>

            <dt><span class="section"><a href="#_my_preferences">My
            Preferences</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_git_grandmastery">7.
        Git Grandmastery</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_source_releases">Source Releases</a></span></dt>

            <dt><span class="section"><a href=
            "#_commit_what_changed">Commit What
            Changed</a></span></dt>

            <dt><span class="section"><a href=
            "#_my_commit_is_too_big">My Commit Is Too
            Big!</a></span></dt>

            <dt><span class="section"><a href=
            "#_the_index_git_8217_s_staging_area">The Index: Git’s
            Staging Area</a></span></dt>

            <dt><span class="section"><a href=
            "#_don_8217_t_lose_your_head">Don’t Lose Your
            HEAD</a></span></dt>

            <dt><span class="section"><a href=
            "#_head_hunting">HEAD-hunting</a></span></dt>

            <dt><span class="section"><a href=
            "#_building_on_git">Building On Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_daring_stunts">Daring Stunts</a></span></dt>

            <dt><span class="section"><a href=
            "#_preventing_bad_commits">Preventing Bad
            Commits</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_secrets_revealed">8.
        Secrets Revealed</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_invisibility">Invisibility</a></span></dt>

            <dt><span class="section"><a href=
            "#_integrity">Integrity</a></span></dt>

            <dt><span class="section"><a href=
            "#_intelligence">Intelligence</a></span></dt>

            <dt><span class="section"><a href=
            "#_indexing">Indexing</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_8217_s_origins">Git’s Origins</a></span></dt>

            <dt><span class="section"><a href=
            "#_the_object_database">The Object
            Database</a></span></dt>

            <dt><span class="section"><a href=
            "#_blobs">Blobs</a></span></dt>

            <dt><span class="section"><a href=
            "#_trees">Trees</a></span></dt>

            <dt><span class="section"><a href=
            "#_commits">Commits</a></span></dt>

            <dt><span class="section"><a href=
            "#_indistinguishable_from_magic">Indistinguishable From
            Magic</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href="#_git_shortcomings">A.
        Git Shortcomings</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_sha1_weaknesses">SHA1 Weaknesses</a></span></dt>

            <dt><span class="section"><a href=
            "#_microsoft_windows">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href=
            "#_unrelated_files">Unrelated Files</a></span></dt>

            <dt><span class="section"><a href=
            "#_who_8217_s_editing_what">Who’s Editing
            What?</a></span></dt>

            <dt><span class="section"><a href="#_file_history">File
            History</a></span></dt>

            <dt><span class="section"><a href=
            "#_initial_clone">Initial Clone</a></span></dt>

            <dt><span class="section"><a href=
            "#_volatile_projects">Volatile Projects</a></span></dt>

            <dt><span class="section"><a href=
            "#_global_counter">Global Counter</a></span></dt>

            <dt><span class="section"><a href=
            "#_empty_subdirectories">Empty
            Subdirectories</a></span></dt>

            <dt><span class="section"><a href=
            "#_initial_commit">Initial Commit</a></span></dt>

            <dt><span class="section"><a href=
            "#_interface_quirks">Interface Quirks</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href=
        "#_translating_this_guide">B. Translating This
        Guide</a></span></dt>
      </dl>
    </div>

    <div class="preface" title="Preface">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="_preface"></a>Preface</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_thanks">Thanks!</a></span></dt>

          <dt><span class="section"><a href=
          "#_license">License</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target=
      "_top">Git</a> is a version control Swiss army knife. A
      reliable versatile multipurpose revision control tool whose
      extraordinary flexibility makes it tricky to learn, let alone
      master.</p>

      <p>As Arthur C. Clarke observed, any sufficiently advanced
      technology is indistinguishable from magic. This is a great
      way to approach Git: newbies can ignore its inner workings
      and view Git as a gizmo that can amaze friends and infuriate
      enemies with its wondrous abilities.</p>

      <p>Rather than go into details, we provide rough instructions
      for particular effects. After repeated use, gradually you
      will understand how each trick works, and how to tailor the
      recipes for your needs.</p>

      <div class="itemizedlist" title="Translations">
        <p class="title"><b>Translations</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/zh_cn/" target="_top">Simplified
          Chinese</a>: by JunJie, Meng and JiangWei. Converted to
          <a class="ulink" href="/~blynn/gitmagic/intl/zh_tw/"
          target="_top">Traditional Chinese</a> via <code class=
          "literal">cconv -f UTF8-CN -t UTF8-TW</code>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/fr/" target="_top">French</a>: by
          Alexandre Garel, Paul Gaborit, and Nicolas Deram. Also
          hosted at <a class="ulink" href=
          "http://tutoriels.itaapy.com/" target=
          "_top">itaapy</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/de/" target="_top">German</a>: by
          Benjamin Bellee and Armin Stebich; also <a class="ulink"
          href="http://gitmagic.lordofbikes.de/" target=
          "_top">hosted on Armin’s website</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git" target=
          "_top">Portuguese</a>: by Leonardo Siqueira Rodrigues
          [<a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git-verso-odt"
          target="_top">ODT version</a>].</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/ru/" target="_top">Russian</a>: by
          Tikhon Tarnavsky, Mikhail Dymskov, and others.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/es/" target="_top">Spanish</a>: by
          Rodrigo Toledo and Ariset Llerena Tapia.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/vi/" target="_top">Vietnamese</a>:
          by Trần Ngọc Quân; also <a class="ulink" href=
          "http://vnwildman.users.sourceforge.net/gitmagic/"
          target="_top">hosted on his website</a>.</li>
        </ul>
      </div>

      <div class="itemizedlist" title="Other Editions">
        <p class="title"><b>Other Editions</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href="book.html"
          target="_top">Single webpage</a>: barebones HTML, with no
          CSS.</li>

          <li class="listitem"><a class="ulink" href="book.pdf"
          target="_top">PDF file</a>: printer-friendly.</li>

          <li class="listitem"><a class="ulink" href=
          "http://packages.debian.org/gitmagic" target=
          "_top">Debian package</a>, <a class="ulink" href=
          "http://packages.ubuntu.com/gitmagic" target=
          "_top">Ubuntu package</a>: get a fast and local copy of
          this site. Handy <a class="ulink" href=
          "http://csdcf.stanford.edu/status/" target="_top">when
          this server is offline</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.amazon.com/Git-Magic-Ben-Lynn/dp/1451523343/"
          target="_top">Physical book [Amazon.com</a>]: 64 pages,
          15.24cm x 22.86cm, black and white. Handy when there is
          no electricity.</li>
        </ul>
      </div>

      <div class="section" title="Thanks!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_thanks"></a>Thanks!</h2>
            </div>
          </div>
        </div>

        <p>I’m humbled that so many people have worked on
        translations of these pages. I greatly appreciate having a
        wider audience because of the efforts of those named
        above.</p>

        <p>Dustin Sallings, Alberto Bertogli, James Cameron,
        Douglas Livingstone, Michael Budde, Richard Albury,
        Tarmigan, Derek Mahar, Frode Aannevik, Keith Rarick, Andy
        Somerville, Ralf Recker, Øyvind A. Holm, Miklos Vajna,
        Sébastien Hinderer, Thomas Miedema, Joe Malin, Tyler
        Breisacher, Sonia Hamilton, Julian Haagsma, Romain
        Lespinasse, Sergey Litvinov, and Oliver Ferrigni
        contributed corrections and improvements.</p>

        <p>François Marier maintains the Debian package originally
        created by Daniel Baumann.</p>

        <p>My gratitude goes to many others for your support and
        praise. I’m tempted to quote you here, but it might raise
        expectations to ridiculous heights.</p>

        <p>If I’ve left you out by mistake, please tell me or just
        send me a patch!</p>

        <p><span class="strong"><strong>Free Git
        hosting</strong></span>: The following sites host public
        projects for free. Many thanks to each of them for hosting
        this guide.</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://repo.or.cz/" target="_top">repo.or.cz</a></li>

            <li class="listitem"><a class="ulink" href=
            "http://gitorious.org/" target=
            "_top">Gitorious</a></li>

            <li class="listitem"><a class="ulink" href=
            "http://github.com/" target="_top">GitHub</a>: hosts
            private projects for a fee.</li>

            <li class="listitem"><a class="ulink" href=
            "http://www.assembla.com/" target="_top">Assembla</a>:
            hosts private projects for a fee, though the first
            gigabyte is free.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="License">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_license"></a>License</h2>
            </div>
          </div>
        </div>

        <p>This guide is released under <a class="ulink" href=
        "http://www.gnu.org/licenses/gpl-3.0.html" target=
        "_top">the GNU General Public License version 3</a>.
        Naturally, the source is kept in a Git repository, and can
        be obtained by typing:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git  # Creates "gitmagic" directory.
</pre>

        <p>or from one of the mirrors:</p>
        <pre class="literallayout">
$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git
$ git clone git://git.assembla.com/gitmagic.git
</pre>
      </div>
    </div>

    <div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_work_is_play">Work
          is Play</a></span></dt>

          <dt><span class="section"><a href=
          "#_version_control">Version Control</a></span></dt>

          <dt><span class="section"><a href=
          "#_distributed_control">Distributed
          Control</a></span></dt>

          <dt><span class="section"><a href=
          "#_a_silly_superstition">A Silly
          Superstition</a></span></dt>

          <dt><span class="section"><a href=
          "#_merge_conflicts">Merge Conflicts</a></span></dt>
        </dl>
      </div>

      <p>I’ll use an analogy to introduce version control. See
      <a class="ulink" href=
      "http://en.wikipedia.org/wiki/Revision_control" target=
      "_top">the Wikipedia entry on revision control</a> for a
      saner explanation.</p>

      <div class="section" title="Work is Play">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_work_is_play"></a>Work is Play</h2>
            </div>
          </div>
        </div>

        <p>I’ve played computer games almost all my life. In
        contrast, I only started using version control systems as
        an adult. I suspect I’m not alone, and comparing the two
        may make these concepts easier to explain and
        understand.</p>

        <p>Think of editing your code, or document, as playing a
        game. Once you’ve made a lot of progress, you’d like to
        save. To do so, you click on the <span class=
        "emphasis"><em>Save</em></span> button in your trusty
        editor.</p>

        <p>But this will overwrite the old version. It’s like those
        old school games which only had one save slot: sure you
        could save, but you could never go back to an older state.
        Which was a shame, because your previous save might have
        been right at an exceptionally fun part of the game that
        you’d like to revisit one day. Or worse still, your current
        save is in an unwinnable state, and you have to start
        again.</p>
      </div>

      <div class="section" title="Version Control">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_version_control"></a>Version Control</h2>
            </div>
          </div>
        </div>

        <p>When editing, you can <span class="emphasis"><em>Save
        As…</em></span> a different file, or copy the file
        somewhere first before saving if you want to savour old
        versions. You can compress them too to save space. This is
        a primitive and labour-intensive form of version control.
        Computer games improved on this long ago, many of them
        providing multiple automatically timestamped save
        slots.</p>

        <p>Let’s make the problem slightly tougher. Say you have a
        bunch of files that go together, such as source code for a
        project, or files for a website. Now if you want to keep an
        old version you have to archive a whole directory. Keeping
        many versions around by hand is inconvenient, and quickly
        becomes expensive.</p>

        <p>With some computer games, a saved game really does
        consist of a directory full of files. These games hide this
        detail from the player and present a convenient interface
        to manage different versions of this directory.</p>

        <p>Version control systems are no different. They all have
        nice interfaces to manage a directory of stuff. You can
        save the state of the directory every so often, and you can
        load any one of the saved states later on. Unlike most
        computer games, they’re usually smart about conserving
        space. Typically, only a few files change from version to
        version, and not by much. Storing the differences instead
        of entire new copies saves room.</p>
      </div>

      <div class="section" title="Distributed Control">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_distributed_control"></a>Distributed Control</h2>
            </div>
          </div>
        </div>

        <p>Now imagine a very difficult computer game. So difficult
        to finish that many experienced gamers all over the world
        decide to team up and share their saved games to try to
        beat it. Speedruns are real-life examples: players
        specializing in different levels of the same game
        collaborate to produce amazing results.</p>

        <p>How would you set up a system so they can get at each
        other’s saves easily? And upload new ones?</p>

        <p>In the old days, every project used centralized version
        control. A server somewhere held all the saved games.
        Nobody else did. Every player kept at most a few saved
        games on their machine. When a player wanted to make
        progress, they’d download the latest save from the main
        server, play a while, save and upload back to the server
        for everyone else to use.</p>

        <p>What if a player wanted to get an older saved game for
        some reason? Maybe the current saved game is in an
        unwinnable state because somebody forgot to pick up an
        object back in level three, and they want to find the
        latest saved game where the game can still be completed. Or
        maybe they want to compare two older saved games to see how
        much work a particular player did.</p>

        <p>There could be many reasons to want to see an older
        revision, but the outcome is the same. They have to ask the
        central server for that old saved game. The more saved
        games they want, the more they need to communicate.</p>

        <p>The new generation of version control systems, of which
        Git is a member, are known as distributed systems, and can
        be thought of as a generalization of centralized systems.
        When players download from the main server they get every
        saved game, not just the latest one. It’s as if they’re
        mirroring the central server.</p>

        <p>This initial cloning operation can be expensive,
        especially if there’s a long history, but it pays off in
        the long run. One immediate benefit is that when an old
        save is desired for any reason, communication with the
        central server is unnecessary.</p>
      </div>

      <div class="section" title="A Silly Superstition">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_a_silly_superstition"></a>A Silly Superstition</h2>
            </div>
          </div>
        </div>

        <p>A popular misconception is that distributed systems are
        ill-suited for projects requiring an official central
        repository. Nothing could be further from the truth.
        Photographing someone does not cause their soul to be
        stolen. Similarly, cloning the master repository does not
        diminish its importance.</p>

        <p>A good first approximation is that anything a
        centralized version control system can do, a well-designed
        distributed system can do better. Network resources are
        simply costlier than local resources. While we shall later
        see there are drawbacks to a distributed approach, one is
        less likely to make erroneous comparisons with this rule of
        thumb.</p>

        <p>A small project may only need a fraction of the features
        offered by such a system, but using systems that scale
        poorly for tiny projects is like using Roman numerals for
        calculations involving small numbers.</p>

        <p>Moreover, your project may grow beyond your original
        expectations. Using Git from the outset is like carrying a
        Swiss army knife even though you mostly use it to open
        bottles. On the day you desperately need a screwdriver
        you’ll be glad you have more than a plain
        bottle-opener.</p>
      </div>

      <div class="section" title="Merge Conflicts">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_merge_conflicts"></a>Merge Conflicts</h2>
            </div>
          </div>
        </div>

        <p>For this topic, our computer game analogy becomes too
        thinly stretched. Instead, let us again consider editing a
        document.</p>

        <p>Suppose Alice inserts a line at the beginning of a file,
        and Bob appends one at the end of his copy. They both
        upload their changes. Most systems will automatically
        deduce a reasonable course of action: accept and merge
        their changes, so both Alice’s and Bob’s edits are
        applied.</p>

        <p>Now suppose both Alice and Bob have made distinct edits
        to the same line. Then it is impossible to proceed without
        human intervention. The second person to upload is informed
        of a <span class="emphasis"><em>merge conflict</em></span>,
        and must choose one edit over another, or revise the line
        entirely.</p>

        <p>More complex situations can arise. Version control
        systems handle the simpler cases themselves, and leave the
        difficult cases for humans. Usually their behaviour is
        configurable.</p>
      </div>
    </div>

    <div class="chapter" title="Chapter&nbsp;2.&nbsp;Basic Tricks">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_basic_tricks"></a>Chapter&nbsp;2.&nbsp;Basic
            Tricks</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_saving_state">Saving
          State</a></span></dt>

          <dt><span class="section"><a href=
          "#_add_delete_rename">Add, Delete, Rename</a></span></dt>

          <dt><span class="section"><a href=
          "#_advanced_undo_redo">Advanced Undo/Redo</a></span></dt>

          <dt><span class="section"><a href=
          "#_reverting">Reverting</a></span></dt>

          <dt><span class="section"><a href=
          "#_changelog_generation">Changelog
          Generation</a></span></dt>

          <dt><span class="section"><a href=
          "#_downloading_files">Downloading Files</a></span></dt>

          <dt><span class="section"><a href=
          "#_the_bleeding_edge">The Bleeding Edge</a></span></dt>

          <dt><span class="section"><a href=
          "#_instant_publishing">Instant Publishing</a></span></dt>

          <dt><span class="section"><a href=
          "#_what_have_i_done">What Have I Done?</a></span></dt>

          <dt><span class="section"><a href=
          "#_exercise">Exercise</a></span></dt>
        </dl>
      </div>

      <p>Rather than diving into a sea of Git commands, use these
      elementary examples to get your feet wet. Despite their
      simplicity, each of them are useful. Indeed, in my first
      months with Git I never ventured beyond the material in this
      chapter.</p>

      <div class="section" title="Saving State">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_saving_state"></a>Saving State</h2>
            </div>
          </div>
        </div>

        <p>About to attempt something drastic? Before you do, take
        a snapshot of all files in the current directory with:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "My first backup"
</pre>

        <p>Now if your new edits go awry, restore the pristine
        version:</p>
        <pre class="literallayout">
$ git reset --hard
</pre>

        <p>To save the state again:</p>
        <pre class="literallayout">
$ git commit -a -m "Another backup"
</pre>
      </div>

      <div class="section" title="Add, Delete, Rename">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_add_delete_rename"></a>Add, Delete, Rename</h2>
            </div>
          </div>
        </div>

        <p>The above only keeps track of the files that were
        present when you first ran <span class="strong"><strong>git
        add</strong></span>. If you add new files or
        subdirectories, you’ll have to tell Git:</p>
        <pre class="literallayout">
$ git add readme.txt Documentation
</pre>

        <p>Similarly, if you want Git to forget about certain
        files:</p>
        <pre class="literallayout">
$ git rm kludge.h obsolete.c
$ git rm -r incriminating/evidence/
</pre>

        <p>Git deletes these files for you if you haven’t
        already.</p>

        <p>Renaming a file is the same as removing the old name and
        adding the new name. There’s also the shortcut <span class=
        "strong"><strong>git mv</strong></span> which has the same
        syntax as the <span class=
        "strong"><strong>mv</strong></span> command. For
        example:</p>
        <pre class="literallayout">
$ git mv bug.c feature.c
</pre>
      </div>

      <div class="section" title="Advanced Undo/Redo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_advanced_undo_redo"></a>Advanced Undo/Redo</h2>
            </div>
          </div>
        </div>

        <p>Sometimes you just want to go back and forget about
        every change past a certain point because they’re all
        wrong. Then:</p>
        <pre class="literallayout">
$ git log
</pre>

        <p>shows you a list of recent commits, and their SHA1
        hashes:</p>
        <pre class="screen">
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob &lt;bob@example.com&gt;
Date:   Tue Mar 14 01:59:26 2000 -0800

    Replace printf() with write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice &lt;alice@example.com&gt;
Date:   Thu Jan 1 00:00:00 1970 +0000

    Initial commit.
</pre>

        <p>The first few characters of the hash are enough to
        specify the commit; alternatively, copy and paste the
        entire hash. Type:</p>
        <pre class="literallayout">
$ git reset --hard 766f
</pre>

        <p>to restore the state to a given commit and erase all
        newer commits from the record permanently.</p>

        <p>Other times you want to hop to an old state briefly. In
        this case, type:</p>
        <pre class="literallayout">
$ git checkout 82f5
</pre>

        <p>This takes you back in time, while preserving newer
        commits. However, like time travel in a science-fiction
        movie, if you now edit and commit, you will be in an
        alternate reality, because your actions are different to
        what they were the first time around.</p>

        <p>This alternate reality is called a <span class=
        "emphasis"><em>branch</em></span>, and <a class="link"
        href="#branch">we’ll have more to say about this later</a>.
        For now, just remember that</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>will take you back to the present. Also, to stop Git
        complaining, always commit or reset your changes before
        running checkout.</p>

        <p>To take the computer game analogy again:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git reset
            --hard</code></strong></span>: load an old save and
            delete all saved games newer than the one just
            loaded.</li>

            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git
            checkout</code></strong></span>: load an old game, but
            if you play on, the game state will deviate from the
            newer saves you made the first time around. Any saved
            games you make now will end up in a separate branch
            representing the alternate reality you have entered.
            <a class="link" href="#branch">We deal with this
            later</a>.</li>
          </ul>
        </div>

        <p>You can choose only to restore particular files and
        subdirectories by appending them after the command:</p>
        <pre class="literallayout">
$ git checkout 82f5 some.file another.file
</pre>

        <p>Take care, as this form of <span class=
        "strong"><strong>checkout</strong></span> can silently
        overwrite files. To prevent accidents, commit before
        running any checkout command, especially when first
        learning Git. In general, whenever you feel unsure about
        any operation, Git command or not, first run <span class=
        "strong"><strong>git commit -a</strong></span>.</p>

        <p>Don’t like cutting and pasting hashes? Then use:</p>
        <pre class="literallayout">
$ git checkout :/"My first b"
</pre>

        <p>to jump to the commit that starts with a given message.
        You can also ask for the 5th-last saved state:</p>
        <pre class="literallayout">
$ git checkout master~5
</pre>
      </div>

      <div class="section" title="Reverting">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_reverting"></a>Reverting</h2>
            </div>
          </div>
        </div>

        <p>In a court of law, events can be stricken from the
        record. Likewise, you can pick specific commits to
        undo.</p>
        <pre class="literallayout">
$ git commit -a
$ git revert 1b6d
</pre>

        <p>will undo just the commit with the given hash. The
        revert is recorded as a new commit, which you can confirm
        by running <span class="strong"><strong>git
        log</strong></span>.</p>
      </div>

      <div class="section" title="Changelog Generation">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_changelog_generation"></a>Changelog Generation</h2>
            </div>
          </div>
        </div>

        <p>Some projects require a <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Changelog" target=
        "_top">changelog</a>. Generate one by typing:</p>
        <pre class="literallayout">
$ git log &gt; ChangeLog
</pre>
      </div>

      <div class="section" title="Downloading Files">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_downloading_files"></a>Downloading Files</h2>
            </div>
          </div>
        </div>

        <p>Get a copy of a project managed with Git by typing:</p>
        <pre class="literallayout">
$ git clone git://server/path/to/files
</pre>

        <p>For example, to get all the files I used to create this
        site:</p>
        <pre class="literallayout">
$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>We’ll have much to say about the <span class=
        "strong"><strong>clone</strong></span> command soon.</p>
      </div>

      <div class="section" title="The Bleeding Edge">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_the_bleeding_edge"></a>The Bleeding Edge</h2>
            </div>
          </div>
        </div>

        <p>If you’ve already downloaded a copy of a project using
        <span class="strong"><strong>git clone</strong></span>, you
        can upgrade to the latest version with:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Instant Publishing">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_instant_publishing"></a>Instant Publishing</h2>
            </div>
          </div>
        </div>

        <p>Suppose you’ve written a script you’d like to share with
        others. You could just tell them to download from your
        computer, but if they do so while you’re improving the
        script or making experimental changes, they could wind up
        in trouble. Of course, this is why release cycles exist.
        Developers may work on a project frequently, but they only
        make the code available when they feel it is
        presentable.</p>

        <p>To do this with Git, in the directory where your script
        resides:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "First release"
</pre>

        <p>Then tell your users to run:</p>
        <pre class="literallayout">
$ git clone your.computer:/path/to/script
</pre>

        <p>to download your script. This assumes they have ssh
        access. If not, run <span class="strong"><strong>git
        daemon</strong></span> and tell your users to instead
        run:</p>
        <pre class="literallayout">
$ git clone git://your.computer/path/to/script
</pre>

        <p>From now on, every time your script is ready for
        release, execute:</p>
        <pre class="literallayout">
$ git commit -a -m "Next release"
</pre>

        <p>and your users can upgrade their version by changing to
        the directory containing your script and typing:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Your users will never end up with a version of your
        script you don’t want them to see.</p>
      </div>

      <div class="section" title="What Have I Done?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_what_have_i_done"></a>What Have I Done?</h2>
            </div>
          </div>
        </div>

        <p>Find out what changes you’ve made since the last commit
        with:</p>
        <pre class="literallayout">
$ git diff
</pre>

        <p>Or since yesterday:</p>
        <pre class="literallayout">
$ git diff "@{yesterday}"
</pre>

        <p>Or between a particular version and 2 versions ago:</p>
        <pre class="literallayout">
$ git diff 1b6d "master~2"
</pre>

        <p>In each case the output is a patch that can be applied
        with <span class="strong"><strong>git
        apply</strong></span>. Try also:</p>
        <pre class="literallayout">
$ git whatchanged --since="2 weeks ago"
</pre>

        <p>Often I’ll browse history with <a class="ulink" href=
        "http://sourceforge.net/projects/qgit" target=
        "_top">qgit</a> instead, due to its slick photogenic
        interface, or <a class="ulink" href=
        "http://jonas.nitro.dk/tig/" target="_top">tig</a>, a
        text-mode interface that works well over slow connections.
        Alternatively, install a web server, run <span class=
        "strong"><strong>git instaweb</strong></span> and fire up
        any web browser.</p>
      </div>

      <div class="section" title="Exercise">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_exercise"></a>Exercise</h2>
            </div>
          </div>
        </div>

        <p>Let A, B, C, D be four successive commits where B is the
        same as A except some files have been removed. We want to
        add the files back at D. How can we do this?</p>

        <p>There are at least three solutions. Assuming we are at
        D:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">The difference between A and B are
              the removed files. We can create a patch representing
              this difference and apply it:</p>
              <pre class="literallayout">
$ git diff B A | git apply
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Since we saved the files back at
              A, we can retrieve them:</p>
              <pre class="literallayout">
$ git checkout A foo.c bar.h
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">We can view going from A to B as a
              change we want to undo:</p>
              <pre class="literallayout">
$ git revert B
</pre>
            </li>
          </ol>
        </div>

        <p>Which choice is best? Whichever you prefer most. It is
        easy to get what you want with Git, and often there are
        many ways to get it.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;3.&nbsp;Cloning Around">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_cloning_around"></a>Chapter&nbsp;3.&nbsp;Cloning
            Around</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_sync_computers">Sync
          Computers</a></span></dt>

          <dt><span class="section"><a href=
          "#_classic_source_control">Classic Source
          Control</a></span></dt>

          <dt><span class="section"><a href=
          "#_secret_source">Secret Source</a></span></dt>

          <dt><span class="section"><a href=
          "#_bare_repositories">Bare repositories</a></span></dt>

          <dt><span class="section"><a href=
          "#_push_versus_pull">Push versus pull</a></span></dt>

          <dt><span class="section"><a href=
          "#_forking_a_project">Forking a Project</a></span></dt>

          <dt><span class="section"><a href=
          "#_ultimate_backups">Ultimate Backups</a></span></dt>

          <dt><span class="section"><a href=
          "#_light_speed_multitask">Light-Speed
          Multitask</a></span></dt>

          <dt><span class="section"><a href=
          "#_guerilla_version_control">Guerilla Version
          Control</a></span></dt>

          <dt><span class="section"><a href=
          "#_mercurial">Mercurial</a></span></dt>

          <dt><span class="section"><a href=
          "#_bazaar">Bazaar</a></span></dt>

          <dt><span class="section"><a href="#_why_i_use_git">Why I
          use Git</a></span></dt>
        </dl>
      </div>

      <p>In older version control systems, checkout is the standard
      operation to get files. You retrieve a bunch of files in a
      particular saved state.</p>

      <p>In Git and other distributed version control systems,
      cloning is the standard operation. To get files, you create a
      <span class="emphasis"><em>clone</em></span> of the entire
      repository. In other words, you practically mirror the
      central server. Anything the main repository can do, you can
      do.</p>

      <div class="section" title="Sync Computers">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_sync_computers"></a>Sync Computers</h2>
            </div>
          </div>
        </div>

        <p>I can tolerate making tarballs or using <span class=
        "strong"><strong>rsync</strong></span> for backups and
        basic syncing. But sometimes I edit on my laptop, other
        times on my desktop, and the two may not have talked to
        each other in between.</p>

        <p>Initialize a Git repository and commit your files on one
        machine. Then on the other:</p>
        <pre class="literallayout">
$ git clone other.computer:/path/to/files
</pre>

        <p>to create a second copy of the files and Git repository.
        From now on,</p>
        <pre class="literallayout">
$ git commit -a
$ git pull other.computer:/path/to/files HEAD
</pre>

        <p>will <span class="emphasis"><em>pull</em></span> in the
        state of the files on the other computer into the one
        you’re working on. If you’ve recently made conflicting
        edits in the same file, Git will let you know and you
        should commit again after resolving them.</p>
      </div>

      <div class="section" title="Classic Source Control">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_classic_source_control"></a>Classic Source
              Control</h2>
            </div>
          </div>
        </div>

        <p>Initialize a Git repository for your files:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>On the central server, initialize a <span class=
        "emphasis"><em>bare repository</em></span> in some
        directory:</p>
        <pre class="literallayout">
$ mkdir proj.git
$ cd proj.git
$ git --bare init
$ touch proj.git/git-daemon-export-ok
</pre>

        <p>Start the Git daemon if necessary:</p>
        <pre class="literallayout">
$ git daemon --detach  # it may already be running
</pre>

        <p>For Git hosting services, follow the instructions to
        setup the initially empty Git repository. Typically one
        fills in a form on a webpage.</p>

        <p><span class="emphasis"><em>Push</em></span> your project
        to the central server with:</p>
        <pre class="literallayout">
$ git push central.server/path/to/proj.git HEAD
</pre>

        <p>To check out the source, a developer types:</p>
        <pre class="literallayout">
$ git clone central.server/path/to/proj.git
</pre>

        <p>After making changes, the developer saves changes
        locally:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>To update to the latest version:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Any merge conflicts should be resolved then
        committed:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>To check in local changes into the central
        repository:</p>
        <pre class="literallayout">
$ git push
</pre>

        <p>If the main server has new changes due to activity by
        other developers, the push fails, and the developer should
        pull the latest version, resolve any merge conflicts, then
        try again.</p>

        <p>Developers must have SSH access for the above pull and
        push commands. However, anyone can see the source by
        typing:</p>
        <pre class="literallayout">
$ git clone git://central.server/path/to/proj.git
</pre>

        <p>The native git protocol is like HTTP: there is no
        authentication, so anyone can retrieve the project.
        Accordingly, by default, pushing is forbidden via the git
        protocol.</p>
      </div>

      <div class="section" title="Secret Source">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_secret_source"></a>Secret Source</h2>
            </div>
          </div>
        </div>

        <p>For a closed-source project, omit the touch command, and
        ensure you never create a file named <code class=
        "literal">git-daemon-export-ok</code>. The repository can
        no longer be retrieved via the git protocol; only those
        with SSH access can see it. If all your repos are closed,
        running the git daemon is unnecessary because all
        communication occurs via SSH.</p>
      </div>

      <div class="section" title="Bare repositories">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bare_repositories"></a>Bare repositories</h2>
            </div>
          </div>
        </div>

        <p>A bare repository is so named because it has no working
        directory; it only contains files that are normally hidden
        away in the <code class="literal">.git</code> subdirectory.
        In other words, it maintains the history of a project, and
        never holds a snapshot of any given version.</p>

        <p>A bare repository plays a role similar to that of the
        main server in a centralized version control system: the
        home of your project. Developers clone your project from
        it, and push the latest official changes to it. Typically
        it resides on a server that does little else but
        disseminate data. Development occurs in the clones, so the
        home repository can do without a working directory.</p>

        <p>Many Git commands fail on bare repositories unless the
        <code class="literal">GIT_DIR</code> environment variable
        is set to the repository path, or the <code class=
        "literal">--bare</code> option is supplied.</p>
      </div>

      <div class="section" title="Push versus pull">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_push_versus_pull"></a>Push versus pull</h2>
            </div>
          </div>
        </div>

        <p>Why did we introduce the push command, rather than rely
        on the familiar pull command? Firstly, pulling fails on
        bare repositories: instead you must <span class=
        "emphasis"><em>fetch</em></span>, a command we later
        discuss. But even if we kept a normal repository on the
        central server, pulling into it would still be cumbersome.
        We would have to login to the server first, and give the
        pull command the network address of the machine we’re
        pulling from. Firewalls may interfere, and what if we have
        no shell access to the server in the first place?</p>

        <p>However, apart from this case, we discourage pushing
        into a repository, because confusion can ensue when the
        destination has a working directory.</p>

        <p>In short, while learning Git, only push when the target
        is a bare repository; otherwise pull.</p>
      </div>

      <div class="section" title="Forking a Project">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_forking_a_project"></a>Forking a Project</h2>
            </div>
          </div>
        </div>

        <p>Sick of the way a project is being run? Think you could
        do a better job? Then on your server:</p>
        <pre class="literallayout">
$ git clone git://main.server/path/to/files
</pre>

        <p>Next, tell everyone about your fork of the project at
        your server.</p>

        <p>At any later time, you can merge in the changes from the
        original project with:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Ultimate Backups">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ultimate_backups"></a>Ultimate Backups</h2>
            </div>
          </div>
        </div>

        <p>Want numerous tamper-proof geographically diverse
        redundant archives? If your project has many developers,
        don’t do anything! Every clone of your code is effectively
        a backup. Not just of the current state, but of your
        project’s entire history. Thanks to cryptographic hashing,
        if anyone’s clone becomes corrupted, it will be spotted as
        soon as they try to communicate with others.</p>

        <p>If your project is not so popular, find as many servers
        as you can to host clones.</p>

        <p>The truly paranoid should always write down the latest
        20-byte SHA1 hash of the HEAD somewhere safe. It has to be
        safe, not private. For example, publishing it in a
        newspaper would work well, because it’s hard for an
        attacker to alter every copy of a newspaper.</p>
      </div>

      <div class="section" title="Light-Speed Multitask">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_light_speed_multitask"></a>Light-Speed
              Multitask</h2>
            </div>
          </div>
        </div>

        <p>Say you want to work on several features in parallel.
        Then commit your project and run:</p>
        <pre class="literallayout">
$ git clone . /some/new/directory
</pre>

        <p>Thanks to <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Hard_link" target=
        "_top">hardlinking</a>, local clones require less time and
        space than a plain backup.</p>

        <p>You can now work on two independent features
        simultaneously. For example, you can edit one clone while
        the other is compiling. At any time, you can commit and
        pull changes from the other clone:</p>
        <pre class="literallayout">
$ git pull /the/other/clone HEAD
</pre>
      </div>

      <div class="section" title="Guerilla Version Control">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_guerilla_version_control"></a>Guerilla Version
              Control</h2>
            </div>
          </div>
        </div>

        <p>Are you working on a project that uses some other
        version control system, and you sorely miss Git? Then
        initialize a Git repository in your working directory:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>then clone it:</p>
        <pre class="literallayout">
$ git clone . /some/new/directory
</pre>

        <p>Now go to the new directory and work here instead, using
        Git to your heart’s content. Once in a while, you’ll want
        to sync with everyone else, in which case go to the
        original directory, sync using the other version control
        system, and type:</p>
        <pre class="literallayout">
$ git add .
$ git commit -m "Sync with everyone else"
</pre>

        <p>Then go to the new directory and run:</p>
        <pre class="literallayout">
$ git commit -a -m "Description of my changes"
$ git pull
</pre>

        <p>The procedure for giving your changes to everyone else
        depends on the other version control system. The new
        directory contains the files with your changes. Run
        whatever commands of the other version control system are
        needed to upload them to the central repository.</p>

        <p>Subversion, perhaps the best centralized version control
        system, is used by countless projects. The <span class=
        "strong"><strong>git svn</strong></span> command automates
        the above for Subversion repositories, and can also be used
        to <a class="ulink" href=
        "http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html"
        target="_top">export a Git project to a Subversion
        repository</a>.</p>
      </div>

      <div class="section" title="Mercurial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mercurial"></a>Mercurial</h2>
            </div>
          </div>
        </div>

        <p>Mercurial is a similar version control system that can
        almost seamlessly work in tandem with Git. With the
        <code class="literal">hg-git</code> plugin, a Mercurial
        user can losslessly push to and pull from a Git
        repository.</p>

        <p>Obtain the <code class="literal">hg-git</code> plugin
        with Git:</p>
        <pre class="literallayout">
$ git clone git://github.com/schacon/hg-git.git
</pre>

        <p>or Mercurial:</p>
        <pre class="literallayout">
$ hg clone http://bitbucket.org/durin42/hg-git/
</pre>

        <p>Sadly, I am unaware of an analogous plugin for Git. For
        this reason, I advocate Git over Mercurial for the main
        repository, even if you prefer Mercurial. With a Mercurial
        project, usually a volunteer maintains a parallel Git
        repository to accommodate Git users, whereas thanks to the
        <code class="literal">hg-git</code> plugin, a Git project
        automatically accommodates Mercurial users.</p>

        <p>Although the plugin can convert a Mercurial repository
        to a Git repository by pushing to an empty repository, this
        job is easier with the <code class=
        "literal">hg-fast-export.sh</code> script, available
        from:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/fast-export.git
</pre>

        <p>To convert, in an empty directory:</p>
        <pre class="literallayout">
$ git init
$ hg-fast-export.sh -r /hg/repo
</pre>

        <p>after adding the script to your <code class=
        "literal">$PATH</code>.</p>
      </div>

      <div class="section" title="Bazaar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bazaar"></a>Bazaar</h2>
            </div>
          </div>
        </div>

        <p>We briefly mention Bazaar because it is the most popular
        free distributed version control system after Git and
        Mercurial.</p>

        <p>Bazaar has the advantage of hindsight, as it is
        relatively young; its designers could learn from mistakes
        of the past, and sidestep minor historical warts.
        Additionally, its developers are mindful of portability and
        interoperation with other version control systems.</p>

        <p>A <code class="literal">bzr-git</code> plugin lets
        Bazaar users work with Git repositories to some extent. The
        <code class="literal">tailor</code> program converts Bazaar
        repositories to Git repositories, and can do so
        incrementally, while <code class=
        "literal">bzr-fast-export</code> is well-suited for
        one-shot conversions.</p>
      </div>

      <div class="section" title="Why I use Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_why_i_use_git"></a>Why I use Git</h2>
            </div>
          </div>
        </div>

        <p>I originally chose Git because I heard it could manage
        the unimaginably unmanageable Linux kernel source. I’ve
        never felt a need to switch. Git has served admirably, and
        I’ve yet to be bitten by its flaws. As I primarily use
        Linux, issues on other platforms are of no concern.</p>

        <p>Also, I prefer C programs and bash scripts to
        executables such as Python scripts: there are fewer
        dependencies, and I’m addicted to fast running times.</p>

        <p>I did think about how Git could be improved, going so
        far as to write my own Git-like tool, but only as an
        academic exercise. Had I completed my project, I would have
        stayed with Git anyway, as the gains are too slight to
        justify using an oddball system.</p>

        <p>Naturally, your needs and wants likely differ, and you
        may be better off with another system. Nonetheless, you
        can’t go far wrong with Git.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;4.&nbsp;Branch Wizardry">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_branch_wizardry"></a>Chapter&nbsp;4.&nbsp;Branch
            Wizardry</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_the_boss_key">The
          Boss Key</a></span></dt>

          <dt><span class="section"><a href="#_dirty_work">Dirty
          Work</a></span></dt>

          <dt><span class="section"><a href="#_quick_fixes">Quick
          Fixes</a></span></dt>

          <dt><span class="section"><a href=
          "#_merging">Merging</a></span></dt>

          <dt><span class="section"><a href=
          "#_uninterrupted_workflow">Uninterrupted
          Workflow</a></span></dt>

          <dt><span class="section"><a href=
          "#_reorganizing_a_medley">Reorganizing a
          Medley</a></span></dt>

          <dt><span class="section"><a href=
          "#_managing_branches">Managing Branches</a></span></dt>

          <dt><span class="section"><a href=
          "#_temporary_branches">Temporary Branches</a></span></dt>

          <dt><span class="section"><a href=
          "#_work_how_you_want">Work How You Want</a></span></dt>
        </dl>
      </div>

      <p>Instant branching and merging are the most lethal of Git’s
      killer features.</p>

      <p><span class="strong"><strong>Problem</strong></span>:
      External factors inevitably necessitate context switching. A
      severe bug manifests in the released version without warning.
      The deadline for a certain feature is moved closer. A
      developer whose help you need for a key section of the
      project is about to leave. In all cases, you must abruptly
      drop what you are doing and focus on a completely different
      task.</p>

      <p>Interrupting your train of thought can be detrimental to
      your productivity, and the more cumbersome it is to switch
      contexts, the greater the loss. With centralized version
      control we must download a fresh working copy from the
      central server. Distributed systems fare better, as we can
      clone the desired version locally.</p>

      <p>But cloning still entails copying the whole working
      directory as well as the entire history up to the given
      point. Even though Git reduces the cost of this with file
      sharing and hard links, the project files themselves must be
      recreated in their entirety in the new working directory.</p>

      <p><span class="strong"><strong>Solution</strong></span>: Git
      has a better tool for these situations that is much faster
      and more space-efficient than cloning: <span class=
      "strong"><strong>git branch</strong></span>.</p>

      <p>With this magic word, the files in your directory suddenly
      shapeshift from one version to another. This transformation
      can do more than merely go back or forward in history. Your
      files can morph from the last release to the experimental
      version to the current development version to your friend’s
      version and so on.</p>

      <div class="section" title="The Boss Key">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_the_boss_key"></a>The Boss Key</h2>
            </div>
          </div>
        </div>

        <p>Ever played one of those games where at the push of a
        button (“the boss key”), the screen would instantly display
        a spreadsheet or something? So if the boss walked in the
        office while you were playing the game you could quickly
        hide it away?</p>

        <p>In some directory:</p>
        <pre class="literallayout">
$ echo "I'm smarter than my boss" &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>We have created a Git repository that tracks one text
        file containing a certain message. Now type:</p>
        <pre class="literallayout">
$ git checkout -b boss  # nothing seems to change after this
$ echo "My boss is smarter than me" &gt; myfile.txt
$ git commit -a -m "Another commit"
</pre>

        <p>It looks like we’ve just overwritten our file and
        committed it. But it’s an illusion. Type:</p>
        <pre class="literallayout">
$ git checkout master  # switch to original version of the file
</pre>

        <p>and hey presto! The text file is restored. And if the
        boss decides to snoop around this directory, type:</p>
        <pre class="literallayout">
$ git checkout boss  # switch to version suitable for boss' eyes
</pre>

        <p>You can switch between the two versions of the file as
        much as you like, and commit to each independently.</p>
      </div>

      <div class="section" title="Dirty Work">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_dirty_work"></a>Dirty Work</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a>Say you’re working on
        some feature, and for some reason, you need to go back
        three versions and temporarily put in a few print
        statements to see how something works. Then:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout HEAD~3
</pre>

        <p>Now you can add ugly temporary code all over the place.
        You can even commit these changes. When you’re done,</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>to return to your original work. Observe that any
        uncommitted changes are carried over.</p>

        <p>What if you wanted to save the temporary changes after
        all? Easy:</p>
        <pre class="literallayout">
$ git checkout -b dirty
</pre>

        <p>and commit before switching back to the master branch.
        Whenever you want to return to the dirty changes, simply
        type:</p>
        <pre class="literallayout">
$ git checkout dirty
</pre>

        <p>We touched upon this command in an earlier chapter, when
        discussing loading old states. At last we can tell the
        whole story: the files change to the requested state, but
        we must leave the master branch. Any commits made from now
        on take your files down a different road, which can be
        named later.</p>

        <p>In other words, after checking out an old state, Git
        automatically puts you in a new, unnamed branch, which can
        be named and saved with <span class="strong"><strong>git
        checkout -b</strong></span>.</p>
      </div>

      <div class="section" title="Quick Fixes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_quick_fixes"></a>Quick Fixes</h2>
            </div>
          </div>
        </div>

        <p>You’re in the middle of something when you are told to
        drop everything and fix a newly discovered bug in commit
        <code class="literal">1b6d...</code>:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout -b fixes 1b6d
</pre>

        <p>Then once you’ve fixed the bug:</p>
        <pre class="literallayout">
$ git commit -a -m "Bug fixed"
$ git checkout master
</pre>

        <p>and resume work on your original task. You can even
        <span class="emphasis"><em>merge</em></span> in the freshly
        baked bugfix:</p>
        <pre class="literallayout">
$ git merge fixes
</pre>
      </div>

      <div class="section" title="Merging">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_merging"></a>Merging</h2>
            </div>
          </div>
        </div>

        <p>With some version control systems, creating branches is
        easy but merging them back together is tough. With Git,
        merging is so trivial that you might be unaware of it
        happening.</p>

        <p>We actually encountered merging long ago. The
        <span class="strong"><strong>pull</strong></span> command
        in fact <span class="emphasis"><em>fetches</em></span>
        commits and then merges them into your current branch. If
        you have no local changes, then the merge is a <span class=
        "emphasis"><em>fast forward</em></span>, a degenerate case
        akin to fetching the latest version in a centralized
        version control system. But if you do have local changes,
        Git will automatically merge, and report any conflicts.</p>

        <p>Ordinarily, a commit has exactly one <span class=
        "emphasis"><em>parent commit</em></span>, namely, the
        previous commit. Merging branches together produces a
        commit with at least two parents. This begs the question:
        what commit does <code class="literal">HEAD~10</code>
        really refer to? A commit could have multiple parents, so
        which one do we follow?</p>

        <p>It turns out this notation chooses the first parent
        every time. This is desirable because the current branch
        becomes the first parent during a merge; frequently you’re
        only concerned with the changes you made in the current
        branch, as opposed to changes merged in from other
        branches.</p>

        <p>You can refer to a specific parent with a caret. For
        example, to show the logs from the second parent:</p>
        <pre class="literallayout">
$ git log HEAD^2
</pre>

        <p>You may omit the number for the first parent. For
        example, to show the differences with the first parent:</p>
        <pre class="literallayout">
$ git diff HEAD^
</pre>

        <p>You can combine this notation with other types. For
        example:</p>
        <pre class="literallayout">
$ git checkout 1b6d^^2~10 -b ancient
</pre>

        <p>starts a new branch “ancient” representing the state 10
        commits back from the second parent of the first parent of
        the commit starting with 1b6d.</p>
      </div>

      <div class="section" title="Uninterrupted Workflow">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_uninterrupted_workflow"></a>Uninterrupted
              Workflow</h2>
            </div>
          </div>
        </div>

        <p>Often in hardware projects, the second step of a plan
        must await the completion of the first step. A car
        undergoing repairs might sit idly in a garage until a
        particular part arrives from the factory. A prototype might
        wait for a chip to be fabricated before construction can
        continue.</p>

        <p>Software projects can be similar. The second part of a
        new feature may have to wait until the first part has been
        released and tested. Some projects require your code to be
        reviewed before accepting it, so you might wait until the
        first part is approved before starting the second part.</p>

        <p>Thanks to painless branching and merging, we can bend
        the rules and work on Part II before Part I is officially
        ready. Suppose you have committed Part I and sent it for
        review. Let’s say you’re in the <code class=
        "literal">master</code> branch. Then branch off:</p>
        <pre class="literallayout">
$ git checkout -b part2
</pre>

        <p>Next, work on Part II, committing your changes along the
        way. To err is human, and often you’ll want to go back and
        fix something in Part I. If you’re lucky, or very good, you
        can skip these lines.</p>
        <pre class="literallayout">
$ git checkout master  # Go back to Part I.
$ fix_problem
$ git commit -a        # Commit the fixes.
$ git checkout part2   # Go back to Part II.
$ git merge master     # Merge in those fixes.
</pre>

        <p>Eventually, Part I is approved:</p>
        <pre class="literallayout">
$ git checkout master  # Go back to Part I.
$ submit files         # Release to the world!
$ git merge part2      # Merge in Part II.
$ git branch -d part2  # Delete "part2" branch.
</pre>

        <p>Now you’re in the <code class="literal">master</code>
        branch again, with Part II in the working directory.</p>

        <p>It’s easy to extend this trick for any number of parts.
        It’s also easy to branch off retroactively: suppose you
        belatedly realize you should have created a branch 7
        commits ago. Then type:</p>
        <pre class="literallayout">
$ git branch -m master part2  # Rename "master" branch to "part2".
$ git branch master HEAD~7    # Create new "master", 7 commits upstream.
</pre>

        <p>The <code class="literal">master</code> branch now
        contains just Part I, and the <code class=
        "literal">part2</code> branch contains the rest. We are in
        the latter branch; we created <code class=
        "literal">master</code> without switching to it, because we
        want to continue work on <code class=
        "literal">part2</code>. This is unusual. Until now, we’ve
        been switching to branches immediately after creation, as
        in:</p>
        <pre class="literallayout">
$ git checkout HEAD~7 -b master  # Create a branch, and switch to it.
</pre>
      </div>

      <div class="section" title="Reorganizing a Medley">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_reorganizing_a_medley"></a>Reorganizing a
              Medley</h2>
            </div>
          </div>
        </div>

        <p>Perhaps you like to work on all aspects of a project in
        the same branch. You want to keep works-in-progress to
        yourself and want others to see your commits only when they
        have been neatly organized. Start a couple of branches:</p>
        <pre class="literallayout">
$ git branch sanitized    # Create a branch for sanitized commits.
$ git checkout -b medley  # Create and switch to a branch to work in.
</pre>

        <p>Next, work on anything: fix bugs, add features, add
        temporary code, and so forth, committing often along the
        way. Then:</p>
        <pre class="literallayout">
$ git checkout sanitized
$ git cherry-pick medley^^
</pre>

        <p>applies the grandparent of the head commit of the
        “medley” branch to the “sanitized” branch. With appropriate
        cherry-picks you can construct a branch that contains only
        permanent code, and has related commits grouped
        together.</p>
      </div>

      <div class="section" title="Managing Branches">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_managing_branches"></a>Managing Branches</h2>
            </div>
          </div>
        </div>

        <p>List all branches by typing:</p>
        <pre class="literallayout">
$ git branch
</pre>

        <p>By default, you start in a branch named “master”. Some
        advocate leaving the “master” branch untouched and creating
        new branches for your own edits.</p>

        <p>The <span class="strong"><strong>-d</strong></span> and
        <span class="strong"><strong>-m</strong></span> options
        allow you to delete and move (rename) branches. See
        <span class="strong"><strong>git help
        branch</strong></span>.</p>

        <p>The “master” branch is a useful custom. Others may
        assume that your repository has a branch with this name,
        and that it contains the official version of your project.
        Although you can rename or obliterate the “master” branch,
        you might as well respect this convention.</p>
      </div>

      <div class="section" title="Temporary Branches">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_temporary_branches"></a>Temporary Branches</h2>
            </div>
          </div>
        </div>

        <p>After a while you may realize you are creating
        short-lived branches frequently for similar reasons: every
        other branch merely serves to save the current state so you
        can briefly hop back to an older state to fix a
        high-priority bug or something.</p>

        <p>It’s analogous to changing the TV channel temporarily to
        see what else is on. But instead of pushing a couple of
        buttons, you have to create, check out, merge, and delete
        temporary branches. Luckily, Git has a shortcut that is as
        convenient as a TV remote control:</p>
        <pre class="literallayout">
$ git stash
</pre>

        <p>This saves the current state in a temporary location (a
        <span class="emphasis"><em>stash</em></span>) and restores
        the previous state. Your working directory appears exactly
        as it was before you started editing, and you can fix bugs,
        pull in upstream changes, and so on. When you want to go
        back to the stashed state, type:</p>
        <pre class="literallayout">
$ git stash apply  # You may need to resolve some conflicts.
</pre>

        <p>You can have multiple stashes, and manipulate them in
        various ways. See <span class="strong"><strong>git help
        stash</strong></span>. As you may have guessed, Git
        maintains branches behind the scenes to perform this magic
        trick.</p>
      </div>

      <div class="section" title="Work How You Want">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_work_how_you_want"></a>Work How You Want</h2>
            </div>
          </div>
        </div>

        <p>You might wonder if branches are worth the bother. After
        all, clones are almost as fast, and you can switch between
        them with <span class="strong"><strong>cd</strong></span>
        instead of esoteric Git commands.</p>

        <p>Consider web browsers. Why support multiple tabs as well
        as multiple windows? Because allowing both accommodates a
        wide variety of styles. Some users like to keep only one
        browser window open, and use tabs for multiple webpages.
        Others might insist on the other extreme: multiple windows
        with no tabs anywhere. Others still prefer something in
        between.</p>

        <p>Branching is like tabs for your working directory, and
        cloning is like opening a new browser window. These
        operations are fast and local, so why not experiment to
        find the combination that best suits you? Git lets you work
        exactly how you want.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;5.&nbsp;Lessons of History">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_lessons_of_history"></a>Chapter&nbsp;5.&nbsp;Lessons
            of History</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_i_stand_corrected">I
          Stand Corrected</a></span></dt>

          <dt><span class="section"><a href=
          "#_8230_and_then_some">… And Then Some</a></span></dt>

          <dt><span class="section"><a href=
          "#_local_changes_last">Local Changes Last</a></span></dt>

          <dt><span class="section"><a href=
          "#_rewriting_history">Rewriting History</a></span></dt>

          <dt><span class="section"><a href=
          "#_making_history">Making History</a></span></dt>

          <dt><span class="section"><a href=
          "#_where_did_it_all_go_wrong">Where Did It All Go
          Wrong?</a></span></dt>

          <dt><span class="section"><a href=
          "#_who_made_it_all_go_wrong">Who Made It All Go
          Wrong?</a></span></dt>

          <dt><span class="section"><a href=
          "#_personal_experience">Personal
          Experience</a></span></dt>
        </dl>
      </div>

      <p>A consequence of Git’s distributed nature is that history
      can be edited easily. But if you tamper with the past, take
      care: only rewrite that part of history which you alone
      possess. Just as nations forever argue over who committed
      what atrocity, if someone else has a clone whose version of
      history differs to yours, you will have trouble reconciling
      when your trees interact.</p>

      <p>Some developers strongly feel history should be immutable,
      warts and all. Others feel trees should be made presentable
      before they are unleashed in public. Git accommodates both
      viewpoints. Like cloning, branching, and merging, rewriting
      history is simply another power Git gives you. It is up to
      you to use it wisely.</p>

      <div class="section" title="I Stand Corrected">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_i_stand_corrected"></a>I Stand Corrected</h2>
            </div>
          </div>
        </div>

        <p>Did you just commit, but wish you had typed a different
        message? Then run:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>to change the last message. Realized you forgot to add a
        file? Run <span class="strong"><strong>git
        add</strong></span> to add it, and then run the above
        command.</p>

        <p>Want to include a few more edits in that last commit?
        Then make those edits and run:</p>
        <pre class="literallayout">
$ git commit --amend -a
</pre>
      </div>

      <div class="section" title="… And Then Some">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_8230_and_then_some"></a>… And Then Some</h2>
            </div>
          </div>
        </div>

        <p>Suppose the previous problem is ten times worse. After a
        lengthy session you’ve made a bunch of commits. But you’re
        not quite happy with the way they’re organized, and some of
        those commit messages could use rewording. Then type:</p>
        <pre class="literallayout">
$ git rebase -i HEAD~10
</pre>

        <p>and the last 10 commits will appear in your favourite
        $EDITOR. A sample excerpt:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Older commits precede newer commits in this list, unlike
        the <code class="literal">log</code> command. Here, 5c6eb73
        is the oldest commit, and 100834f is the newest. Then:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">Remove commits by deleting lines.
            Like the revert command, but off the record: it will be
            as if the commit never existed.</li>

            <li class="listitem">Reorder commits by reordering
            lines.</li>

            <li class="listitem">
              <p class="simpara">Replace <code class=
              "literal">pick</code> with:</p>

              <div class="itemizedlist">
                <ul class="itemizedlist" type="circle">
                  <li class="listitem"><code class=
                  "literal">edit</code> to mark a commit for
                  amending.</li>

                  <li class="listitem"><code class=
                  "literal">reword</code> to change the log
                  message.</li>

                  <li class="listitem"><code class=
                  "literal">squash</code> to merge a commit with
                  the previous one.</li>

                  <li class="listitem"><code class=
                  "literal">fixup</code> to merge a commit with the
                  previous one and discard the log message.</li>
                </ul>
              </div>
            </li>
          </ul>
        </div>

        <p>For example, we might replace the second <code class=
        "literal">pick</code> with <code class=
        "literal">squash</code>:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
squash a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>After we save and quit, Git merges a311a64 into 5c6eb73.
        Thus <span class="strong"><strong>squash</strong></span>
        merges into the next commit up: think “squash up”.</p>

        <p>Git then combines their log messages and presents them
        for editing. The command <span class=
        "strong"><strong>fixup</strong></span> skips this step; the
        squashed log message is simply discarded.</p>

        <p>If you marked a commit with <span class=
        "strong"><strong>edit</strong></span>, Git returns you to
        the past, to the oldest such commit. You can amend the old
        commit as described in the previous section, and even
        create new commits that belong here. Once you’re pleased
        with the “retcon”, go forward in time by running:</p>
        <pre class="literallayout">
$ git rebase --continue
</pre>

        <p>Git replays commits until the next <span class=
        "strong"><strong>edit</strong></span>, or to the present if
        none remain.</p>

        <p>You can also abandon the rebase with:</p>
        <pre class="literallayout">
$ git rebase --abort
</pre>

        <p>So commit early and commit often: you can tidy up later
        with rebase.</p>
      </div>

      <div class="section" title="Local Changes Last">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_local_changes_last"></a>Local Changes Last</h2>
            </div>
          </div>
        </div>

        <p>You’re working on an active project. You make some local
        commits over time, and then you sync with the official tree
        with a merge. This cycle repeats itself a few times before
        you’re ready to push to the central tree.</p>

        <p>But now the history in your local Git clone is a messy
        jumble of your changes and the official changes. You’d
        prefer to see all your changes in one contiguous section,
        and after all the official changes.</p>

        <p>This is a job for <span class="strong"><strong>git
        rebase</strong></span> as described above. In many cases
        you can use the <span class=
        "strong"><strong>--onto</strong></span> flag and avoid
        interaction.</p>

        <p>Also see <span class="strong"><strong>git help
        rebase</strong></span> for detailed examples of this
        amazing command. You can split commits. You can even
        rearrange branches of a tree.</p>

        <p>Take care: rebase is a powerful command. For complicated
        rebases, first make a backup with <span class=
        "strong"><strong>git clone</strong></span>.</p>
      </div>

      <div class="section" title="Rewriting History">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_rewriting_history"></a>Rewriting History</h2>
            </div>
          </div>
        </div>

        <p>Occasionally, you need the source control equivalent of
        airbrushing people out of official photos, erasing them
        from history in a Stalinesque fashion. For example, suppose
        we intend to release a project, but it involves a file that
        should be kept private for some reason. Perhaps I left my
        credit card number in a text file and accidentally added it
        to the project. Deleting the file is insufficient, for the
        file can be accessed from older commits. We must remove the
        file from all commits:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'rm top/secret/file' HEAD
</pre>

        <p>See <span class="strong"><strong>git help
        filter-branch</strong></span>, which discusses this example
        and gives a faster method. In general, <span class=
        "strong"><strong>filter-branch</strong></span> lets you
        alter large sections of history with a single command.</p>

        <p>Afterwards, the <code class=
        "literal">.git/refs/original</code> directory describes the
        state of affairs before the operation. Check the
        filter-branch command did what you wanted, then delete this
        directory if you wish to run more filter-branch
        commands.</p>

        <p>Lastly, replace clones of your project with your revised
        version if you want to interact with them later.</p>
      </div>

      <div class="section" title="Making History">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_making_history"></a>Making History</h2>
            </div>
          </div>
        </div>

        <p><a name="makinghistory" id="makinghistory"></a>Want to
        migrate a project to Git? If it’s managed with one of the
        more well-known systems, then chances are someone has
        already written a script to export the whole history to
        Git.</p>

        <p>Otherwise, look up <span class="strong"><strong>git
        fast-import</strong></span>, which reads text input in a
        specific format to create Git history from scratch.
        Typically a script using this command is hastily cobbled
        together and run once, migrating the project in a single
        shot.</p>

        <p>As an example, paste the following listing into
        temporary file, such as <code class=
        "literal">/tmp/history</code>:</p>
        <pre class="screen">
commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Initial commit.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Then create a Git repository from this temporary file by
        typing:</p>
        <pre class="literallayout">
$ mkdir project; cd project; git init
$ git fast-import --date-format=rfc2822 &lt; /tmp/history
</pre>

        <p>You can checkout the latest version of the project
        with:</p>
        <pre class="literallayout">
$ git checkout master .
</pre>

        <p>The <span class="strong"><strong>git
        fast-export</strong></span> command converts any repository
        to the <span class="strong"><strong>git
        fast-import</strong></span> format, whose output you can
        study for writing exporters, and also to transport
        repositories in a human-readable format. Indeed, these
        commands can send repositories of text files over text-only
        channels.</p>
      </div>

      <div class="section" title="Where Did It All Go Wrong?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_where_did_it_all_go_wrong"></a>Where Did It All Go
              Wrong?</h2>
            </div>
          </div>
        </div>

        <p>You’ve just discovered a broken feature in your program
        which you know for sure was working a few months ago. Argh!
        Where did this bug come from? If only you had been testing
        the feature as you developed.</p>

        <p>It’s too late for that now. However, provided you’ve
        been committing often, Git can pinpoint the problem:</p>
        <pre class="literallayout">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d
</pre>

        <p>Git checks out a state halfway in between. Test the
        feature, and if it’s still broken:</p>
        <pre class="literallayout">
$ git bisect bad
</pre>

        <p>If not, replace "bad" with "good". Git again transports
        you to a state halfway between the known good and bad
        versions, narrowing down the possibilities. After a few
        iterations, this binary search will lead you to the commit
        that caused the trouble. Once you’ve finished your
        investigation, return to your original state by typing:</p>
        <pre class="literallayout">
$ git bisect reset
</pre>

        <p>Instead of testing every change by hand, automate the
        search by running:</p>
        <pre class="literallayout">
$ git bisect run my_script
</pre>

        <p>Git uses the return value of the given command,
        typically a one-off script, to decide whether a change is
        good or bad: the command should exit with code 0 when good,
        125 when the change should be skipped, and anything else
        between 1 and 127 if it is bad. A negative return value
        aborts the bisect.</p>

        <p>You can do much more: the help page explains how to
        visualize bisects, examine or replay the bisect log, and
        eliminate known innocent changes for a speedier search.</p>
      </div>

      <div class="section" title="Who Made It All Go Wrong?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_who_made_it_all_go_wrong"></a>Who Made It All Go
              Wrong?</h2>
            </div>
          </div>
        </div>

        <p>Like many other version control systems, Git has a blame
        command:</p>
        <pre class="literallayout">
$ git blame bug.c
</pre>

        <p>which annotates every line in the given file showing who
        last changed it, and when. Unlike many other version
        control systems, this operation works offline, reading only
        from local disk.</p>
      </div>

      <div class="section" title="Personal Experience">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_personal_experience"></a>Personal Experience</h2>
            </div>
          </div>
        </div>

        <p>In a centralized version control system, history
        modification is a difficult operation, and only available
        to administrators. Cloning, branching, and merging are
        impossible without network communication. So are basic
        operations such as browsing history, or committing a
        change. In some systems, users require network connectivity
        just to view their own changes or open a file for
        editing.</p>

        <p>Centralized systems preclude working offline, and need
        more expensive network infrastructure, especially as the
        number of developers grows. Most importantly, all
        operations are slower to some degree, usually to the point
        where users shun advanced commands unless absolutely
        necessary. In extreme cases this is true of even the most
        basic commands. When users must run slow commands,
        productivity suffers because of an interrupted work
        flow.</p>

        <p>I experienced these phenomena first-hand. Git was the
        first version control system I used. I quickly grew
        accustomed to it, taking many features for granted. I
        simply assumed other systems were similar: choosing a
        version control system ought to be no different from
        choosing a text editor or web browser.</p>

        <p>I was shocked when later forced to use a centralized
        system. A flaky internet connection matters little with
        Git, but makes development unbearable when it needs to be
        as reliable as local disk. Additionally, I found myself
        conditioned to avoid certain commands because of the
        latencies involved, which ultimately prevented me from
        following my desired work flow.</p>

        <p>When I had to run a slow command, the interruption to my
        train of thought dealt a disproportionate amount of damage.
        While waiting for server communication to complete, I’d do
        something else to pass the time, such as check email or
        write documentation. By the time I returned to the original
        task, the command had finished long ago, and I would waste
        more time trying to remember what I was doing. Humans are
        bad at context switching.</p>

        <p>There was also an interesting tragedy-of-the-commons
        effect: anticipating network congestion, individuals would
        consume more bandwidth than necessary on various operations
        in an attempt to reduce future delays. The combined efforts
        intensified congestion, encouraging individuals to consume
        even more bandwidth next time to avoid even longer
        delays.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;6.&nbsp;Multiplayer Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_multiplayer_git"></a>Chapter&nbsp;6.&nbsp;Multiplayer
            Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#_who_am_i">Who Am
          I?</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_over_ssh_http">Git Over SSH, HTTP</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_over_anything">Git Over Anything</a></span></dt>

          <dt><span class="section"><a href=
          "#_patches_the_global_currency">Patches: The Global
          Currency</a></span></dt>

          <dt><span class="section"><a href=
          "#_sorry_we_8217_ve_moved">Sorry, We’ve
          Moved</a></span></dt>

          <dt><span class="section"><a href=
          "#_remote_branches">Remote Branches</a></span></dt>

          <dt><span class="section"><a href=
          "#_multiple_remotes">Multiple Remotes</a></span></dt>

          <dt><span class="section"><a href="#_my_preferences">My
          Preferences</a></span></dt>
        </dl>
      </div>

      <p>Initially I used Git on a private project where I was the
      sole developer. Amongst the commands related to Git’s
      distributed nature, I needed only <span class=
      "strong"><strong>pull</strong></span> and <span class=
      "strong"><strong>clone</strong></span> so could I keep the
      same project in different places.</p>

      <p>Later I wanted to publish my code with Git, and include
      changes from contributors. I had to learn how to manage
      projects with multiple developers from all over the world.
      Fortunately, this is Git’s forte, and arguably its raison
      d'être.</p>

      <div class="section" title="Who Am I?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_who_am_i"></a>Who Am I?</h2>
            </div>
          </div>
        </div>

        <p>Every commit has an author name and email, which is
        shown by <span class="strong"><strong>git
        log</strong></span>. By default, Git uses system settings
        to populate these fields. To set them explicitly, type:</p>
        <pre class="literallayout">
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</pre>

        <p>Omit the global flag to set these options only for the
        current repository.</p>
      </div>

      <div class="section" title="Git Over SSH, HTTP">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_over_ssh_http"></a>Git Over SSH, HTTP</h2>
            </div>
          </div>
        </div>

        <p>Suppose you have SSH access to a web server, but Git is
        not installed. Though less efficient than its native
        protocol, Git can communicate over HTTP.</p>

        <p>Download, compile and install Git in your account, and
        create a repository in your web directory:</p>
        <pre class="literallayout">
$ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample hooks/post-update
</pre>

        <p>For older versions of Git, the copy command fails and
        you should run:</p>
        <pre class="literallayout">
$ chmod a+x hooks/post-update
</pre>

        <p>Now you can publish your latest edits via SSH from any
        clone:</p>
        <pre class="literallayout">
$ git push web.server:/path/to/proj.git master
</pre>

        <p>and anybody can get your project with:</p>
        <pre class="literallayout">
$ git clone http://web.server/proj.git
</pre>
      </div>

      <div class="section" title="Git Over Anything">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_over_anything"></a>Git Over Anything</h2>
            </div>
          </div>
        </div>

        <p>Want to synchronize repositories without servers, or
        even a network connection? Need to improvise during an
        emergency? We’ve seen <a class="link" href=
        "#makinghistory"><span class="strong"><strong>git
        fast-export</strong></span> and <span class=
        "strong"><strong>git fast-import</strong></span> can
        convert repositories to a single file and back</a>. We
        could shuttle such files back and forth to transport git
        repositories over any medium, but a more efficient tool is
        <span class="strong"><strong>git
        bundle</strong></span>.</p>

        <p>The sender creates a <span class=
        "emphasis"><em>bundle</em></span>:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD
</pre>

        <p>then transports the bundle, <code class=
        "literal">somefile</code>, to the other party somehow:
        email, thumb drive, an <span class=
        "strong"><strong>xxd</strong></span> printout and an OCR
        scanner, reading bits over the phone, smoke signals, etc.
        The receiver retrieves commits from the bundle by
        typing:</p>
        <pre class="literallayout">
$ git pull somefile
</pre>

        <p>The receiver can even do this from an empty repository.
        Despite its size, <code class="literal">somefile</code>
        contains the entire original git repository.</p>

        <p>In larger projects, eliminate waste by bundling only
        changes the other repository lacks. For example, suppose
        the commit “1b6d…” is the most recent commit shared by both
        parties:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD ^1b6d
</pre>

        <p>If done frequently, one could easily forget which commit
        was last sent. The help page suggests using tags to solve
        this. Namely, after you send a bundle, type:</p>
        <pre class="literallayout">
$ git tag -f lastbundle HEAD
</pre>

        <p>and create new refresher bundles with:</p>
        <pre class="literallayout">
$ git bundle create newbundle HEAD ^lastbundle
</pre>
      </div>

      <div class="section" title="Patches: The Global Currency">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_patches_the_global_currency"></a>Patches: The
              Global Currency</h2>
            </div>
          </div>
        </div>

        <p>Patches are text representations of your changes that
        can be easily understood by computers and humans alike.
        This gives them universal appeal. You can email a patch to
        developers no matter what version control system they’re
        using. As long as your audience can read their email, they
        can see your edits. Similarly, on your side, all you
        require is an email account: there’s no need to setup an
        online Git repository.</p>

        <p>Recall from the first chapter:</p>
        <pre class="literallayout">
$ git diff 1b6d &gt; my.patch
</pre>

        <p>outputs a patch which can be pasted into an email for
        discussion. In a Git repository, type:</p>
        <pre class="literallayout">
$ git apply &lt; my.patch
</pre>

        <p>to apply the patch.</p>

        <p>In more formal settings, when author names and perhaps
        signatures should be recorded, generate the corresponding
        patches past a certain point by typing:</p>
        <pre class="literallayout">
$ git format-patch 1b6d
</pre>

        <p>The resulting files can be given to <span class=
        "strong"><strong>git-send-email</strong></span>, or sent by
        hand. You can also specify a range of commits:</p>
        <pre class="literallayout">
$ git format-patch 1b6d..HEAD^^
</pre>

        <p>On the receiving end, save an email to a file, then
        type:</p>
        <pre class="literallayout">
$ git am &lt; email.txt
</pre>

        <p>This applies the incoming patch and also creates a
        commit, including information such as the author.</p>

        <p>With a browser email client, you may need to click a
        button to see the email in its raw original form before
        saving the patch to a file.</p>

        <p>There are slight differences for mbox-based email
        clients, but if you use one of these, you’re probably the
        sort of person who can figure them out easily without
        reading tutorials!</p>
      </div>

      <div class="section" title="Sorry, We’ve Moved">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_sorry_we_8217_ve_moved"></a>Sorry, We’ve Moved</h2>
            </div>
          </div>
        </div>

        <p>After cloning a repository, running <span class=
        "strong"><strong>git push</strong></span> or <span class=
        "strong"><strong>git pull</strong></span> will
        automatically push to or pull from the original URL. How
        does Git do this? The secret lies in config options created
        with the clone. Let’s take a peek:</p>
        <pre class="literallayout">
$ git config --list
</pre>

        <p>The <code class="literal">remote.origin.url</code>
        option controls the source URL; “origin” is a nickname
        given to the source repository. As with the “master” branch
        convention, we may change or delete this nickname but there
        is usually no reason for doing so.</p>

        <p>If the original repository moves, we can update the URL
        via:</p>
        <pre class="literallayout">
$ git config remote.origin.url git://new.url/proj.git
</pre>

        <p>The <code class="literal">branch.master.merge</code>
        option specifies the default remote branch in a
        <span class="strong"><strong>git pull</strong></span>.
        During the initial clone, it is set to the current branch
        of the source repository, so even if the HEAD of the source
        repository subsequently moves to a different branch, a
        later pull will faithfully follow the original branch.</p>

        <p>This option only applies to the repository we first
        cloned from, which is recorded in the option <code class=
        "literal">branch.master.remote</code>. If we pull in from
        other repositories we must explicitly state which branch we
        want:</p>
        <pre class="literallayout">
$ git pull git://example.com/other.git master
</pre>

        <p>The above explains why some of our earlier push and pull
        examples had no arguments.</p>
      </div>

      <div class="section" title="Remote Branches">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_remote_branches"></a>Remote Branches</h2>
            </div>
          </div>
        </div>

        <p>When you clone a repository, you also clone all its
        branches. You may not have noticed this because Git hides
        them away: you must ask for them specifically. This
        prevents branches in the remote repository from interfering
        with your branches, and also makes Git easier for
        beginners.</p>

        <p>List the remote branches with:</p>
        <pre class="literallayout">
$ git branch -r
</pre>

        <p>You should see something like:</p>
        <pre class="literallayout">
origin/HEAD
origin/master
origin/experimental
</pre>

        <p>These represent branches and the HEAD of the remote
        repository, and can be used in regular Git commands. For
        example, suppose you have made many commits, and wish to
        compare against the last fetched version. You could search
        through the logs for the appropriate SHA1 hash, but it’s
        much easier to type:</p>
        <pre class="literallayout">
$ git diff origin/HEAD
</pre>

        <p>Or you can see what the “experimental” branch has been
        up to:</p>
        <pre class="literallayout">
$ git log origin/experimental
</pre>
      </div>

      <div class="section" title="Multiple Remotes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_multiple_remotes"></a>Multiple Remotes</h2>
            </div>
          </div>
        </div>

        <p>Suppose two other developers are working on our project,
        and we want to keep tabs on both. We can follow more than
        one repository at a time with:</p>
        <pre class="literallayout">
$ git remote add other git://example.com/some_repo.git
$ git pull other some_branch
</pre>

        <p>Now we have merged in a branch from the second
        repository, and we have easy access to all branches of all
        repositories:</p>
        <pre class="literallayout">
$ git diff origin/experimental^ other/some_branch~5
</pre>

        <p>But what if we just want to compare their changes
        without affecting our own work? In other words, we want to
        examine their branches without having their changes invade
        our working directory. Then rather than pull, run:</p>
        <pre class="literallayout">
$ git fetch        # Fetch from origin, the default.
$ git fetch other  # Fetch from the second programmer.
</pre>

        <p>This just fetches histories. Although the working
        directory remains untouched, we can refer to any branch of
        any repository in a Git command because we now possess a
        local copy.</p>

        <p>Recall that behind the scenes, a pull is simply a
        <span class="strong"><strong>fetch</strong></span> then
        <span class="strong"><strong>merge</strong></span>. Usually
        we <span class="strong"><strong>pull</strong></span>
        because we want to merge the latest commit after a fetch;
        this situation is a notable exception.</p>

        <p>See <span class="strong"><strong>git help
        remote</strong></span> for how to remove remote
        repositories, ignore certain branches, and more.</p>
      </div>

      <div class="section" title="My Preferences">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_my_preferences"></a>My Preferences</h2>
            </div>
          </div>
        </div>

        <p>For my projects, I like contributors to prepare
        repositories from which I can pull. Some Git hosting
        services let you host your own fork of a project with the
        click of a button.</p>

        <p>After I fetch a tree, I run Git commands to navigate and
        examine the changes, which ideally are well-organized and
        well-described. I merge my own changes, and perhaps make
        further edits. Once satisfied, I push to the main
        repository.</p>

        <p>Though I infrequently receive contributions, I believe
        this approach scales well. See <a class="ulink" href=
        "http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html"
        target="_top">this blog post by Linus Torvalds</a>.</p>

        <p>Staying in the Git world is slightly more convenient
        than patch files, as it saves me from converting them to
        Git commits. Furthermore, Git handles details such as
        recording the author’s name and email address, as well as
        the time and date, and asks the author to describe their
        own change.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;7.&nbsp;Git Grandmastery">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_git_grandmastery"></a>Chapter&nbsp;7.&nbsp;Git
            Grandmastery</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_source_releases">Source Releases</a></span></dt>

          <dt><span class="section"><a href=
          "#_commit_what_changed">Commit What
          Changed</a></span></dt>

          <dt><span class="section"><a href=
          "#_my_commit_is_too_big">My Commit Is Too
          Big!</a></span></dt>

          <dt><span class="section"><a href=
          "#_the_index_git_8217_s_staging_area">The Index: Git’s
          Staging Area</a></span></dt>

          <dt><span class="section"><a href=
          "#_don_8217_t_lose_your_head">Don’t Lose Your
          HEAD</a></span></dt>

          <dt><span class="section"><a href=
          "#_head_hunting">HEAD-hunting</a></span></dt>

          <dt><span class="section"><a href=
          "#_building_on_git">Building On Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_daring_stunts">Daring Stunts</a></span></dt>

          <dt><span class="section"><a href=
          "#_preventing_bad_commits">Preventing Bad
          Commits</a></span></dt>
        </dl>
      </div>

      <p>By now, you should be able to navigate the <span class=
      "strong"><strong>git help</strong></span> pages and
      understand almost everything. However, pinpointing the exact
      command required to solve a given problem can be tedious.
      Perhaps I can save you some time: below are some recipes I
      have needed in the past.</p>

      <div class="section" title="Source Releases">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_source_releases"></a>Source Releases</h2>
            </div>
          </div>
        </div>

        <p>For my projects, Git tracks exactly the files I’d like
        to archive and release to users. To create a tarball of the
        source code, I run:</p>
        <pre class="literallayout">
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" title="Commit What Changed">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_commit_what_changed"></a>Commit What Changed</h2>
            </div>
          </div>
        </div>

        <p>Telling Git when you’ve added, deleted and renamed files
        is troublesome for certain projects. Instead, you can
        type:</p>
        <pre class="literallayout">
$ git add .
$ git add -u
</pre>

        <p>Git will look at the files in the current directory and
        work out the details by itself. Instead of the second add
        command, run <code class="literal">git commit -a</code> if
        you also intend to commit at this time. See <span class=
        "strong"><strong>git help ignore</strong></span> for how to
        specify files that should be ignored.</p>

        <p>You can perform the above in a single pass with:</p>
        <pre class="literallayout">
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>The <span class="strong"><strong>-z</strong></span> and
        <span class="strong"><strong>-0</strong></span> options
        prevent ill side-effects from filenames containing strange
        characters. As this command adds ignored files, you may
        want to use the <code class="literal">-x</code> or
        <code class="literal">-X</code> option.</p>
      </div>

      <div class="section" title="My Commit Is Too Big!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_my_commit_is_too_big"></a>My Commit Is Too
              Big!</h2>
            </div>
          </div>
        </div>

        <p>Have you neglected to commit for too long? Been coding
        furiously and forgotten about source control until now?
        Made a series of unrelated changes, because that’s your
        style?</p>

        <p>No worries. Run:</p>
        <pre class="literallayout">
$ git add -p
</pre>

        <p>For each edit you made, Git will show you the hunk of
        code that was changed, and ask if it should be part of the
        next commit. Answer with "y" or "n". You have other
        options, such as postponing the decision; type "?" to learn
        more.</p>

        <p>Once you’re satisfied, type</p>
        <pre class="literallayout">
$ git commit
</pre>

        <p>to commit precisely the changes you selected (the
        <span class="emphasis"><em>staged</em></span> changes).
        Make sure you omit the <span class=
        "strong"><strong>-a</strong></span> option, otherwise Git
        will commit all the edits.</p>

        <p>What if you’ve edited many files in many places?
        Reviewing each change one by one becomes frustratingly
        mind-numbing. In this case, use <span class=
        "strong"><strong>git add -i</strong></span>, whose
        interface is less straightforward, but more flexible. With
        a few keystrokes, you can stage or unstage several files at
        a time, or review and select changes in particular files
        only. Alternatively, run <span class="strong"><strong>git
        commit --interactive</strong></span> which automatically
        commits after you’re done.</p>
      </div>

      <div class="section" title="The Index: Git’s Staging Area">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_the_index_git_8217_s_staging_area"></a>The Index:
              Git’s Staging Area</h2>
            </div>
          </div>
        </div>

        <p>So far we have avoided Git’s famous <span class=
        "emphasis"><em>index</em></span>, but we must now confront
        it to explain the above. The index is a temporary staging
        area. Git seldom shuttles data directly between your
        project and its history. Rather, Git first writes data to
        the index, and then copies the data in the index to its
        final destination.</p>

        <p>For example, <span class="strong"><strong>commit
        -a</strong></span> is really a two-step process. The first
        step places a snapshot of the current state of every
        tracked file into the index. The second step permanently
        records the snapshot now in the index. Committing without
        the <span class="strong"><strong>-a</strong></span> option
        only performs the second step, and only makes sense after
        running commands that somehow change the index, such as
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Usually we can ignore the index and pretend we are
        reading straight from and writing straight to the history.
        On this occasion, we want finer control, so we manipulate
        the index. We place a snapshot of some, but not all, of our
        changes into the index, and then permanently record this
        carefully rigged snapshot.</p>
      </div>

      <div class="section" title="Don’t Lose Your HEAD">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_don_8217_t_lose_your_head"></a>Don’t Lose Your
              HEAD</h2>
            </div>
          </div>
        </div>

        <p>The HEAD tag is like a cursor that normally points at
        the latest commit, advancing with each new commit. Some Git
        commands let you move it. For example:</p>
        <pre class="literallayout">
$ git reset HEAD~3
</pre>

        <p>will move the HEAD three commits back. Thus all Git
        commands now act as if you hadn’t made those last three
        commits, while your files remain in the present. See the
        help page for some applications.</p>

        <p>But how can you go back to the future? The past commits
        know nothing of the future.</p>

        <p>If you have the SHA1 of the original HEAD then:</p>
        <pre class="literallayout">
$ git reset 1b6d
</pre>

        <p>But suppose you never took it down? Don’t worry: for
        commands like these, Git saves the original HEAD as a tag
        called ORIG_HEAD, and you can return safe and sound
        with:</p>
        <pre class="literallayout">
$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" title="HEAD-hunting">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_head_hunting"></a>HEAD-hunting</h2>
            </div>
          </div>
        </div>

        <p>Perhaps ORIG_HEAD isn’t enough. Perhaps you’ve just
        realized you made a monumental mistake and you need to go
        back to an ancient commit in a long-forgotten branch.</p>

        <p>By default, Git keeps a commit for at least two weeks,
        even if you ordered Git to destroy the branch containing
        it. The trouble is finding the appropriate hash. You could
        look at all the hash values in <code class=
        "literal">.git/objects</code> and use trial and error to
        find the one you want. But there’s a much easier way.</p>

        <p>Git records every hash of a commit it computes in
        <code class="literal">.git/logs</code>. The subdirectory
        <code class="literal">refs</code> contains the history of
        all activity on all branches, while the file <code class=
        "literal">HEAD</code> shows every hash value it has ever
        taken. The latter can be used to find hashes of commits on
        branches that have been accidentally lopped off.</p>

        <p>The reflog command provides a friendly interface to
        these log files. Try</p>
        <pre class="literallayout">
$ git reflog
</pre>

        <p>Instead of cutting and pasting hashes from the reflog,
        try:</p>
        <pre class="literallayout">
$ git checkout "@{10 minutes ago}"
</pre>

        <p>Or checkout the 5th-last visited commit via:</p>
        <pre class="literallayout">
$ git checkout "@{5}"
</pre>

        <p>See the “Specifying Revisions” section of <span class=
        "strong"><strong>git help rev-parse</strong></span> for
        more.</p>

        <p>You may wish to configure a longer grace period for
        doomed commits. For example:</p>
        <pre class="literallayout">
$ git config gc.pruneexpire "30 days"
</pre>

        <p>means a deleted commit will only be permanently lost
        once 30 days have passed and <span class=
        "strong"><strong>git gc</strong></span> is run.</p>

        <p>You may also wish to disable automatic invocations of
        <span class="strong"><strong>git gc</strong></span>:</p>
        <pre class="literallayout">
$ git config gc.auto 0
</pre>

        <p>in which case commits will only be deleted when you run
        <span class="strong"><strong>git gc</strong></span>
        manually.</p>
      </div>

      <div class="section" title="Building On Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_building_on_git"></a>Building On Git</h2>
            </div>
          </div>
        </div>

        <p>In true UNIX fashion, Git’s design allows it to be
        easily used as a low-level component of other programs,
        such as GUI and web interfaces, alternative command-line
        interfaces, patch managements tools, importing and
        conversion tools and so on. In fact, some Git commands are
        themselves scripts standing on the shoulders of giants.
        With a little tinkering, you can customize Git to suit your
        preferences.</p>

        <p>One easy trick is to use built-in Git aliases to shorten
        your most frequently used commands:</p>
        <pre class="literallayout">
$ git config --global alias.co checkout
$ git config --global --get-regexp alias  # display current aliases
alias.co checkout
$ git co foo                              # same as 'git checkout foo'
</pre>

        <p>Another is to print the current branch in the prompt, or
        window title. Invoking</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD
</pre>

        <p>shows the current branch name. In practice, you most
        likely want to remove the "refs/heads/" and ignore
        errors:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>The <code class="literal">contrib</code> subdirectory is
        a treasure trove of tools built on Git. In time, some of
        them may be promoted to official commands. On Debian and
        Ubuntu, this directory lives at <code class=
        "literal">/usr/share/doc/git-core/contrib</code>.</p>

        <p>One popular resident is <code class=
        "literal">workdir/git-new-workdir</code>. Via clever
        symlinking, this script creates a new working directory
        whose history is shared with the original repository:</p>
        <pre class="literallayout">
$ git-new-workdir an/existing/repo new/directory
</pre>

        <p>The new directory and the files within can be thought of
        as a clone, except since the history is shared, the two
        trees automatically stay in sync. There’s no need to merge,
        push, or pull.</p>
      </div>

      <div class="section" title="Daring Stunts">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_daring_stunts"></a>Daring Stunts</h2>
            </div>
          </div>
        </div>

        <p>These days, Git makes it difficult for the user to
        accidentally destroy data. But if you know what you are
        doing, you can override safeguards for common commands.</p>

        <p><span class="strong"><strong>Checkout</strong></span>:
        Uncommitted changes cause checkout to fail. To destroy your
        changes, and checkout a given commit anyway, use the force
        flag:</p>
        <pre class="literallayout">
$ git checkout -f HEAD^
</pre>

        <p>On the other hand, if you specify particular paths for
        checkout, then there are no safety checks. The supplied
        paths are quietly overwritten. Take care if you use
        checkout in this manner.</p>

        <p><span class="strong"><strong>Reset</strong></span>:
        Reset also fails in the presence of uncommitted changes. To
        force it through, run:</p>
        <pre class="literallayout">
$ git reset --hard 1b6d
</pre>

        <p><span class="strong"><strong>Branch</strong></span>:
        Deleting branches fails if this causes changes to be lost.
        To force a deletion, type:</p>
        <pre class="literallayout">
$ git branch -D dead_branch  # instead of -d
</pre>

        <p>Similarly, attempting to overwrite a branch via a move
        fails if data loss would ensue. To force a branch move,
        type:</p>
        <pre class="literallayout">
$ git branch -M source target  # instead of -m
</pre>

        <p>Unlike checkout and reset, these two commands defer data
        destruction. The changes are still stored in the .git
        subdirectory, and can be retrieved by recovering the
        appropriate hash from <code class=
        "literal">.git/logs</code> (see "HEAD-hunting" above). By
        default, they will be kept for at least two weeks.</p>

        <p><span class="strong"><strong>Clean</strong></span>: Some
        git commands refuse to proceed because they’re worried
        about clobbering untracked files. If you’re certain that
        all untracked files and directories are expendable, then
        delete them mercilessly with:</p>
        <pre class="literallayout">
$ git clean -f -d
</pre>

        <p>Next time, that pesky command will work!</p>
      </div>

      <div class="section" title="Preventing Bad Commits">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_preventing_bad_commits"></a>Preventing Bad
              Commits</h2>
            </div>
          </div>
        </div>

        <p>Stupid mistakes pollute my repositories. Most
        frightening are missing files due to a forgotten
        <span class="strong"><strong>git add</strong></span>.
        Lesser transgressions are trailing whitespace and
        unresolved merge conflicts: though harmless, I wish these
        never appeared on the public record.</p>

        <p>If only I had bought idiot insurance by using a
        <span class="emphasis"><em>hook</em></span> to alert me
        about these problems:</p>
        <pre class="literallayout">
$ cd .git/hooks
$ cp pre-commit.sample pre-commit  # Older Git versions: chmod +x pre-commit
</pre>

        <p>Now Git aborts a commit if useless whitespace or
        unresolved merge conflicts are detected.</p>

        <p>For this guide, I eventually added the following to the
        beginning of the <span class=
        "strong"><strong>pre-commit</strong></span> hook to guard
        against absent-mindedness:</p>
        <pre class="literallayout">
if git ls-files -o | grep '\.txt$'; then
  echo FAIL! Untracked .txt files.
  exit 1
fi
</pre>

        <p>Several git operations support hooks; see <span class=
        "strong"><strong>git help hooks</strong></span>. We
        activated the sample <span class=
        "strong"><strong>post-update</strong></span> hook earlier
        when discussing Git over HTTP. This runs whenever the head
        moves. The sample post-update script updates files Git
        needs for communication over Git-agnostic transports such
        as HTTP.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapter&nbsp;8.&nbsp;Secrets Revealed">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_secrets_revealed"></a>Chapter&nbsp;8.&nbsp;Secrets
            Revealed</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_invisibility">Invisibility</a></span></dt>

          <dt><span class="section"><a href=
          "#_integrity">Integrity</a></span></dt>

          <dt><span class="section"><a href=
          "#_intelligence">Intelligence</a></span></dt>

          <dt><span class="section"><a href=
          "#_indexing">Indexing</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_8217_s_origins">Git’s Origins</a></span></dt>

          <dt><span class="section"><a href=
          "#_the_object_database">The Object
          Database</a></span></dt>

          <dt><span class="section"><a href=
          "#_blobs">Blobs</a></span></dt>

          <dt><span class="section"><a href=
          "#_trees">Trees</a></span></dt>

          <dt><span class="section"><a href=
          "#_commits">Commits</a></span></dt>

          <dt><span class="section"><a href=
          "#_indistinguishable_from_magic">Indistinguishable From
          Magic</a></span></dt>
        </dl>
      </div>

      <p>We take a peek under the hood and explain how Git performs
      its miracles. I will skimp over details. For in-depth
      descriptions refer to <a class="ulink" href=
      "http://schacon.github.com/git/user-manual.html" target=
      "_top">the user manual</a>.</p>

      <div class="section" title="Invisibility">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_invisibility"></a>Invisibility</h2>
            </div>
          </div>
        </div>

        <p>How can Git be so unobtrusive? Aside from occasional
        commits and merges, you can work as if you were unaware
        that version control exists. That is, until you need it,
        and that’s when you’re glad Git was watching over you the
        whole time.</p>

        <p>Other version control systems force you to constantly
        struggle with red tape and bureaucracy. Permissions of
        files may be read-only unless you explicitly tell a central
        server which files you intend to edit. The most basic
        commands may slow to a crawl as the number of users
        increases. Work grinds to a halt when the network or the
        central server goes down.</p>

        <p>In contrast, Git simply keeps the history of your
        project in the <code class="literal">.git</code> directory
        in your working directory. This is your own copy of the
        history, so you can stay offline until you want to
        communicate with others. You have total control over the
        fate of your files because Git can easily recreate a saved
        state from <code class="literal">.git</code> at any
        time.</p>
      </div>

      <div class="section" title="Integrity">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_integrity"></a>Integrity</h2>
            </div>
          </div>
        </div>

        <p>Most people associate cryptography with keeping
        information secret, but another equally important goal is
        keeping information safe. Proper use of cryptographic hash
        functions can prevent accidental or malicious data
        corruption.</p>

        <p>A SHA1 hash can be thought of as a unique 160-bit ID
        number for every string of bytes you’ll encounter in your
        life. Actually more than that: every string of bytes that
        any human will ever use over many lifetimes.</p>

        <p>As a SHA1 hash is itself a string of bytes, we can hash
        strings of bytes containing other hashes. This simple
        observation is surprisingly useful: look up <span class=
        "emphasis"><em>hash chains</em></span>. We’ll later see how
        Git uses it to efficiently guarantee data integrity.</p>

        <p>Briefly, Git keeps your data in the <code class=
        "literal">.git/objects</code> subdirectory, where instead
        of normal filenames, you’ll find only IDs. By using IDs as
        filenames, as well as a few lockfiles and timestamping
        tricks, Git transforms any humble filesystem into an
        efficient and robust database.</p>
      </div>

      <div class="section" title="Intelligence">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_intelligence"></a>Intelligence</h2>
            </div>
          </div>
        </div>

        <p>How does Git know you renamed a file, even though you
        never mentioned the fact explicitly? Sure, you may have run
        <span class="strong"><strong>git mv</strong></span>, but
        that is exactly the same as a <span class=
        "strong"><strong>git rm</strong></span> followed by a
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git heuristically ferrets out renames and copies between
        successive versions. In fact, it can detect chunks of code
        being moved or copied around between files! Though it
        cannot cover all cases, it does a decent job, and this
        feature is always improving. If it fails to work for you,
        try options enabling more expensive copy detection, and
        consider upgrading.</p>
      </div>

      <div class="section" title="Indexing">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_indexing"></a>Indexing</h2>
            </div>
          </div>
        </div>

        <p>For every tracked file, Git records information such as
        its size, creation time and last modification time in a
        file known as the <span class=
        "emphasis"><em>index</em></span>. To determine whether a
        file has changed, Git compares its current stats with those
        cached in the index. If they match, then Git can skip
        reading the file again.</p>

        <p>Since stat calls are considerably faster than file
        reads, if you only edit a few files, Git can update its
        state in almost no time.</p>

        <p>We stated earlier that the index is a staging area. Why
        is a bunch of file stats a staging area? Because the add
        command puts files into Git’s database and updates these
        stats, while the commit command, without options, creates a
        commit based only on these stats and the files already in
        the database.</p>
      </div>

      <div class="section" title="Git’s Origins">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_8217_s_origins"></a>Git’s Origins</h2>
            </div>
          </div>
        </div>

        <p>This <a class="ulink" href=
        "http://lkml.org/lkml/2005/4/6/121" target="_top">Linux
        Kernel Mailing List post</a> describes the chain of events
        that led to Git. The entire thread is a fascinating
        archaeological site for Git historians.</p>
      </div>

      <div class="section" title="The Object Database">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_the_object_database"></a>The Object Database</h2>
            </div>
          </div>
        </div>

        <p>Every version of your data is kept in the <span class=
        "emphasis"><em>object database</em></span>, which lives in
        the subdirectory <code class="literal">.git/objects</code>;
        the other residents of <code class="literal">.git/</code>
        hold lesser data: the index, branch names, tags,
        configuration options, logs, the current location of the
        head commit, and so on. The object database is elementary
        yet elegant, and the source of Git’s power.</p>

        <p>Each file within <code class=
        "literal">.git/objects</code> is an <span class=
        "emphasis"><em>object</em></span>. There are 3 kinds of
        objects that concern us: <span class=
        "emphasis"><em>blob</em></span> objects, <span class=
        "emphasis"><em>tree</em></span> objects, and <span class=
        "emphasis"><em>commit</em></span> objects.</p>
      </div>

      <div class="section" title="Blobs">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_blobs"></a>Blobs</h2>
            </div>
          </div>
        </div>

        <p>First, a magic trick. Pick a filename, any filename. In
        an empty directory:</p>
        <pre class="literallayout">
$ echo sweet &gt; YOUR_FILENAME
$ git init
$ git add .
$ find .git/objects -type f
</pre>

        <p>You’ll see <code class=
        "literal">.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d</code>.</p>

        <p>How do I know this without knowing the filename? It’s
        because the SHA1 hash of:</p>
        <pre class="literallayout">
"blob" SP "6" NUL "sweet" LF
</pre>

        <p>is aa823728ea7d592acc69b36875a482cdf3fd5c8d, where SP is
        a space, NUL is a zero byte and LF is a linefeed. You can
        verify this by typing:</p>
        <pre class="literallayout">
$ printf "blob 6\000sweet\n" | sha1sum
</pre>

        <p>Git is <span class=
        "emphasis"><em>content-addressable</em></span>: files are
        not stored according to their filename, but rather by the
        hash of the data they contain, in a file we call a
        <span class="emphasis"><em>blob object</em></span>. We can
        think of the hash as a unique ID for a file’s contents, so
        in a sense we are addressing files by their content. The
        initial <code class="literal">blob 6</code> is merely a
        header consisting of the object type and its length in
        bytes; it simplifies internal bookkeeping.</p>

        <p>Thus I could easily predict what you would see. The
        file’s name is irrelevant: only the data inside is used to
        construct the blob object.</p>

        <p>You may be wondering what happens to identical files.
        Try adding copies of your file, with any filenames
        whatsoever. The contents of <code class=
        "literal">.git/objects</code> stay the same no matter how
        many you add. Git only stores the data once.</p>

        <p>By the way, the files within <code class=
        "literal">.git/objects</code> are compressed with zlib so
        you should not stare at them directly. Filter them through
        <a class="ulink" href="http://www.zlib.net/zpipe.c" target=
        "_top">zpipe -d</a>, or type:</p>
        <pre class="literallayout">
$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>which pretty-prints the given object.</p>
      </div>

      <div class="section" title="Trees">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_trees"></a>Trees</h2>
            </div>
          </div>
        </div>

        <p>But where are the filenames? They must be stored
        somewhere at some stage. Git gets around to the filenames
        during a commit:</p>
        <pre class="literallayout">
$ git commit  # Type some message.
$ find .git/objects -type f
</pre>

        <p>You should now see 3 objects. This time I cannot tell
        you what the 2 new files are, as it partly depends on the
        filename you picked. We’ll proceed assuming you chose
        “rose”. If you didn’t, you can rewrite history to make it
        look like you did:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'mv YOUR_FILENAME rose'
$ find .git/objects -type f
</pre>

        <p>Now you should see the file <code class=
        "literal">.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9</code>,
        because this is the SHA1 hash of its contents:</p>
        <pre class="literallayout">
"tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>Check this file does indeed contain the above by
        typing:</p>
        <pre class="literallayout">
$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
</pre>

        <p>With zpipe, it’s easy to verify the hash:</p>
        <pre class="literallayout">
$ zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
</pre>

        <p>Hash verification is trickier via cat-file because its
        output contains more than the raw uncompressed object
        file.</p>

        <p>This file is a <span class=
        "emphasis"><em>tree</em></span> object: a list of tuples
        consisting of a file type, a filename, and a hash. In our
        example, the file type is 100644, which means ‘rose` is a
        normal file, and the hash is the blob object that contains
        the contents of `rose’. Other possible file types are
        executables, symlinks or directories. In the last case, the
        hash points to a tree object.</p>

        <p>If you ran filter-branch, you’ll have old objects you no
        longer need. Although they will be jettisoned automatically
        once the grace period expires, we’ll delete them now to
        make our toy example easier to follow:</p>
        <pre class="literallayout">
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
</pre>

        <p>For real projects you should typically avoid commands
        like this, as you are destroying backups. If you want a
        clean repository, it is usually best to make a fresh clone.
        Also, take care when directly manipulating <code class=
        "literal">.git</code>: what if a Git command is running at
        the same time, or a sudden power outage occurs? In general,
        refs should be deleted with <span class=
        "strong"><strong>git update-ref -d</strong></span>, though
        usually it’s safe to remove <code class=
        "literal">refs/original</code> by hand.</p>
      </div>

      <div class="section" title="Commits">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_commits"></a>Commits</h2>
            </div>
          </div>
        </div>

        <p>We’ve explained 2 of the 3 objects. The third is a
        <span class="emphasis"><em>commit</em></span> object. Its
        contents depend on the commit message as well as the date
        and time it was created. To match what we have here, we’ll
        have to tweak it a little:</p>
        <pre class="literallayout">
$ git commit --amend -m Shakespeare  # Change the commit message.
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # Rig timestamps and authors.
$ find .git/objects -type f
</pre>

        <p>You should now see <code class=
        "literal">.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187</code>
        which is the SHA1 hash of its contents:</p>
        <pre class="literallayout">
"commit 158" NUL
"tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
"author Alice &lt;alice@example.com&gt; 1234567890 -0800" LF
"committer Bob &lt;bob@example.com&gt; 1234567890 -0800" LF
LF
"Shakespeare" LF
</pre>

        <p>As before, you can run zpipe or cat-file to see for
        yourself.</p>

        <p>This is the first commit, so there are no parent
        commits, but later commits will always contain at least one
        line identifying a parent commit.</p>
      </div>

      <div class="section" title="Indistinguishable From Magic">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_indistinguishable_from_magic"></a>Indistinguishable
              From Magic</h2>
            </div>
          </div>
        </div>

        <p>Git’s secrets seem too simple. It looks like you could
        mix together a few shell scripts and add a dash of C code
        to cook it up in a matter of hours: a melange of basic
        filesystem operations and SHA1 hashing, garnished with lock
        files and fsyncs for robustness. In fact, this accurately
        describes the earliest versions of Git. Nonetheless, apart
        from ingenious packing tricks to save space, and ingenious
        indexing tricks to save time, we now know how Git deftly
        changes a filesystem into a database perfect for version
        control.</p>

        <p>For example, if any file within the object database is
        corrupted by a disk error, then its hash will no longer
        match, alerting us to the problem. By hashing hashes of
        other objects, we maintain integrity at all levels. Commits
        are atomic, that is, a commit can never only partially
        record changes: we can only compute the hash of a commit
        and store it in the database after we already have stored
        all relevant trees, blobs and parent commits. The object
        database is immune to unexpected interruptions such as
        power outages.</p>

        <p>We defeat even the most devious adversaries. Suppose
        somebody attempts to stealthily modify the contents of a
        file in an ancient version of a project. To keep the object
        database looking healthy, they must also change the hash of
        the corresponding blob object since it’s now a different
        string of bytes. This means they’ll have to change the hash
        of any tree object referencing the file, and in turn change
        the hash of all commit objects involving such a tree, in
        addition to the hashes of all the descendants of these
        commits. This implies the hash of the official head differs
        to that of the bad repository. By following the trail of
        mismatching hashes we can pinpoint the mutilated file, as
        well as the commit where it was first corrupted.</p>

        <p>In short, so long as the 20 bytes representing the last
        commit are safe, it’s impossible to tamper with a Git
        repository.</p>

        <p>What about Git’s famous features? Branching? Merging?
        Tags? Mere details. The current head is kept in the file
        <code class="literal">.git/HEAD</code>, which contains a
        hash of a commit object. The hash gets updated during a
        commit as well as many other commands. Branches are almost
        the same: they are files in <code class=
        "literal">.git/refs/heads</code>. Tags too: they live in
        <code class="literal">.git/refs/tags</code> but they are
        updated by a different set of commands.</p>
      </div>
    </div>

    <div class="appendix" title=
    "Appendix&nbsp;A.&nbsp;Git Shortcomings">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_git_shortcomings"></a>Appendix&nbsp;A.&nbsp;Git
            Shortcomings</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_sha1_weaknesses">SHA1 Weaknesses</a></span></dt>

          <dt><span class="section"><a href=
          "#_microsoft_windows">Microsoft Windows</a></span></dt>

          <dt><span class="section"><a href=
          "#_unrelated_files">Unrelated Files</a></span></dt>

          <dt><span class="section"><a href=
          "#_who_8217_s_editing_what">Who’s Editing
          What?</a></span></dt>

          <dt><span class="section"><a href="#_file_history">File
          History</a></span></dt>

          <dt><span class="section"><a href=
          "#_initial_clone">Initial Clone</a></span></dt>

          <dt><span class="section"><a href=
          "#_volatile_projects">Volatile Projects</a></span></dt>

          <dt><span class="section"><a href=
          "#_global_counter">Global Counter</a></span></dt>

          <dt><span class="section"><a href=
          "#_empty_subdirectories">Empty
          Subdirectories</a></span></dt>

          <dt><span class="section"><a href=
          "#_initial_commit">Initial Commit</a></span></dt>

          <dt><span class="section"><a href=
          "#_interface_quirks">Interface Quirks</a></span></dt>
        </dl>
      </div>

      <p>There are some Git issues I’ve swept under the carpet.
      Some can be handled easily with scripts and hooks, some
      require reorganizing or redefining the project, and for the
      few remaining annoyances, one will just have to wait. Or
      better yet, pitch in and help!</p>

      <div class="section" title="SHA1 Weaknesses">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_sha1_weaknesses"></a>SHA1 Weaknesses</h2>
            </div>
          </div>
        </div>

        <p>As time passes, cryptographers discover more and more
        SHA1 weaknesses. Already, finding hash collisions is
        feasible for well-funded organizations. Within years,
        perhaps even a typical PC will have enough computing power
        to silently corrupt a Git repository.</p>

        <p>Hopefully Git will migrate to a better hash function
        before further research destroys SHA1.</p>
      </div>

      <div class="section" title="Microsoft Windows">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_microsoft_windows"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Git on Microsoft Windows can be cumbersome:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://cygwin.com/" target="_top">Cygwin</a>, a
            Linux-like environment for Windows, contains <a class=
            "ulink" href="http://cygwin.com/packages/git/" target=
            "_top">a Windows port of Git</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://code.google.com/p/msysgit/" target="_top">Git
            on MSys</a> is an alternative requiring minimal runtime
            support, though a few of the commands need some
            work.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Unrelated Files">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_unrelated_files"></a>Unrelated Files</h2>
            </div>
          </div>
        </div>

        <p>If your project is very large and contains many
        unrelated files that are constantly being changed, Git may
        be disadvantaged more than other systems because single
        files are not tracked. Git tracks changes to the whole
        project, which is usually beneficial.</p>

        <p>A solution is to break up your project into pieces, each
        consisting of related files. Use <span class=
        "strong"><strong>git submodule</strong></span> if you still
        want to keep everything in a single repository.</p>
      </div>

      <div class="section" title="Who’s Editing What?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_who_8217_s_editing_what"></a>Who’s Editing
              What?</h2>
            </div>
          </div>
        </div>

        <p>Some version control systems force you to explicitly
        mark a file in some way before editing. While this is
        especially annoying when this involves talking to a central
        server, it does have two benefits:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">Diffs are quick because only the
            marked files need be examined.</li>

            <li class="listitem">One can discover who else is
            working on the file by asking the central server who
            has marked it for editing.</li>
          </ol>
        </div>

        <p>With appropriate scripting, you can achieve the same
        with Git. This requires cooperation from the programmer,
        who should execute particular scripts when editing a
        file.</p>
      </div>

      <div class="section" title="File History">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_file_history"></a>File History</h2>
            </div>
          </div>
        </div>

        <p>Since Git records project-wide changes, reconstructing
        the history of a single file requires more work than in
        version control systems that track individual files.</p>

        <p>The penalty is typically slight, and well worth having
        as other operations are incredibly efficient. For example,
        <code class="literal">git checkout</code> is faster than
        <code class="literal">cp -a</code>, and project-wide deltas
        compress better than collections of file-based deltas.</p>
      </div>

      <div class="section" title="Initial Clone">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_initial_clone"></a>Initial Clone</h2>
            </div>
          </div>
        </div>

        <p>Creating a clone is more expensive than checking out
        code in other version control systems when there is a
        lengthy history.</p>

        <p>The initial cost is worth paying in the long run, as
        most future operations will then be fast and offline.
        However, in some situations, it may be preferable to create
        a shallow clone with the <code class=
        "literal">--depth</code> option. This is much faster, but
        the resulting clone has reduced functionality.</p>
      </div>

      <div class="section" title="Volatile Projects">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_volatile_projects"></a>Volatile Projects</h2>
            </div>
          </div>
        </div>

        <p>Git was written to be fast with respect to the size of
        the changes. Humans make small edits from version to
        version. A one-liner bugfix here, a new feature there,
        emended comments, and so forth. But if your files are
        radically different in successive revisions, then on each
        commit, your history necessarily grows by the size of your
        whole project.</p>

        <p>There is nothing any version control system can do about
        this, but standard Git users will suffer more since
        normally histories are cloned.</p>

        <p>The reasons why the changes are so great should be
        examined. Perhaps file formats should be changed. Minor
        edits should only cause minor changes to at most a few
        files.</p>

        <p>Or perhaps a database or backup/archival solution is
        what is actually being sought, not a version control
        system. For example, version control may be ill-suited for
        managing photos periodically taken from a webcam.</p>

        <p>If the files really must be constantly morphing and they
        really must be versioned, a possibility is to use Git in a
        centralized fashion. One can create shallow clones, which
        checks out little or no history of the project. Of course,
        many Git tools will be unavailable, and fixes must be
        submitted as patches. This is probably fine as it’s unclear
        why anyone would want the history of wildly unstable
        files.</p>

        <p>Another example is a project depending on firmware,
        which takes the form of a huge binary file. The history of
        the firmware is uninteresting to users, and updates
        compress poorly, so firmware revisions would unnecessarily
        blow up the size of the repository.</p>

        <p>In this case, the source code should be stored in a Git
        repository, and the binary file should be kept separately.
        To make life easier, one could distribute a script that
        uses Git to clone the code, and rsync or a Git shallow
        clone for the firmware.</p>
      </div>

      <div class="section" title="Global Counter">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_global_counter"></a>Global Counter</h2>
            </div>
          </div>
        </div>

        <p>Some centralized version control systems maintain a
        positive integer that increases when a new commit is
        accepted. Git refers to changes by their hash, which is
        better in many circumstances.</p>

        <p>But some people like having this integer around.
        Luckily, it’s easy to write scripts so that with every
        update, the central Git repository increments an integer,
        perhaps in a tag, and associates it with the hash of the
        latest commit.</p>

        <p>Every clone could maintain such a counter, but this
        would probably be useless, since only the central
        repository and its counter matters to everyone.</p>
      </div>

      <div class="section" title="Empty Subdirectories">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_empty_subdirectories"></a>Empty Subdirectories</h2>
            </div>
          </div>
        </div>

        <p>Empty subdirectories cannot be tracked. Create dummy
        files to work around this problem.</p>

        <p>The current implementation of Git, rather than its
        design, is to blame for this drawback. With luck, once Git
        gains more traction, more users will clamour for this
        feature and it will be implemented.</p>
      </div>

      <div class="section" title="Initial Commit">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_initial_commit"></a>Initial Commit</h2>
            </div>
          </div>
        </div>

        <p>A stereotypical computer scientist counts from 0, rather
        than 1. Unfortunately, with respect to commits, git does
        not adhere to this convention. Many commands are unfriendly
        before the initial commit. Additionally, some corner cases
        must be handled specially, such as rebasing a branch with a
        different initial commit.</p>

        <p>Git would benefit from defining the zero commit: as soon
        as a repository is constructed, HEAD would be set to the
        string consisting of 20 zero bytes. This special commit
        represents an empty tree, with no parent, at some time
        predating all Git repositories.</p>

        <p>Then running git log, for example, would inform the user
        that no commits have been made yet, instead of exiting with
        a fatal error. Similarly for other tools.</p>

        <p>Every initial commit is implicitly a descendant of this
        zero commit.</p>

        <p>However there are some problem cases unfortunately. If
        several branches with different initial commits are merged
        together, then rebasing the result requires substantial
        manual intervention.</p>
      </div>

      <div class="section" title="Interface Quirks">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_interface_quirks"></a>Interface Quirks</h2>
            </div>
          </div>
        </div>

        <p>For commits A and B, the meaning of the expressions
        "A..B" and "A…B" depends on whether the command expects two
        endpoints or a range. See <span class="strong"><strong>git
        help diff</strong></span> and <span class=
        "strong"><strong>git help rev-parse</strong></span>.</p>
      </div>
    </div>

    <div class="appendix" title=
    "Appendix&nbsp;B.&nbsp;Translating This Guide">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_translating_this_guide"></a>Appendix&nbsp;B.&nbsp;Translating
            This Guide</h2>
          </div>
        </div>
      </div>

      <p>I recommend the following steps for translating this
      guide, so my scripts can quickly produce HTML and PDF
      versions, and all translations can live in the same
      repository.</p>

      <p>Clone the source, then create a directory corresponding to
      the target language’s IETF tag: see <a class="ulink" href=
      "http://www.w3.org/International/articles/language-tags/Overview.en.php"
      target="_top">the W3C article on internationalization</a>.
      For example, English is "en" and Japanese is "ja". In the new
      directory, and translate the <code class="literal">txt</code>
      files from the "en" subdirectory.</p>

      <p>For instance, to translate the guide into <a class="ulink"
      href="http://en.wikipedia.org/wiki/Klingon_language" target=
      "_top">Klingon</a>, you might type:</p>
      <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh  # "tlh" is the IETF language code for Klingon.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Translate the file.
</pre>

      <p>and so on for each text file.</p>

      <p>Edit the Makefile and add the language code to the
      <code class="literal">TRANSLATIONS</code> variable. You can
      now review your work incrementally:</p>
      <pre class="literallayout">
$ make tlh
$ firefox book-tlh/index.html
</pre>

      <p>Commit your changes often, then let me know when they’re
      ready. GitHub has an interface that facilitates this: fork
      the "gitmagic" project, push your changes, then ask me to
      merge.</p>
    </div>
  </div>
</body>
</html>
