From zsh-workers-return-11346-mason-zsh=primenet.com.au@sunsite.auc.dk Fri May 12 11:50:41 2000
Return-Path: <zsh-workers-return-11346-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6988 invoked from network); 12 May 2000 11:50:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 May 2000 11:50:39 -0000
Received: (qmail 2174 invoked by alias); 12 May 2000 11:50:14 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11346
Received: (qmail 2147 invoked from network); 12 May 2000 11:50:13 -0000
Date: Fri, 12 May 2000 13:49:58 +0200 (MET DST)
Message-Id: <200005121149.NAA24616@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Felix Rosencrantz's message of Thu, 11 May 2000 21:54:28 -0700
	(PDT)
Subject: Re: PATCH: Completion matching control test.


Felix Rosencrantz wrote:

> ...

I'll extract the `broken' ones:

1) The option completion thingy, match spec `L:|[nN][oO]= M:_= M:{A-Z}={a-z}':

a) `__N__o__': There are two things to say: we look for [nN]oO] only 
   at the *beginning*, which it isn't here. Also, we look *only* for
   [nN][oO]. Expecting anything else would mean to expect that it
   tries all specs and after it succeeds tries the specs again as if
   nothing had changed, so that what previously was not the beginning
   of the word would now be it.
   I haven't looked, but you may find some discussion about this way
   back in the archive (1998? 1999?), because it once did this --
   although, now that I think of it, it may well be that I never
   published that version. By the fact that it was changed you can see 
   that there were some problems (ugly endless-recusion ones, I
   guess). Note also that even if we would allow the change-of-beg-of-word
   thing (so that `__no_<TAB>' would work), this still wouldn't work
   with `n_o_<TAB>'. For that the code would have to first use match
   specs (any number of them) and then go back again and again to try
   the other specs. When should it stop?
   One way to implement it is to allow users to define some sort of
   precedence, i.e. he says that `M:_=' should be tried first and the
   other specs work on the result of that. Doesn't sound very friendly 
   to me either.

   Because of all this: I don't think it's broken and hence no patch.

b) `__listbeep__': Yes, the trailing `_'s should be ignored. The patch
   below should do that. For that I had to change the test in the main 
   while-loop in match_str(), probably the only thing that hasn't
   changed there yet. I've left a comment there just in case this
   turns out to have nasty side-effects.


2) The match spec `m:{a-z}={A-Z}' and matches `ABC Abc abc', doing
   `A<TAB>' inserted `Abc'.

   Ah, this is a beloved part of the matching system. It wasn't so
   stupid to insert the `Abc' match, far from that. It cunningly had a 
   look at the possible matches `ABC' and `Abc' and at the metch spec
   and from that derived that `Abc' is a string that, using the given
   match spec, matches both matches. Then it inserted it.

   I still like this, unless we have a case like this, where we don't
   have an easy way to disambiguate between the matches. So the patch
   below has a closer look at the resulting cline list and cuts it in
   such cases.


3) The match spec `m:{a-z}={A-Z} r:|[.,_-]=*' and matches
   `Abc-Def-Ghij.txt Abc-def.ghi.jkl_mno.pqr.txt
   Abc_def_ghi_jkl_mno_pqr.txt', completing `a-d.' considered both 
   Abc-Def-Ghij.txt and Abc-def.ghi.jkl_mno.pqr.txt to be possible
   completions. The first one isn't because there the `*' would match
   more than one part. So the patch changes that, but only for `*',
   not for `**', obviously. For that there is a cursor-positioning fix 
   in the patch (I've only uncommented the code that caused it because 
   we had some problems in that function lately, caused by the new
   `**' thing; if I'm not completely mistaken, I just changed the code 
   in too many places; actually, I'm pretty sure about this, now that
   I had a look at it from another angle).


No changes to the test itself because that isn't in the CVS yet and
there is this bit of discussion about the numbering going on.

Bye
 Sven

Index: Src/Zle/compmatch.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compmatch.c,v
retrieving revision 1.11
diff -u -r1.11 compmatch.c
--- Src/Zle/compmatch.c	2000/05/08 09:29:22	1.11
+++ Src/Zle/compmatch.c	2000/05/12 11:49:21
@@ -466,7 +466,9 @@
 	bp->curpos = bc;
 	bp = bp->next;
     }
-    while (ll && lw) {
+    /*** This once was: `while (ll && lw)', but then ignored characters at
+     *   the end or not, well, ignored. */
+    while (ll) {
 
 	/* Hm, we unconditionally first tried the matchers for the cases
 	 * where the beginnings of the line and word patterns match the
@@ -576,7 +578,12 @@
 			     pattern_match(ap, tp - moff, NULL, NULL) &&
 			     (!aol || pattern_match(aop, tp - moff - aol,
 						    NULL, NULL)) &&
-			     match_parts(l + aoff , tp - moff, alen, part))) {
+			     (mp->wlen == -1 ||
+			      match_parts(l + aoff , tp - moff,
+						      alen, part)))) {
+			    if (!both && mp->wlen == -1 &&
+				!match_parts(l + aoff , tp - moff, alen, part))
+				break;
 			    if (sfx) {
 				savw = tp[-zoff];
 				tp[-zoff] = '\0';
@@ -1819,13 +1826,19 @@
 		    free_cline(o);
 		    x = o;
 		    o = tn;
+#if 0
+		    /*** These should be handled different from the ones
+			 that compare anchors. */
 		    if (po && po->prefix && cmp_anchors(x, po, 0)) {
 			po->flags |= CLF_MISS;
 			po->max += diff;
 		    } else {
+#endif
 			o->flags |= CLF_MISS;
 			o->max += diff;
+#if 0
 		    }
+#endif
 		    continue;
 		}
 	    }
@@ -1836,13 +1849,19 @@
 		if (tn && cmp_anchors(o, tn, 0)) {
 		    diff = sub_join(o, n, tn, 0);
 
+#if 0
+		    /*** These should be handled different from the ones
+			 that compare anchors. */
 		    if (po && po->prefix && cmp_anchors(n, pn, 0)) {
 			po->flags |= CLF_MISS;
 			po->max += diff;
 		    } else {
+#endif
 			o->flags |= CLF_MISS;
 			o->max += diff;
+#if 0
 		    }
+#endif
 		    n = tn;
 		    continue;
 		}
Index: Src/Zle/compresult.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compresult.c,v
retrieving revision 1.13
diff -u -r1.13 compresult.c
--- Src/Zle/compresult.c	2000/04/30 17:58:36	1.13
+++ Src/Zle/compresult.c	2000/05/12 11:49:22
@@ -40,7 +40,7 @@
 cut_cline(Cline l)
 {
     Cline q, p, e = NULL, maxp = NULL;
-    int sum = 0, max = 0, tmp, ls = 0;
+    int sum = 0, max = 0, tmp, ls = 0, miss = 0;
 
     /* If no match was added with matching, we don't really know
      * which parts of the unambiguous string are worth keeping,
@@ -108,12 +108,39 @@
 		    len += p->max;
 
 		if (len > ((minmlen << 1) / 3))
-		    return l;
+		    goto end;
 	    }
 	    e->line = e->word = NULL;
 	    e->llen = e->wlen = e->olen = 0;
 	    e->next = NULL;
 	}
+    }
+ end:
+
+    /* Sanity check. If there are no parts with missing characters but
+     * parts with joined substrings, remove those. */
+
+    for (p = l, e = 0, tmp = 0; p; p = p->next) {
+	if (p->flags & (CLF_MISS|CLF_DIFF))
+	    miss = 1;
+	for (q = p->prefix; q; q = q->next)
+	    if (q->flags & CLF_JOIN) {
+		e = p;
+		tmp = 0;
+		break;
+	    }
+	for (q = p->suffix; q; q = q->next)
+	    if (q->flags & CLF_JOIN) {
+		e = p;
+		tmp = 1;
+		break;
+	    }
+    }
+    if (e && (!miss || cline_sublen(e) == e->min)) {
+	for (p = (tmp ? e->suffix : e->prefix);
+	     p && p->next && !(p->next->flags & CLF_JOIN); p = p->next);
+	if (p)
+	    p->next = NULL;
     }
     if (!ls)
 	cline_setlens(l, 0);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

