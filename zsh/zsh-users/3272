From zsh-users-return-3272-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jul 12 18:55:27 2000
Return-Path: <zsh-users-return-3272-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16206 invoked from network); 12 Jul 2000 18:55:25 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Jul 2000 18:55:25 -0000
Received: (qmail 13864 invoked by alias); 12 Jul 2000 18:54:49 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 3272
Received: (qmail 13855 invoked from network); 12 Jul 2000 18:54:46 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000712185437.ZM18513@candle.brasslantern.com>
Date: Wed, 12 Jul 2000 18:54:37 +0000
In-Reply-To: <Pine.LNX.4.10.10007121828230.6434-100000@langec.myip.org>
Comments: In reply to Christoph Lange <langec@gmx.de>
        "Re: ZLE Widget: Insert last word (except &)" (Jul 12,  6:38pm)
References: <Pine.LNX.4.10.10007121828230.6434-100000@langec.myip.org>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Christoph Lange <duke@cyberspaces.de>
Subject: Re: ZLE Widget: Insert last word (except &)
Cc: zsh-users@sunsite.auc.dk
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Jul 12,  6:38pm, Christoph Lange wrote:
} Subject: Re: ZLE Widget: Insert last word (except &)
}
} There is another bug in your version of smart-insert-last-word: repeated
} calls to it don't go back in the history.

Oops, I forgot about that behavior.

} Rather than doing the word
} splitting yourself, you should always call insert-last-word

Nah.

The fiddling with NUMERIC below serves two purposes:  One, it passes the
same value to both up-history and down-history without having to pass an
argument to each.  Two, `zle WIDGET -n NUM' is broken for NUM > 9.

---- 8< ---- cut ---- 8< ----
# smart-insert-last-word
# Inspired by Christoph Lange <langec@gmx.de> from zsh-users/3265;
# rewritten to correct multiple-call behavior after zsh-users/3270.
#
# This function as a ZLE widget can replace insert-last-word, like so:
#
#   zle -N insert-last-word smart-insert-last-word
#
# With a numeric prefix, behaves like insert-last-word, except that words
# in comments are ignored when interactive_comments is set.
#
# Otherwise, the rightmost "interesting" word from the previous command is
# found and inserted.  The default definition of "interesting" is that the
# word contains at least one alphabetic character, slash, or backslash.
# This definition can be overridden by use of a style like so:
#
#   zstyle :insert-last-word match '*[[:alpha:]/\\]*'
#
# For example, you might want to include words that contain spaces:
#
#   zstyle :insert-last-word match '*[[:alpha:][:space:]/\\]*'
#
# Or include numbers as long as the word is at least two characters long:
#
#   zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\])*'
#
# That causes redirections like "2>" to be included.
#
# Note also that the style is looked up based on the widget name, so you
# can bind this function to different widgets to use different patterns:
#
#   zle -N insert-last-assignment smart-insert-last-word
#   zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'
#   bindkey '\e=' insert-last-assignment

emulate -L zsh
setopt extendedglob

# Not strictly necessary:
# (($+_ilw_hist)) || integer -g _ilw_hist _ilw_count _ilw_cursor _ilw_lcursor

integer cursor=$CURSOR lcursor=$CURSOR
local lastcmd pattern numeric=$NUMERIC

# Save state for repeated calls
if (( HISTNO == _ilw_hist && cursor == _ilw_cursor )); then
    NUMERIC=$[_ilw_count+1]
    lcursor=$_ilw_lcursor
else
    NUMERIC=1
    _ilw_lcursor=$lcursor
fi
_ilw_hist=$HISTNO
_ilw_count=$NUMERIC

zle up-history || return 1    # Retrieve previous command
lastcmd=( ${(z)BUFFER} )      # Split into shell words
zle down-history              # Return to current command
CURSOR=$cursor                # Restore cursor position
NUMERIC=${numeric:-1}         # In case of fall through

(( NUMERIC > $#lastcmd )) && return 1

if [[ -z "$numeric" ]]
then
    integer i=1
    zstyle -s :$WIDGET match pattern ||
	pattern='*[[:alpha:]/\\]*'
    while ((i <= $#lastcmd)); do
	if [[ $lastcmd[-i] == $~pattern ]]; then
	    NUMERIC=$i
	    break
	else
	    ((--i))
	fi
    done
fi
LBUFFER[lcursor+1,cursor+1]=$lastcmd[-NUMERIC]
_ilw_cursor=$CURSOR
---- 8< ---- cut ---- 8< ----

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

