From zsh-workers-return-9759-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Feb 16 10:50:47 2000
Return-Path: <zsh-workers-return-9759-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3085 invoked from network); 16 Feb 2000 10:50:45 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Feb 2000 10:50:45 -0000
Received: (qmail 28287 invoked by alias); 16 Feb 2000 10:50:35 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9759
Received: (qmail 28279 invoked from network); 16 Feb 2000 10:50:34 -0000
Date: Wed, 16 Feb 2000 11:50:25 +0100 (MET)
Message-Id: <200002161050.LAA17494@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Tue, 15 Feb 2000 21:58:45 +0000
Subject: Re: 3.1.6-dev-18


Peter Stephenson wrote:

> Sven Wischnowsky wrote:
> > I can only repeat... I would have no problems with turning the matcher 
> > style as used by _matcher (or even renaming it for clarity) into one
> > that is used as an array. The first _matcher would then use the first
> > string in the value, the second one the second string and so on. I
> > just thought -- and I may very well be wrong here -- that it would
> > make users more aware of what they are doing if we use this more
> > explicit setting we have now. I.e., even with the suggested
> > array-interpretation of the matcher style one would have to add a new
> > call to _matcher in the completer list when adding a new string to the 
> > matcher style.
> 
> Given the last sentence, your way of doing things does make more sense.
> But I appreciate Andrej's point that the _matcher completer ideally
> shouldn't be necessary at all, given that there's a style controlling it.
> If there is some magic which could go in, say, _main_complete to handle
> this, it would be nice.  For example, start with matcher-1, try with that;
> then retrieve matcher-N, continuing until either you get the same string as
> before (assumption: there was a * in the matcher column), or you get
> nothing (assumption: the style's not set at all); plus do some optimisation
> based on which completers don't use matching at all, to avoid calling
> completers unnecessarily.

Err, hadn't thought about putting that into _main_complete (where we
can optimise).

One last question: wouldn't it then be better to just have a
matcher-list style, taken as an array, containing the match specs to
try one after another?

> On the other discussion, I'm certainly not hung up on providing
> alternatives to the string context, which I think is pretty usable when you
> get your mind round it.  It's more a question of what the punters think
> than what I think.
> 
> By the way, should there be a style that says that old-style completions
> are to be used?  It would avoid the necessity of customizing _default.

Good idea. The patch does that and if the style is unset, compcall
will be used if the compctl module is loaded (so it should work
automatically for those who still have compctls). It can be explicitly 
turned off by setting the style to one of the `false' values, though.

Then I found another problem with compcall -- we need enable the
compctl module to clean up after completion since compcall may be
called. Yet another hook (or, more precisely, a old hook re-appearing).

Bye
 Sven

diff -ru ../z.old/Completion/Base/_default Completion/Base/_default
--- ../z.old/Completion/Base/_default	Wed Feb 16 11:15:32 2000
+++ Completion/Base/_default	Wed Feb 16 11:42:14 2000
@@ -1,16 +1,16 @@
 #compdef -default-
 
-# You can first try the `compctl's by uncommenting the `compcall' line
-# below.
-# This is without first (-T) and default (-D) completion. If you want
-# them add `-T' and/or `-D' to this command. If there is a `compctl'
-# for the command we are working on, we return immediatly. If you want
-# to use new style completion anyway, remove the `|| return'. Also,
-# you may want to use new style completion if the `compctl' didn't
-# produce any matches. In that case remove the `|| return' and insert
-# the line `[[ compstate[nmatches] -eq 0 ]] || return' after `compcall'.
+local ctl
 
-# compcall || return 0
+if { zstyle -s ':completion:${curcontext}:' use-compctl ctl ||
+     zmodload -e zsh/compctl } && [[ "$ctl" != (no|false|0|off) ]]; then
+  local opt
+
+  opt=()
+  [[ "$ctl" = *first* ]] && opt=(-T)
+  [[ "$ctl" = *default* ]] && opt=("$opt[@]" -D)
+  compcall "$opt[@]" || return 0
+fi
 
 _tags files || return 1
 
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Wed Feb 16 11:15:21 2000
+++ Doc/Zsh/compsys.yo	Wed Feb 16 11:48:48 2000
@@ -1359,6 +1359,23 @@
 tt(all-files) plus all tags offered by the completion function will be 
 used.
 )
+item(tt(use-compctl))(
+If this style is set to a string not equal to tt(false), tt(0),
+tt(no), and tt(off), the completion system will use any completion
+specifications defined with the tt(compctl) builtin command. If the
+style is unset, this will only be done if the tt(zsh/compctl) module
+is loaded. The string may also contain the substring tt(first) to make
+the definition for tt(compctl -T) be used and the substring
+tt(default) to make the one for tt(compctl -D) be used.
+
+Note that this is only intended to smooth the transition from
+tt(compctl) to the new completion system and may disappear in the
+future.
+
+Note also, that the definitions from tt(compctl) will only be used if
+there is no special completion function for the command completion is
+done upon.
+)
 item(tt(users))(
 This may be set to a list of names that should be completed whenever 
 a username is needed. If it is not set or the string on the line
diff -ru ../z.old/Src/Zle/comp.h Src/Zle/comp.h
--- ../z.old/Src/Zle/comp.h	Wed Feb 16 11:15:12 2000
+++ Src/Zle/comp.h	Wed Feb 16 11:28:05 2000
@@ -364,7 +364,8 @@
 #define INSERTMATCHHOOK     (comphooks + 0)
 #define MENUSTARTHOOK       (comphooks + 1)
 #define COMPCTLMAKEHOOK     (comphooks + 2)
-#define COMPLISTMATCHESHOOK (comphooks + 3)
+#define COMPCTLCLEANUPHOOK  (comphooks + 3)
+#define COMPLISTMATCHESHOOK (comphooks + 4)
 
 /* compctl hook data struct */
 
diff -ru ../z.old/Src/Zle/compcore.c Src/Zle/compcore.c
--- ../z.old/Src/Zle/compcore.c	Wed Feb 16 11:15:12 2000
+++ Src/Zle/compcore.c	Wed Feb 16 11:38:04 2000
@@ -844,6 +844,9 @@
 	callcompfunc(s, compfunc);
 	endcmgroup(NULL);
 
+	/* Needed for compcall. */
+	runhookdef(COMPCTLCLEANUPHOOK, NULL);
+
 	if (oldlist) {
 	    nmatches = onm;
 	    validlist = 1;
@@ -891,6 +894,9 @@
 	dat.incmd = incmd;
 	dat.lst = lst;
 	runhookdef(COMPCTLMAKEHOOK, (void *) &dat);
+
+	/* Needed for compcall. */
+	runhookdef(COMPCTLCLEANUPHOOK, NULL);
 
 	return dat.lst;
     }
diff -ru ../z.old/Src/Zle/compctl.c Src/Zle/compctl.c
--- ../z.old/Src/Zle/compctl.c	Wed Feb 16 11:15:13 2000
+++ Src/Zle/compctl.c	Wed Feb 16 11:30:53 2000
@@ -1892,6 +1892,13 @@
     return 0;
 }
 
+static int
+cccleanuphookfn(Hookdef dummy, void *dat)
+{
+    ccused = ccstack = NULL;
+    return 0;
+}
+
 /* This adds a match to the list of matches.  The string to add is given   *
  * in s, the type of match is given in the global variable addwhat and     *
  * the parameter t (if not NULL) is a pointer to a hash node node which    *
@@ -3906,6 +3913,7 @@
 boot_(Module m)
 {
     addhookfunc("compctl_make", (Hookfn) ccmakehookfn);
+    addhookfunc("compctl_cleanup", (Hookfn) cccleanuphookfn);
     return (addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab)) != 1);
 }
 
@@ -3914,6 +3922,7 @@
 cleanup_(Module m)
 {
     deletehookfunc("compctl_make", (Hookfn) ccmakehookfn);
+    deletehookfunc("compctl_cleanup", (Hookfn) cccleanuphookfn);
     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
     return 0;
 }
diff -ru ../z.old/Src/Zle/complete.c Src/Zle/complete.c
--- ../z.old/Src/Zle/complete.c	Wed Feb 16 11:15:13 2000
+++ Src/Zle/complete.c	Wed Feb 16 11:27:42 2000
@@ -1288,6 +1288,7 @@
     HOOKDEF("insert_match", NULL, HOOKF_ALL),
     HOOKDEF("menu_start", NULL, HOOKF_ALL),
     HOOKDEF("compctl_make", NULL, 0),
+    HOOKDEF("compctl_cleanup", NULL, 0),
     HOOKDEF("comp_list_matches", ilistmatches, 0),
 };
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

