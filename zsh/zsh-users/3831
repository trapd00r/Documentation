From zsh-users-return-3831-mason-zsh=primenet.com.au@sunsite.dk Thu Apr 26 03:51:01 2001
Return-Path: <zsh-users-return-3831-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20668 invoked from network); 26 Apr 2001 03:51:00 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Apr 2001 03:51:00 -0000
Received: (qmail 22277 invoked by alias); 26 Apr 2001 03:50:50 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3831
Received: (qmail 22260 invoked from network); 26 Apr 2001 03:50:49 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010426034956.ZM11913@candle.brasslantern.com>
Date: Thu, 26 Apr 2001 03:49:56 +0000
In-Reply-To: <Pine.LNX.4.21.0104252225360.5979-100000@linux.local>
Comments: In reply to Christoph Lange <langec@gmx.de>
        "IGNORE_EOF like in bash" (Apr 25, 10:33pm)
References: <Pine.LNX.4.21.0104252225360.5979-100000@linux.local>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Christoph Lange <duke@cyberspaces.de>, zsh-users@sunsite.auc.dk
Subject: Re: IGNORE_EOF like in bash
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Apr 25, 10:33pm, Christoph Lange wrote:
} Subject: IGNORE_EOF like in bash
}
} [...] I found out that one can script it in zsh-4.0.1-pre-3 [...]
} since the shell no longer bypasses ZLE when ^D is pressed on an empty
} command line.

Almost correct:  It doesn't bypass ZLE on ^D provided `setopt ignoreeof'.
 
} Here is my solution, configurable by the variable IGNOREEOF:
} 
} IGNOREEOF=3				# or something like that
} 
} bash-ctrl-d() {
}   if [[ $CURSOR == 0 && -z $BUFFER ]]
}   then
}     [[ -z $IGNOREEOF || $IGNOREEOF == 0 ]] && exit
}     [[ $LASTWIDGET == bash-ctrl-d ]] \
}       && (( --__BASH_IGNORE_EOF == 0 )) \
}       && exit
}     : ${__BASH_IGNORE_EOF=$IGNOREEOF}
}     zle send-break
}   else
}     zle delete-char-or-list
}   fi
} }

With your function, IGNOREEOF=3 will require four ^D to exit, or two ^D
and then anything else, repeated four times (because it never starts
__BASH_IGNORE_EOF over at three after the first call to this function).

I think you want:

bash-ctrl-d() {
  if [[ $CURSOR == 0 && -z $BUFFER ]]
  then
    [[ -z $IGNOREEOF || $IGNOREEOF == 0 ]] && exit
    if [[ $LASTWIDGET == bash-ctrl-d ]]
    then
      (( --__BASH_IGNORE_EOF <= 0 )) && exit
    else
      (( __BASH_IGNORE_EOF = IGNOREEOF-1 ))
    fi
    zle send-break
  else
    zle delete-char-or-list
  fi
}


-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

