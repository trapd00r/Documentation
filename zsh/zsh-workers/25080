From zsh-workers-return-25080-mason-zsh=primenet.com.au@sunsite.dk Wed May 21 17:29:06 2008
Return-Path: <zsh-workers-return-25080-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23092 invoked from network); 21 May 2008 17:29:04 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.4 (2008-01-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.4 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 21 May 2008 17:29:04 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 75598 invoked from network); 21 May 2008 17:29:00 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 21 May 2008 17:29:00 -0000
Received: (qmail 3426 invoked by alias); 21 May 2008 17:28:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 25080
Received: (qmail 3414 invoked from network); 21 May 2008 17:28:57 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 21 May 2008 17:28:57 -0000
Received: from flock1.newmail.ru (flock1.newmail.ru [82.204.219.207])
	by bifrost.dotsrc.org (Postfix) with SMTP id 070A580589A4
	for <zsh-workers@sunsite.dk>; Wed, 21 May 2008 19:28:51 +0200 (CEST)
Received: (qmail 7149 invoked from network); 21 May 2008 17:28:04 -0000
Received: from unknown (HELO cooker.net) (arvidjaar@newmail.ru@91.77.110.104)
  by smtpd.newmail.ru with SMTP; 21 May 2008 17:28:04 -0000
From: Andrey Borzenkov <arvidjaar@newmail.ru>
To: zsh-workers@sunsite.dk
Subject: Re: compmatch behaviour
Date: Wed, 21 May 2008 21:28:02 +0400
User-Agent: KMail/1.9.9
References: <10710.1211137299@pws-pc>
In-Reply-To: <10710.1211137299@pws-pc>
MIME-Version: 1.0
Content-Type: multipart/signed;
  boundary="nextPart1336888.8E6XsxYLQF";
  protocol="application/pgp-signature";
  micalg=pgp-sha1
Content-Transfer-Encoding: 7bit
Message-Id: <200805212128.03103.arvidjaar@newmail.ru>
X-Virus-Scanned: ClamAV 0.91.2/7199/Wed May 21 17:11:08 2008 on bifrost
X-Virus-Status: Clean

--nextPart1336888.8E6XsxYLQF
Content-Type: text/plain;
  charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

On Sunday 18 May 2008, Peter Stephenson wrote:
>=20
> Plea for help.
>=20
> I usually face the completion code on my own, but I'm just looking at
> trying to update the matching code to make it more general.  (I believe
> I'm already relying on a change of Andrey's that simplifies it in one
> respect.  Thank you.)
>=20
> However, there's one bit that's got me stumped, and unfortunately it's
> the core of the whole business.  bld_line() in Src/Zle/compmatch.c works
> as follows:
>=20
> - Input a "word pattern" (the test completion) and a "line pattern" (what
>   we're matching it against).
> - If we haven't yet got to the end of the line pattern
>   - If the line pattern is an equivalence class,

Nope, this is other way round. Equivalence (actually it is called
correspondence in documentation) class is simply reduced to standard
character class; this condition later returns a single match:

(lpat->equiv && c) ? (c =3D=3D lpat->tab[i])

The problem we have is *really* with standard character class.

>                                                  then for *every* charact=
er=20
>     that can match the character in the test word (yes, you read that
>     correctly---if we're looking at upper case characters, for example,
>     we will try every possible upper case character until it works)

Nope, we will check only uppercase variant of character in the commad line

>     - set the character in the string from the command line
>     - recurse to test with this character in place with the line
>       pattern advanced but the same word pattern
>     - if it succeeded, return success.
>   - If it's not an equivalence class, no problem: only one character
>     to try.  Try it (same recursive logic but no nasty loop).
> - If we've got to the end of the line pattern (i.e. have recursed to the
>   extent where we've got a complete string from the command line,
>   - try matching the test completion and the trial word
>   - return success or failure.  (This causes the loop above either
>     to return success or try with a new character in the equivalence
>     class.)
>=20
> In other words, to detect a match we try every possible character that
> could possibly match and see if it does.  This is crazy.  Obviously this
> doesn't generalize to larger groups of characters.
>=20
> I think the basic reason for this is something along the lines of the
> following (I realise this isn't particularly coherent but this is the
> best I've got for now): because we can have patterns associated with
> both the trial string and the word on the command line, we have got
> ourselves into a position where the logic is naturally qudratic: both
> sides can in principle change and consequently we need to change one
> side to see if it can match the other.
>=20
> The code for bld_line() is in Src/Zle/compmatch.c.  If anyone can see a
> way out of this mess, I'd be glad to hear even tentative theories.

I tried to replace this function with something else and failed because I
still do not understand most of this file. Some clue what's going on may
give comment in join_strs() (where one use case for bld_line is):

/* This builds a string that may be put on the line that fully matches the
 * given strings. The return value is NULL if no such string could be built
 * or that string in local static memory, dup it. */

So we *actually* try to *build* line for whatever reasons; and this
perfectly explains what happens in bld_line(). But I failed to grasp full
sequence of transformations that happen in this file so I must admit I
do not understand why and when would we need to do this.

> Obviously, I will continue to look at it.  For now, however, I'm
> stumped.
>=20
> Another problem is that the match code makes extensive use of lengths,
> which need to become character counts, which means that anything that
> touches this code needs to use wide characters,

Hmm ... but if we ever want to move to "normal" pattern mathing code it
operates on multibyte not wide characters, does not it? This would imply
quite a lot of coversions; and some functions from compmatch.c are also
used in very unexpected places.

> which is a lot of=20
> tortuous code.  However, that problem is in principle soluble.  We need
> to get the first problem solved.
>=20



--nextPart1336888.8E6XsxYLQF
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEABECAAYFAkg0W6IACgkQR6LMutpd94yrwgCeOsoBws4E13Y+WMoCI8knh1DP
FRgAnA1eupPMt9+DIT2Jy6m/RjYobt3c
=C5+m
-----END PGP SIGNATURE-----

--nextPart1336888.8E6XsxYLQF--

