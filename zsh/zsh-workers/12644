From zsh-workers-return-12644-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Aug 15 15:37:44 2000
Return-Path: <zsh-workers-return-12644-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10329 invoked from network); 15 Aug 2000 15:37:40 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Aug 2000 15:37:40 -0000
Received: (qmail 27220 invoked by alias); 15 Aug 2000 15:36:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12644
Received: (qmail 27213 invoked from network); 15 Aug 2000 15:36:47 -0000
X-Envelope-Sender-Is: Andrej.Borsenkow@mow.siemens.ru (at relayer david.siemens.de)
From: "Andrej Borsenkow" <Andrej.Borsenkow@mow.siemens.ru>
To: "ZSH workers mailing list" <zsh-workers@sunsite.auc.dk>
Subject: SourceForge bug id 104052 - case study.
Date: Tue, 15 Aug 2000 19:36:38 +0400
Message-ID: <000401c006ce$9a5e8810$21c9ca95@mow.siemens.ru>
MIME-Version: 1.0
Content-Type: text/plain;
	charset="koi8-r"
Content-Transfer-Encoding: 7bit
X-Priority: 3 (Normal)
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2911.0)
X-MimeOLE: Produced By Microsoft MimeOLE V5.50.4133.2400
Importance: Normal

May be, it is well known already.

There are at least three different cases covered by this bug:

Case 1.

bor@itsrm2% typeset -A foo
bor@itsrm2% foo[\]]=bar
zsh: not an identifier: foo[\]]

Case 2.

bor@itsrm2% print $foo[\]]
]
bor@itsrm2% print ${foo[\]]}
zsh: bad substitution

Case 3.

bor@itsrm2% print $foo[(I)[^]]]
bar] <== that I do not understand at all!
bor@itsrm2% print ${(kv)foo}
a bar abc baz

Case 1 is caused by the fact, that setsparam() gets unmetafied parameter name.
Ironically, in this case everything is correctly parsed, `]' is properly
quoted, but distinction between `]' and `\]' is lost when parameter is
unmetafied. setsparam() calls isident(), that just checks for balanced `[' and
`]' and barfs (it never checks what is really inside the brackets).

Case 2 comes from the fact, that paramsubst() and getindex() treat both quoted
and unquoted brackets the same. The reason is (as I suspect) parameter
substitution in double-quotes - "$foo[bar]". When it is parsed by
dquote_parse(), it adds just plain ']' and not Outbrack; so, when it finally
reaches paramsubst() it may encounter both values. When inside of parens, Zsh
just warns about missing closing one (because it finds end of substitution too
early).

Case 3 the problem seems to be getarg(). It blindly skips over balanced
brackets that is of course wrong in this case.

Case 1 is basically independent of other two. Unfortunately, to solve it we
need to either remove call to isident() in setsparam() or pass metafied
parameter name to setsparam() and make isident() smart enough.

Case 2 - lexer should return different token for "]" as for \], e.g. Qoutbrack
like Qstring. And, of course, all uses of ']'/Outbrack should be checked ...
but note, that in this case

$foo[\]]

will be valid, but

"$foo[\]]"

not. By definition, you cannot quote inside of double quotes. Even

$foo["]"]

will be invalid in this case (a bit unexpected), unless code can be smart
enough to notice, that initial Inbrack was not quoted.

Case 3 - we may try to change (getarg(), around line 916 in Src/params.c)

	else if (c == ']' || c == Outbrack)

into something like

	else if ((c == ']' || c == Outbrack) &&
                t[-1] != '^' && t[-1] != '!' && t[-2] != '[' && t[-2] !=
Inbrack)

but this highly ambiguous case remains

$foo[(I)$bar[^]]

-andrej

