From zsh-workers-request@math.gatech.edu Wed Jun 10 08:57:14 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23914 invoked from network); 10 Jun 1998 08:57:12 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 10 Jun 1998 08:57:12 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id EAA03073;
	Wed, 10 Jun 1998 04:50:40 -0400 (EDT)
Resent-Date: Wed, 10 Jun 1998 04:50:40 -0400 (EDT)
Message-Id: <199806100851.BAA05622@bebop.clari.net>
To: "Bart Schaefer" <schaefer@brasslantern.com>
Cc: zsh-workers@math.gatech.edu
In-reply-to: schaefer's message of Tue, 09 Jun 1998 20:58:02 -0700.
	     <980609205803.ZM8774@candle.brasslantern.com> 
Subject: PATCH: even better history-search-{for,back}ward for 3.1.4 
Date: Wed, 10 Jun 1998 01:51:44 -0700
From: Wayne Davison <wayne@clari.net>
Resent-Message-ID: <"0am393.0.vl.VZaVr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4078
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

"Bart Schaefer" writes:
> Unfortunately, this doesn't work right.

Yeah, that code didn't save enough state.  I've appended a new
patch that does a better job.

> You can do a little better if you also save `hl' and reset the
> search if `histline' differs from the last time through, but
> that's still not quite right.

Cool -- I had the same idea, plus I also decided to save cs and the
search prefix, which allows the code to do a much better job at
figuring out when to start a new search.  It is still possible to
fool it into continuing the last search when the old code would have
started a new one, but it does behave much more like the code in
3.0.5 now.

A known deficiency is that if you use uplineorsearch and pass
through a multi-line history entry, the code will start a new
search, which may not be what you want (if it was searching for
a prefix and not a command name).  This should be easy enough
to fix, though.

> zsh% ech<M-p>
> zsh% echo this is a test<C-p>
> zsh% fc -R historytest<M-p>

I find it humorous that my old code did the right thing in this case
but for the wrong reason.  The new code will still search for "fc ",
but because it properly decided to start a new search.

This patch assumes that you've removed the previous one.

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: zle_hist.c
@@ -369,55 +369,69 @@
 	feep();
 }
 
+static int histpos, srch_hl, srch_cs = -1;
+static char *srch_str;
+
 /**/
 void
 historysearchbackward(void)
 {
-    int histpos, histmpos, hl = histline;
+    int hl = histline;
     char *s;
 
-    for (histpos = histmpos = 0; histpos < ll && !iblank(line[histpos]);
-	histpos++, histmpos++)
-	if(imeta(line[histpos]))
-	    histmpos++;
+    if (hl == curhist || hl != srch_hl || cs != srch_cs || mark != 0
+     || memcmp(srch_str, line, histpos) != 0) {
+	zfree(srch_str, histpos);
+	for (histpos = 0; histpos < ll && !iblank(line[histpos]); histpos++) ;
+	if (histpos < ll)
+	    histpos++;
+	srch_str = zalloc(histpos);
+	memcpy(srch_str, line, histpos);
+    }
     for (;;) {
 	hl--;
 	if (!(s = zle_get_event(hl))) {
 	    feep();
 	    return;
 	}
-	if (metadiffer(s, (char *) line, histpos) < 0 &&
-	    iblank(s[histmpos] == Meta ? s[histmpos+1]^32 : s[histmpos]) &&
-	    metadiffer(s, (char *) line, ll))
+	if (metadiffer(s, srch_str, histpos) < 0 &&
+	    metadiffer(s, srch_str, ll))
 	    break;
     }
     zle_goto_hist(hl);
+    srch_hl = hl;
+    srch_cs = cs;
 }
 
 /**/
 void
 historysearchforward(void)
 {
-    int histpos, histmpos, hl = histline;
+    int hl = histline;
     char *s;
 
-    for (histpos = histmpos = 0; histpos < ll && !iblank(line[histpos]);
-	histpos++, histmpos++)
-	if(imeta(line[histpos]))
-	    histmpos++;
+    if (hl == curhist || hl != srch_hl || cs != srch_cs || mark != 0
+     || memcmp(srch_str, line, histpos) != 0) {
+	zfree(srch_str, histpos);
+	for (histpos = 0; histpos < ll && !iblank(line[histpos]); histpos++) ;
+	if (histpos < ll)
+	    histpos++;
+	srch_str = zalloc(histpos);
+	memcpy(srch_str, line, histpos);
+    }
     for (;;) {
 	hl++;
 	if (!(s = zle_get_event(hl))) {
 	    feep();
 	    return;
 	}
-	if (metadiffer(s, (char *) line, histpos) < (histline == curhist) &&
-	    (!s[histmpos] ||
-	     iblank(s[histmpos] == Meta ? s[histmpos+1]^32 : s[histmpos])) &&
-	    metadiffer(s, (char *) line, ll))
+	if (metadiffer(s, srch_str, histpos) < (hl == curhist) &&
+	    metadiffer(s, srch_str, ll))
 	    break;
     }
     zle_goto_hist(hl);
+    srch_hl = hl;
+    srch_cs = cs;
 }
 
 /**/
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

