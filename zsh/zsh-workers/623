From pws@ifh.de  Fri Nov 17 11:37:42 1995
Return-Path: <pws@ifh.de>
Received: from moira.ifh.de by math.gatech.edu (5.x/SMI-SVR4)
	id AA04997; Fri, 17 Nov 1995 11:37:42 -0500
Received: from sgi.ifh.de by moira.ifh.de with SMTP id AA63336
  (5.67b8/IDA-1.5 for <@moira.ifh.de:zsh-workers@math.gatech.edu>); Fri, 17 Nov 1995 17:38:17 +0100
Received: by sgi.ifh.de (931110.SGI/930416.SGI)
	for @moira.ifh.de:zsh-workers@math.gatech.edu id AA11768; Fri, 17 Nov 95 17:38:01 +0100
Message-Id: <9511171638.AA11768@sgi.ifh.de>
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: Re: When does single_line_zle get set? 
In-Reply-To: "p.stephenson@swansea.ac.uk"'s message of "Mon, 26 Jun 1995 11:19:18 MET."
             <25744.9506261019@pyro.swan.ac.uk> 
Date: Fri, 17 Nov 1995 17:38:01 +0100
From: Peter Stephenson <pws@ifh.de>
content-length: 5875

Here's a repeat of a patch fixing the following problem:  if the shell
starts with TERM set to something which exists but doesn't have
up-line, SINGLE_LINE_ZLE gets set.  The problem is that it stays set
if the TERM gets changed (unlike if the initial setting was complete
nonsense).  As this happens for an initial setting of `unknown' on a
lot of machines, this is bad news for users.

The new patch is necessary because the termcap code has been moved
around.  I've made it smarter with some definitions, but it does
exactly the same thing it did before.

*** Src/init.c.sl	Fri Nov 17 17:15:16 1995
--- Src/init.c	Fri Nov 17 17:21:40 1995
***************
*** 427,433 ****
  init_term(void)
  {
      if (!*term)
! 	return termok = 0;
  
      /* unset zle if using zsh under emacs */
      if (!strcmp(term, "emacs"))
--- 427,433 ----
  init_term(void)
  {
      if (!*term)
! 	return termok = TERM_BAD;
  
      /* unset zle if using zsh under emacs */
      if (!strcmp(term, "emacs"))
***************
*** 437,448 ****
  	if (isset(INTERACTIVE))
  	    zerr("can't find termcap info for %s", term, 0);
  	errflag = 0;
! 	return termok = 0;
      } else {
  	char tbuf[1024], *pp;
  	int t0;
  
! 	termok = 1;
  	for (t0 = 0; t0 != TC_COUNT; t0++) {
  	    pp = tbuf;
  	    zsfree(tcstr[t0]);
--- 437,448 ----
  	if (isset(INTERACTIVE))
  	    zerr("can't find termcap info for %s", term, 0);
  	errflag = 0;
! 	return termok = TERM_BAD;
      } else {
  	char tbuf[1024], *pp;
  	int t0;
  
! 	termok = TERM_OK;
  	for (t0 = 0; t0 != TC_COUNT; t0++) {
  	    pp = tbuf;
  	    zsfree(tcstr[t0]);
***************
*** 458,467 ****
  	/* check whether terminal has automargin (wraparound) capability */
  	hasam = tgetflag("am");
  
! 	/* if there's no termcap entry for cursor up, use single line mode. */
  	if (!tccan(TCUP)) {
  		tcstr[TCUP] = NULL;
! 		opts[SINGLELINEZLE] = OPT_SET;
  	}
  
  	/* if there's no termcap entry for cursor left, use \b. */
--- 458,469 ----
  	/* check whether terminal has automargin (wraparound) capability */
  	hasam = tgetflag("am");
  
! 	/* if there's no termcap entry for cursor up, use single line mode: *
! 	 * this is flagged by termok which is examined in zle_refresh.c     *
! 	 */
  	if (!tccan(TCUP)) {
  		tcstr[TCUP] = NULL;
! 		termok = TERM_NOUP;
  	}
  
  	/* if there's no termcap entry for cursor left, use \b. */
***************
*** 515,521 ****
      bangchar = '!';
      hashchar = '#';
      hatchar = '^';
!     termok = 0;
      curjob = prevjob = coprocin = coprocout = -1;
      gettimeofday(&shtimer, &dummy_tz);	/* init $SECONDS */
      srand((unsigned int)(shtimer.tv_sec + shtimer.tv_usec)); /* seed $RANDOM */
--- 517,523 ----
      bangchar = '!';
      hashchar = '#';
      hatchar = '^';
!     termok = TERM_BAD;
      curjob = prevjob = coprocin = coprocout = -1;
      gettimeofday(&shtimer, &dummy_tz);	/* init $SECONDS */
      srand((unsigned int)(shtimer.tv_sec + shtimer.tv_usec)); /* seed $RANDOM */
*** Src/params.c.sl	Fri Nov 17 17:24:05 1995
--- Src/params.c	Fri Nov 17 17:22:28 1995
***************
*** 1691,1697 ****
  
      /* If non-interactive, delay setting up term till we need it. */
      if (unset(INTERACTIVE) || !*term)
! 	termok = 0;
      else 
  	init_term();
  }
--- 1691,1697 ----
  
      /* If non-interactive, delay setting up term till we need it. */
      if (unset(INTERACTIVE) || !*term)
! 	termok = TERM_BAD;
      else 
  	init_term();
  }
*** Src/zle_refresh.c.sl	Fri Nov 17 17:18:24 1995
--- Src/zle_refresh.c	Fri Nov 17 17:19:25 1995
***************
*** 66,72 ****
      static int lwinw = -1, lwinh = -1;	/* last window width & height */
   
      winw = (columns < 1) ? (columns = 80) : columns;  /* terminal width */
!     if (isset(SINGLELINEZLE) || !termok)
  	winh = 1;
      else
  	winh = (lines < 2) ? 24 : lines;
--- 66,72 ----
      static int lwinw = -1, lwinh = -1;	/* last window width & height */
   
      winw = (columns < 1) ? (columns = 80) : columns;  /* terminal width */
!     if (isset(SINGLELINEZLE) || termok != TERM_OK)
  	winh = 1;
      else
  	winh = (lines < 2) ? 24 : lines;
***************
*** 196,202 ****
                  cleareol = 1;   /* set */
          if (t0 > -1)
              olnct = t0;
!         if (isset(SINGLELINEZLE) || !termok)
              vcs = 0;
          else if (!clearflag && lpptlen) {
              fwrite(lpptbuf, lpptlen, 1, shout);
--- 196,202 ----
                  cleareol = 1;   /* set */
          if (t0 > -1)
              olnct = t0;
!         if (isset(SINGLELINEZLE) || termok != TERM_OK)
              vcs = 0;
          else if (!clearflag && lpptlen) {
              fwrite(lpptbuf, lpptlen, 1, shout);
***************
*** 210,216 ****
  
  /* now winw equals columns; now all width comparisons can be made to winw */
  
!     if (isset(SINGLELINEZLE) || !termok) {
  	singlerefresh();
  	return;
      }
--- 210,216 ----
  
  /* now winw equals columns; now all width comparisons can be made to winw */
  
!     if (isset(SINGLELINEZLE) || termok != TERM_OK) {
  	singlerefresh();
  	return;
      }
*** Src/zsh.h.sl	Fri Nov 17 17:15:26 1995
--- Src/zsh.h	Fri Nov 17 17:23:31 1995
***************
*** 1130,1135 ****
--- 1130,1142 ----
  #define txtchangeisset(X)	(txtchange & (X))
  #define txtchangeset(X, Y)	(txtchange |= (X), txtchange &= ~(Y))
  
+ /* flags for termok state: usually the test for whether termok is set is
+  * enough: in the refresh code we need to know whether the terminal has
+  * an up capability.
+  */
+ #define TERM_BAD	0
+ #define TERM_OK		1
+ #define TERM_NOUP	2
  
  /*********************/
  /* Definitions for ? */

-- 
Peter Stephenson <pws@ifh.de>       Tel: +49 33762 77366
WWW:  http://www.ifh.de/~pws/       Fax: +49 33762 77330
Deutches Electronen-Synchrotron --- Institut fuer Hochenergiephysik Zeuthen
DESY-IfH, 15735 Zeuthen, Germany.

