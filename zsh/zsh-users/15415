From zsh-users-return-15415-mason-zsh=primenet.com.au@zsh.org Mon Sep 20 14:55:52 2010
Return-Path: <zsh-users-return-15415-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19926 invoked by alias); 20 Sep 2010 14:55:52 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15415
Received: (qmail 2699 invoked from network); 20 Sep 2010 14:55:49 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100920075521.ZM30584@torch.brasslantern.com>
Date: Mon, 20 Sep 2010 07:55:21 -0700
In-reply-to: <AANLkTimY1T1n9Nq7ePkNdSbJ9zhPobwzwM5SfNYb8qfB@mail.gmail.com>
Comments: In reply to Anonymous bin ich <ichbinanon@gmail.com>
 "Re: Waiting for a process without using pid" (Sep 20,  1:09pm)
References: <AANLkTinyDC-OoGBzuisMKUg+OqeeqG=HKZrNDuJZL+sD@mail.gmail.com>
	<100916072654.ZM29712@torch.brasslantern.com>	<4C950347.9060109@gmail.com>
	<100918124147.ZM31152@torch.brasslantern.com>
	<AANLkTimY1T1n9Nq7ePkNdSbJ9zhPobwzwM5SfNYb8qfB@mail.gmail.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Waiting for a process without using pid
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 20,  1:09pm, Anonymous bin ich wrote:
}
} Ok, I have made some modifications, and I am now confused :(
} Three output are given here. Is there a race condition somewhere?

"setopt HUP" means that zsh starts the children with SIGHUP unblocked.
/bin/sh doesn't reset that signal, so when you "kill -HUP -$$" in the
parent, every process in the process group gets SIGHUP.

Because you used "sleep $1 & wait" in the child, the sleep process is
a separate entity which is also in the process group, so it is also
a target for that HUP.  The race is whether the OS delivers the HUP
to child.sh before it delivers it to sleep (or, more likely, whether
child.sh gets a timeslice to run before sleep does); if child.sh goes
first, it can "kill $pid" before sleep has exited, otherwise it gets
an error because sleep already died on HUP.

You could probably observe this by putting a trap on CHLD in child.sh.
 
} PS: My original aim was to have both childs killed whenever SIGCHLD is
} received, and parent should continue to run. But I think I can manage
} that if this problem goes away...

Perhaps I was trying to make my solution too general; i.e., I didn't
want to care how many children were started or whether their PIDs had
been remembered.  But if you always have exactly two children, why not
this?

    coproc read -E
    trap "print -p" CHLD

    ./child.sh &
    pid1=$!
    ./child.sh &
    pid2=$!

    read -p
    kill $pid1 >&/dev/null
    kill $pid2 >&/dev/null

Does it matter whether you kill again a PID that's already exited?  If
PIDs recycle rapidly and this script is running as root, it might, but
otherwise I wouldn't think so.

