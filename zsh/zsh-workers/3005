From zsh-workers-request@euclid.skiles.gatech.edu Wed Mar 19 18:35:22 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 19062 invoked from network); 19 Mar 1997 18:35:18 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 19 Mar 1997 18:35:18 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id MAA15537; Wed, 19 Mar 1997 12:58:55 -0500 (EST)
Resent-Date: Wed, 19 Mar 1997 12:58:55 -0500 (EST)
Date: Wed, 19 Mar 1997 18:01:29 GMT
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <22109.199703191801@stone.dcs.warwick.ac.uk>
Subject: unloading zle
X-Patch: 210
Resent-Message-ID: <"tnORc2.0.io3.Pb2Cp"@euclid>
To: zsh-workers@math.gatech.edu
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3005
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

This patch makes it possible to unload the zle module.  In addition to
being the kind of thing that ought to work anyway, it is useful when
testing changes to ZLE -- unloading a module and loading the new version
is a lot quicker than restarting the entire shell.

The Makefile changes merely avoid overwriting possibly-running code,
which is a significant issue when testing in this manner.

 -zefram

 *** Src/Makefile.in	1997/01/29 03:25:01	1.35
 --- Src/Makefile.in	1997/03/19 15:32:18
 ***************
 *** 171,184 ****
 --- 171,187 ----
   bin: zsh
   
   zsh: $(PROTO) $(@L@IBZSH) $(@L@OBJS) $(@L@STMP)
 + 	rm -f $@
   	$(LINK) $(@L@OBJS) $(@L@LIST) $(LIBS)
   
   $(LIBZSH): $(LIBOBJS) $(NSTMP)
 + 	rm -f $@
   	$(DLLD) $(LDFLAGS) $(DLLDFLAGS) -o $(LIBZSH) $(LIBOBJS) $(NLIST)
   	ln -sf $(LIBZSH) libzsh.so
   
   ansi2knr: ansi2knr.c
   	$(COMPILE) $(srcdir)/ansi2knr.c
 + 	rm -f $@
   	$(LINK) ansi2knr.o
   
   signames.h: signames.awk $(SIGNAL_H)
 *** Src/Modules/Makefile.in	1997/03/17 01:43:24	1.18
 --- Src/Modules/Makefile.in	1997/03/19 15:32:36
 ***************
 *** 94,99 ****
 --- 94,100 ----
   	rm -f $@.c
   
   ..o.$(DL_EXT):
 + 	rm -f $@
   	$(DLLINK) $<
   
   .c.pro:
 *** Src/Zle/Makefile.in	1997/03/18 23:56:47	1.23
 --- Src/Zle/Makefile.in	1997/03/19 15:33:16
 ***************
 *** 93,98 ****
 --- 93,99 ----
   	rm -f $@.c
   
   ..o.$(DL_EXT):
 + 	rm -f $@
   	$(DLLINK) $<
   
   .c.pro:
 ***************
 *** 131,136 ****
 --- 132,138 ----
   shobjs: $(MODULES)
   
   zle.so: $(ZLEDOBJS)
 + 	rm -f $@
   	$(DLLINK) $(ZLEDOBJS)
   
   zle_things.h: thingies.list zle_things.sed
 *** Src/Zle/zle_hist.c	1997/03/18 23:56:48	1.13
 --- Src/Zle/zle_hist.c	1997/03/19 15:00:59
 ***************
 *** 627,632 ****
 --- 627,643 ----
   
   static int max_spot = 0;
   
 + #ifdef MODULE
 + 
 + /**/
 + void
 + free_isrch_spots(void)
 + {
 +     zfree(isrch_spots, max_spot * sizeof(*isrch_spots));
 + }
 + 
 + #endif /* MODULE */
 + 
   static void
   set_isrch_spot(int num, int hl, int pos, int cs, int len, int dir, int nomatch)
   {
 *** Src/Zle/zle_keymap.c	1997/03/04 02:22:38	1.9
 --- Src/Zle/zle_keymap.c	1997/03/19 14:47:44
 ***************
 *** 980,985 ****
 --- 980,999 ----
       keybuf = (char *)zalloc(keybufsz);
   }
   
 + #ifdef MODULE
 + 
 + /* cleanup entry point (for unloading the zle module) */
 + 
 + /**/
 + void
 + cleanup_keymaps(void)
 + {
 +     deletehashtable(keymapnamtab);
 +     zfree(keybuf, keybufsz);
 + }
 + 
 + #endif /* MODULE */
 + 
   /* Create the default keymaps.  For efficiency reasons, this function   *
    * assigns directly to the km->first array.  It knows that there are no *
    * prefix bindings in the way, and that it is using a simple keymap.    */
 *** Src/Zle/zle_main.c	1997/03/18 23:56:49	1.26
 --- Src/Zle/zle_main.c	1997/03/19 15:33:26
 ***************
 *** 782,784 ****
 --- 782,825 ----
       addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
       return 0;
   }
 + 
 + #ifdef MODULE
 + 
 + /**/
 + int
 + cleanup_zle(Module m)
 + {
 +     int i;
 + 
 +     if(zleactive) {
 + 	zerrnam(m->nam, "can't unload the zle module while zle is active",
 + 	    NULL, 0);
 + 	return 1;
 +     }
 + 
 +     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
 +     cleanup_keymaps();
 +     unrefthingy(lastnamed);
 +     deletehashtable(thingytab);
 + 
 +     zfree(vichgbuf, vichgbufsz);
 +     zfree(kungetbuf, kungetsz);
 +     free_isrch_spots();
 + 
 +     zfree(cutbuf.buf, cutbuf.len);
 +     for(i = KRINGCT; i--; )
 + 	zfree(kring[i].buf, kring[i].len);
 +     for(i = 35; i--; )
 + 	zfree(vibuf[i].buf, vibuf[i].len);
 + 
 +     /* editor entry points */
 +     trashzleptr = noop_function;
 +     gotwordptr = noop_function;
 +     refreshptr = noop_function;
 +     spaceinlineptr = noop_function_int;
 +     zlereadptr = fallback_zleread;
 + 
 +     return 0;
 + }
 + 
 + #endif /* MODULE */
 *** Src/Zle/zle_thingy.c	1997/03/18 23:56:49	1.3
 --- Src/Zle/zle_thingy.c	1997/03/19 15:14:27
 ***************
 *** 51,56 ****
 --- 51,57 ----
   /* local functions */
   
   static void createthingytab _((void));
 + static void emptythingytab _((HashTable));
   static Thingy makethingynode _((void));
   static void freethingynode _((HashNode));
   
 ***************
 *** 71,77 ****
       thingytab = newhashtable(199, "thingytab", NULL);
   
       thingytab->hash        = hasher;
 !     thingytab->emptytable  = NULL;
       thingytab->filltable   = NULL;
       thingytab->addnode     = addhashnode;
       thingytab->getnode     = gethashnode;
 --- 72,78 ----
       thingytab = newhashtable(199, "thingytab", NULL);
   
       thingytab->hash        = hasher;
 !     thingytab->emptytable  = emptythingytab;
       thingytab->filltable   = NULL;
       thingytab->addnode     = addhashnode;
       thingytab->getnode     = gethashnode;
 ***************
 *** 81,86 ****
 --- 82,100 ----
       thingytab->enablenode  = NULL;
       thingytab->freenode    = freethingynode;
       thingytab->printnode   = NULL;
 + }
 + 
 + static void
 + emptythingytab(HashTable ht)
 + {
 +     /* This will only be called when deleting the thingy table, which *
 +      * is only done to unload the zle module.  A normal emptytable()  *
 +      * function would free all the thingies, but we don't want to do  *
 +      * that because some of them are the known thingies in the fixed  *
 +      * `thingies' table.  As the module cleanup code deletes all the  *
 +      * keymaps and so on before deleting the thingy table, we can be  *
 +      * sure that *all* the thingies left at this point are the fixed  *
 +      * ones.  Therefore, we don't want to free any of them.           */
   }
   
   static Thingy

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia
Charset: ascii

iQCVAwUBMzAJ5HD/+HJTpU/hAQHA7QP/ZZijMYUwO17sPBfG89n3SrajDu0hg4Ji
YOHYR7RrldZ7eLJCg59MTlIwylLffu0SyVsw/ghZB24sQKPNvXvtW2uZs8+8gJ4W
8fn05wqH5c5IVWzw1TJ/VkfoITyhM47msMse6PZitpAql3/n5HFcb6t+Ivtc8rcg
5GRX3eOqUJc=
=ov4P
-----END PGP SIGNATURE-----

