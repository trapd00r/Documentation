From zsh-workers-return-8217-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Oct 12 08:19:51 1999
Return-Path: <zsh-workers-return-8217-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4692 invoked from network); 12 Oct 1999 08:19:49 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Oct 1999 08:19:49 -0000
Received: (qmail 15211 invoked by alias); 12 Oct 1999 08:19:41 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8217
Received: (qmail 15201 invoked from network); 12 Oct 1999 08:19:38 -0000
Date: Tue, 12 Oct 1999 10:19:35 +0200 (MET DST)
Message-Id: <199910120819.KAA04337@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: misc completion stuff


Changes:

- Remove the longish comments in some of the functions. This is mainly 
  because this is now in the manual and the comments are partly
  out-of-date (and who goes through all the functions anyway?).
  I wouldn't object to leaving them there, though, but then somebody
  should make sure they are still correct.
- The handling of the special contexts in `_complete' is cleaner
  (i.e. I finally removed that stupid `case...').
- (This one may be the most arguable...) The call to `compcall' in
  `_default' is commented out (i.e. it doesn't try to use `compctl's
  anymore if no special completion function was found. I /hope/ that
  you agree that the new completion system is already good enough to
  do that.

Bye
 Sven

diff -u -r oldcompletion/Base/_default Completion/Base/_default
--- oldcompletion/Base/_default	Mon Oct 11 14:32:16 1999
+++ Completion/Base/_default	Tue Oct 12 09:23:25 1999
@@ -1,21 +1,25 @@
 #compdef -default-
 
-# We first try the `compctl's. This is without first (-T) and default (-D)
-# completion. If you want them add `-T' and/or `-D' to this command.
-# If there is a `compctl' for the command we are working on, we return
-# immediatly. If you want to use new style completion anyway, remove the
-# `|| return'. Also, you may want to use new style completion if the 
-# `compctl' didn't produce any matches. In that case remove the `|| return'
-# and insert the line `[[ compstate[nmatches] -eq 0 ]] || return' after
-# `compcall'.
+local expl
 
-compcall || return 0
+# You can first try the `compctl's by uncommenting the `compcall' line
+# below.
+# This is without first (-T) and default (-D) completion. If you want
+# them add `-T' and/or `-D' to this command. If there is a `compctl'
+# for the command we are working on, we return immediatly. If you want
+# to use new style completion anyway, remove the `|| return'. Also,
+# you may want to use new style completion if the `compctl' didn't
+# produce any matches. In that case remove the `|| return' and insert
+# the line `[[ compstate[nmatches] -eq 0 ]] || return' after `compcall'.
 
-_files && return
+# compcall || return 0
+
+_description expl file
+_files "$expl[@]" && return
 
 # magicequalsubst allows arguments like <any-old-stuff>=~/foo to do
 # file name expansion after the =.  In that case, it's natural to
 # allow completion to handle file names after any equals sign.
 if [[ -o magicequalsubst ]] && compset -P 1 '*='; then
-  _files
+  _files "$expl[@]"
 fi
diff -u -r oldcompletion/Core/_approximate Completion/Core/_approximate
--- oldcompletion/Core/_approximate	Mon Oct 11 14:32:19 1999
+++ Completion/Core/_approximate	Tue Oct 12 09:22:23 1999
@@ -4,62 +4,6 @@
 # strings generated for the context. These corrected strings will be
 # shown in a list and one can cycle through them as in a menucompletion
 # or get the corrected prefix.
-#
-# Supported configuration keys:
-#
-#  approximate_accept
-#    This should be set to a number, specifying the maximum number
-#    of errors that should be accepted. If the string also contains
-#    a `n' or `N', the code will use the numeric argument as the
-#    maximum number of errors if a numeric argument was given. If no
-#    numeric argument was given, the number from the value of this
-#    key will be used. E.g. with `compconf approximate_accept=2n' two
-#    errors will be accepted, but if the user gives another number
-#    with the numeric argument, this will be prefered. Also, with
-#    `compconf approximate_accept=0n', normally no correction will be
-#    tried, but if a numeric argument is given, automatic correction
-#    will be used. On the other hand, if the string contains an `!'
-#    and a `n' or `N', correction is not attempted if a numeric
-#    argument is given. Once the number of errors to accept is
-#    determined, the code will repeatedly try to generate matches by
-#    allowing one error, two errors, and so on. Independent of the
-#    number of errors the user wants to accept, the code will allow
-#    only fewer errors than there are characters in the string from
-#    the line.
-#
-#  approximate_original
-#    This value is used to determine if the original string should
-#    be included in the list (and thus be presented to the user when
-#    cycling through the corrections). If it is set to any non-empty
-#    value, the original string will be offered. If it contains the
-#    sub-string `last', the original string will appear as the last
-#    string when cycling through the corrections, otherwise it will
-#    appear as the first one (so that the command line does not
-#    change immediately). Also, if the value contains the sub-string
-#    `always', the original string will always be included, whereas
-#    normally it is included only if more than one possible
-#    correction was generated.
-#
-#  approximate_prompt
-#    This can be set to a string that should be printed before the
-#    list of corrected strings when cycling through them. This string
-#    may contain the control sequences `%n', `%B', etc. known from
-#    the `-X' option of `compctl'. Also, the sequence `%e' will be
-#    replaced by the number of errors accepted to generate the
-#    corrected strings.
-#
-#  approximate_insert
-#    If this is set to a string starting with `unambig', the code
-#    will try to insert a usable unambiguous string in the command
-#    line instead of always cycling through the corrected strings.
-#    If such a unambiguous string could be found, the original
-#    string is not used, independent of the setting of
-#    `approximate_original'. If no sensible string could be found,
-#    one can cycle through the corrected strings as usual.
-#
-# If any of these keys is not set, but the the same key with the
-# prefix `correct' instead of `approximate' is set, that value will
-# be used.
 
 local _comp_correct _correct_prompt comax
 local cfgacc cfgorig cfgps cfgins
diff -u -r oldcompletion/Core/_complete Completion/Core/_complete
--- oldcompletion/Core/_complete	Mon Oct 11 14:32:19 1999
+++ Completion/Core/_complete	Tue Oct 12 09:22:23 1999
@@ -36,20 +36,7 @@
   # Let's see if we have a special completion definition for the other
   # possible contexts.
 
-  comp=''
-
-  case $compstate[context] in
-  equal)           comp="$_comps[-equal-]";;
-  tilde)           comp="$_comps[-tilde-]";;
-  redirect)        comp="$_comps[-redirect-]";;
-  math)            comp="$_comps[-math-]";;
-  subscript)       comp="$_comps[-subscript-]";;
-  value)           comp="$_comps[-value-]";;
-  array_value)     comp="$_comps[-array-value-]";;
-  condition)       comp="$_comps[-condition-]";;
-  parameter)       comp="$_comps[-parameter-]";;
-  brace_parameter) comp="$_comps[-brace-parameter-]";;
-  esac
+  comp="$_comps[-${compstate[context]:s/_/-/}-]"
 
   # If not, we use default completion, if any.
 
diff -u -r oldcompletion/Core/_expand Completion/Core/_expand
--- oldcompletion/Core/_expand	Mon Oct 11 14:32:20 1999
+++ Completion/Core/_expand	Tue Oct 12 09:22:24 1999
@@ -6,55 +6,6 @@
 # This function will allow other completer functions to be called if
 # the expansions done produce no result or do not change the original
 # word from the line.
-#
-# Configuration keys:
-#
-#  expand_substitute
-#    If this is unset or set to the empty string, the code will first
-#    try to expand all substitutions in the string (such as $(...) and
-#    ${...}). If this is set to an non-empty string it should be 
-#    an expression usable inside a $[...] arithmetical expression.
-#    In this case, expansion of substitutions will be done if the
-#    expression evaluates to `1'. For example, with
-#
-#      compconf expand_substitute='${NUMERIC:-1} != 1'
-#
-#    substitution will be performed only if given an explicit numeric
-#    argument other than `1', as by typing ESC 2 TAB.
-#
-#  expand_glob
-#    If this is unset or set to an empty string, globbing will be
-#    attempted on the word resulting from substitution or the
-#    original string. The values accepted for this key are the same
-#    as for expand_substitute.
-#
-#  expand_menu
-#    If this is unset or set to the empty string, the words resulting
-#    from expansion (if any) will simply be inserted in the command line,
-#    replacing the original string. However, if this key is set to an
-#    non-empty string, the user can cycle through the expansion as in
-#    a menucompletion. Unless the value contains the sub-string `only',
-#    the user will still be offered all expansions at once as one of
-#    the strings to insert in the command line. Also, if the value
-#    contains the sub-string `last', the string with all expansion will
-#    be offered first, whereas normally it is offered as the last string
-#    to insert. Finally, if the value contains the sub-string `sort',
-#    the expansions will be sorted alphabetically, normally they are
-#    kept in the order the expansion produced them in.
-#    
-#  expand_original
-#    If this is set to an non-empty string, the original string from the
-#    line will be included in the list of strings the user can cycle
-#    through as in a menucompletion. If the value contains the sub-string
-#    `last', the original string will appear as the last string, with
-#    other values it is inserted as the first one (so that the command
-#    line does not change immediatly).
-#
-#  expand_prompt
-#    This may be set to a string that should be displayed before the
-#    possible expansions. This is given to the -X option and thus may
-#    contain the control sequences `%n', `%B', etc. Also, the sequence
-#    `%o' in this string will be replaced by the original string.
 
 local exp word="$PREFIX$SUFFIX" group=-V expl expl2 disp
 
diff -u -r oldcompletion/Core/_list Completion/Core/_list
--- oldcompletion/Core/_list	Mon Oct 11 14:32:20 1999
+++ Completion/Core/_list	Tue Oct 12 09:22:24 1999
@@ -3,30 +3,6 @@
 # This completer function makes the other completer functions used
 # insert possible completions only after the list has been shown at
 # least once.
-#
-# Configuration keys:
-#
-#  list_condition
-#    If this key is unset or set to the empty string, this completer
-#    will delay the insertion of matches unconditionally. However,
-#    if this value is set, it should be set to an expression usable
-#    inside a $[...] arithmetical expression. In this case, delaying
-#    will be done if the expression evaluates to `1'.
-#    For example, with
-#
-#      compconf list_condition='${NUMERIC:-1} != 1'
-#
-#    delaying will be done only if given an explicit numeric argument
-#    other than `1'.
-#
-#  list_word
-#    To find out if only listing should be done, the code normally
-#    compares the contents of the line with the contents the line
-#    had at the time of the last invocation. If this key is set to
-#    an non-empty string comparison is done using only the current
-#    word. So if it is set, attempting completion on a word equal
-#    to the one completion was called on the last time will not
-#    delay the generation of matches.
 
 local pre suf
 
diff -u -r oldcompletion/Core/_main_complete Completion/Core/_main_complete
--- oldcompletion/Core/_main_complete	Mon Oct 11 14:32:20 1999
+++ Completion/Core/_main_complete	Tue Oct 12 09:22:24 1999
@@ -2,44 +2,6 @@
 
 # The main loop of the completion code. This is what is called when 
 # completion is attempted from the command line.
-#
-# Configuration keys used:
-#
-#  completer
-#    This should be set to the names of the functions to generate the
-#    matches separated by colons. E.g. with
-#
-#      compconf completer=_complete:_correct:_approximate
-#
-#    the code will first try normal completion. If that doesn't yield
-#    any matches, correction is tried and if that doesn't yield
-#    anything either, correcting completion is attempted.
-#
-#    These completer functions are only used when this function is called
-#    without arguments. If arguments are given, they should be names of
-#    completer functions which will then be called.
-#
-#  last_prompt
-#    If this is set to `always' the cursor is moved up to the last prompt
-#    after printing a list even if a numeric argument was given.
-#
-#
-# Also, most completion functions use the configuration keys:
-#
-#  description_format
-#    If this is set to a non-empty string, it will be displayed above
-#    all matches generated. The sequence `%d' in this string is replaced
-#    by a short description of what is completed in the current position
-#    of the command line.
-#
-#  message_format
-#    Like `description_format', but used in places where no completions
-#    can automatically be generated but the completion system still wants
-#    to give a hint what is expected in that position.
-#
-#  group_matches
-#    If this is set to a non-empty string, different types of matches will
-#    be put in different groups.
 
 
 # If you want to complete only set or unset options for the unsetopt
diff -u -r oldcompletion/Core/_match Completion/Core/_match
--- oldcompletion/Core/_match	Mon Oct 11 14:32:20 1999
+++ Completion/Core/_match	Tue Oct 12 09:22:24 1999
@@ -8,21 +8,6 @@
 # Note, however, that this is only really useful if you don't use the
 # expand-or-complete function because otherwise the pattern will
 # be expanded using globbing.
-#
-# Configuration keys used:
-#
-#  match_original
-#    If this is set to a `only', pattern matching will only be tried
-#    with the string from the line. If it is set to any other non-empty
-#    string, the original pattern will be tried first and if that yields
-#    no completions, matching will be tried again with a `*' inserted
-#    at the cursor position. If this key is not set or set to an empty
-#    string, matching will only be attempted with the `*' inserted.
-#
-#  match_insert
-#    If this is set to a string starting with `unambig', menucompletion
-#    will only be turned on if no unambiguous string could be built
-#    that is at least as long as the original string.
 
 local tmp opm="$compstate[pattern_match]" ret=0
 
diff -u -r oldcompletion/Core/_path_files Completion/Core/_path_files
--- oldcompletion/Core/_path_files	Mon Oct 11 14:32:20 1999
+++ Completion/Core/_path_files	Tue Oct 12 09:22:24 1999
@@ -1,27 +1,7 @@
 #autoload
 
-# Utility function for in-path completion.
-# Supported arguments are: `-f', `-/', `-g <patterns>', `-J <group>',
-# `-V <group>', `-W paths', `-X explanation', `-P prefix', `-S suffix',
-# `-q', `-r remove-chars', `-R remove-func', and `-F <ignore>'. All but 
-# the last have the same syntax and meaning as for `compgen' or
-# `compadd', respectively. The `-F <ignore>' option may be used to give
-# a list of suffixes either by giving the name of an array or
-# literally by giving them in a string surrounded by parentheses. Files
-# with one of the suffixes thus given are treated like files with one
-# of the suffixes in the `fignore' array in normal completion.
-#
-# This function supports two configuration keys:
-#
-#  path_expand
-#    If this is set to a non-empty string, the partially typed path
-#    from the line will be expanded as far as possible even if trailing
-#    pathname components can not be completed.
-#
-#  path_cursor
-#    If this is set to an non-empty string, the cursor will be placed
-#    in the path after the ambiguous pathname component even when using
-#    menucompletion.
+# Utility function for in-path completion. This allows `/u/l/b<TAB>'
+# to complete to `/usr/local/bin'.
 
 local linepath realpath donepath prepath testpath exppath
 local tmp1 tmp2 tmp3 tmp4 i orig pre suf tpre tsuf opre osuf cpre

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

