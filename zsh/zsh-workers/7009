From zsh-workers-return-7009-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jul 07 12:58:38 1999
Return-Path: <zsh-workers-return-7009-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11016 invoked from network); 7 Jul 1999 12:58:36 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Jul 1999 12:58:36 -0000
Received: (qmail 17749 invoked by alias); 7 Jul 1999 12:58:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7009
Received: (qmail 17742 invoked from network); 7 Jul 1999 12:58:16 -0000
Message-Id: <9907071229.AA12427@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk
Subject: Re: PATCH: Enhancing math expressions a bit 
In-Reply-To: "Peter Stephenson"'s message of "Wed, 07 Jul 1999 13:57:49 DFT."
             <9907071157.AA19534@ibmth.df.unipi.it> 
Date: Wed, 07 Jul 1999 14:29:34 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

Peter Stephenson wrote:
> Sven Wischnowsky wrote:
> > Ok, with the last patch and the one below, I hacked these two widgets
> 
> I'll make a directory Functions/Zle and put these in

I changed them a bit to make them presentable, so here's what I actually
put in Functions/Zle.  I hope I've deciphered the behaviour OK --- does the
incremental_completer really work yet?

Comments on behaviour:

- <TAB> in i-c-w should probably cause the function to exit if it
  gets a unique completion.  (Note menucompletion is now explicitly
  turned off inside the function.)
- a left parenthesis typed in insert-files is causing the whole function to
  crash; probably also nobadpattern needs to be set inside (I have it
  set all the time).


# incremental-complete-word() {

# Autoload this function, run `zle -N <func-name>' and bind <func-name>
# to a key.

# This allows incremental completion of a word.  After starting this
# command, a list of completion choices is shown after every character you
# type, which you can delete with ^h or DEL.  RET will accept the
# completion so far.  You can hit TAB to do normal completion and ^g to
# abort back to the state when you started.
#
# Completion keys:
#   incremental_prompt   Prompt to show in status line during icompletion
#   incremental_stop     Pattern matching keys which will cause icompletion
#                        to stop and the key to re-executed
#   incremental_break    Pattern matching keys which will cause icompletion
#                        to stop and the key to be discarded
#   incremental_completer  Name of completion widget to call to get choices

emulate -L zsh
unsetopt menucomplete # doesn't work well

local key lbuf="$LBUFFER" rbuf="$RBUFFER" pmpt

[[ -n "$compconfig[incremental_completer]" ]] &&
set ${(s.:.)compconfig[incremental_completer]}
pmpt="${compconfig[incremental_prompt]-incremental completion...}"

zle list-choices
zle -R "$pmpt"
read -k key

while [[ '#key' -ne '#\\r' && '#key' -ne '#\\n' &&
         '#key' -ne '#\\C-g' ]]; do
  if [[ "$key" = ${~compconfig[incremental_stop]} ]]; then
    zle -U "$key"
    return
  elif [[ "$key" = ${~compconfig[incremental_break]} ]]; then
    return
  elif [[ '#key' -eq '#\\C-h' || '#key' -eq '#\\C-?' ]]; then
    [[ $#LBUFFER -gt $#l ]] && LBUFFER="$LBUFFER[1,-2]"
  elif [[ '#key' -eq '#\\t' ]]; then
    zle complete-word "$@"
  else
    LBUFFER="$LBUFFER$key"
  fi
  zle list-choices "$@"
  zle -R "$pmpt"
  read -k key
done

if [[ '#key' -eq '#\\C-g' ]]; then
  LBUFFER="$lbuf"
  RBUFFER="$rbuf"
fi
zle -Rc
# }


# insert-files() {

# Autoload this function, run `zle -N <func-name>' and bind <func-name>
# to a key.

# This function allows you type a file pattern, and see the results of the
# expansion at each step.  When you hit return, they will be inserted into
# the command line.

local key str files

files=( *(N) )
if (( $#files )); then
  zle -R "files: ${str}_" "$files[@]"
else
  zle -R "files: ${str}_ (failed)"
fi
read -k key
while [[ '#key' -ne '#\\r' && '#key' -ne '#\\n' &&
         '#key' -ne '#\\C-g' ]]; do
  if [[ '#key' -eq '#\\C-h' || '#key' -eq '#\\C-?' ]]; then
    [[ -n "$str" ]] && str="$str[1,-2]"
  else
    str="$str$key"
  fi
  files=( ${~str}*(N) )
  if (( $#files )); then
    zle -R "files: ${str}_" "$files[@]"
  else
    zle -R "files: ${str}_ (failed)"
  fi
  read -k key
done
zle -Rc
if [[ '#key' -ne '#\\C-g' && $#files -gt 0 ]]; then
  [[ "$LBUFFER[-1]" = ' ' ]] || files=('' "$files[@]")
  LBUFFER="$LBUFFER$files "
fi
# }

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

