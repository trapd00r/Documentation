From zsh-workers-return-10297-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Mar 28 12:33:07 2000
Return-Path: <zsh-workers-return-10297-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29155 invoked from network); 28 Mar 2000 12:33:01 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 28 Mar 2000 12:33:01 -0000
Received: (qmail 8387 invoked by alias); 28 Mar 2000 12:32:44 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10297
Received: (qmail 8360 invoked from network); 28 Mar 2000 12:32:40 -0000
Date: Tue, 28 Mar 2000 14:32:29 +0200 (MET DST)
Message-Id: <200003281232.OAA16841@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Mon, 27 Mar 2000 16:28:19 +0000
Subject: PATCH: was: Re: endianness of wordcode


Bart Schaefer wrote:

> On Mar 27,  1:43pm, Sven Wischnowsky wrote:
> } Subject: Re: endianness of wordcode
> }
> } Bart Schaefer wrote:
> } 
> } > In particular
> } > I'm not sure how to explain what happens if you do
> } > 
> } > 	zcompile -c foo foo bar frob ding
> } > 	fpath=($PWD)
> } > 	autoload foo
> } > 	foo
>
> ...
> 
> The question in this first case is:  `bar', `frob' and `ding' do not
> become available when foo is autoloaded, but why not?  If I had a text
> (not .zwc) file named `foo' inside a directory in $fpath, and that
> file contained four functions, and I said to autoload foo and then I
> executed foo, all four functions would become defined.
> 
> If I'd said `fpath=($PWD/foo)' so that foo.zwc was treated like a
> directory, I'd expect only `foo' to be searched out of it; but since
> `foo' is *inside* a directory in $fpath, I expected it to be treated
> like a script.  (Well, *I* didn't, but I'm trying to think like a
> newbie.)

Maybe it would be clearer if we made people pay more attention to the
files. Because: if I have a couple of function definition files,
containing the functions foo, bar, frob and ding (in $PWD) and I do

  fpath=($PWD)
  autoload foo
  foo

this makes available (and before that: autoloaded(!)) only foo. And
with a zwc file it's just the same. If one doesn't say that bar, frob
and ding are to be autoloaded and/or doesn't tell the shell where to
find the definitions for them, they won't be autoloaded (of course ;-).
And the things you wrote in func.yo make it quite clear, how zwc files 
are searched for functions, so `fpath=($PWD)' without files like
bar.zwc in $PWD doesn't tell the shell where to find the
file/definition for bar, frob, ding.

Hm, dunno if that would help...

> ...
> 
> Given this, I think we should just make -k not work at all with -c, and
> ignore kshautoload on -c as well, i.e. -c always behaves as if -z.  If
> -k is given, stop with an error, and if kshautoload is set, print an
> informative warning message but write the file anyway.

The patch does this and it also swaps -[rm] and -M. I.e. -R is for
`make zwc file be read', -M for `make it be mapped' and -m is for
`make names be used as patterns with the -c option'.

Bye
 Sven

diff -ru ../z.old/Doc/Zsh/builtins.yo Doc/Zsh/builtins.yo
--- ../z.old/Doc/Zsh/builtins.yo	Tue Mar 28 13:41:06 2000
+++ Doc/Zsh/builtins.yo	Tue Mar 28 14:12:31 2000
@@ -1303,8 +1303,8 @@
 findex(zcompile)
 cindex(.zwc files, creation)
 cindex(compilation)
-xitem(tt(zcompile) [ tt(-U) ] [ tt(-z) | tt(-k) ] [ tt(-r) | tt(-m) ] var(file) [ var(name) ... ])
-xitem(tt(zcompile) tt(-c) [ tt(-M) ] [ tt(-z) | tt(-k) ] [ tt(-r) | tt(-m) ] var(file) [ var(name) ... ])
+xitem(tt(zcompile) [ tt(-U) ] [ tt(-z) | tt(-k) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
+xitem(tt(zcompile) tt(-c) [ tt(-m) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
 item(tt(zcompile -t) var(file) [ var(name) ... ])(
 This builtin command can be used to compile functions or scripts and
 store the compiled form in a file, and to examine files containing
@@ -1337,10 +1337,12 @@
 The second form, with the tt(-c) option, writes the definitions for
 all the named functions into var(file).  The names must be functions
 currently defined in the shell or marked for autoloading.  If the
-tt(-M) option is given, too, the var(name)s are used as patterns and
+tt(-m) option is given, too, the var(name)s are used as patterns and
 all functions whose names match one of these patterns will be
 written. If no var(name) is given, the definitions of all functions
-currently defined or marked as autoloaded will be written.
+currently defined or marked as autoloaded will be written. In any
+case, the functions in files written with the tt(-c) option will be
+autoloaded as if the tt(KSH_AUTOLOAD) option were unset.
 
 The third form, with the tt(-t) option, examines an existing
 compiled file.  Without further arguments, the names of the original
@@ -1357,9 +1359,9 @@
 item(tt(-U))(
 Aliases are not expanded when compiling the var(name)d files.
 )
-item(tt(-r))(
+item(tt(-R))(
 When the compiled file is read, its contents are copied into the
-shell's memory, rather than memory-mapped (see tt(-m)).  This
+shell's memory, rather than memory-mapped (see tt(-M)).  This
 happens automatically on systems that do not support memory mapping.
 
 When compiling scripts instead of autoloadable functions, it is
@@ -1367,22 +1369,22 @@
 remain mapped if the script has defined one or more functions, even
 if the rest of the file will not be used again.
 )
-item(tt(-m))(
+item(tt(-M))(
 The compiled file is mapped into the shell's memory when read. This
 is done in such a way that multiple instances of the shell running
-on the same host will share this mapped file.  If neither tt(-r) nor
-tt(-m) is given, the tt(zcompile) builtin decides what to do based
+on the same host will share this mapped file.  If neither tt(-R) nor
+tt(-M) is given, the tt(zcompile) builtin decides what to do based
 on the size of the compiled file.
 )
 xitem(tt(-k))
 item(tt(-z))(
 These options are used when the compiled file contains functions and
 those functions are to be autoloaded. If tt(-z) is given, the
-function will be autoloaded as if the tt(KSHAUTOLOAD) option is
+function will be autoloaded as if the tt(KSH_AUTOLOAD) option is
 em(not) set, even if it is set at the time the compiled file is
-read. The tt(-k) makes the function be loaded as if tt(KASHAUTOLOAD)
+read. The tt(-k) makes the function be loaded as if tt(KSH_AUTOLOAD)
 em(is) set.  If neither of these options is given, the function will
-be loaded as determined by the setting of the tt(KSHAUTOLOAD) option
+be loaded as determined by the setting of the tt(KSH_AUTOLOAD) option
 at the time the compiled file is read.
 
 These options may also be repeated among the listed var(name)s to
diff -ru ../z.old/Functions/Misc/zrecompile Functions/Misc/zrecompile
--- ../z.old/Functions/Misc/zrecompile	Tue Mar 28 13:41:49 2000
+++ Functions/Misc/zrecompile	Tue Mar 28 14:31:44 2000
@@ -18,8 +18,8 @@
 #       seperated by `--'. For example:
 #
 #         zrecompile -p \
-#                    -r ~/.zshrc -- \
-#                    -m ~/.zcompdump -- \
+#                    -R ~/.zshrc -- \
+#                    -M ~/.zcompdump -- \
 #                    ~/zsh/comp.zwc ~/zsh/Completion/*/_* \
 #
 #       This makes ~/.zshrc be compiled into ~/.zshrc.zwc if that doesn't
@@ -146,10 +146,10 @@
   # See if the wordcode file will be mapped.
 
   if [[ $files[1] = *\(mapped\)* ]]; then
-    map=-m
+    map=-M
     mesg='succeeded (old saved)'
   else
-    map=-r
+    map=-R
     mesg=succeeded
   fi
 
diff -ru ../z.old/Src/parse.c Src/parse.c
--- ../z.old/Src/parse.c	Tue Mar 28 13:40:58 2000
+++ Src/parse.c	Tue Mar 28 14:28:44 2000
@@ -2283,10 +2283,15 @@
     int map, flags;
     char *dump;
 
-    if (ops['k'] && ops['z']) {
+    if ((ops['k'] && ops['z']) || (ops['R'] && ops['M']) ||
+	(ops['c'] && (ops['U'] || ops['k'] || ops['z'])) ||
+	(!ops['c'] && ops['m'])) {
 	zwarnnam(nam, "illegal combination of options", NULL, 0);
 	return 1;
     }
+    if (ops['c'] && isset(KSHAUTOLOAD))
+	zwarnnam(nam, "functions will use zsh style autoloading", NULL, 0);
+
     flags = (ops['k'] ? FDHF_KSHLOAD :
 	     (ops['z'] ? FDHF_ZSHLOAD : 0));
 
@@ -2321,18 +2326,14 @@
 	zwarnnam(nam, "too few arguments", NULL, 0);
 	return 1;
     }
-    if ((ops['c'] && ops['U']) || (!ops['c'] && ops['M'])) {
-	zwarnnam(nam, "illegal combination of options", NULL, 0);
-	return 1;
-    }
-    map = (ops['m'] ? 2 : (ops['r'] ? 0 : 1));
+    map = (ops['M'] ? 2 : (ops['R'] ? 0 : 1));
 
     if (!args[1] && !ops['c'])
 	return build_dump(nam, dyncat(*args, FD_EXT), args, ops['U'], map, flags);
 
     dump = (strsfx(FD_EXT, *args) ? *args : dyncat(*args, FD_EXT));
 
-    return (ops['c'] ? build_cur_dump(nam, dump, args + 1, ops['M'], map, flags) :
+    return (ops['c'] ? build_cur_dump(nam, dump, args + 1, ops['m'], map) :
 	    build_dump(nam, dump, args + 1, ops['U'], map, flags));
 }
 
@@ -2533,7 +2534,7 @@
 	wcf = (WCFunc) zhalloc(sizeof(*wcf));
 	wcf->name = *files;
 	wcf->prog = prog;
-	wcf->flags = flags;
+	wcf->flags = ((prog->flags & EF_RUN) ? FDHF_KSHLOAD : flags);
 	addlinknode(progs, wcf);
 
 	flen = (strlen(*files) + sizeof(wordcode)) / sizeof(wordcode);
@@ -2555,7 +2556,7 @@
 
 static int
 cur_add_func(Shfunc shf, LinkList names, LinkList progs,
-	     int *hlen, int *tlen, int flags)
+	     int *hlen, int *tlen)
 {
     Eprog prog;
     WCFunc wcf;
@@ -2578,7 +2579,7 @@
     wcf = (WCFunc) zhalloc(sizeof(*wcf));
     wcf->name = shf->nam;
     wcf->prog = prog;
-    wcf->flags = flags;
+    wcf->flags = ((prog->flags & EF_RUN) ? FDHF_KSHLOAD : FDHF_ZSHLOAD);
     addlinknode(progs, wcf);
     addlinknode(names, shf->nam);
 
@@ -2592,7 +2593,7 @@
 
 /**/
 static int
-build_cur_dump(char *nam, char *dump, char **names, int match, int map, int flags)
+build_cur_dump(char *nam, char *dump, char **names, int match, int map)
 {
     int dfd, hlen, tlen;
     LinkList progs, lnames;
@@ -2618,7 +2619,7 @@
 	for (i = 0; i < shfunctab->hsize; i++)
 	    for (hn = shfunctab->nodes[i]; hn; hn = hn->next)
 		if (cur_add_func((Shfunc) hn, lnames, progs,
-				 &hlen, &tlen, flags)) {
+				 &hlen, &tlen)) {
 		    zwarnnam(nam, "can't load function: %s", shf->nam, 0);
 		    errflag = 0;
 		    close(dfd);
@@ -2632,13 +2633,6 @@
 	HashNode hn;
 
 	for (; *names; names++) {
-	    if (!strcmp(*names, "-k")) {
-		flags = (flags & ~(FDHF_KSHLOAD | FDHF_ZSHLOAD)) | FDHF_KSHLOAD;
-		continue;
-	    } else if (!strcmp(*names, "-z")) {
-		flags = (flags & ~(FDHF_KSHLOAD | FDHF_ZSHLOAD)) | FDHF_ZSHLOAD;
-		continue;
-	    }
 	    tokenize(pat = dupstring(*names));
 	    if (!(pprog = patcompile(pat, PAT_STATIC, NULL))) {
 		zwarnnam(nam, "bad pattern: %s", *names, 0);
@@ -2651,7 +2645,7 @@
 		    if (!listcontains(lnames, hn->nam) &&
 			pattry(pprog, hn->nam) &&
 			cur_add_func((Shfunc) hn, lnames, progs,
-				     &hlen, &tlen, flags)) {
+				     &hlen, &tlen)) {
 			zwarnnam(nam, "can't load function: %s", shf->nam, 0);
 			errflag = 0;
 			close(dfd);
@@ -2661,13 +2655,6 @@
 	}
     } else {
 	for (; *names; names++) {
-	    if (!strcmp(*names, "-k")) {
-		flags = (flags & ~(FDHF_KSHLOAD | FDHF_ZSHLOAD)) | FDHF_KSHLOAD;
-		continue;
-	    } else if (!strcmp(*names, "-z")) {
-		flags = (flags & ~(FDHF_KSHLOAD | FDHF_ZSHLOAD)) | FDHF_ZSHLOAD;
-		continue;
-	    }
 	    if (errflag ||
 		!(shf = (Shfunc) shfunctab->getnode(shfunctab, *names))) {
 		zwarnnam(nam, "unknown function: %s", *names, 0);
@@ -2676,7 +2663,7 @@
 		unlink(dump);
 		return 1;
 	    }
-	    if (cur_add_func(shf, lnames, progs, &hlen, &tlen, flags)) {
+	    if (cur_add_func(shf, lnames, progs, &hlen, &tlen)) {
 		zwarnnam(nam, "can't load function: %s", shf->nam, 0);
 		errflag = 0;
 		close(dfd);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

