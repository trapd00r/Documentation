From zsh-workers-return-12265-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jul 17 02:06:00 2000
Return-Path: <zsh-workers-return-12265-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4228 invoked from network); 17 Jul 2000 02:05:57 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Jul 2000 02:05:57 -0000
Received: (qmail 14209 invoked by alias); 17 Jul 2000 02:05:34 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12265
Received: (qmail 14200 invoked from network); 17 Jul 2000 02:05:33 -0000
Date: Sun, 16 Jul 2000 19:05:05 -0700 (PDT)
From: Wayne Davison <wayned@users.sourceforge.net>
X-Sender: wayne@phong.blorf.net
To: Zsh Workers <zsh-workers@sunsite.auc.dk>
Subject: PATCH: fix unshared history lines
Message-ID: <Pine.LNX.4.21.0007161855190.23825-100000@phong.blorf.net>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

The following patch fixes the breakage in gethistent() that I managed
to introduce back on May 30th.  It also ensures that if SHARE_HISTORY
is set, we only save our outstanding history lines if we successfully
locked the history file back before the readhistfile() call (i.e.  if
the lock is in place to encompass both operations, not just the one).
This ensures that we don't fail to read in some history events from a
sibling process.

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: Src/hist.c
@@ -882,21 +882,19 @@
 
     if (ev - hist_ring->down->histnum < hist_ring->histnum - ev) {
 	for (he = hist_ring->down; he->histnum < ev; he = he->down) ;
-	if (nearmatch == 0) {
-	    if (he->histnum != ev)
+	if (he->histnum != ev) {
+	    if (nearmatch == 0
+	     || (nearmatch < 0 && (he = up_histent(he)) == NULL))
 		return NULL;
 	}
-	else if (nearmatch < 0 && (he = up_histent(he)) == NULL)
-	    return NULL;
     }
     else {
 	for (he = hist_ring; he->histnum > ev; he = he->up) ;
-	if (nearmatch == 0) {
-	    if (he->histnum != ev)
+	if (he->histnum != ev) {
+	    if (nearmatch == 0
+	     || (nearmatch > 0 && (he = down_histent(he)) == NULL))
 		return NULL;
 	}
-	else if (nearmatch > 0 && (he = down_histent(he)) == NULL)
-	    return NULL;
     }
 
     checkcurline(he);
@@ -1060,7 +1058,7 @@
     zfree(chwords, chwordlen*sizeof(short));
     chline = NULL;
     histactive = 0;
-    if (isset(SHAREHISTORY) || isset(INCAPPENDHISTORY))
+    if (isset(SHAREHISTORY)? histfileIsLocked() : isset(INCAPPENDHISTORY))
 	savehistfile(hf, 0, HFILE_USE_OPTIONS | HFILE_FAST);
     unlockhistfile(hf); /* It's OK to call this even if we aren't locked */
     return !(flag & HISTFLAG_NOEXEC || errflag);
@@ -2065,6 +2063,13 @@
 	unlink(lockfile);
 	free(lockfile);
     }
+}
+
+/**/
+int
+histfileIsLocked(void)
+{
+    return lockhistct > 0;
 }
 
 /* Get the words in the current buffer. Using the lexer. */
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

