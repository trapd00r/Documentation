From zsh-workers-return-12565-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Aug 08 10:30:51 2000
Return-Path: <zsh-workers-return-12565-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21097 invoked from network); 8 Aug 2000 10:30:50 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Aug 2000 10:30:50 -0000
Received: (qmail 25317 invoked by alias); 8 Aug 2000 10:30:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12565
Received: (qmail 25307 invoked from network); 8 Aug 2000 10:30:21 -0000
Date: Tue, 8 Aug 2000 12:30:17 +0200 (MET DST)
Message-Id: <200008081030.MAA06448@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Fri, 04 Aug 2000 15:33:30 +0100
Subject: Re: \# completion


Peter Stephenson wrote:

> Unless it's me,
>   rm \#<TAB>
> isn't working at the moment, although
>   rm '#<TAB>
> is.
> 
>   rm #<TAB>
> doesn't work either --- I wouldn't particularly expect it to, so I'm not
> worried, but I recall it did several generations of completion code ago,
> which is the last time I can remember trying it.

I'm very confused, because I was sure that I had tested it. Dunno what 
went wrong, maybe I committed an earlier version. Sorry.

The same for the dependency on _expand Bart noted.


Tanaka Akira wrote:

> \ has the problem yet.
> 
> Z(2):akr@flux% Src/zsh -f  
> flux% bindkey -e; autoload -U compinit; compinit -D
> flux% mkdir -p '\ab/cd'
> flux% ls \\<TAB>
> 
> This completes nothing.

Huh? This worked for me.

> I made a test to check this problem and found other problems.
> 
> flux% mkdir -p '=ab/cd'
> flux% ls \=<TAB>
> _path_files:327: * not found

But this didn't. Forgot to test for the `=' character in compfiles.


> Note that the completion with = behaves curiously as follows.
> 
> flux% ls ./=<TAB>
> flux% ls ./\=ab/<TAB>
> flux% ls ./=ab/cd/

Urgh. The problem was that the compquote builtin quoted the `=' when
completing `=ab', because it didn't know that there was a prefix.

So, the patch adds the `-p' option to compquote to tell it about an
existing prefix.

> Also note that metafied characters (0x83 to 0x9c) is printed in
> metafied form.

I couldn't reproduce this.


Bye
 Sven

Index: Completion/Core/_expand
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_expand,v
retrieving revision 1.27
diff -u -r1.27 _expand
--- Completion/Core/_expand	2000/08/03 13:35:44	1.27
+++ Completion/Core/_expand	2000/08/08 10:29:37
@@ -63,7 +63,7 @@
       eval exp\=\( ${${(q)exp}:gs/\\{/\{/:gs/\\}/\}/} \)
   eval 'exp=( ${${(e)exp//\\[ 	
 ]/ }//(#b)([ 	
-\\])/\\$match[1]} )' 2>/dev/null
+])/\\$match[1]} )' 2>/dev/null
 else
   exp=( ${exp:s/\\\$/\$} )
 fi
@@ -77,14 +77,14 @@
 # Now try globbing.
 
 [[ "$force" = *g* ]] || zstyle -T ":completion:${curcontext}:" glob &&
-    eval 'exp=( ${~exp} ); exp=( ${exp//(#b)([][()|*?^#~<>\\])/\\${match[1]}} )' 2>/dev/null
+    eval 'exp=( ${~exp} ); exp=( ${exp//(#b)([][()|*?^#~<>\\=])/\\${match[1]}} )' 2>/dev/null
 
 # If we don't have any expansions or only one and that is the same
 # as the original string, we let other completers run.
 
 (( $#exp )) || exp=("$subd[@]")
 
-[[ $#exp -eq 1 && "$exp[1]" = "$word"(|\(N\)) ]] && return 1
+[[ $#exp -eq 1 && "${exp[1]//\\}" = "${word//\\}"(|\(N\)) ]] && return 1
 
 # With subst-globs-only we bail out if there were no glob expansions,
 # regardless of any substitutions
Index: Completion/Core/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_path_files,v
retrieving revision 1.29
diff -u -r1.29 _path_files
--- Completion/Core/_path_files	2000/08/03 13:35:44	1.29
+++ Completion/Core/_path_files	2000/08/08 10:29:38
@@ -421,7 +421,7 @@
     # There are more components, so skip over the next components and make a
     # slash be added.
 
-    tmp1=( ${tmp1//(#b)([][()|*?^#~<>\\])/\\${match[1]}} )
+    tmp1=( ${tmp1//(#b)([][()|*?^#~<>\\=])/\\${match[1]}} )
     tmp2="${(M)tpre##((.|..|)/)##}"
     if [[ -n "$tmp2" ]]; then
       skipped="/$tmp2"
@@ -470,7 +470,14 @@
       # it as far as possible.
 
       tmp2="$testpath"
-      compquote tmp1 tmp2
+      if [[ -n "$linepath" ]]; then
+        compquote -p tmp2 tmp1
+      elif [[ -n "$tmp2" ]]; then
+        compquote -p tmp1
+        compquote tmp2
+      else
+        compquote tmp1 tmp2
+      fi
 
       if [[ -n $menu || -z "$compstate[insert]" ]] ||
          ! zstyle -t ":completion:${curcontext}:paths" expand suffix; then
@@ -544,7 +551,12 @@
       tmp4="${testpath#${mid}}"
       tmp3="${mid%/*/}"
       tmp2="${${mid%/}##*/}"
-      compquote tmp4 tmp3 tmp2 tmp1
+      if [[ -n "$linepath" ]]; then
+        compquote -p tmp3
+      else
+        compquote tmp3
+      fi
+      compquote tmp4 tmp2 tmp1
       for i in "$tmp1[@]"; do
         compadd -Qf "$mopts[@]" -p "$linepath$tmp3/" -s "/$tmp4$i" \
                 -W "$prepath$realpath${mid%/*/}/" \
@@ -559,7 +571,14 @@
         SUFFIX="${osuf}"
       fi
       tmp4="$testpath"
-      compquote tmp4 tmp1
+      if [[ -n "$linepath" ]]; then
+        compquote -p tmp4 tmp1
+      elif [[ -n "$tmp4" ]]; then
+        compquote -p tmp1
+        compquote tmp4
+      else
+        compquote tmp4 tmp1
+      fi
       compadd -Qf "$mopts[@]" -p "$linepath$tmp4" -W "$prepath$realpath$testpath" \
 	      "$pfxsfx[@]" -M "r:|/=* r:|=*" -a tmp1
     fi
Index: Doc/Zsh/mod_computil.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_computil.yo,v
retrieving revision 1.5
diff -u -r1.5 mod_computil.yo
--- Doc/Zsh/mod_computil.yo	2000/06/26 08:36:43	1.5
+++ Doc/Zsh/mod_computil.yo	2000/08/08 10:29:39
@@ -61,7 +61,7 @@
 duplicates and with removing consecutive duplicates).
 )
 findex(compquote)
-item(tt(compquote) var(names) ...)(
+item(tt(compquote) [ tt(-p) ] var(names) ...)(
 There may be reasons to write completion functions that have to add
 the matches using the tt(-Q) option to tt(compadd) and perform quoting
 themselves.  Instead of interpreting the first character of the
@@ -69,7 +69,9 @@
 the tt(q) flag for parameter expansions, one can use this builtin
 command.  The arguments are the names of scalar or array parameters
 and the values of these parameters are quoted as needed for the
-innermost quoting level.
+innermost quoting level.  If the tt(-p) option is given, quoting is
+done as if there is some prefix before the values of the parameters,
+so that a leading equal sign will not be quoted.
 
 The return value is non-zero in case of an error and zero otherwise.
 )
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.39
diff -u -r1.39 computil.c
--- Src/Zle/computil.c	2000/07/27 08:32:02	1.39
+++ Src/Zle/computil.c	2000/08/08 10:29:42
@@ -2559,6 +2559,24 @@
     return 1;
 }
 
+static char *
+comp_quote(char *str, int prefix)
+{
+    int x;
+    char *ret;
+
+    if ((x = (prefix && *str == '=')))
+	*str = 'x';
+
+    ret = bslashquote(str, NULL, (*compqstack == '\'' ? 1 :
+				  (*compqstack == '"' ? 2 : 0)));
+
+    if (x)
+	*str = *ret = '=';
+
+    return ret;
+}
+
 static int
 bin_compquote(char *nam, char **args, char *ops, int func)
 {
@@ -2578,15 +2596,7 @@
 	if ((v = getvalue(&vbuf, &name, 0))) {
 	    switch (PM_TYPE(v->pm->flags)) {
 	    case PM_SCALAR:
-		{
-		    char *val = getstrvalue(v);
-
-		    val = bslashquote(val, NULL,
-				      (*compqstack == '\'' ? 1 :
-				       (*compqstack == '"' ? 2 : 0)));
-
-		    setstrvalue(v, ztrdup(val));
-		}
+		setstrvalue(v, ztrdup(comp_quote(getstrvalue(v), ops['p'])));
 		break;
 	    case PM_ARRAY:
 		{
@@ -2596,10 +2606,7 @@
 		    char **p = new;
 
 		    for (; *val; val++, p++)
-			*p = ztrdup(bslashquote(*val, NULL,
-						(*compqstack == '\'' ? 1 :
-						 (*compqstack == '"' ? 2 :
-						  0))));
+			*p = ztrdup(comp_quote(*val, ops['p']));
 		    *p = NULL;
 
 		    setarrvalue(v, new);
@@ -3242,11 +3249,12 @@
 	if (*s != '\\' || !s[1] || s[1] == '*' || s[1] == '?' ||
 	    s[1] == '<' || s[1] == '>' || s[1] == '(' || s[1] == ')' ||
 	    s[1] == '[' || s[1] == ']' || s[1] == '|' || s[1] == '#' ||
-	    s[1] == '^' || s[1] == '~') {
+	    s[1] == '^' || s[1] == '~' || s[1] == '=') {
 	    if ((s == compprefix || s[-1] != '\\') &&
 		(*s == '*' || *s == '?' || *s == '<' || *s == '>' ||
 		 *s == '(' || *s == ')' || *s == '[' || *s == ']' ||
-		 *s == '|' || *s == '#' || *s == '^' || *s == '~'))
+		 *s == '|' || *s == '#' || *s == '^' || *s == '~' ||
+		 *s == '='))
 		*t++ = '\\';
 	    *t++ = *s;
 	}
@@ -3653,7 +3661,7 @@
     BUILTIN("compdescribe", 0, bin_compdescribe, 3, -1, 0, NULL, NULL),
     BUILTIN("comparguments", 0, bin_comparguments, 1, -1, 0, NULL, NULL),
     BUILTIN("compvalues", 0, bin_compvalues, 1, -1, 0, NULL, NULL),
-    BUILTIN("compquote", 0, bin_compquote, 1, -1, 0, NULL, NULL),
+    BUILTIN("compquote", 0, bin_compquote, 1, -1, 0, "p", NULL),
     BUILTIN("comptags", 0, bin_comptags, 1, -1, 0, NULL, NULL),
     BUILTIN("comptry", 0, bin_comptry, 0, -1, 0, NULL, NULL),
     BUILTIN("compfiles", 0, bin_compfiles, 1, -1, 0, NULL, NULL),

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

