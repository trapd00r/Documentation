From zsh-workers-request@math.gatech.edu Mon Sep 15 11:38:58 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 672 invoked from network); 15 Sep 1997 11:38:57 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 15 Sep 1997 11:38:57 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id HAA17308;
	Mon, 15 Sep 1997 07:34:34 -0400 (EDT)
Resent-Date: Mon, 15 Sep 1997 07:34:34 -0400 (EDT)
Message-Id: <199709151134.NAA26240@sgi.ifh.de>
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: Re: multiple background jobs of the same program 
In-reply-to: "Stefan Monnier"'s message of "15 Sep 1997 07:16:41 MET."
             <5len6q9692.fsf@tequila.systemsz.cs.yale.edu> 
Date: Mon, 15 Sep 1997 13:34:48 +0200
From: Peter Stephenson <pws@ifh.de>
Resent-Message-ID: <"5ZkYa1.0.NE4.ArH7q"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3491
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

In case it helps, here's a function I posted some time ago to enable
completion of jobs along the lines required.  The difference is
essentially that it relies on interactivecomments, putting the
job description in a comment, e.g.

% kill %1  # sleep 10 

so parsing isn't a problem.  Otherwise it's not so different.  Again,
some kind of menu-like completion is best.

# Function to complete jobnames, with a commented description, as
# suggested by Harmanjit Singh.
# Author:  pws@ifh.de (Peter Stephenson)
# Usage:  with a compctl such as
#   compctl -Q -K jobfunc -x 's[-] p[1,1]' -k signals -- kill

# Make sure interactivecomments is on in the shell running the function.
unsetopt localoptions
setopt interactivecomments

# Use a temporary file to store the jobs, since we can't use a pipe.
local tmpf=/tmp/zshjobs$$

# Get the jobs list: looks like
# [1]  + running    sleep 30
jobs >&! $tmpf
reply=()

local job jobno
while read -A job
do
   # Extract the job no. from the square brackets
   jobno=$job[1]
   jobno=${${jobno#\[}%\]}

   shift job
   # If this job is marked as - or +, the command starts at the
   # fourth field, else at the third.
   [[ $job[1] = [-+] ]] && shift job
   shift job
   # Now the remaining elements of $job contain the command description.
   # Add the whole completion to the reply.
   reply[$#reply+1]="%$jobno  # $job"
done < $tmpf

# Tidy up the job file.
rm $tmpf

