From zsh-users-return-3795-mason-zsh=primenet.com.au@sunsite.dk Wed Apr 04 22:41:47 2001
Return-Path: <zsh-users-return-3795-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23022 invoked from network); 4 Apr 2001 22:41:46 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 4 Apr 2001 22:41:46 -0000
Received: (qmail 26130 invoked by alias); 4 Apr 2001 22:41:33 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3795
Received: (qmail 26119 invoked from network); 4 Apr 2001 22:41:32 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010404224108.ZM434@candle.brasslantern.com>
Date: Wed, 4 Apr 2001 22:41:08 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.dk
Subject: Fix up the history upon "fg"
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

Here's a possibly-handy function.  When you use "fg" or "bg" (or one of
the abbreviations, e.g. "%+"), "getjobs" finds the original text of that
command and inserts it into the history, so that e.g., "!!" will execute
that command again rather than executing "fg" again.

If you use several arguments to "fg", e.g. "fg %2 %3 %1", the commands
for all those jobs are collected and concatenated with semicolons.

Arguably this could be implemented in C as an optional behavior of bin_fg,
so the fg command itself could be removed from the history and replaced
with the job text; but I'm not feeling that ambitious today.

This requires at least zsh-3.1.9, I think.  Definitely not 3.0.anything.

    # Call this from the preexec function like so:
    #   preexec() {
    #	  getjobs "${(z)1}"
    #   }
    getjobs () {
	setopt localoptions noshwordsplit noksharrays
	local texts
	case $1 in
	    fg|bg) shift; [[ -n $1 ]] || set -- %% ;;
	    %*) ;;
	    *) return 0 ;;
	esac
	repeat $#
	do
	    # This case statement emulates jobs.c:getjob()
	    case $1 in
		%(|[%+])) 1=${(k)jobstates[(r)*:+:*]} ;;
		%-) 1=${(k)jobstates[(r)*:-:*]} ;;
		%<->) 1=${1#%} ;;
		%[?]*) 1=${${(Ok)jobtexts[(R)*${1#%[?]}*]}[1]} ;;
		*) 1=${${(Ok)jobtexts[(R)$1*]}[1]} ;;
	    esac
	    [[ -n $1 ]] && texts=($texts ${jobtexts[$1]})
	    shift
	done
	# Remove the "-s" below if you'd prefer that this just report
	# what jobs are being affected rather than modify the history
	(( $#texts )) && print -s ${(j:; :)texts}
	return 0
    }

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

