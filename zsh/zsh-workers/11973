From zsh-workers-return-11973-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jun 19 09:54:19 2000
Return-Path: <zsh-workers-return-11973-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9784 invoked from network); 19 Jun 2000 09:54:17 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 19 Jun 2000 09:54:17 -0000
Received: (qmail 23912 invoked by alias); 19 Jun 2000 09:53:59 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11973
Received: (qmail 23903 invoked from network); 19 Jun 2000 09:53:56 -0000
Date: Mon, 19 Jun 2000 11:53:52 +0200 (MET DST)
Message-Id: <200006190953.LAA07149@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: expansion and comments (and styles)


This enables _expand to expand braces. It also improves the C-code
that decides if there are braces it has to handle internally and if
there are some to let through (see also the comments below...).

This, err..., circumvents the problem Bart mentioned:

> Since 11939, I get this behavior:
> 
> zagzig<2> ls Functions/{Misc,Prompts}<TAB>
> zagzig<2> ls Functions/{Misc,Prompts/ 
> Completing corrections
> Prompts/
> Completing original
> Functions/Prompts} 

Because now the braces are expanded, of course.

The patch also re-synchronises _zstyle, adding new styles, updating
changed ones.

And since this is so small that it doesn't warrant a separate patch,
it also contains the suggested enhancement to the ignore-line style:
it may be set to `current-shown' to ignore the current word only if
the list of matches is shown.


Comments about expansion...

Bart Schaefer wrote:

> On Jun 16,  9:50am, Sven Wischnowsky wrote:
> } Subject: PATCH: Re: _expand doesn't do brace expansion?
> }
> } About the `a{b,c}<TAB>': of course this discussion now got me thinking 
> } about it again, but this is horrible. There are a few things that I
> } never changed in all my work on the completion code from 2.4.xxx
> } on. One of them is that the completion code only ever has to work on
> } one string. Trying to implement the above would change that and
> } currently I don't even know where to place the loop over the possible
> } prefixes/suffixes.
> 
> My inclination would be not to change the C code for this, but instead
> to make the shell code expand the braces, generate completions for each
> resulting string separately, and then mash them back together somehow.
> 
> Of course the "mash them back together" is the hard part, but if you
> don't try to compute intersections it's just chopping off each of the
> different prefixes and sticking on the original (with unexpanded braces)
> from the line.

At one point at least we agree: we need to put that into shell
code. Because now that _expand can expand such brace expansion, we
can't have the C-code steal them...

And probably not only `closed' brace expansions (like `{a,b}'), but
also `open' ones, i.e. ones we are completing in (like
`s{foo,i<TAB>'), because only then can _expand do something reasonable 
with `a{{b,c}<TAB>'. But *that* is terribly difficult. Even for the
C-code which has as much control over everything as it needs, this was 
hard to write. We would need some realtive easy way to report the
barce stuff to the shell code and read it back (as we do with all the
special parameters). Then the shell code could modify it it in some
controlled way. But the shell code should still not be responsible to
completely handle that, I think.

That reminded me of the prefix/suffix handling Oliver was complaining
about some time ago. Maybe this could be done together... dunno.

The other problem is, of course, that it really isn't `*JUST* chopping 
off...'. We need to tell somebody about the part we don't want to be
modified by matching and we need to tell it with what this should be
replaced. Ok, in the interface this could be done with options to
compadd or, probably better, with some special parameter(s) -- then
we're back at the brace-reporting thing (which is good).

I don't have any real ideas about any of this yet...

Bye
 Sven

Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.14
diff -u -r1.14 _zstyle
--- Completion/Builtins/_zstyle	2000/05/31 09:38:26	1.14
+++ Completion/Builtins/_zstyle	2000/06/19 09:44:04
@@ -17,31 +17,32 @@
   break-keys             c:
   command                c:command
   completer		 c:completer
-  completions		 c:
-  condition		 c:
+  completions		 c:bool
+  condition		 c:bool
   cursor		 c:cursor
   disable-stat		 c:bool
   domains                c:
   expand		 c:
+  fake			 c:fake
   file-patterns		 c:filepat
   file-sort              c:fsort
-  force-list             c
+  force-list             c:
   format		 c:
-  glob			 c:
+  glob			 c:bool
   group-name		 c:
   group-order		 c:tag
   groups		 c:_groups
-  guarded-completer      c:completer
   hidden		 c:bool
   hosts			 c:_hosts
   hosts-ports		 c:host-port
   users-hosts-ports	 c:user-host-port
-  ignore-line            c:bool
+  ignore-line            c:ignline
   ignore-parents         c:ignorepar
   ignored-patterns	 c:
   insert-ids             c:insert-ids
   insert-tab             c:bool
   insert-unambiguous	 c:bool
+  keep-prefix		 c:keep-prefix
   last-prompt		 c:bool
   list			 c:listwhen
   list-colors		 c:
@@ -49,6 +50,8 @@
   list-prompt            c:
   list-rows-first	 c:bool
   local			 c:
+  match-original	 c:match-orig
+  matcher		 c:
   matcher-list		 c:
   max-errors		 c:
   menu			 c:boolauto
@@ -62,6 +65,7 @@
   prefix-hidden		 c:bool
   prefix-needed		 c:bool
   prompt		 c:
+  remote-access		 c:bool
   remove-all-dups	 c:bool
   select-prompt          c:
   select-scroll          c:
@@ -71,9 +75,12 @@
   squeeze-slashes	 c:bool
   stop			 c:stop
   stop-keys		 c:
-  subst-globs-only       c:
-  substitute		 c:
+  subst-globs-only       c:bool
+  substitute		 c:bool
+  suffix		 c:bool
   tag-order		 c:tag
+  try-to-use-pminst	 c:bool
+  use-compctl		 c:urgh
   users			 c:_users
   users-hosts		 c:user-host
   verbose		 c:bool
@@ -254,6 +261,26 @@
     insert-ids)
       _wanted values expl 'when to insert process IDs' \
           compadd - menu single longer
+      ;;
+
+    fake)
+      _message 'prefix and names'
+      ;;
+
+    ignline) 
+      _wanted values expl boolean compadd true false current current-shown other
+      ;;
+
+    keep-prefix) 
+      _wanted values expl boolean compadd true false changed
+      ;;
+
+    match-orig) 
+      _wanted values expl boolean compadd only both
+      ;;
+
+    urgh) 
+      _wanted values expl no compadd no false off 0
       ;;
 
     _*)
Index: Completion/Core/_description
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_description,v
retrieving revision 1.8
diff -u -r1.8 _description
--- Completion/Core/_description	2000/06/19 08:47:44	1.8
+++ Completion/Core/_description	2000/06/19 09:44:04
@@ -38,6 +38,8 @@
     case "$hidden" in
     true|yes|on|1) _comp_ignore=( "$_comp_ignore[@]" "$words[@]" );;
     current)       _comp_ignore=( "$_comp_ignore[@]" "$words[CURRENT]" );;
+    current-shown) [[ "$compstate[old_list]" = *shown* ]] &&
+                       _comp_ignore=( "$_comp_ignore[@]" "$words[CURRENT]" );;
     other)         _comp_ignore=( "$_comp_ignore[@]"
                                   "${(@)words[1,CURRENT-1]}"
 				  "${(@)words[CURRENT+1,-1]}" );;
Index: Completion/Core/_expand
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_expand,v
retrieving revision 1.18
diff -u -r1.18 _expand
--- Completion/Core/_expand	2000/06/16 07:31:09	1.18
+++ Completion/Core/_expand	2000/06/19 09:44:04
@@ -55,10 +55,12 @@
 
 if [[ "$force" = *s* ]] ||
    zstyle -T ":completion:${curcontext}:" substitute; then
-  exp=( "${(e)exp//\\[ 	
-]/ }" )
+  [[ ! -o ignorebraces && "${#${exp}//[^\{]}" = "${#${exp}//[^\}]}" ]] &&
+      eval exp\=\( ${${(q)exp}:gs/\\{/\{/:gs/\\}/\}/} \)
+  exp=( ${(e)exp//\\[ 	
+]/ } )
 else
-  exp=( "${exp:s/\\\$/\$}" )
+  exp=( ${exp:s/\\\$/\$} )
 fi
 
 # If the array is empty, store the original string again.
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.69
diff -u -r1.69 compsys.yo
--- Doc/Zsh/compsys.yo	2000/06/19 09:32:31	1.69
+++ Doc/Zsh/compsys.yo	2000/06/19 09:44:06
@@ -1207,12 +1207,15 @@
 is set to `true', then none of the words that are already on the line
 will be considered possible completions.  If it is set to
 `tt(current)', the word the cursor is on will not be considered a
-possible completion and if it is set to `tt(other)' all words except
-the current one will not be considered to be a possible completion.
+possible completion.  The same happens if the value is
+`tt(current-shown)', but only if the list of completions is currently
+shown on the screen.  Finally, if it is set to `tt(other)' all words
+except the current one will not be considered to be a possible
+completion.
 
-The value `tt(current)' is a bit like the opposite of the
-tt(accept-exact). It means that only strings with missing characters
-will be completed.
+The values `tt(current)' and `tt(current-shown)' are a bit like the
+opposite of the tt(accept-exact). It means that only strings with
+missing characters will be completed.
 
 Note that you almost certainly don't want to set this to `true' or
 `tt(other)' for a general
Index: Src/Zle/zle_tricky.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_tricky.c,v
retrieving revision 1.15
diff -u -r1.15 zle_tricky.c
--- Src/Zle/zle_tricky.c	2000/06/16 07:52:05	1.15
+++ Src/Zle/zle_tricky.c	2000/06/19 09:44:06
@@ -1434,7 +1434,19 @@
 		    }
 		}
 	    } else if (p < curs) {
+		if (*p == Outbrace) {
+		    cant = 1;
+		    break;
+		}
 		if (*p == Inbrace) {
+		    char *tp = p;
+
+		    if (!skipparens(Inbrace, Outbrace, &tp)) {
+			i += tp - p - 1;
+			dp += tp - p - 1;
+			p = tp - 1;
+			continue;
+		    }
 		    if (bbeg) {
 			Brinfo new;
 			int len = bend - bbeg;
@@ -1470,6 +1482,18 @@
 		    hascom = 1;
 		}
 	    } else {
+		if (*p == Inbrace) {
+		    char *tp = p;
+
+		    if (!skipparens(Inbrace, Outbrace, &tp)) {
+			i += tp - p - 1;
+			dp += tp - p - 1;
+			p = tp - 1;
+			continue;
+		    }
+		    cant = 1;
+		    break;
+		}
 		if (p == curs) {
 		    if (bbeg) {
 			Brinfo new;
@@ -1501,7 +1525,7 @@
 		if (*p == Comma) {
 		    if (!bbeg)
 			bbeg = p;
-		    hascom = 1;
+		    hascom = 2;
 		} else if (*p == Outbrace) {
 		    Brinfo new;
 		    int len;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

