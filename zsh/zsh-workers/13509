From zsh-workers-return-13509-mason-zsh=primenet.com.au@sunsite.dk Tue Feb 20 09:08:56 2001
Return-Path: <zsh-workers-return-13509-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 12285 invoked from network); 20 Feb 2001 09:08:55 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Feb 2001 09:08:55 -0000
Received: (qmail 27768 invoked by alias); 20 Feb 2001 09:08:48 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13509
Received: (qmail 27756 invoked from network); 20 Feb 2001 09:08:48 -0000
Date: Tue, 20 Feb 2001 10:08:46 +0100 (MET)
Message-Id: <200102200908.KAA15900@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: PATCH: signal queueing


I've now looked through it again. The patch below adds signal queueing 
to the functions for the job control builtins (fg/bg/wait/kill). I
hope the other accesses to the job table are made secure in the
calling functions.

The signal code already used (|un)queue_signals() and the uses of
Param pointers looked good, too.

The only thing I'm, not yet sure about is the zftp module: maybe the
calls to createparam() should be protected...

Bye
 Sven

Index: Src/jobs.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/jobs.c,v
retrieving revision 1.9
diff -u -r1.9 jobs.c
--- Src/jobs.c	2001/01/16 13:44:20	1.9
+++ Src/jobs.c	2001/02/20 09:08:18
@@ -1248,6 +1248,7 @@
 	return 1;
     }
 
+    queue_signals();
     /* If necessary, update job table. */
     if (unset(NOTIFY))
 	scanjobs();
@@ -1267,6 +1268,7 @@
 	    point or else. */
 	    if (curjob == -1 || (jobtab[curjob].stat & STAT_NOPRINT)) {
 		zwarnnam(name, "no current job", NULL, 0);
+		unqueue_signals();
 		return 1;
 	    }
 	    firstjob = curjob;
@@ -1280,11 +1282,13 @@
 			(ops['s'] && jobtab[job].stat & STAT_STOPPED))
 			printjob(job + jobtab, lng, 2);
 		}
+	    unqueue_signals();
 	    return 0;
 	} else {   /* Must be BIN_WAIT, so wait for all jobs */
 	    for (job = 0; job != MAXJOB; job++)
 		if (job != thisjob && jobtab[job].stat)
 		    zwaitjob(job, SIGINT);
+	    unqueue_signals();
 	    return 0;
 	}
     }
@@ -1319,6 +1323,7 @@
 	if (!(jobtab[job].stat & STAT_INUSE) ||
 	    (jobtab[job].stat & STAT_NOPRINT)) {
 	    zwarnnam(name, "no such job: %d", 0, job);
+	    unqueue_signals();
 	    return 1;
 	}
 	/* We have a job number.  Now decide what to do with it. */
@@ -1334,6 +1339,7 @@
 		/* Silly to bg a job already running. */
 		zwarnnam(name, "job already in background", NULL, 0);
 		thisjob = ocj;
+		unqueue_signals();
 		return 1;
 	    }
 	    /* It's time to shuffle the jobs around!  Reset the current job,
@@ -1391,6 +1397,7 @@
 	}
 	thisjob = ocj;
     }
+    unqueue_signals();
     return retval;
 }
 
@@ -1473,6 +1480,7 @@
 	argv++;
     }
 
+    queue_signals();
     setcurjob();
 
     /* Remaining arguments specify processes.  Loop over them, and send the
@@ -1509,6 +1517,8 @@
 	    returnval++;
 	}
     }
+    unqueue_signals();
+
     return returnval < 126 ? returnval : 1;
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

