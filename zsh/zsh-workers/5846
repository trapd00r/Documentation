From zsh-workers-return-5846-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 17 15:00:57 1999
Return-Path: <zsh-workers-return-5846-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3253 invoked from network); 17 Mar 1999 15:00:56 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Mar 1999 15:00:56 -0000
Received: (qmail 5680 invoked by alias); 17 Mar 1999 15:00:32 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5846
Received: (qmail 5672 invoked from network); 17 Mar 1999 15:00:30 -0000
Date: Wed, 17 Mar 1999 15:59:06 +0100 (MET)
Message-Id: <199903171459.PAA27145@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Wed, 17 Mar 1999 17:35:30 +0300
Subject: RE: PATCH: param stuff and was: PATCH: 3.1.5-pws-12: _brace_parameter


Andrej Borsenkow wrote:

> > It's actually completely predictable, once you know the rule.
> >
> 
> 'course. What I tried to explain, that there is probably a dozen of people,
> who know these rules :-( (correct me if I'm wrong)
> 
> O.K. Is it intentional?
> 
> itsrm2% foo=(axb cxd)
> itsrm2% print -l ${(s/x/)foo}
> a
> b c
> d
> 
> I won't argue, if this is correct or not. I'd just to point out
> a) if this is intentional, it should be documented
> b) it is very different from word splitting (which is referred to in
> manual). In this case, *every* resulting word is splitted:
> 
> itsrm2% foo=("a b" "c d")
> itsrm2% print -l ${=foo}
> a
> b
> c
> d

The `s' flag just says where to split -- without it is done at the
well known places, with it it is done only at the string given with
the flag.

> The second question is, what is applied first - flags or modifications?
> Again, after soms tests :-)
> 
> itsrm2% foo=(ax1 bx1)
> itsrm2% print -l ${(s/x/)foo%%1*}
> a
>  b
> 
> I don't argue, that it may be predictable. Unfortunately, I simply fail to
> find the rule ...

Modification is done first. Splitting is done at the very end, in this 
case.

So the above does: apply the `%%1*', yielding the two elements `ax'
and `bx'. The `s' flag makes them be joined as usual and then broken at 
the `x's, yielding the three elements `a', ` b', and `'. Since you
didn't enclose it in quotes that last one is removed so you can't see
it. But with `"${(@s/x/)foo%%1*}" you can. And I can almost see you
trying `print -l "${(s/x/)foo%%1*}" now ;-) Perhaps surprisingly this
gives `a' and `', because without the `(@)' flag, the array elements
are first joined and re-separated at the `x's and then the `%%1*' is
applied -- which looks a bit like a bug, but then again, maybe not.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

