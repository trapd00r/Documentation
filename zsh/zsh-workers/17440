From zsh-workers-return-17440-mason-zsh=primenet.com.au@sunsite.dk Mon Jul 08 09:13:57 2002
Return-Path: <zsh-workers-return-17440-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17686 invoked from network); 8 Jul 2002 09:13:56 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 8 Jul 2002 09:13:56 -0000
Received: (qmail 5511 invoked by alias); 8 Jul 2002 09:13:44 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 17440
Received: (qmail 5494 invoked from network); 8 Jul 2002 09:13:41 -0000
From: Sven Wischnowsky <wischnow@berkom.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-ID: <15657.22524.49473.53727@wischnow.berkom.de>
Date: Mon, 8 Jul 2002 11:14:36 +0200
To: zsh-workers@sunsite.dk
Subject: get completion information
X-Mailer: VM 7.03 under 21.5 (patch 5) "beets" XEmacs Lucid


Hi

I'm not going to commit this right now, it's merely a suggestion.

This adds the _get_context widget. It can be called to retrieve
information about what the completion system thinks the context is at
the current cursor position and what kind of stuff has to be completed
there.

It doesn't return the actual words the completion system would offer,
though. That would probably the next thing that would have to be added.
But then we need to parse the compadd-options there. Then we'd need to
be able to get at the beginning and end-positions where the words
would be inserted. Then there is the problem with completion in
braces. Etc. I hope you can see why I didn't try to do that yet ;-)
Also, I'm still wondering if we shouldn't move more of the completion
code into shell code. E.g. by offering a new builtin that's used to
set up the variables (and otherwise initialise the completion code
internals) and that's used to start the insertion of the matches and
whatnot. With menu completion, selection and so on this is what makes
this hard. So hard that I'm not sure if it's worth it, especially if
we can get the widget below (or it's descendents) to do most of or
everything we need/want.

Opinions? Ideas?


Bye
  Sven

P.S.: I would have loved to be able to include a widget that does
      something sensible with the information _get_context returns.
      The only thing I could think of is what has been discussed some
      time ago: a word movement widget that uses different separation
      characters for different types of words (files, hosts, ...). But
      to make this nice would have required more time than I had at
      the weekend.


diff -ur -r ../oz/Completion/Base/Widget/_get_context ./Completion/Base/Widget/_get_context
--- ../oz/Completion/Base/Widget/_get_context	Sat Jul  6 23:59:42 2002
+++ ./Completion/Base/Widget/_get_context	Sun Jul  7 23:04:37 2002
@@ -0,0 +1,42 @@
+#compdef -k complete-word
+
+_get_context() {
+  eval "$_comp_setup"
+
+  local _sort_tags=_help_get_context
+
+  if [[ "$1" = -t ]]; then
+     local _get_context=0 _get_return
+    shift
+  else
+    typeset -A _get_return
+  fi
+  (( $+1 )) || 1=reply
+
+  compadd() { return 1 }
+  trap 'unfunction compadd' EXIT INT
+
+  _main_complete
+
+  unfunction compadd
+  trap - EXIT INT
+
+  compstate[list]=''
+  compstate[insert]=''
+
+  set -A "$1" "$_get_return[@]"
+}
+
+_help_get_context() {
+  if (( ! $+_get_context )); then
+    _get_return[${curcontext}]+="${argv:#${(j:|:)~_get_return[${curcontext}]}}"
+  elif [[ $#curcontext -eq $_get_context ]]; then
+    _get_return+=( "${(@)argv:#${(j:|:)~_get_return}}" )
+  elif [[ $#curcontext -gt $_get_context ]]; then
+    _get_context=$#curcontext
+    _get_return=( "${(@)argv}" )
+  fi
+  comptry "$@"
+}
+
+_get_context "$@"
diff -ur -r ../oz/Completion/compinit ./Completion/compinit
--- ../oz/Completion/compinit	Fri Jul  5 22:37:50 2002
+++ ./Completion/compinit	Sat Jul  6 23:24:13 2002
@@ -316,11 +316,6 @@
       done
       ;;
     key)
-      if [[ $# -lt 2 ]]; then
-        echo "$0: missing keys"
-	return 1
-      fi
-
       # Define the widget.
       if [[ $1 = .* ]]; then
         [[ $1 = .menu-select ]] && zmodload -i zsh/complist
diff -ur -r ../oz/Doc/Zsh/compsys.yo ./Doc/Zsh/compsys.yo
--- ../oz/Doc/Zsh/compsys.yo	Fri Jul  5 22:37:48 2002
+++ ./Doc/Zsh/compsys.yo	Sun Jul  7 23:13:05 2002
@@ -3001,6 +3001,30 @@
 The corresponding completion tags used are tt(etags) and tt(vtags), after
 emacs and vi respectively.
 )
+findex(_get_context)
+item(tt(_get_context))(
+This widget is not intended to be bound to a key. Instead, it may be
+called from a function implementing a normal ZLE widget to get
+information about what the completion system thinks the context at the
+current cursor position is. E.g., calling the widget as in:
+
+example(typeset -A foo
+zle _get_context foo)
+
+will make tt(_get_context) invoke the completion system and after
+store the contexts and their tags in the association `tt(foo)'.
+
+If only the tags, i.e. the types of words expected at the cursor
+position is of interest, tt(_get_context) can be given the option
+tt(-t):
+
+example(local -A foo
+zle _get_context - -t foo)
+
+(The single dash is needed to stop option parsing of the tt(zle)
+builtin command.) This will set the parameter `tt(foo)' to an array
+containing the names of the tags.
+)
 enditem()
 
 texinode(Completion Functions)(Completion Directories)(Bindable Commands)(Completion System)

-- 
Sven Wischnowsky                          wischnow@berkom.de

