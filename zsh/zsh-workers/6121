From zsh-workers-return-6121-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Apr 27 13:38:33 1999
Return-Path: <zsh-workers-return-6121-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13461 invoked from network); 27 Apr 1999 13:38:29 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Apr 1999 13:38:29 -0000
Received: (qmail 15067 invoked by alias); 27 Apr 1999 13:38:05 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6121
Received: (qmail 15053 invoked from network); 27 Apr 1999 13:37:58 -0000
Date: Tue, 27 Apr 1999 15:37:18 +0200 (MET DST)
Message-Id: <199904271337.PAA13588@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Tue, 27 Apr 1999 13:56:22 +0100
Subject: Re: Completion in braces limitation


Oliver Kiddle wrote:

> Completion in braces doesn't seem to work in combination with variables:
> 
> zsh -f
> less $PWD/<tab>  - beep and lists files
> less $PWD/{<tab> - just beeps

This was intentional, the completion gave up as soon as it found the `$'.
The patch below makes it try a little harder by looking at what comes
after the `$'. If there is a complete parameter expansion and the
opening brace from the brace expansion comes after it, this should
work now.
I would be thankful if someone (you?) could test this more thoroughly, 
though.

> Another feature which would be useful is if completion of variables was
> extended to
> properly handle associative arrays. So for example, if I have an
> associative array named 'test',
> cd $test[<tab>
> would complete from the list of keys in $test.

Well, the new style completion can do this, of course...

And: I /think/ I already mentioned this some time ago (I knew someone
would say that he would like to have it). I don't remember exactly,
but I think I foresaw some problem there (mainly due to the code, I
think, not in what the user sees). There might be some ugly
interaction with normal subscripts...

So, no patch for this now. Sorry.

Bye
 Sven

diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Tue Apr 27 13:06:22 1999
+++ Src/Zle/zle_tricky.c	Tue Apr 27 15:29:04 1999
@@ -1515,12 +1515,46 @@
 	     */
 	    for (i = 0, p = s; *p; p++, i++) {
 		/* careful, ${... is not a brace expansion...
-		 * in fact, if it's got a substitution in it's too
-		 * hard for us anyway.  sorry.
+		 * we try to get braces after a parameter expansion right,
+		 * but this may fail sometimes. sorry.
 		 */
 		if (*p == String || *p == Qstring) {
-		    tt = NULL;
-		    break;
+		    if (p[1] == Inbrace) {
+			char *tp = p + 1;
+			if (skipparens(Inbrace, Outbrace, &tp)) {
+			    tt = NULL;
+			    break;
+			}
+			i += tp - p;
+			p = tp;
+		    } else {
+			char *tp = p + 1;
+
+			if (*tp == Quest || *tp == Star || *tp == String ||
+			    *tp == Qstring || *tp == '?' || *tp == '*' ||
+			    *tp == '$' || *tp == '-' || *tp == '!' ||
+			    *tp == '@')
+			    p++, i++;
+			else {
+			    if (idigit(*tp))
+				while (idigit(*tp))
+				    tp++;
+			    else if (iident(*tp))
+				while (iident(*tp))
+				    tp++;
+			    else {
+				tt = NULL;
+				break;
+			    }
+			    if (*tp == Inbrace) {
+				tt = NULL;
+				break;
+			    }
+			    tp--;
+			    i += tp - p;
+			    p = tp;
+			}
+		    }
 		} else if (*p == Inbrace) {
 		    if (tt) {
 			/* too many inbraces */

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

