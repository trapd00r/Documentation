From zsh-workers-return-14090-mason-zsh=primenet.com.au@sunsite.dk Wed Apr 25 12:55:37 2001
Return-Path: <zsh-workers-return-14090-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3695 invoked from network); 25 Apr 2001 12:55:36 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 25 Apr 2001 12:55:36 -0000
Received: (qmail 4859 invoked by alias); 25 Apr 2001 12:55:21 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14090
Received: (qmail 4786 invoked from network); 25 Apr 2001 12:55:19 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Tue, 24 Apr 2001 12:00:56 +0200 (MET DST)
Message-Id: <200104241000.MAA02825@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: problem with _arguments exclusion lists
In-Reply-To: <3AE3EF09.C25C8DF8@u.genie.co.uk>

Ok, here's my suggestion.  The option's name is `-w', dunno if we should
exchange the meaning of -W and -w (-w is the stronger one, so to say).

Then I suggest to use the following as the pattern-match utility function:

  local mesg pat garbage

  mesg=()
  zparseopts -K -D -a garbage M: J: V: 1 2 n F: X:=mesg 

  [[ "$PREFIX$SUFFIX" != $~1 ]] && return 1

  if [[ $# -gt 1 || $#mesg -eq 0 ]]; then
    shift
    _message "$*"
  else
    _message -r "$mesg[2]"
  fi

  [[ -n "$PREFIX$SUFFIX" ]] 

It ignores the compadd-options that might be passed from the completion
system internals to called function and can extract a given explanation
string from that (e.g. when called from _arguments or _alternative).

The first real argument is the pattern to test for and if more arguments
are given, those are used as the description to display (overriding the
string from -X, if any).

It might be called as in:

  _arguments  -s '(-conf)-c+:numeric value:prop "[0-9]#"' '-conf' '-f'

or:

  _arguments  -s '(-conf)-c+: :prop "[0-9]#" numeric value' '-conf' '-f'

and makes that complete options and display the message after `-c<TAB>'.
After `-c<digits><TAB>' only the message will be displayed and after
`-c<non-digits><TAB>' only options will be completed.  All that due to
the new behaviour of completing options if the action returns non-zero.

That feels quite satisfying.

So, if anyway can tell me a good name for that utility function, I'm
going to commit it.  I really don't have the faintest idea.  Oliver?

Bye
  Sven

Index: Completion/Base/Utility/_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_arguments,v
retrieving revision 1.3
diff -u -r1.3 _arguments
--- Completion/Base/Utility/_arguments	2001/04/05 12:12:47	1.3
+++ Completion/Base/Utility/_arguments	2001/04/24 09:59:46
@@ -4,7 +4,7 @@
 # descriptions given as arguments to this function.
 
 local long cmd="$words[1]" descr mesg subopts opt usecc autod
-local oldcontext="$curcontext" hasopts rawret optarg singopt
+local oldcontext="$curcontext" hasopts rawret optarg singopt alwopt
 
 long=$argv[(I)--]
 if (( long )); then
@@ -174,7 +174,7 @@
 
 subopts=()
 singopt=()
-while [[ "$1" = -(O*|[CRWs]) ]]; do
+while [[ "$1" = -(O*|[CRWsw]) ]]; do
   case "$1" in
   -C)  usecc=yes; shift ;;
   -O)  subopts=( "${(@P)2}" ); shift 2 ;;
@@ -182,13 +182,14 @@
   -R)  rawret=yes; shift;;
   -W)  optarg=yes; shift;;
   -s)  singopt=(-s); shift;;
+  -w)  alwopt=yes; shift;;
   esac
 done
 
 zstyle -s ":completion:${curcontext}:options" auto-description autod
 
 if (( $# )) && comparguments -i "$autod" "$singopt[@]" "$@"; then
-  local action noargs aret expl local tried
+  local action noargs aret expl local tried ret=1
   local next direct odirect equal single matcher matched ws tmp1 tmp2 tmp3
   local opts subc tc prefix suffix descrs actions subcs anum
   local origpre="$PREFIX" origipre="$IPREFIX" nm="$compstate[nmatches]"
@@ -280,7 +281,8 @@
 
               eval ws\=\( "${action[3,-3]}" \)
 
-              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]"
+              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]" ||
+                  alwopt=yes
 	      tried=yes
 
             elif [[ "$action" = \(*\) ]]; then
@@ -289,15 +291,17 @@
 
               eval ws\=\( "${action[2,-2]}" \)
 
-              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws
+              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws ||
+                  alwopt=yes
 	      tried=yes
             elif [[ "$action" = \{*\} ]]; then
 
               # A string in braces is evaluated.
 
               while _next_label "$subc" expl "$descr"; do
-                eval "$action[2,-2]"
+                eval "$action[2,-2]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             elif [[ "$action" = \ * ]]; then
 
@@ -305,8 +309,9 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[@]"
+                "$action[@]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             else
 
@@ -314,15 +319,17 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}"
+                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}" && ret=0
 	      done
+              (( ret )) && alwopt=yes
 	      tried=yes
             fi
           fi
         fi
       done
-
-      if [[ -z "$matched$hasopts" && ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
+      if [[ -z "$hasopts" &&
+            ( -z "$matched" || -n "$alwopt" ) &&
+            ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
           _requested options &&
           { ! zstyle -T ":completion:${curcontext}:options" prefix-needed ||
             [[ "$origpre" = [-+]* || -z "$aret$mesg$tried" ]] } ; then
@@ -378,9 +385,10 @@
 	PREFIX="$prevpre"
 	IPREFIX="$previpre"
       fi
-      [[ -n "$tried" && "$PREFIX" != [-+]* ]] && break
+      [[ -n "$tried" && "${${alwopt:+$origpre}:-$PREFIX}" != [-+]* ]] && break
     done
-    if [[ -n "$opts" && -z "$aret$matched$mesg" &&
+    if [[ -n "$opts" && -z "$aret" &&
+          ( -z "$matched$mesg" || -n "$alwopt" ) &&
           nm -eq compstate[nmatches] ]]; then
 
       PREFIX="$origpre"
Index: Completion/X/Utility/_x_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_x_arguments,v
retrieving revision 1.2
diff -u -r1.2 _x_arguments
--- Completion/X/Utility/_x_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_x_arguments	2001/04/24 09:59:47
@@ -17,7 +17,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Completion/X/Utility/_xt_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_xt_arguments,v
retrieving revision 1.2
diff -u -r1.2 _xt_arguments
--- Completion/X/Utility/_xt_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_xt_arguments	2001/04/24 09:59:47
@@ -53,7 +53,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.117
diff -u -r1.117 compsys.yo
--- Doc/Zsh/compsys.yo	2001/04/04 11:29:22	1.117
+++ Doc/Zsh/compsys.yo	2001/04/24 09:59:50
@@ -2937,6 +2937,18 @@
 normally not complete the other option directly after `tt(-a)', but it would
 allow that if given the tt(-W) option.
 
+Similarly, the option tt(-w) may be given to force completion of options
+even after options that get an argument in the same word.  For example,
+if a command takes the options `tt(a)' and `tt(b)', where `tt(a)' needs
+an argument in the same word, directly after the option character,
+tt(_arguments) would normally only execute the action for that argument
+and not offer other options as possible completions.  If given the
+tt(-w) option, it will offer other options as possible completions after
+executing the action for the argument.  Note that, depending on the
+action, this may mean that the other options can't really be completed,
+but at least they will be listed.  For more control, use an utility
+function like tt(_XXX) in the argument's action.
+
 The forms of var(optspec) are:
 
 startitem()
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.48
diff -u -r1.48 computil.c
--- Src/Zle/computil.c	2001/04/17 09:52:32	1.48
+++ Src/Zle/computil.c	2001/04/24 09:59:51
@@ -1941,7 +1941,12 @@
     case 's':
 	for (; lstate; lstate = lstate->snext)
 	    if (lstate->d->single && lstate->singles &&
-		lstate->actopts && lstate->opt) {
+		lstate->actopts
+#if 0
+                /* let's try without, for the -o option of _arguments */
+                && lstate->opt
+#endif
+                ) {
 		setsparam(args[1],
 			  ztrdup((lstate->ddef && lstate->dopt) ?
 				 (lstate->dopt->type == CAO_DIRECT ?

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

