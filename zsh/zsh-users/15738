From zsh-users-return-15738-mason-zsh=primenet.com.au@zsh.org Fri Jan 28 22:49:34 2011
Return-Path: <zsh-users-return-15738-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3280 invoked by alias); 28 Jan 2011 22:49:34 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15738
Received: (qmail 10658 invoked from network); 28 Jan 2011 22:49:30 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at ntlworld.com designates 81.103.221.58 as permitted sender)
Date: Fri, 28 Jan 2011 22:17:24 +0000
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: zsh-users@zsh.org
Subject: Re: Absolute pathnames similar to expand-cmd-path
Message-ID: <20110128221724.2f1753ba@pws-pc.ntlworld.com>
In-Reply-To: <110127195309.ZM4952@torch.brasslantern.com>
References: <44CE36D4-9044-4148-BDCE-636D85AC003B@cl.cam.ac.uk>
	<AANLkTi==AFonoqW8xjRMtzROxsNdPNx4e8k=7Wt8zXUd@mail.gmail.com>
	<110127195309.ZM4952@torch.brasslantern.com>
X-Mailer: Claws Mail 3.7.8 (GTK+ 2.22.0; x86_64-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-Cloudmark-Analysis: v=1.1 cv=JvdXmxIgLJv2/GthKqHpGJEEHukvLcvELVXUanXFreg= c=1 sm=0 a=grTaqnFszTkA:10 a=kj9zAlcOel0A:10 a=q2GGsy2AAAAA:8 a=NLZqzBF-AAAA:8 a=fX3Nme6NPZP6zjh5EVQA:9 a=UfOepkxRNwzVk2Q99TgA:7 a=M2YGoCqMe2KEc98lsGLIs1hYDyIA:4 a=CjuIK1q_8ugA:10 a=Peh4Twq3hjUA:10 a=I6wTmPyJxzYA:10 a=_dQi-Dcv4p4A:10 a=5mX0W4TQuz_r2G-Z:21 a=kWR-9n52Wp_ZnB8M:21 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117

On Thu, 27 Jan 2011 19:53:09 -0800
Bart Schaefer <schaefer@brasslantern.com> wrote:
> The following seems to work for me, though sometimes it doesn't leave
> the cursor where I expect:
> 
>     autoload -uZ modify-current-argument
>     current-argument-absolute-path() {
>       modify-current-argument '$ARG:a'
>     }
>     zle -N current-argument-absolute-path

Ah, it's magic you want.

The following changes the logic so that if the cursor was on the last
character or after the end of the original argument it is on the last
character or after the end of the new argument, and even more magically
if the characters from the original cursor position to the end are the
same characters at the end of the new string then the cursor is
positioned relative to the end of the new string.

This tickles cursor positioning annyonances in undo.

It will have to wait until Sourceforge resolve the problems.

--- ../zsh-git/zsh/Functions/Zle/modify-current-argument	2010-03-25 21:01:19.000000000 +0000
+++ Functions/Zle/modify-current-argument	2011-01-28 22:09:28.000000000 +0000
@@ -14,7 +14,7 @@
 setopt localoptions noksharrays multibyte
 
 local -a reply
-integer REPLY REPLY2
+integer REPLY REPLY2 fromend endoffset
 
 autoload -Uz split-shell-arguments
 split-shell-arguments
@@ -30,6 +30,13 @@ if (( REPLY & 1 )); then
   (( REPLY2 = ${#reply[REPLY]} + 1 ))
 fi
 
+# Work out offset from end of string
+(( fromend = $REPLY2 - ${#reply[REPLY]} - 1 ))
+if (( fromend >= -1 )); then
+  # Cursor is near the end of the word, we'll try to keep it there.
+  endoffset=1
+fi
+
 # Length of all characters before current.
 # Force use of character (not index) counting and join without IFS.
 integer wordoff="${(cj..)#reply[1,REPLY-1]}"
@@ -37,15 +44,32 @@ integer wordoff="${(cj..)#reply[1,REPLY-
 # Replacement for current word.  This could do anything to ${reply[REPLY]}.
 local ARG="${reply[REPLY]}" repl
 eval repl=\"$1\"
+
+if (( !endoffset )) && [[ ${repl[fromend,-1]} = ${ARG[fromend,-1]} ]]; then
+  # If the part of the string from here to the end hasn't changed,
+  # leave the cursor this distance from the end instead of the beginning.
+  endoffset=1
+fi
+
 # New line:  all words before and after current word, with
 # no additional spaces since we've already got the whitespace
 # and the replacement word in the middle.
-BUFFER="${(j..)reply[1,REPLY-1]}${repl}${(j..)reply[REPLY+1,-1]}"
+local left="${(j..)reply[1,REPLY-1]}${repl}"
+local right="${(j..)reply[REPLY+1,-1]}"
 
-# Keep cursor at same position in replaced word.
-# Redundant here, but useful if $repl changes the length.
-# Limit to the next position after the end of the word.
-integer repmax=$(( ${#repl} + 1 ))
-# Remember CURSOR starts from offset 0 for some reason, so
-# subtract 1 from positions.
-(( CURSOR = wordoff + (REPLY2 > repmax ? repmax : REPLY2) - 1 ))
+if [[ endoffset -ne 0 && ${#repl} -ne 0 ]]; then
+  # Place cursor relative to end.
+  LBUFFER="$left"
+  RBUFFER="$right"
+  (( CURSOR += fromend ))
+else
+  BUFFER="$left$right"
+
+  # Keep cursor at same position in replaced word.
+  # Redundant here, but useful if $repl changes the length.
+  # Limit to the next position after the end of the word.
+  integer repmax=$(( ${#repl} + 1 ))
+  # Remember CURSOR starts from offset 0 for some reason, so
+  # subtract 1 from positions.
+  (( CURSOR = wordoff + (REPLY2 > repmax ? repmax : REPLY2) - 1 ))
+fi

-- 
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

