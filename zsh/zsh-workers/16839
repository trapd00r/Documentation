From zsh-workers-return-16839-mason-zsh=primenet.com.au@sunsite.dk Fri Mar 15 15:32:05 2002
Return-Path: <zsh-workers-return-16839-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 805 invoked from network); 15 Mar 2002 15:32:05 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 15 Mar 2002 15:32:05 -0000
Received: (qmail 23071 invoked by alias); 15 Mar 2002 15:31:57 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16839
Received: (qmail 23054 invoked from network); 15 Mar 2002 15:31:55 -0000
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <1020315153147.ZM2228@candle.brasslantern.com>
Date: Fri, 15 Mar 2002 15:31:46 +0000
In-Reply-To: <15505.46831.979708.369781@wischnow.berkom.de>
Comments: In reply to Sven Wischnowsky <wischnow@berkom.de>
        "Re: (backward-)kill-argument" (Mar 15,  9:55am)
References: <m2zo1cxvvl.fsf@linux3.maruska.tin.it> 
	<15505.46831.979708.369781@wischnow.berkom.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.dk
Subject: Re: (backward-)kill-argument
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Mar 15,  9:55am, Sven Wischnowsky wrote:
}
} > i want to:
} >   * kill filenames w/  spaces: e.g.    this\ is\ file.txt
} 
} Write yourself a little widget. As a starting point:
} 
}   kill-with-spaces() {
}     local words
}     words="${(z)BUFFER}"
}     BUFFER="${BUFFER%${words[-1]}[ 	]#}"
}   }

That's a nice function, Sven, but I think I'd call it something like
`backward-kill-shell-word', and it ought to test $LBUFFER, not $BUFFER.
If you throw in `setopt localoptions extendedglob', we could even put
it in the distribution,

} (There's a space and a TAB inside that [ ].)

You can write that as [[:space:]] now, I think?

} >   * maybe even the bracketed part:
} >         find  { -name '*.h' }
} > 
} > Is it possible in Zsh?
} 
} Using the above you could check if $words[-1] is one of the closing
} braces and if it is, search back in the array for the matching opening
} brace. When found, you can delete the end of $BUFFER up to that
} matching brace by using a pattern of the form:
} 
}   ${words[-n]}[ 	]##...[ 	]##${words[-1]}[ 	]#

Hmm, I think I'd just do a loop killing words until the open-brace was
missing from $LBUFFER.  So, putting it all together,

    backward-kill-shell-expression() {
        setopt localoptions extendedglob
        local words
        words="${(z)LBUFFER}"
        LBUFFER="${LBUFFER%${words[-1]}[[:space:]]#}"
        if [[ "$words[-1]" == '}' ]]
        then
            words="${(z)LBUFFER}"
            while [[ "${${(@M)words:#[\{\}]}[-1]}" == '{' ]]
            do
                LBUFFER="${LBUFFER%${words[-1]}[[:space:]]#}"
                words="${(z)LBUFFER}"
            done
        fi
    }

This could be extended to handle `( ... )', `[[ ... ]]', etc., and we
could of course also write a forward- version.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

