From zsh-workers-return-13451-mason-zsh=primenet.com.au@sunsite.dk Fri Feb 09 18:19:18 2001
Return-Path: <zsh-workers-return-13451-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9273 invoked from network); 9 Feb 2001 18:19:16 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Feb 2001 18:19:16 -0000
Received: (qmail 16580 invoked by alias); 9 Feb 2001 18:19:09 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13451
Received: (qmail 16569 invoked from network); 9 Feb 2001 18:19:05 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010209181818.ZM16052@candle.brasslantern.com>
Date: Fri, 9 Feb 2001 18:18:18 +0000
In-Reply-To: <000d01c0926a$ce26c590$21c9ca95@mow.siemens.ru>
Comments: In reply to "Andrej Borsenkow" <Andrej.Borsenkow@mow.siemens.ru>
        "RE: Word splitting in zsh" (Feb  9, 10:34am)
References: <000d01c0926a$ce26c590$21c9ca95@mow.siemens.ru>
X-Mailer: Z-Mail (5.0.0 30July97)
To: "Deborah Ariel Pickett" <debbiep@mail.csse.monash.edu.au>,
        zsh-workers@sunsite.dk
Subject: Re: Word splitting in zsh
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

(Distribution changed to -workers)

On Feb 9, 10:34am, Andrej Borsenkow wrote:
}
} > zagzig% echo $ZSH_VERSION
} > 3.1.9-dev-8
} > zagzig% set "a1 a2 a3" b c
} > zagzig% print -l ${1+"$@"}
} > a1 a2 a3 b c						<-- Yipes!
} 
} Well, this is "correct" *zsh* behaviour. The part after `+' is a word - not
} array. And is taken as single word and is never splitted. What happens here,
} is
} 
} - zsh evaluates "$@" that gives you array with three elements
} - but because of "scalar context" in this case (the best I can call it) array
} is concatenated forming the above value.

Yes, your analysis is correct; the bug is that there should not be a scalar
context there.  The effect of ${NAME:+WORD} and ${NAME:-WORD} should be to
replace the context of NAME with the context of WORD in the event that NAME
is (or not) set.  Put another way, the type of NAME should only determine
the type of the whole ${...} when NAME really is being substituted.

(One could argue, then, that ${NAME:=WORD} should make NAME into an array if
WORD expands to an array.  In fact, there are a number of things that this
would make simpler, though there also may be some things it would break.)

} Even worse, it is inconsistent with everything else - array joining is
} supposed to use IFS ... but it does not in this case.

Well, that ought to be relatively simple to fix, and probably isn't even
widely depended-upon.  Zsh scripts hardly ever bother fooling with IFS,
given all the other ways that one has to chop up strings.

} > I don't know exactly when this bug was introduced, though.
} 
} That is almost inevitable in current implementation.

Yes, but 3.0.6 doesn't *have* the current implementation, and it's got
the same problem as demonstrated for 3.0.8 in my previous message.  So
part of this got introduced quite some time ago, which is what I meant.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

