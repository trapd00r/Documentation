From zsh-workers-return-24275-mason-zsh=primenet.com.au@sunsite.dk Mon Dec 17 17:04:26 2007
Return-Path: <zsh-workers-return-24275-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14316 invoked from network); 17 Dec 2007 17:04:15 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.3 (2007-08-08) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.4 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.3
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 17 Dec 2007 17:04:15 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 76835 invoked from network); 17 Dec 2007 16:59:53 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 17 Dec 2007 16:59:53 -0000
Received: (qmail 17171 invoked by alias); 17 Dec 2007 16:59:50 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 24275
Received: (qmail 17157 invoked from network); 17 Dec 2007 16:59:49 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 17 Dec 2007 16:59:49 -0000
Received: from virusfilter.dotsrc.org (bifrost [127.0.0.1])
	by spamfilter.dotsrc.org (Postfix) with ESMTP id EECCC8058F54
	for <zsh-workers@sunsite.dk>; Mon, 17 Dec 2007 17:56:44 +0100 (CET)
Received: from cluster-g.mailcontrol.com (cluster-g.mailcontrol.com [85.115.41.190])
	by bifrost.dotsrc.org (Postfix) with ESMTP
	for <zsh-workers@sunsite.dk>; Mon, 17 Dec 2007 17:56:44 +0100 (CET)
Received: from cameurexb01.EUROPE.ROOT.PRI ([62.189.241.200])
	by rly18g.srv.mailcontrol.com (MailControl) with ESMTP id lBHGsmV8015201
	for <zsh-workers@sunsite.dk>; Mon, 17 Dec 2007 16:59:16 GMT
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.1830);
	 Mon, 17 Dec 2007 16:58:18 +0000
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.14.1/8.13.4) with ESMTP id lBHGwHIJ015833
	for <zsh-workers@sunsite.dk>; Mon, 17 Dec 2007 16:58:17 GMT
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.14.1/8.14.1/Submit) with ESMTP id lBHGwGCn015830
	for <zsh-workers@sunsite.dk>; Mon, 17 Dec 2007 16:58:17 GMT
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: Solaris multibyte stuff
X-Mailer: MH-E 8.0.3; nmh 1.2-20070115cvs; GNU Emacs 22.1.1
Date: Mon, 17 Dec 2007 16:58:16 +0000
Message-ID: <15829.1197910696@csr.com>
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 17 Dec 2007 16:58:18.0840 (UTC) FILETIME=[06039D80:01C840CE]
X-Scanned-By: MailControl A-06-00-00 (www.mailcontrol.com) on 10.71.0.128
X-Virus-Scanned: ClamAV using ClamSMTP

Thanks to Danek, I was able to trace the multibyte problem on Solaris.
It turns out that mbrlen() and presumably other functions that
return the number of characters in a multibyte expression return
the full number of character, even if reading one byte at a time
left you in the middle of a character from the previous time.  So we
were miscounting.  Luckily, this doesn't affect too much of the shell
and it's easy to make it robust since (obviously) we know how many
bytes we've just examined.  However, it's something to remember for
future code.

One other test was failing:  I was expecting $'\u00e9' in the C locale
to fail to convert but it seems it gets converted silently to a question
mark, so I've tested for that as an alternative.

All the tests now pass.

Index: Src/builtin.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/builtin.c,v
retrieving revision 1.183
diff -u -r1.183 builtin.c
--- Src/builtin.c	12 Dec 2007 18:43:29 -0000	1.183
+++ Src/builtin.c	17 Dec 2007 16:54:01 -0000
@@ -4927,7 +4927,7 @@
 		    break;
 		}
 		*bptr = (char) val;
-#ifdef MULTIBYTE_SUPPORT	
+#ifdef MULTIBYTE_SUPPORT
 		if (isset(MULTIBYTE)) {
 		    ret = mbrlen(bptr++, 1, &mbs);
 		    if (ret == MB_INVALID)
@@ -4954,8 +4954,8 @@
 		    eof = 1;
 		    break;
 		}
-	    
-#ifdef MULTIBYTE_SUPPORT	
+
+#ifdef MULTIBYTE_SUPPORT
 		if (isset(MULTIBYTE)) {
 		    while (val > 0) {
 			ret = mbrlen(bptr, val, &mbs);
@@ -4970,6 +4970,10 @@
 			    }
 			    else if (ret == 0) /* handle null as normal char */
 				ret = 1;
+			    else if (ret > val) {
+				/* Some mbrlen()s return the full char len */
+				ret = val;
+			    }
 			    nchars--;
 			    val -= ret;
 			    bptr += ret;
Index: Src/Zle/zle_utils.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_utils.c,v
retrieving revision 1.42
diff -u -r1.42 zle_utils.c
--- Src/Zle/zle_utils.c	19 Apr 2007 14:16:23 -0000	1.42
+++ Src/Zle/zle_utils.c	17 Dec 2007 16:54:03 -0000
@@ -294,6 +294,16 @@
 		 * (certainly true for Unicode and unlikely to be false
 		 * in any non-pathological multibyte representation). */
 		cnt = 1;
+	    } else if (cnt > ll) {
+		/*
+		 * Some multibyte implementations return the
+		 * full length of a previous incomplete character
+		 * instead of the remaining length.
+		 * This is paranoia: it only applies if we start
+		 * midway through a multibyte character, which
+		 * presumably can't happen.
+		 */
+		cnt = ll;
 	    }
 
 	    if (outcs) {
@@ -843,6 +853,12 @@
 		cnt = 1;
 		/* FALL THROUGH */
 	    default:
+		/*
+		 * Paranoia: only needed if we start in the middle
+		 * of a multibyte string and only in some implementations.
+		 */
+		if (cnt > ulen)
+		    cnt = ulen;
 		n = wcs_nicechar(c, &width, NULL);
 		break;
 	    }
Index: Test/D07multibyte.ztst
===================================================================
RCS file: /cvsroot/zsh/zsh/Test/D07multibyte.ztst,v
retrieving revision 1.21
diff -u -r1.21 D07multibyte.ztst
--- Test/D07multibyte.ztst	6 Nov 2007 20:45:09 -0000	1.21
+++ Test/D07multibyte.ztst	17 Dec 2007 16:54:03 -0000
@@ -388,9 +388,18 @@
 # This also isn't strictly multibyte and is here to reduce the
 # likelihood of a "can't do character set conversion" error.
   testfn() { (LC_ALL=C; print $'\u00e9') }
-  repeat 4 testfn
-1:error handling in Unicode quoting
-?testfn: character not in range
-?testfn: character not in range
-?testfn: character not in range
-?testfn: character not in range
+  repeat 4 testfn 2>&1 | while read line; do
+    if [[ $line = *"character not in range"* ]]; then
+      print OK
+    elif [[ $line = "?" ]]; then
+      print OK
+    else
+      print Failed: no error message and no question mark
+    fi
+  done
+  true
+0:error handling in Unicode quoting
+>OK
+>OK
+>OK
+>OK


-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070

