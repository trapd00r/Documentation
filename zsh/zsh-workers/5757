From zsh-workers-return-5757-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 11 15:02:27 1999
Return-Path: <zsh-workers-return-5757-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21948 invoked from network); 11 Mar 1999 15:02:21 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Mar 1999 15:02:21 -0000
Received: (qmail 8554 invoked by alias); 11 Mar 1999 13:28:11 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5757
Received: (qmail 8486 invoked from network); 11 Mar 1999 13:27:47 -0000
Date: Thu, 11 Mar 1999 14:27:44 +0100 (MET)
Message-Id: <199903111327.OAA01106@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: compconfig


Here is the patch adding the associative array `compconfig' in the
completion examples.

Currently this is used only for the auto-correction stuff, but maybe
we'll add other things...

The array is defined in `compinit' so that one can easily set it after 
sourcing that, e.g.:

  source .../compinit -d
  compconfig=(
    correct        2n
    correct_orig   always
    correct_prompt 'correct to (%e):'
  )

`correct' is what once was `COMPCORRECT'. `correct_orig' was `CCORIG'
and is more powerful now. If it's value contains `always', the
original string will always be offered (previously it was shown only
if there was more than one corrected string). Also, if it contains
`last', the original string will be the last one reached when cycling
through the strings. `correct_prompt' is the replacement for
`CCPROMPT' with one addition: the sequence `%e' in this string will be 
replaced by the number of errors that had to be accepted to generate
the corrected strings.

I decided against putting the name of the dump-file in it for two
reasons: to use it, one would have to do `typeset -A compconfig'
before sourcing `compinit' and after sourcing it, one would have to do 
several `compconfig[...]=...' instead of the convenient all-in-one
above. The first could be overcome by letting `compinit' take the name 
of the dump-file from `$1' if one was given. It would then store it in 
`compconfig' automatically. The second problem could be resolved by
using `compconfig=( "${(@kv)compconfig}" ...)', which would probably a 
wise thing to do anyway (if we find other uses for it later). Also, we 
could add a function `compconf' that stuffs its arguments in
`compconfig'. Hm, now that I think about it again, that sounds like a
better way. Any comments?

Anyway, other things we might want to do with `compconfig' include:

  - add `*style'-keys (or something like that) that can be used in
    completion functions to find out how they should do their job -- 
    some of Andrej's remarks made me think about this
  - this could also be used to find out in `_path_files' if the
    special code for menu-completion should always be used (or never)
  - when I was musing about whether `_path_files' should always try to 
    expand the beginning of the path, Jason suggested a behavior that
    does nothing on the first TAB, and expands the path on the second
    one; things like this might somehow be offered using settings in
    `compconfig', too

Ok, other ideas? (Even if not, at least it is a bit cleaner now.)

Bye
 Sven

diff -u -r oc/Core/_main_complete Completion/Core/_main_complete
--- oc/Core/_main_complete	Wed Mar 10 17:18:01 1999
+++ Completion/Core/_main_complete	Thu Mar 11 13:35:59 1999
@@ -3,34 +3,43 @@
 # The main loop of the completion code. This is what is called when 
 # completion is attempted from the command line.
 #
-# This code will automatically try to correct the string on the
-# line based on the strings generated for the context if the
-# parameter `COMPCORRECT' is set and normal completion didn't yield
-# any matches. These corrected strings will be shown in a list and
-# one can cycle through them as in a menucompletion. To use this 
-# feature, `COMPCORRECT' should be set to a number, specifying the
+# This code will automatically try to correct the string on the line
+# based on the strings generated for the context if
+# `compconfig[correct]' is set and normal completion didn't yield any
+# matches. These corrected strings will be shown in a list and one can
+#cycle through them as in a menucompletion. To use this feature,
+#`compconfig[correct]' should be set to a number, specifying the 
 # maximum number of errors that should be accepted. If the string also
 # contains a `n' or `N', the code will use the numeric argument as the
 # maximum number of errors if a numeric argument was given. If no
 # numeric argument was given, the number from the value of
-# `COMPCORRECT' will be used. E.g. with `COMPCORRECT=2n' two errors
-# will be accepted, but if the user gives another number with the
-# numeric argument, this will be prefered. Also, with `COMPCORRECT=0n',
-# normally no automatic correction will be tried, but if a numeric
-# argument is given, automatic correction will be used. Once the
-# number of errors to accept is determined, the code will repeatedly
-# try to generate matches by allowing one error, two errors, and so
-# on.
-# If the parameter `CCORIG' is set (independent of the value), the
-# line will first be left unchanged and consecutive TABs cycle through 
-# the list.
-# When using automatic correction, one can also set the parameter
-# `CCPROMPT' to a string that will be shown when multiple
-# correction results are displayed and the code starts cycling
-# through them (this string is used with the `-X' option and thus may
-# contain the control sequences `%n', `%B',...).
+# `compconfig[correct]' will be used. E.g. with `compconfig[correct]=2n'
+# two errors will be accepted, but if the user gives another number
+# with the numeric argument, this will be prefered. Also, with
+# `compconfig[correct]=0n',normally no automatic correction will be
+# tried, but if a numeric argument is given, automatic correction will
+# be used. Once the number of errors to accept is determined, the code
+# will repeatedly try to generate matches by allowing one error, two
+# errors, and so on.
+# The value of `compconfig[correct_orig]' is used to determine if the
+# original string should be included in the list (and thus be
+# presented to the user when cycling through the corrections). If it
+# is set to any non-empty value, the original string will be
+# offered. If it contains the sub-string `last', the original string
+# will apear as the last string when cycling through the corrections,
+# otherwise it will appear as the first one (so that the command line
+# does not change immediatly). Also, if the value of
+# `compconfig[correct_orig]' contains the sub-string `always', the
+# original string will always be included, whereas normally it is
+# included only if more than one possible correction was generated.
+# Finally, `compconfig[correct_prompt]' may be set to a string that
+# should be printed before the list of corrected strings when cycling
+# through them. This string may contain the control sequences `%n',
+# `%B', etc. known from the `-X' option of `compctl'. Also, the
+# sequence `%e' will be replaced by the number of errors accepted to
+# generate the corrected strings.
 
-local comp name _comp_correct comax
+local comp name _comp_correct _correct_prompt comax
 
 setopt localoptions nullglob rcexpandparam
 unsetopt markdirs globsubst shwordsplit nounset ksharrays
@@ -91,23 +100,27 @@
 
   # Use automatic correction?
 
-  if (( $+COMPCORRECT )); then
+  if (( $+compconfig[correct] )); then
 
     # Do we have matches?
     if (( compstate[nmatches] )); then
 
       # Yes, were they added using correction? (More than one match?)
 
-      if [[ -n "$_comp_correct" && compstate[nmatches] -gt 1 ]]; then
-
-        # If we got more than one string from correction, we add the 
-	# original string as a possible match, let it not be shown in
-	# the list, and probably display the `CCPROMPT'.
-
-        (( $+CCORIG )) && builtin compadd -nQ - "$PREFIX$SUFFIX"
+      if [[ -n "$_comp_correct" &&
+            ( "$compconfig[correct_orig]" = *always* ||
+	      compstate[nmatches] -gt 1 ) ]]; then
+
+        if [[ "$compconfig[correct_orig]" = *last* ]]; then
+	  builtin compadd -V _correct_orig -nQ - "$PREFIX$SUFFIX"
+        elif [[ -n "$compconfig[correct_orig]" ]]; then
+	  builtin compadd -nQ - "$PREFIX$SUFFIX"
+	fi
 
 	# If you always want to see the list of possible corrections,
 	# set `compstate[list]=list' here.
+
+	compstate[force_list]=list
       fi
       # Since we have matches, we don't want to try again.
       break
@@ -123,19 +136,21 @@
       [[ _comp_correct -eq comax ]] && break
       (( _comp_correct++ ))
 
+      _correct_prompt="${compconfig[correct_prompt]//\%e/$_comp_correct}"
+
     elif [[ compstate[matcher] -eq compstate[total_matchers] ]]; then
 
       # No matches and no correction tried yet, but we just tried the
       # last global match specification, so let's see if we should use
       # correction now. First, get the maximum number of errors.
 
-      if [[ "$COMPCORRECT" = *[nN]* && NUMERIC -ne 1 ]]; then
+      if [[ "$compconfig[correct]" = *[nN]* && NUMERIC -ne 1 ]]; then
         # Prefer the numeric argument if that has a sensible value.
         comax="$NUMERIC"
       else
-        comax="${COMPCORRECT//[^0-9]}"
+        comax="${compconfig[correct]//[^0-9]}"
       fi
-      # If the number of errors to accept is to small, give up.
+      # If the number of errors to accept is too small, give up.
 
       [[ "$comax" -lt 1 ]] && break
 
@@ -150,8 +165,8 @@
 	else
           PREFIX="(#a${_comp_correct})$PREFIX"
 	fi
-	if (( $+CCPROMPT )); then
-	  builtin compadd -X "$CCPROMPT" -J _correct "$@"
+	if [[ -n "$_correct_prompt" ]]; then
+	  builtin compadd -X "$_correct_prompt" -J _correct "$@"
 	else
 	  builtin compadd -J _correct "$@"
 	fi
@@ -162,8 +177,8 @@
 	else
           PREFIX="(#a${_comp_correct})$PREFIX"
 	fi
-	if (( $+CCPROMPT )); then
-	  builtin compgen "$@" -X "$CCPROMPT" -J _correct
+	if [[ -n "$_correct_prompt" ]]; then
+	  builtin compgen "$@" -X "$_correct_prompt" -J _correct
 	else
 	  builtin compgen "$@" -J _correct
 	fi
@@ -178,6 +193,8 @@
 
       _comp_correct=1
       compstate[matcher]=-1
+
+      _correct_prompt="${compconfig[correct_prompt]//\%e/$_comp_correct}"
 
       # We also need to set `extendedglob' and to make the completion
       # code behave as if globcomplete were set.
diff -u -r oc/Core/compinit Completion/Core/compinit
--- oc/Core/compinit	Wed Mar 10 17:18:01 1999
+++ Completion/Core/compinit	Thu Mar 11 13:43:15 1999
@@ -62,6 +62,10 @@
 typeset -A _comps
 _patcomps=()
 
+# This is the associative array used for configuration.
+
+typeset -A compconfig
+
 # This function is used to register or delete completion functions. For
 # registering completion functions, it is invoked with the name of the
 # function as it's first argument (after the options). The other

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

