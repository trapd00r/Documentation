From zsh-users-return-8092-mason-zsh=primenet.com.au@sunsite.dk Fri Oct 22 01:46:27 2004
Return-Path: <zsh-users-return-8092-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9689 invoked from network); 22 Oct 2004 01:46:26 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 22 Oct 2004 01:46:26 -0000
Received: (qmail 57844 invoked from network); 22 Oct 2004 01:46:20 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 22 Oct 2004 01:46:20 -0000
Received: (qmail 2846 invoked by alias); 22 Oct 2004 01:45:33 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 8092
Received: (qmail 2837 invoked from network); 22 Oct 2004 01:45:32 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 22 Oct 2004 01:45:32 -0000
Received: (qmail 56771 invoked from network); 22 Oct 2004 01:45:32 -0000
Received: from mxfep04.bredband.com (195.54.107.79)
  by a.mx.sunsite.dk with SMTP; 22 Oct 2004 01:45:30 -0000
Received: from puritan.pcp.ath.cx ([213.112.43.197] [213.112.43.197])
          by mxfep01.bredband.com with ESMTP
          id <20041021202237.RSFI18265.mxfep01.bredband.com@puritan.pcp.ath.cx>
          for <zsh-users@sunsite.dk>; Thu, 21 Oct 2004 22:22:37 +0200
Received: by puritan.pcp.ath.cx (Postfix, from userid 1000)
	id 22443AE041; Thu, 21 Oct 2004 22:22:40 +0200 (CEST)
Date: Thu, 21 Oct 2004 22:22:40 +0200
From: Nikolai Weibull <zsh-users-list@pcppopper.org>
To: zsh-users@sunsite.dk
Subject: Re: Associative Arrays
Message-ID: <20041021202240.GJ9224@puritan.pcp.ath.cx>
References: <20041020195348.GJ11322@puritan.pcp.ath.cx> <20041021110526.GE1740@frhdtmp102861.morse.corp.wan> <20041021123835.GF9224@puritan.pcp.ath.cx> <Pine.LNX.4.61.0410210900110.14956@toltec.zanshin.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <Pine.LNX.4.61.0410210900110.14956@toltec.zanshin.com>
User-Agent: Mutt/1.5.6i
X-Spam-Checker-Version: SpamAssassin 2.63 on a.mx.sunsite.dk
X-Spam-Level: *
X-Spam-Status: No, hits=1.5 required=6.0 tests=RCVD_IN_SORBS autolearn=no 
	version=2.63
X-Spam-Hits: 1.5

* Bart Schaefer <schaefer@brasslantern.com> [Oct 21, 2004 18:50]:
> Obviously one would be more likely to use it as ${(AA)=a:=foo bar}
> (note only one colon) where it assigns only if the hash is empty.

> > > > Is there any way to pass an associative array as ONE argument to
> > > > a function and easily deal with it as the same associative array
> > > > in the other function?

> I note in passing that this is not just an issue with associative
> arrays.  The shell language (not just zsh's language) in general lacks
> a way to truly pass by reference rather than by value.

> > > > The easiest way seems to be the "pass-by-reference" technique,
> > > > where one simply passes the name of the array and then use the P
> > > > flag to deal with it.

> That's one way.  Another way is simply to make use of dynamic scoping,
> so that the called function treats the variable as global, and the
> calling function restricts the scope when necessary.  Part of the
> function's API then becomes the name of the variable that it expects
> to manipulate.

Yes, precisely.  That's the way I implemented it.  I guess if elisp gets
away with it, then so should zsh.

> (This is one reason why ksh has "namerefs" so that you can explicitly
> alias two names to the same value, which is after all what happens
> implicitly in other languages when a call-by-reference parameter is
> passed.)

Mm.

> Or am I misreading the question?  Are you asking how to pass-by-value an
> associative array?

Either, or; whatever works.

> > > You could use "${${(@qqkv)A}[*]}"

> > > So that in the function you can have

> > > typeset -A local_hash
> > > local_hash=("${(Q@)${(z)1}}")

> > Aha, double quotation and then dequoting.  What a bitch...is this
> > seriously the simplest/only ways to do it?

> If you want to pass its entire value as a single positional parameter,
> that's pretty close to the only way.

OK.

> However, you have the entire set of positional parameters to play with.

> Think like a Perl programmer,

I try not to.

> and imagine you're trying to pass a set of name-value pairs as @_.
> You'd probably write something like

>  sub blather {
>    my $unnamed1 = shift;
>    my $unnamed2 = shift;
>    my %named = @_;
>    if ($named{'winnie'} eq 'pooh') { print "Oh, stuff and bother\n"; }
>  }

> So in zsh that'd be

>  function blather {
>    local unnamed1=$1; shift
>    local unnamed2=$2; shift
>    local -A named; set -A named "$@"
>    if [[ $named[winnie] = pooh ]]; then print "Oh, stuff and bother\n"; fi
>  }

> > I'd say that shell programming would be a lot simpler as a whole if this
> > was simpler.

> Hey, it's only been a few years now that shells have had associative
> arrays AT ALL.  Imagine what shell programming was like in the old days.

Yes, I know...scary stuff ;-).  Anyway, thanks for the tips.  The Perl
@_-like argument passing style might actually have its merrits,
	nikolai

--
::: name: Nikolai Weibull    :: aliases: pcp / lone-star / aka :::
::: born: Chicago, IL USA    :: loc atm: Gothenburg, Sweden    :::
::: page: www.pcppopper.org  :: fun atm: gf,lps,ruby,lisp,war3 :::
main(){printf(&linux["\021%six\012\0"],(linux)["have"]+"fun"-97);}

