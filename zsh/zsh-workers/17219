From zsh-workers-return-17219-mason-zsh=primenet.com.au@sunsite.dk Fri May 24 08:49:19 2002
Return-Path: <zsh-workers-return-17219-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2369 invoked from network); 24 May 2002 08:49:18 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 24 May 2002 08:49:18 -0000
Received: (qmail 17006 invoked by alias); 24 May 2002 08:49:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 17219
Received: (qmail 16995 invoked from network); 24 May 2002 08:49:03 -0000
From: Sven Wischnowsky <wischnow@berkom.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-ID: <15597.65133.916597.845112@wischnow.berkom.de>
Date: Fri, 24 May 2002 10:48:45 +0200
To: zsh-workers@sunsite.dk
Subject: Re: Menu-selection screen refresh slowness
In-Reply-To: <1020221153751.ZM2398@candle.brasslantern.com>
References: <20020221125435.59439.qmail@web9303.mail.yahoo.com>
	<1020221153751.ZM2398@candle.brasslantern.com>
X-Mailer: VM 6.95 under 21.5 (patch 3) "asparagus" XEmacs Lucid


Bart Schaefer wrote:

> On Feb 21, 12:54pm, Oliver Kiddle wrote:
> }
> } Every configuration item in pine can be used on the command line like a
> } normal option. [...]
> } 
> } As an aside, _pine could perhaps use two calls to _arguments so that
> } you can select between the two sets of options with a tag-order.
> 
> I was just trying out this completion while using ssh over my dialup PPP
> link, and I have to say that the screen refresh behavior of the menu-
> selection display is absolutely appalling.  It redraws the entire listing
> every time you move to a new selection -- which, on a mid-speed link with
> a completion listing that fills a 64-line xterm, means a full second or 
> more every time you press a cursor key.

Here is the (almost) promised patch for this. It makes the menu
selection code try to only re-display the previously and the newly
highlighted matches. Andrej, are you still using a dtterm? If yes, is
it bettern now?


Bye
  Sven

Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.46
diff -u -r1.46 complist.c
--- Src/Zle/complist.c	21 May 2002 08:07:51 -0000	1.46
+++ Src/Zle/complist.c	24 May 2002 08:34:20 -0000
@@ -392,7 +392,7 @@
 static int noselect, mselect, inselect, mcol, mline, mcols, mlines, mmlen;
 static int selected, mlbeg = -1, mlend = 9999999, mscroll, mrestlines;
 static int mnew, mlastcols, mlastlines, mhasstat, mfirstl, mlastm;
-static int mlprinted;
+static int mlprinted, molbeg = -2, mocol = 0, moline = 0, mstatprinted;
 static char *mstatus, *mlistp;
 static Cmatch **mtab, **mmtabp;
 static Cmgroup *mgtab, *mgtabp;
@@ -1304,6 +1304,7 @@
     }
     asked = 0;
  end:
+    mstatprinted = 0;
     lastlistlen = 0;
     if (nlnct <= 1)
 	mscroll = 0;
@@ -1317,6 +1318,7 @@
 		if (mhasstat) {
 		    putc('\n', shout);
 		    compprintfmt(NULL, 0, 1, 1, mline, NULL);
+                    mstatprinted = 1;
 		}
 		nl = lines - 1;
 	    } else
@@ -1494,6 +1496,79 @@
 }
 
 static int
+singlecalc(int *cp, int l, int *lcp)
+{
+    int c = *cp, n, j, first = 1;
+    Cmatch **p, *op, *mp = mtab[l * columns + c];
+
+    for (n = 0, j = c, p = mtab + l * columns + c, op = NULL; j >= 0; j--, p--) {
+        if (*p == mp)
+            c = j;
+        if (!first && *p != op)
+            n++;
+        op = *p;
+        first = 0;
+    }
+    *cp = c;
+    *lcp = 1;
+    for (p = mtab + l * columns + c; c < columns; c++, p++)
+        if (*p && mp != *p)
+            *lcp = 0;
+
+    return n;
+}
+
+static void
+singledraw()
+{
+    Cmgroup g;
+    int mc1, mc2, ml1, ml2, md1, md2, mcc1, mcc2, lc1, lc2, t1, t2;
+
+    t1 = mline - mlbeg;
+    t2 = moline - molbeg;
+
+    if (t2 < t1) {
+        mc1 = mocol; ml1 = moline; md1 = t2;
+        mc2 = mcol; ml2 = mline; md2 = t1;
+    } else {
+        mc1 = mcol; ml1 = mline; md1 = t1;
+        mc2 = mocol; ml2 = moline; md2 = t2;
+    }
+    mcc1 = singlecalc(&mc1, ml1, &lc1);
+    mcc2 = singlecalc(&mc2, ml2, &lc2);
+
+    if (md1)
+        tcmultout(TCDOWN, TCMULTDOWN, md1);
+    if (mc1)
+        tcmultout(TCRIGHT, TCMULTRIGHT, mc1);
+    g = mgtab[ml1 * columns + mc1];
+    clprintm(g, mtab[ml1 * columns + mc1], mcc1, ml1, lc1,
+             (g->widths ? g->widths[mcc1] : g->width));
+    putc('\r', shout);
+
+    if (md2 != md1)
+        tcmultout(TCDOWN, TCMULTDOWN, md2 - md1);
+    if (mc2)
+        tcmultout(TCRIGHT, TCMULTRIGHT, mc2);
+    g = mgtab[ml2 * columns + mc2];
+    clprintm(g, mtab[ml2 * columns + mc2], mcc2, ml2, lc2,
+             (g->widths ? g->widths[mcc2] : g->width));
+    putc('\r', shout);
+
+    if (mstatprinted) {
+        int i = lines - md2 - nlnct;
+
+        tcmultout(TCDOWN, TCMULTDOWN, i - 1);
+        compprintfmt(NULL, 0, 1, 1, mline, NULL);
+        tcmultout(TCUP, TCMULTUP, lines - 1);
+    } else
+        tcmultout(TCUP, TCMULTUP, md2 + nlnct);
+
+    showinglist = -1;
+    listshown = 1;
+}
+
+static int
 complistmatches(Hookdef dummy, Chdata dat)
 {
     Cmgroup oamatches = amatches;
@@ -1575,9 +1650,15 @@
     last_cap = (char *) zhalloc(max_caplen + 1);
     *last_cap = '\0';
 
-    if (!compprintlist(mselect >= 0) || !clearflag)
+    if (mlbeg >= 0 && mlbeg == molbeg)
+        singledraw();
+    else if (!compprintlist(mselect >= 0) || !clearflag)
 	noselect = 1;
 
+    molbeg = mlbeg;
+    mocol = mcol;
+    moline = mline;
+
     amatches = oamatches;
 
     return noselect;
@@ -1678,6 +1759,7 @@
     mline = 0;
     mlines = 999999;
     mlbeg = 0;
+    molbeg = -42;
     for (;;) {
 	if (mline < 0) {
 	    int x, y;
@@ -1730,17 +1812,17 @@
 	    }
 	}
 	lbeg = mlbeg;
-	onlyexpl = 0;
-	showinglist = -2;
-	if (first && !listshown && isset(LISTBEEP))
-	    zbeep();
-	first = 0;
-	zrefresh();
-	inselect = 1;
-	if (noselect) {
-	    broken = 1;
-	    break;
-	}
+        onlyexpl = 0;
+        showinglist = -2;
+        if (first && !listshown && isset(LISTBEEP))
+            zbeep();
+        first = 0;
+        zrefresh();
+        inselect = 1;
+        if (noselect) {
+            broken = 1;
+            break;
+        }
 	selected = 1;
 	if (!i) {
 	    i = mcols * mlines;
@@ -1770,6 +1852,7 @@
 
 	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
 	    zbeep();
+            molbeg = -1;
 	    break;
 	} else if (nolist && cmd != Th(z_undo)) {
 	    ungetkeycmd();

-- 
Sven Wischnowsky                          wischnow@berkom.de

