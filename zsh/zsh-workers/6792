From zsh-workers-return-6792-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jun 23 05:09:52 1999
Return-Path: <zsh-workers-return-6792-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6104 invoked from network); 23 Jun 1999 05:09:51 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Jun 1999 05:09:51 -0000
Received: (qmail 13801 invoked by alias); 23 Jun 1999 05:09:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6792
Received: (qmail 13794 invoked from network); 23 Jun 1999 05:09:35 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <990623050925.ZM31030@candle.brasslantern.com>
Date: Wed, 23 Jun 1999 05:09:25 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: More about ${(A)param=} and some stuff about subst.c
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

I've been staring at this some more ... consider:

zsh% : ${(A)=arr1=foo bar}
zsh% echo $#arr1
2
zsh% : ${(A)=arr2="foo bar"}
zsh% echo $#arr2
2

Now, why is it that the quotes in the arr2 case didn't make any difference
at all?  Is it really right that they shouldn't?  And:

zsh% : ${(A)arr3=foo "bar baz"}
zsh% echo $#arr3 $arr3
1 foo bar baz

It's true that this is the same behavior as far back as at least 3.0.0 (I
no longer have any older binaries around) but it seems a bit strange when
I think about it.  Either the quotes should mean something, or they should
not get stripped out.

So I went tracing through the way that the code gets here.  The relevant
bit starts at about line 1308 of subst.c; it first calls multsub(), then
if either shwordsplit or the (s) flag was present it calls sepsplit().  So
the only way to assign a "real" array in this construct is to be sure that
shwordsplit is off and place an expansion on the RHS of the `=' that will
yield an array out of multsub().

That led me into multsub(), which has had a bit of pounding recently; but
this one thing has been unchanged since 3.0.0:  as far as I can tell, the
`sep' parameter of multsub() isn't used at all.  It would appear from the
comment above the function that it is supposed to be passed on to sepjoin()
when `if (a && mult_isarr)' is false, but that's not done -- which may be
just as well because in the one case when something non-NULL is given to
multsub() in that parameter, I'm not sure that it's the right thing.

Another question is whether glob_assign should apply:

zsh% setopt globassign
zsh% : ${(A)arr4=*}
zsh% echo $arr4
*
zsh% : ${(A)~arr5=*}
zsh% echo $arr5
*

Which brings me finally to ${(A)param=}, the original problem.  As long as
quotes don't matter in the RHS for other purposes, I don't like the idea
of special-casing that instance to create an empty array.  So it *could*
be fixed to treat any empty string returned from multsub() as creating an
empty array; thus ${(A)param=''} would also create an empty array.  Other
solutions might be possible, but not without cleaning up the rest of these
issues too.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

