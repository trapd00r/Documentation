From zsh-workers-return-20854-mason-zsh=primenet.com.au@sunsite.dk Wed Feb 23 13:06:24 2005
Return-Path: <zsh-workers-return-20854-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5516 invoked from network); 23 Feb 2005 13:06:22 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 23 Feb 2005 13:06:22 -0000
Received: (qmail 76880 invoked from network); 23 Feb 2005 13:06:14 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 23 Feb 2005 13:06:14 -0000
Received: (qmail 19676 invoked by alias); 23 Feb 2005 13:06:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 20854
Received: (qmail 19662 invoked from network); 23 Feb 2005 13:06:07 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 23 Feb 2005 13:06:07 -0000
Received: (qmail 76574 invoked from network); 23 Feb 2005 13:06:07 -0000
Received: from mailhost1.csr.com (HELO MAILSWEEPER01.csr.com) (81.105.217.43)
  by a.mx.sunsite.dk with SMTP; 23 Feb 2005 13:05:53 -0000
Received: from exchange03.csr.com (unverified [10.100.137.60]) by MAILSWEEPER01.csr.com
 (Content Technologies SMTPRS 4.3.12) with ESMTP id <T6f4bba344c0a6c8d018f0@MAILSWEEPER01.csr.com> for <zsh-workers@sunsite.dk>;
 Wed, 23 Feb 2005 13:04:24 +0000
Received: from news01.csr.com ([10.103.143.38]) by exchange03.csr.com with Microsoft SMTPSVC(5.0.2195.6713);
	 Wed, 23 Feb 2005 13:06:48 +0000
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.1/8.12.11) with ESMTP id j1ND5pb1030163
	for <zsh-workers@sunsite.dk>; Wed, 23 Feb 2005 13:05:51 GMT
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.1/8.13.1/Submit) with ESMTP id j1ND5p6F030160
	for <zsh-workers@sunsite.dk>; Wed, 23 Feb 2005 13:05:51 GMT
Message-Id: <200502231305.j1ND5p6F030160@news01.csr.com>
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: more zle fixes
Date: Wed, 23 Feb 2005 13:05:50 +0000
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 23 Feb 2005 13:06:48.0448 (UTC) FILETIME=[8874C000:01C519A8]
X-Spam-Checker-Version: SpamAssassin 3.0.2 on a.mx.sunsite.dk
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=6.0 tests=AWL,BAYES_00 autolearn=ham 
	version=3.0.2
X-Spam-Hits: -2.5

This patch fixes up a small number of the zillion inconsistencies in the
Unicode support.  It doesn't go anywhere near zle_refresh.c.  There are
still many holes but I'm trying to do this in small chunks to avoid
causing problems for other people.

Andrej's ZWC macro is now in place.

Next...

vichgbuf still needs rationalising.

execute-named-command needs fixing.  The difficulty is that it maintains
a multibyte string for immediate display, but this makes it hard to
backup characters.  I think we'll end up with both the multibyte string
and the wide character array.

The completion system is almost untouched.  Luckily, there are already
the functions metafy_line and unmetafy_line.  Currently these operation
on zleline in place; clearly this should go into a separate character
buffer.  Then all references to zleline need to be picked up.  The weird
interaction between the completion system and the main shell is another
complication.

Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.64
diff -u -r1.64 complist.c
--- Src/Zle/complist.c	18 Feb 2005 13:57:27 -0000	1.64
+++ Src/Zle/complist.c	23 Feb 2005 12:55:24 -0000
@@ -1861,7 +1861,11 @@
 static Cmatch **
 msearch(Cmatch **ptr, int ins, int back, int rep, int *wrapp)
 {
+#ifdef ZLE_UNICODE_SUPPORT
+    char s[MB_CUR_MAX+1];
+#else
     char s[2];
+#endif
     Cmatch **p, *l = NULL, m;
     int x = mcol, y = mline;
     int ex, ey, wrap = 0, owrap = (msearchstate & MS_WRAPPED);
@@ -1869,12 +1873,19 @@
     msearchpush(ptr, back);
 
     if (ins) {
-	/*
-	 * TODO: probably need to convert back to multibyte character
-	 * string?  Who knows...
-	 */
-        s[0] = lastchar;
-        s[1] = '\0';
+#ifdef ZLE_UNICODE_SUPPORT
+	if (lastchar_wide_valid)
+	{
+	    int len = wctomb(s, lastchar_wide);
+	    if (len < 0)
+		len = 0;
+	    s[len] = '\0';
+	} else
+#endif
+	{
+	    s[0] = lastchar;
+	    s[1] = '\0';
+	}
 
         msearchstr = dyncat(msearchstr, s);
     }
Index: Src/Zle/zle.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle.h,v
retrieving revision 1.9
diff -u -r1.9 zle.h
--- Src/Zle/zle.h	22 Feb 2005 13:13:05 -0000	1.9
+++ Src/Zle/zle.h	23 Feb 2005 12:55:25 -0000
@@ -44,21 +44,9 @@
 #define MB_CUR_MAX 6
 #endif
 
-#define ZLENL	L'\n'
-#define ZLENUL	L'\0'
-#define ZLETAB	L'\t'
-#define ZLESPC	L' '
-
-#define DIGIT_1		L'1'
-#define DIGIT_9		L'9'
-#define LETTER_a	L'a'
-#define LETTER_z	L'z'
-#define LETTER_A	L'A'
-#define LETTER_Z	L'Z'
-#define LETTER_y	L'y'
-#define LETTER_n	L'n'
+/* Convert character or string to wide character or string */
+#define ZWC(c)	L ## c
 
-#define ZLENULSTR	L""
 #define ZLEEOF	WEOF
 #define ZS_memcpy wmemcpy
 #define ZS_memmove wmemmove
@@ -73,21 +61,9 @@
 typedef int ZLE_INT_T;
 #define ZLE_CHAR_SIZE	sizeof(unsigned char)
 
-#define ZLENL	'\n'
-#define ZLENUL	'\0'
-#define ZLETAB	'\t'
-#define ZLESPC	' '
-
-#define DIGIT_1		'1'
-#define DIGIT_9		'9'
-#define LETTER_a	'a'
-#define LETTER_z	'z'
-#define LETTER_A	'A'
-#define LETTER_Z	'Z'
-#define LETTER_y	'y'
-#define LETTER_n	'n'
+/* Leave character or string as is */
+#define ZWC(c)	c
 
-#define ZLENULSTR	""
 #define ZLEEOF	EOF
 #define ZS_memcpy memcpy
 #define ZS_memmove memmove
Index: Src/Zle/zle_hist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_hist.c,v
retrieving revision 1.18
diff -u -r1.18 zle_hist.c
--- Src/Zle/zle_hist.c	18 Feb 2005 13:57:28 -0000	1.18
+++ Src/Zle/zle_hist.c	23 Feb 2005 12:55:25 -0000
@@ -614,11 +614,11 @@
 
     if (n < 0)
 	return 1;
-    zpushnode(bufstack, metafy((char *) zleline, zlell, META_DUP));
+    zpushnode(bufstack, zlelineasstring(zleline, zlell, 0, NULL, NULL, 0));
     while (--n)
 	zpushnode(bufstack, ztrdup(""));
     stackcs = zlecs;
-    *zleline = '\0';
+    *zleline = ZWC('\0');
     zlell = zlecs = 0;
     clearlist = 1;
     return 0;
@@ -629,19 +629,23 @@
 pushlineoredit(char **args)
 {
     int ics, ret;
-    unsigned char *s;
+    ZLE_STRING_T s;
     char *hline = hgetline();
 
     if (zmult < 0)
 	return 1;
     if (hline && *hline) {
-	ics = ztrlen(hline);
+	ZLE_STRING_T zhline = stringaszleline((unsigned char *)hline,
+					      &ics, NULL);
+
 	sizeline(ics + zlell + 1);
-	for (s = zleline + zlell; --s >= zleline; *(s + ics) = *s);
-	for (s = zleline; *hline; hline++)
-	    *s++ = *hline == Meta ? *++hline ^ 32 : *hline;
+	/* careful of overlapping copy */
+	for (s = zleline + zlell; --s >= zleline; s[ics] = *s)
+	    ;
+	ZS_memcpy(zleline, zhline, ics);
 	zlell += ics;
 	zlecs += ics;
+	free(zhline);
     }
     ret = pushline(args);
     if (!isfirstln)
@@ -669,18 +673,19 @@
 int
 zgetline(UNUSED(char **args))
 {
-    char *s = (char *)getlinknode(bufstack);
+    unsigned char *s = (unsigned char *)getlinknode(bufstack);
 
     if (!s) {
 	return 1;
     } else {
 	int cc;
+	ZLE_STRING_T lineadd = stringaszleline(s, &cc, NULL);
 
-	unmetafy(s, &cc);
 	spaceinline(cc);
-	memcpy((char *)zleline + zlecs, s, cc);
+	ZS_memcpy(zleline + zlecs, lineadd, cc);
 	zlecs += cc;
 	free(s);
+	free(lineadd);
 	clearlist = 1;
     }
     return 0;
@@ -940,7 +945,11 @@
 	    skip_pos = 1;
 	rpt:
 	    if (!sbptr && previous_search_len) {
-		if (previous_search_len > sibuf - FIRST_SEARCH_CHAR - 2) {
+		if (previous_search_len > sibuf - FIRST_SEARCH_CHAR - 2
+#ifdef ZLE_UNICODE_SUPPORT
+		    - MB_CUR_MAX
+#endif
+		    ) {
 		    ibuf = hrealloc(ibuf, sibuf, sibuf + previous_search_len);
 		    sbuf = ibuf + FIRST_SEARCH_CHAR;
 		    sibuf += previous_search_len;
@@ -983,14 +992,28 @@
 		continue;
 	    }
 	    set_isrch_spot(top_spot++, hl, pos, zlecs, sbptr, dir, nomatch);
-	    if (sbptr == sibuf - FIRST_SEARCH_CHAR - 2) {
+	    if (sbptr >= sibuf - FIRST_SEARCH_CHAR - 2
+#ifdef ZLE_UNICODE_SUPPORT
+		- MB_CUR_MAX
+#endif
+		) {
 		ibuf = hrealloc(ibuf, sibuf, sibuf * 2);
 		sbuf = ibuf + FIRST_SEARCH_CHAR;
 		sibuf *= 2;
 	    }
-	    /* TODO: use lastchar_wide if available, convert back to
-	     * multibyte string.  Yuk.  */
+#ifdef ZLE_UNICODE_SUPPORT
+	    /*
+	     * We've supposedly arranged above that lastchar_wide is
+	     * always valid at this point.
+	     */
+	    {
+		int len = wctomb(sbuf + sbptr, lastchar_wide);
+		if (len > 0)
+		    sbptr += len;
+	    }
+#else
 	    sbuf[sbptr++] = lastchar;
+#endif
 	}
 	if (feep)
 	    handlefeep(zlenoargs);
@@ -1160,8 +1183,15 @@
 		strcpy(newbuf, sbuf);
 		statusline = sbuf = newbuf;
 	    }
-	    /* TODO: may be wide char, convert back to multibyte string */
+#ifdef ZLE_UNICODE_SUPPORT
+	    {
+		int len = wctomb(sbuf + sptr, lastchar_wide);
+		if (len > 0)
+		    sptr += len;
+	    }
+#else
 	    sbuf[sptr++] = lastchar;
+#endif
 	} else {
 	    feep = 1;
 	}
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.61
diff -u -r1.61 zle_main.c
--- Src/Zle/zle_main.c	22 Feb 2005 21:37:00 -0000	1.61
+++ Src/Zle/zle_main.c	23 Feb 2005 12:55:25 -0000
@@ -717,8 +717,6 @@
 
 /*
  * Get a full character rather than just a single byte.
- * (TODO: Strictly we ought to call this getbyte and the above
- * function getbyte.)
  */
 
 /**/
@@ -778,6 +776,8 @@
 
 	/* No timeout here as we really need the character. */
 	inchar = getbyte(0);
+	/* getbyte deliberately resets lastchar_wide_valid */
+	lastchar_wide_valid = 1;
 	if (inchar == EOF)
 	    return lastchar_wide = WEOF;
 	c = inchar;
@@ -833,7 +833,7 @@
 	    handleprefixes();
 	    /* for vi mode, make sure the cursor isn't somewhere illegal */
 	    if (invicmdmode() && zlecs > findbol() &&
-		(zlecs == zlell || zleline[zlecs] == ZLENL))
+		(zlecs == zlell || zleline[zlecs] == ZWC('\n')))
 		zlecs--;
 	    if (undoing)
 		handleundo();
@@ -934,7 +934,7 @@
     histline = curhist;
     undoing = 1;
     zleline = (unsigned char *)zalloc(((linesz = 256) + 2) * ZLE_CHAR_SIZE);
-    *zleline = ZLENUL;
+    *zleline = ZWC('\0');
     virangeflag = lastcmd = done = zlecs = zlell = mark = 0;
     vichgflag = 0;
     viinsbegin = 0;
@@ -993,7 +993,7 @@
     if (eofsent) {
 	s = NULL;
     } else {
-	zleline[zlell++] = ZLENL;
+	zleline[zlell++] = ZWC('\n');
 	s = zlegetline(NULL, NULL);
     }
     free(zleline);
Index: Src/Zle/zle_misc.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_misc.c,v
retrieving revision 1.17
diff -u -r1.17 zle_misc.c
--- Src/Zle/zle_misc.c	22 Feb 2005 13:13:06 -0000	1.17
+++ Src/Zle/zle_misc.c	23 Feb 2005 12:55:25 -0000
@@ -294,7 +294,7 @@
 int
 acceptandhold(UNUSED(char **args))
 {
-    zpushnode(bufstack, metafy((char *)zleline, zlell, META_DUP));
+    zpushnode(bufstack, zlelineasstring(zleline, zlell, 0, NULL, NULL, 0));
     stackcs = zlecs;
     done = 1;
     return 0;
@@ -314,10 +314,10 @@
 	return ret;
     }
     while (n--) {
-	if (zleline[zlecs] == '\n')
+	if (zleline[zlecs] == ZWC('\n'))
 	    zlecs++, i++;
 	else
-	    while (zlecs != zlell && zleline[zlecs] != '\n')
+	    while (zlecs != zlell && zleline[zlecs] != ZWC('\n'))
 		zlecs++, i++;
     }
     backkill(i, 0);
@@ -378,8 +378,7 @@
     while (n--) {
 	kct = -1;
 	spaceinline(kctbuf->len);
-	memcpy((char *)(zleline + zlecs), (char *)kctbuf->buf,
-	       kctbuf->len * ZLE_CHAR_SIZE);
+	ZS_memcpy(zleline + zlecs, kctbuf->buf, kctbuf->len);
 	zlecs += kctbuf->len;
 	yanke = zlecs;
     }
@@ -433,13 +432,13 @@
 	 *    was full, we could loop round and round it, otherwise
 	 *    we just stopped when we hit the first empty buffer.
 	 */
-    } while (!buf->buf || *buf->buf == ZLENUL);
+    } while (!buf->buf || *buf->buf == ZWC('\0'));
 
     zlecs = yankb;
     foredel(yanke - yankb);
     cc = buf->len;
     spaceinline(cc);
-    memcpy((char *)(zleline + zlecs), (char *)buf->buf, cc * ZLE_CHAR_SIZE);
+    ZS_memcpy(zleline + zlecs, buf->buf, cc);
     zlecs += cc;
     yanke = zlecs;
     return 0;
@@ -458,32 +457,35 @@
 whatcursorposition(UNUSED(char **args))
 {
     char msg[100];
-    char *s = msg;
-    int bol = findbol();
-    int c = STOUC(zleline[zlecs]);
+    char *s = msg, *mbstr;
+    int bol = findbol(), len;
+    ZLE_CHAR_T c = zleline[zlecs];
 
     if (zlecs == zlell)
 	strucpy(&s, "EOF");
     else {
 	strucpy(&s, "Char: ");
 	switch (c) {
-	case ' ':
+	case ZWC(' '):
 	    strucpy(&s, "SPC");
 	    break;
-	case '\t':
+	case ZWC('\t'):
 	    strucpy(&s, "TAB");
 	    break;
-	case '\n':
+	case ZWC('\n'):
 	    strucpy(&s, "LFD");
 	    break;
 	default:
-	    if (imeta(c)) {
-		*s++ = Meta;
-		*s++ = c ^ 32;
-	    } else
-		*s++ = c;
+	    /*
+	     * convert a single character, remembering it may
+	     * turn into a multibyte string or be metafied.
+	     */
+	    mbstr = zlelineasstring(zleline+zlecs, 1, 0, &len, NULL, 1);
+	    strcpy(s, mbstr);
+	    s += len;
 	}
-	sprintf(s, " (0%o, %d, 0x%x)", c, c, c);
+	sprintf(s, " (0%o, %u, 0x%x)", (unsigned int)c,
+		(unsigned int)c, (unsigned int)c);
 	s += strlen(s);
     }
     sprintf(s, "  point %d of %d(%d%%)  column %d", zlecs+1, zlell+1,
@@ -629,7 +631,7 @@
 	t0++;
     len = zlecs - t0;
     spaceinline(len);
-    memcpy((char *)&zleline[zlecs], (char *)&zleline[t0], len);
+    ZS_memcpy(zleline + zlecs, zleline + t0, len);
     zlecs += len;
     return 0;
 }
@@ -641,21 +643,24 @@
     LinkList l;
     LinkNode n;
     int i;
-    char *p = NULL;
+    unsigned char *p = NULL;
 
     if ((l = bufferwords(NULL, NULL, &i)))
         for (n = firstnode(l); n; incnode(n))
             if (!i--) {
-                p = getdata(n);
+                p = (unsigned char *)getdata(n);
                 break;
             }
 
     if (p) {
-	int len = strlen(p);
+	int len;
+	ZLE_STRING_T lineadd = stringaszleline(p, &len, NULL);
 
 	spaceinline(len);
-	memcpy(zleline + zlecs, p, len);
+	ZS_memcpy(zleline + zlecs, lineadd, len);
 	zlecs += len;
+
+	free(lineadd);
     }
     return 0;
 }
@@ -672,7 +677,7 @@
 int
 quoteregion(UNUSED(char **args))
 {
-    char *str;
+    ZLE_STRING_T str;
     size_t len;
 
     if (mark > zlell)
@@ -682,12 +687,12 @@
 	mark = zlecs;
 	zlecs = tmp;
     }
-    str = (char *)hcalloc(len = mark - zlecs);
-    memcpy(str, (char *)&zleline[zlecs], len);
+    str = (ZLE_STRING_T)hcalloc((len = mark - zlecs) * ZLE_CHAR_SIZE);
+    ZS_memcpy(str, zleline + zlecs, len);
     foredel(len);
     str = makequote(str, &len);
     spaceinline(len);
-    memcpy((char *)&zleline[zlecs], str, len);
+    ZS_memcpy(zleline + zlecs, str, len);
     mark = zlecs;
     zlecs += len;
     return 0;
@@ -697,39 +702,39 @@
 int
 quoteline(UNUSED(char **args))
 {
-    char *str;
+    ZLE_STRING_T str;
     size_t len = zlell;
 
-    str = makequote((char *)zleline, &len);
+    str = makequote(zleline, &len);
     sizeline(len);
-    memcpy(zleline, str, len);
+    ZS_memcpy(zleline, str, len);
     zlecs = zlell = len;
     return 0;
 }
 
 /**/
-static char *
-makequote(char *str, size_t *len)
+static ZLE_STRING_T
+makequote(ZLE_STRING_T str, size_t *len)
 {
     int qtct = 0;
-    char *l, *ol;
-    char *end = str + *len;
+    ZLE_STRING_T l, ol;
+    ZLE_STRING_T end = str + *len;
 
     for (l = str; l < end; l++)
-	if (*l == '\'')
+	if (*l == ZWC('\''))
 	    qtct++;
     *len += 2 + qtct*3;
-    l = ol = (char *)zhalloc(*len);
-    *l++ = '\'';
+    l = ol = (char *)zhalloc(*len * ZLE_CHAR_SIZE);
+    *l++ = ZWC('\'');
     for (; str < end; str++)
-	if (*str == '\'') {
-	    *l++ = '\'';
-	    *l++ = '\\';
-	    *l++ = '\'';
-	    *l++ = '\'';
+	if (*str == ZWC('\'')) {
+	    *l++ = ZWC('\'');
+	    *l++ = ZWC('\\');
+	    *l++ = ZWC('\'');
+	    *l++ = ZWC('\'');
 	} else
 	    *l++ = *str;
-    *l++ = '\'';
+    *l++ = ZWC('\'');
     return ol;
 }
 
Index: Src/Zle/zle_move.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_move.c,v
retrieving revision 1.5
diff -u -r1.5 zle_move.c
--- Src/Zle/zle_move.c	18 Feb 2005 13:57:28 -0000	1.5
+++ Src/Zle/zle_move.c	23 Feb 2005 12:55:25 -0000
@@ -469,9 +469,9 @@
     ZLE_INT_T ch;
 
     ch = getfullchar(0);
-    if (ch < LETTER_a || ch > LETTER_z)
+    if (ch < ZWC('a') || ch > ZWC('z'))
 	return 1;
-    ch -= LETTER_a;
+    ch -= ZWC('a');
     vimarkcs[ch] = zlecs;
     vimarkline[ch] = histline;
     return 0;
@@ -487,9 +487,9 @@
     if (ch == LASTFULLCHAR)
 	ch = 26;
     else {
-	if (ch < LETTER_a || ch > LETTER_z)
+	if (ch < ZWC('a') || ch > ZWC('z'))
 	    return 1;
-	ch -= LETTER_a;
+	ch -= ZWC('a');
     }
     if (!vimarkline[ch])
 	return 1;
Index: Src/Zle/zle_params.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_params.c,v
retrieving revision 1.23
diff -u -r1.23 zle_params.c
--- Src/Zle/zle_params.c	26 Jan 2005 18:37:32 -0000	1.23
+++ Src/Zle/zle_params.c	23 Feb 2005 12:55:25 -0000
@@ -237,10 +237,10 @@
     ZLE_STRING_T y;
     int len;
 
-    if (x && *x != ZLENUL)
+    if (x && *x != ZWC('\0'))
 	y = stringaszleline((unsigned char *)x, &len, NULL);
     else
-	y = ZLENULSTR, len = 0;
+	y = ZWC(""), len = 0;
     sizeline(zlell - zlecs + len);
     ZS_memmove(zleline + len, zleline + zlecs, zlell - zlecs);
     ZS_memcpy(zleline, y, len);
@@ -267,10 +267,10 @@
     char *y;
     int len;
 
-    if (x && *x != ZLENUL)
+    if (x && *x != ZWC('\0'))
 	y = stringaszleline((unsigned char *)x, &len, NULL);
     else
-	y = ZLENULSTR, len = 0;
+	y = ZWC(""), len = 0;
     sizeline(zlell = zlecs + len);
     ZS_memcpy(zleline + zlecs, y, len);
     zsfree(x);
Index: Src/Zle/zle_refresh.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_refresh.c,v
retrieving revision 1.17
diff -u -r1.17 zle_refresh.c
--- Src/Zle/zle_refresh.c	26 Jan 2005 18:12:18 -0000	1.17
+++ Src/Zle/zle_refresh.c	23 Feb 2005 12:55:25 -0000
@@ -459,10 +459,10 @@
 	if (t == scs)			/* if cursor is here, remember it */
 	    nvcs = s - (unsigned char *)(nbuf[nvln = ln]);
 
-	if (*t == ZLENL){		/* newline */
+	if (*t == ZWC('\n')){		/* newline */
 	    nbuf[ln][winw + 1] = '\0';	/* text not wrapped */
 	    nextline
-	} else if (*t == ZLETAB) {		/* tab */
+	} else if (*t == ZWC('\t')) {		/* tab */
 	    t0 = (char *)s - nbuf[ln];
 	    if ((t0 | 7) + 1 >= winw) {
 		nbuf[ln][winw + 1] = '\n';	/* text wrapped */
Index: Src/Zle/zle_tricky.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_tricky.c,v
retrieving revision 1.50
diff -u -r1.50 zle_tricky.c
--- Src/Zle/zle_tricky.c	22 Feb 2005 13:13:06 -0000	1.50
+++ Src/Zle/zle_tricky.c	23 Feb 2005 12:55:25 -0000
@@ -163,8 +163,8 @@
 
     if (keybuf[0] != '\t' || keybuf[1])
 	return 0;
-    for (; s >= zleline && *s != ZLENL; s--)
-	if (*s != ZLETAB && *s != ZLESPC)
+    for (; s >= zleline && *s != ZWC('\n'); s--)
+	if (*s != ZWC('\t') && *s != ZWC(' '))
 	    return 0;
     if (compfunc) {
 	wouldinstab = 1;
@@ -582,6 +582,15 @@
 	active = 0;
 	return 0;
     }
+
+    /*
+     * TODO: metafy_line() currently tries to metafy in place.
+     * For ZLE_UNICODE_SUPPORT we need to metafy into a separate
+     * string, replacing all use of zleline, zlecs and zlell here
+     * with those values, then restoring at the end.
+     *
+     * The alternative is probably too horrendous to contemplate.
+     */
     metafy_line();
 
     ocs = zlecs;
Index: Src/Zle/zle_utils.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_utils.c,v
retrieving revision 1.20
diff -u -r1.20 zle_utils.c
--- Src/Zle/zle_utils.c	22 Feb 2005 21:37:01 -0000	1.20
+++ Src/Zle/zle_utils.c	23 Feb 2005 12:55:25 -0000
@@ -94,11 +94,17 @@
 /*
  * Input a line in internal zle format, possibly using wide characters,
  * possibly not, together with its length and the cursor position.
- * Output an ordinary string, using multibyte characters instead of wide
- * characters where appropriate and with the contents metafied.
+ * The length must be accurate and includes all characters (no NULL
+ * termination is expected).  The input cursor position is only
+ * significant if outcs is non-NULL.
+ *
+ * Output an ordinary NULL-terminated string, using multibyte characters
+ * instead of wide characters where appropriate and with the contents
+ * metafied.
  *
  * If outll is non-NULL, assign the new length.  If outcs is non-NULL,
- * assign the new character position.
+ * assign the new character position.  This is the conventional string
+ * length, without the NULL byte.
  *
  * If useheap is 1, memory is returned from the heap, else is allocated
  * for later freeing.
@@ -200,12 +206,10 @@
 
 #ifdef ZLE_UNICODE_SUPPORT
     if (ll) {
-	/* reset shift state by converting null. */
-	/* char cnull = '\0'; */
 	char *inptr = (char *)instr;
 	wchar_t *outptr = outstr;
 
-	/* mbrtowc(outstr, &cnull, 1, &ps); */
+	/* Reset shift state to input complete string */
 	memset(&ps, '\0', sizeof(ps));
 
 	while (ll) {
@@ -268,7 +272,7 @@
     for (i = zlell; --i >= zlecs;)
 	zleline[i + ct] = zleline[i];
     zlell += ct;
-    zleline[zlell] = ZLENUL;
+    zleline[zlell] = ZWC('\0');
 
     if (mark > zlecs)
 	mark += ct;
@@ -287,7 +291,7 @@
 	zleline[to] = zleline[to + cnt];
 	to++;
     }
-    zleline[zlell = to] = ZLENUL;
+    zleline[zlell = to] = ZWC('\0');
 }
 
 /**/
@@ -323,7 +327,7 @@
 	if (!(zmod.flags & MOD_VIAPP) || !b->buf) {
 	    free(b->buf);
 	    b->buf = (ZLE_STRING_T)zalloc(ct * ZLE_CHAR_SIZE);
-	    memcpy((char *)b->buf, (char *)(zleline + i), ct * ZLE_CHAR_SIZE);
+	    ZS_memcpy(b->buf, zleline + i, ct);
 	    b->len = ct;
 	    b->flags = vilinerange ? CUTBUFFER_LINE : 0;
 	} else {
@@ -336,9 +340,8 @@
 			(ct + len + !!(b->flags & CUTBUFFER_LINE))
 			* ZLE_CHAR_SIZE);
 	    if (b->flags & CUTBUFFER_LINE)
-		b->buf[len++] = ZLENL;
-	    memcpy((char *)(b->buf + len), (char *)(zleline + i),
-		   ct * ZLE_CHAR_SIZE);
+		b->buf[len++] = ZWC('\n');
+	    ZS_memcpy(b->buf + len, zleline + i, ct);
 	    b->len = len + ct;
 	}
 	return;
@@ -349,14 +352,13 @@
 	for(n=34; n>26; n--)
 	    vibuf[n] = vibuf[n-1];
 	vibuf[26].buf = (ZLE_STRING_T)zalloc(ct * ZLE_CHAR_SIZE);
-	memcpy((char *)vibuf[26].buf, (char *)(zleline + i),
-	       ct * ZLE_CHAR_SIZE);
+	ZS_memcpy(vibuf[26].buf, zleline + i, ct);
 	vibuf[26].len = ct;
 	vibuf[26].flags = vilinerange ? CUTBUFFER_LINE : 0;
     }
     if (!cutbuf.buf) {
 	cutbuf.buf = (ZLE_STRING_T)zalloc(ZLE_CHAR_SIZE);
-	cutbuf.buf[0] = ZLENUL;
+	cutbuf.buf[0] = ZWC('\0');
 	cutbuf.len = cutbuf.flags = 0;
     } else if (!(lastcmd & ZLE_KILL)) {
 	Cutbuffer kptr;
@@ -370,23 +372,21 @@
 	    free(kptr->buf);
 	*kptr = cutbuf;
 	cutbuf.buf = (ZLE_STRING_T)zalloc(ZLE_CHAR_SIZE);
-	cutbuf.buf[0] = ZLENUL;
+	cutbuf.buf[0] = ZWC('\0');
 	cutbuf.len = cutbuf.flags = 0;
     }
     if (dir) {
 	ZLE_STRING_T s = (ZLE_STRING_T)zalloc((cutbuf.len + ct)*ZLE_CHAR_SIZE);
 
-	memcpy(s, (char *) (zleline + i), ct * ZLE_CHAR_SIZE);
-	memcpy((char *)(s + ct), (char *)cutbuf.buf,
-	       cutbuf.len * ZLE_CHAR_SIZE);
+	ZS_memcpy(s, zleline + i, ct);
+	ZS_memcpy(s + ct, cutbuf.buf, cutbuf.len);
 	free(cutbuf.buf);
 	cutbuf.buf = s;
 	cutbuf.len += ct;
     } else {
 	cutbuf.buf = realloc((char *)cutbuf.buf,
 			     (cutbuf.len + ct) * ZLE_CHAR_SIZE);
-	memcpy((char *)(cutbuf.buf + cutbuf.len), (char *) (zleline + i),
-	       ct * ZLE_CHAR_SIZE);
+	ZS_memcpy(cutbuf.buf + cutbuf.len, zleline + i, ct);
 	cutbuf.len += ct;
     }
     if(vilinerange)
@@ -442,7 +442,7 @@
 {
     int x = zlecs;
 
-    while (x > 0 && zleline[x - 1] != ZLENL)
+    while (x > 0 && zleline[x - 1] != ZWC('\n'))
 	x--;
     return x;
 }
@@ -453,7 +453,7 @@
 {
     int x = zlecs;
 
-    while (x != zlell && zleline[x] != ZLENL)
+    while (x != zlell && zleline[x] != ZWC('\n'))
 	x++;
     return x;
 }
@@ -528,15 +528,15 @@
     /* get a character from the tty and interpret it */
     c = getfullchar(0);
     if (yesno) {
-	if (c == ZLETAB)
-	    c = LETTER_y;
-	else if (icntrl(c) || c == EOF)
-	    c = LETTER_n;
+	if (c == ZWC('\t'))
+	    c = ZWC('y');
+	else if (icntrl(c) || c == ZLEEOF) /* TODO iswcntrl */
+	    c = ZWC('n');
 	else
-	    c = tulower(c);
+	    c = tulower(c);	/* TODO tulower doesn't handle wint_t */
     }
     /* echo response and return */
-    if (c != ZLENL)
+    if (c != ZWC('\n'))
 	putc(c, shout);		/* TODO: convert to multibyte */
     return c;
 }
@@ -667,7 +667,7 @@
     curchange->del = curchange->ins = NULL;
     curchange->dell = curchange->insl = 0;
     lastline = zalloc((lastlinesz = linesz) * ZLE_CHAR_SIZE);
-    memcpy(lastline, zleline, (lastll = zlell) * ZLE_CHAR_SIZE);
+    ZS_memcpy(lastline, zleline, (lastll = zlell));
     lastcs = zlecs;
 }
 
@@ -751,8 +751,7 @@
     } else {
 	ch->dell = lastll - pre - suf;
 	ch->del = (ZLE_STRING_T)zalloc(ch->dell * ZLE_CHAR_SIZE);
-	memcpy((char *)ch->del, (char *)(lastline + pre),
-	       ch->dell * ZLE_CHAR_SIZE);
+	ZS_memcpy(ch->del, lastline + pre, ch->dell);
     }
     if(suf + pre == zlell) {
 	ch->ins = NULL;
@@ -760,8 +759,7 @@
     } else {
 	ch->insl = zlell - pre - suf;
 	ch->ins = (ZLE_STRING_T)zalloc(ch->insl * ZLE_CHAR_SIZE);
-	memcpy((char *)ch->ins, (char *)(zleline + pre),
-	       ch->insl * ZLE_CHAR_SIZE);
+	ZS_memcpy(ch->ins, zleline + pre, ch->insl);
     }
     if(nextchanges) {
 	ch->flags = CH_PREV;
@@ -784,7 +782,7 @@
 {
     if(lastlinesz != linesz)
 	lastline = realloc(lastline, (lastlinesz = linesz) * ZLE_CHAR_SIZE);
-    memcpy(lastline, zleline, (lastll = zlell) * ZLE_CHAR_SIZE);
+    ZS_memcpy(lastline, zleline, (lastll = zlell));
     lastcs = zlecs;
 }
 
@@ -821,8 +819,7 @@
 	foredel(ch->insl);
     if(ch->del) {
 	spaceinline(ch->dell);
-	memcpy((char *)(zleline + zlecs), (char *)ch->del,
-	       ch->dell * ZLE_CHAR_SIZE);
+	ZS_memcpy(zleline + zlecs, ch->del, ch->dell);
 	zlecs += ch->dell;
     }
     zlecs = ch->old_cs;
@@ -862,8 +859,7 @@
 	foredel(ch->dell);
     if(ch->ins) {
 	spaceinline(ch->insl);
-	memcpy((char *)(zleline + zlecs), (char *)ch->ins,
-	       ch->insl * ZLE_CHAR_SIZE);
+	ZS_memcpy(zleline + zlecs, ch->ins, ch->insl);
 	zlecs += ch->insl;
     }
     zlecs = ch->new_cs;
Index: Src/Zle/zle_vi.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_vi.c,v
retrieving revision 1.5
diff -u -r1.5 zle_vi.c
--- Src/Zle/zle_vi.c	18 Feb 2005 13:57:28 -0000	1.5
+++ Src/Zle/zle_vi.c	23 Feb 2005 12:55:25 -0000
@@ -200,7 +200,7 @@
      * the line, or selected a different history line.             */
     if (histline != hist1 || zlell != lastll || memcmp(zleline, lastline, zlell)) {
 	histline = hist1;
-	memcpy(zleline, lastline, zlell = lastll);
+	ZS_memcpy(zleline, lastline, zlell = lastll);
 	zlecs = pos;
 	return -1;
     }
@@ -733,13 +733,13 @@
     if(buf->flags & CUTBUFFER_LINE) {
 	zlecs = findbol();
 	spaceinline(buf->len + 1);
-	memcpy((char *)zleline + zlecs, buf->buf, buf->len);
-	zleline[zlecs + buf->len] = '\n';
+	ZS_memcpy(zleline + zlecs, buf->buf, buf->len);
+	zleline[zlecs + buf->len] = ZWC('\n');
 	vifirstnonblank(zlenoargs);
     } else {
 	while (n--) {
 	    spaceinline(buf->len);
-	    memcpy((char *)zleline + zlecs, buf->buf, buf->len);
+	    ZS_memcpy(zleline + zlecs, buf->buf, buf->len);
 	    zlecs += buf->len;
 	}
 	if (zlecs)
@@ -765,15 +765,15 @@
     if(buf->flags & CUTBUFFER_LINE) {
 	zlecs = findeol();
 	spaceinline(buf->len + 1);
-	zleline[zlecs++] = '\n';
-	memcpy((char *)zleline + zlecs, buf->buf, buf->len);
+	zleline[zlecs++] = ZWC('\n');
+	ZS_memcpy(zleline + zlecs, buf->buf, buf->len);
 	vifirstnonblank(zlenoargs);
     } else {
 	if (zlecs != findeol())
 	    zlecs++;
 	while (n--) {
 	    spaceinline(buf->len);
-	    memcpy((char *)zleline + zlecs, buf->buf, buf->len);
+	    ZS_memcpy(zleline + zlecs, buf->buf, buf->len);
 	    zlecs += buf->len;
 	}
 	if (zlecs)
@@ -798,7 +798,7 @@
 	zlecs--;
     else {
 	spaceinline(1);
-	zleline[zlecs] = ' ';
+	zleline[zlecs] = ZWC(' ');
     }
     return 0;
 }
@@ -854,15 +854,16 @@
     ZLE_INT_T ch;
 
     if ((zmod.flags & MOD_VIBUF) ||
-	(((ch = getfullchar(0)) < DIGIT_1 || ch > DIGIT_9) &&
-	 (ch < LETTER_a || ch > LETTER_z) &&
-	 (ch < LETTER_A || ch > LETTER_Z)))
+	(((ch = getfullchar(0)) < ZWC('1') || ch > ZWC('9')) &&
+	 (ch < ZWC('a') || ch > ZWC('z')) &&
+	 (ch < ZWC('A') || ch > ZWC('Z'))))
 	return 1;
-    if (ch >= LETTER_A && ch <= LETTER_Z)	/* needed in cut() */
+    if (ch >= ZWC('A') && ch <= ZWC('Z'))	/* needed in cut() */
 	zmod.flags |= MOD_VIAPP;
     else
 	zmod.flags &= ~MOD_VIAPP;
-    zmod.vibuf = tulower(ch) + (idigit(ch) ? - DIGIT_1 + 26 : -LETTER_a);
+    /* TODO tulower, idigit doen't handle wint_t */
+    zmod.vibuf = tulower(ch) + (idigit(ch) ? - ZWC('1') + 26 : -ZWC('a'));
     zmod.flags |= MOD_VIBUF;
     prefixflag = 1;
     return 0;

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


**********************************************************************
This email and any files transmitted with it are confidential and
intended solely for the use of the individual or entity to whom they
are addressed. If you have received this email in error please notify
the system manager.

**********************************************************************

