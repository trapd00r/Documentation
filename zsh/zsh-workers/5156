Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <990201110919.ZM32244@candle.brasslantern.com>
Date: Mon, 1 Feb 1999 11:09:19 -0800
In-Reply-To: <vb4sp6dnwf.fsf@snake.isode.com>
Comments: In reply to Bruce Stephens <b.stephens@isode.com>
        "Re: Associative array ordering and selective unset (Re: Example function)" (Feb  1,  5:39pm)
References: <199902011048.LAA07559@beta.informatik.hu-berlin.de> 
	<990201090246.ZM31742@candle.brasslantern.com> 
	<vb4sp6dnwf.fsf@snake.isode.com>
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: zsh-workers@sunsite.auc.dk
Subject: Re: Associative array ordering and selective unset (Re: Example function)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5156

On Feb 1,  5:39pm, Bruce Stephens wrote:
} Subject: Re: Associative array ordering and selective unset (Re: Example f
}
} It would be a bit tricky to reorder the associative array, wouldn't
} it?  i.e., if I set up some configuration, and then want to insert
} some pattern before some others, then I'd need to recreate the
} associative array.  Maybe that's OK, but it feels a bit awkward.

I just thought of a really clever way to do the specific example that I
gave.  Assume for a moment that the (q) modifier were implemented, i.e.
that (almost repeating the original example) given

        typeset -A map
        map=('*.(gz|Z)' zcat
             '*.bz2' 'bzip2 -dc'
             '*.bz' 'bzip -dc'
             '*' '<')

then ${map[(q)$argv[i]]} returns the value for the first subscript match
found, and ${map[(Q)$argv[i]]} returns the array of values for every key
that matches the subscript.

(Note that I moved the (qQ) into the subscript flags, which is probably
where it really has to be.  And I still hope for a better letter.)

Now change the assignment a little:

        map=('*.(gz|Z)' ': 1; zcat
             '*.bz2' ': 2; bzip2 -dc'
             '*.bz' ': 3; bzip -dc'
             '*' ': 4; <')

Now we can use the (o) substitution flag like so:

	eval ${${(o)map[(Q)$argv[i]]}[1]} '$argv[i]'

That says "find all the values for which the key is a pattern that matches
$argv[i], sort them in ascending order, take the first one, and evaluate
it as a command with argument $argv[i]."  By embedding the "preferred"
ordering in the value as a leading ":" command, we're assured of always
getting the most-specific match.

Now, if only this actually worked ... I'm about to be tied up in a several-
week consulting job, so I probably won't get a chance to do anything with
this anytime soon.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

