From zsh-workers-return-15672-mason-zsh=primenet.com.au@sunsite.dk Tue Aug 21 14:03:17 2001
Return-Path: <zsh-workers-return-15672-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27208 invoked from network); 21 Aug 2001 14:03:14 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 21 Aug 2001 14:03:14 -0000
Received: (qmail 15181 invoked by alias); 21 Aug 2001 14:03:06 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15672
Received: (qmail 15167 invoked from network); 21 Aug 2001 14:03:04 -0000
Message-ID: <20010821140301.35191.qmail@web10404.mail.yahoo.com>
Date: Tue, 21 Aug 2001 07:03:01 -0700 (PDT)
From: Felix Rosencrantz <f_rosencrantz@yahoo.com>
Subject: XML progress
To: zsh-workers <zsh-workers@sunsite.auc.dk>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="0-247940966-998402581=:34928"

--0-247940966-998402581=:34928
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

More news from my XML experiment.

I didn't have a lot of time to work on this after I last posted.
Originally I intended to write some perl to help generate XML.  I
didn't really get started on that.  I started downloading some tools
for evaluation.  I started playing with a windows-based editor called
XSLerator.  To try it out, I wrote an XSL stylesheet to convert the
files I had sent last time into completion functions.  (XSLerator is
nice to use.)

I had to make some tweaks to my original .xml to make the files
consistent.  But I was able to regenerate the original completion
scripts.  Well, almost, there were some white space differences.  I also
started writing XSL scripts for editting these XML files.

It occured to me that if these scripts could perform editting operations
on the XML it would be possible to harness the completion system to help
with the creation and modification of the XML files.  The completion
system turns command line creation into a multiple choice quiz.  It
would be possible to use the completion system's documentation on demand
to help guide the user, so the user wouldn't need to stare at the man
page.

I've attached the XSL for generating a completion function from .xml. ll
I'post some XML files later in the week that can be used with it.

To give you an idea, I've created a completion function for the Xalan
XSLT processor (lastest Xalan Java 2) from the Apache folks. For
those who are interested in size, the XML file is 2.2 times larger
than the generated completion function, though about 4 times as many
lines... There is no extra help or much indenting.  The process I
performed to get this file is listed below.

XSL Scripts and XML Files attached.  There is a lot of gratuitous perl
code here.  My feeling is that hese throw away scripts could be replaced
by more general purpose tools.

        #Create the initial xml file.
        java org.apache.xalan.xslt.Process -IN null.xml -OUT xalan.xml  \
             -XSL new_service.xsl \
             -PARAM Service "org.apache.xalan.xslt.Process" \ 
             -PARAM Filename "_xalan"

        #Create a list of the flags from the help output
        #(flags start with '-' and are separated
        # by whitespace/sq brackets, or equal signs.)
        flags=(`java org.apache.xalan.xslt.Process|
               perl -ne 'chop;@w = split(/[\s\[\]=]+/);
               print join(" ",grep(/^-/ ,@w))," ";
              END{ print "\n";}' `)

        #Add the flags to the file.
        java org.apache.xalan.xslt.Process -IN xalan.xml -OUT xalan2.xml  \
             -XSL add_flags.xsl \
             -PARAM Service "org.apache.xalan.xslt.Process" \
             -PARAM Filename "_xalan"
             -PARAM Flags "$flags"


        #Get the explanations
        typeset -A help
        eval  "help=("  $(java org.apache.xalan.xslt.Process | \
               perl -n -e 'chop; m#\[(-\w+).*\((.*)\)#; $flag = $1;$help = $2;
                    print "\"", $flag , "\" \"",$help,"\"\n" 
                    if ($flag ne "" && $help ne "");') ")"

        # Add the extracted explanations to the files.
        cp xalan2.xml xalan3.xml
        foreach f (${(k)help}) {
                java org.apache.xalan.xslt.Process -IN xalan3.xml \
                    -OUT xalan3b.xml -XSL add_explanation.xsl \
                    -PARAM Service "org.apache.xalan.xslt.Process" \
                    -PARAM Flag "$f" \
                    -PARAM Explanation "$help[$f]"
                cp xalan3b.xml xalan3.xml
        }

        #By hand to get final version of attached xalan.xml, I
        # did the following
            1) Added descriptions and actions.
            2) Prolog code, code for parameter_name state.
            3) Added some missing explanations.

        #Generate the completion function
        java org.apache.xalan.xslt.Process -IN xalan3.xml \
            -OUT _xalan -XSL arg.xsl

Much of the manual edits could be done via XSL scripts.  Though I
wanted to post some of this before going much further.  Also, adding
the explanations was slower than I had hoped.  I suspect that there is
a lot of start up costs associated with the java vm, and re-parsing
add_explanation.xsl.  So if it was possible to batch a bunch of edits I
think that would be better.  I suspect the way to do this is via an XSL
merge script.  The idea being to create a new XML file with deltas, and
have the XSL script take the master XML file and perform the edits from
the new XML file.

-FR.

Files included:
    null.xml             Shell XML file used by new_service.xsl 
    new_service.xsl      From null.xml creates an empty completion XML file
    add_flags.xsl        Add the specified flags to the service file.
    add_explanation.xsl  Add the explanation for the given Service and Flag
    arg.xsl              Takes a completion XML file and generates ZSH func.
    xalan.xml            The final XML file, after generation and hand edits.
    _xalan               The generated completion function


__________________________________________________
Do You Yahoo!?
Make international calls for as low as $.04/minute with Yahoo! Messenger
http://phonecard.yahoo.com/
--0-247940966-998402581=:34928
Content-Type: text/xml; name="send_files.txt"
Content-Description: send_files.txt
Content-Disposition: inline; filename="send_files.txt"

cat <<'EOF_null.xml' > null.xml
<?xml version="1.0"?>
<null/>
EOF_null.xml
cat <<'EOF_new_service.xsl' > new_service.xsl
<?xml version='1.0'?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="xml" indent="yes"/>
<xsl:param name="Service"/>
<xsl:param name="Filename"/>

<xsl:template match="/">
	<xsl:call-template name="CreateCompletion"></xsl:call-template>
</xsl:template>


<xsl:template name="CreateCompletion">
    <xsl:variable name="File">
        <xsl:choose>
        <xsl:when test="$Filename = ''">
            <xsl:value-of select="concat('_',$Service)"/>
        </xsl:when>
        <xsl:otherwise>
           <xsl:value-of select="$Filename"/>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
<completion version='.01'>
    <filename> <xsl:value-of select="$File"/> </filename>
        <service name="{$Service}">
            <arguments/>
            <argspecs/>
        </service>
</completion>
</xsl:template>

</xsl:stylesheet>
EOF_new_service.xsl
cat <<'EOF_add_flags.xsl' > add_flags.xsl
<?xml version="1.0"?>
<xsl:stylesheet id="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.1">
<xsl:output method="xml" indent="yes" cdata-section-elements="code"/>
<xsl:param name="Service"/>
<xsl:param name="Flags"/>

<xsl:template match="/completion">
	<xsl:copy>
		<xsl:apply-templates select="*"/>
	</xsl:copy>
</xsl:template>

<xsl:template match="argspecs">
	<xsl:choose>
		<xsl:when test="(ancestor::service/@name = $Service) or ($Service = '' and (count(//service) = 1))">
			<xsl:copy>
				<xsl:apply-templates select="*"></xsl:apply-templates>
				<xsl:call-template name="AddFlags">
					<xsl:with-param name="Flags" select="$Flags"/>
				</xsl:call-template>
			</xsl:copy>
		</xsl:when>

		<xsl:otherwise>
			<xsl:copy-of select="."/>
		</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>




<xsl:template name="AddFlags">
	<xsl:param name="Flags"/>

	<xsl:choose>
		<xsl:when test="contains($Flags,' ')">
			<xsl:call-template name="AddFlag">
				<xsl:with-param name="Flag" select="substring-before($Flags,' ')"/>
			</xsl:call-template>
			<xsl:call-template name="AddFlags">
				<xsl:with-param name="Flags" select="substring-after($Flags,' ')"/>
			</xsl:call-template>
		</xsl:when>
		<xsl:otherwise>
			<xsl:call-template name="AddFlag">
				<xsl:with-param name="Flag" select="$Flags"/>
			</xsl:call-template>
		</xsl:otherwise>
	</xsl:choose>


</xsl:template>


<xsl:template name="AddFlag">
<xsl:param name="Flag"/>
				<argspec>
					<optspec>
						<flagarg name="{$Flag}"/>
					</optspec>
				</argspec>
</xsl:template>







<xsl:template match="@*|text()">
	<xsl:copy-of select="."/>
</xsl:template>







<xsl:template match="*">
	<xsl:copy>
		<xsl:apply-templates select="*|@*|text()"/>
	</xsl:copy>
</xsl:template>

</xsl:stylesheet>
EOF_add_flags.xsl
cat <<'EOF_add_explanation.xsl' > add_explanation.xsl
<?xml version="1.0"?>
<xsl:stylesheet id="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.1">
<xsl:output method="xml" indent="yes" cdata-section-elements="code"/>
<xsl:param name="Service"/>
<xsl:param name="Flag"/>
<xsl:param name="Explanation"/>
<!-- Current doesn't allow the user to specify the language or the source of the explanation -->

<xsl:template match="/completion">
	<xsl:copy>
		<xsl:apply-templates select="*"/>
	</xsl:copy>
</xsl:template>

<!-- Assure that we are in the correct service, if not just make a plain copy -->
<xsl:template match="argspecs">
	<xsl:choose>
		<xsl:when test="(ancestor::service/@name = $Service) or ($Service = '' and (count(//service) = 1))">
			<xsl:copy>
				<xsl:apply-templates select="*"></xsl:apply-templates>
			</xsl:copy>
		</xsl:when>

		<xsl:otherwise>
			<xsl:copy-of select="."/>
		</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>

<xsl:template match="flagarg">
	<xsl:variable name="this" select="."/>
	<xsl:choose>
		<xsl:when test="@name = $Flag">
			<xsl:copy>
				<xsl:for-each select="@*|*">
					<xsl:choose>
						<xsl:when test="name() = 'explanation'">
							<explanation><xsl:copy-of select="@*"/>
							<xsl:value-of select="$Explanation"/></explanation>
						 </xsl:when>
						 <xsl:otherwise>
						 	<xsl:copy-of select="."/>
						 </xsl:otherwise>
					</xsl:choose>
				</xsl:for-each>
				<xsl:if test="not(explanation)">
					<explanation><xsl:value-of select="$Explanation"/></explanation>
				</xsl:if>
			</xsl:copy>
		</xsl:when>
		<xsl:otherwise>
			<xsl:copy-of select="."/>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>


<xsl:template match="@*|text()">
	<xsl:copy-of select="."/>
</xsl:template>
<xsl:template match="*">
	<xsl:copy>
		<xsl:apply-templates select="*|@*|text()"/>
	</xsl:copy>
</xsl:template>

</xsl:stylesheet>
EOF_add_explanation.xsl
cat <<'EOF_arg.xsl' > arg.xsl
<?xml version='1.0'?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="text"/>

<!-- Starting point -->
<xsl:template match="/completion">
<xsl:call-template name="FirstLine"></xsl:call-template>
<xsl:call-template name="Prolog"></xsl:call-template>
<xsl:if test="count(services) != 0">
	<xsl:apply-templates select="services"/>
</xsl:if>
<xsl:if test="count(service) != 0">
	<xsl:apply-templates select="service"/>
</xsl:if>
<xsl:apply-templates select="states"/>


</xsl:template>


<xsl:template name="FirstLine">
	<xsl:text>#compdef </xsl:text>
	<xsl:for-each select="//service">
		<xsl:value-of select="@name"/><xsl:text> </xsl:text>
	</xsl:for-each>
	<xsl:text disable-output-escaping="yes"><![CDATA[
]]></xsl:text>
</xsl:template>

<xsl:template name="Prolog">
<xsl:value-of select="//prolog/code/text()"/>
</xsl:template>

<xsl:template match="services">
	<xsl:text>case $service in
</xsl:text>
	<xsl:for-each select="service">
		<xsl:text>        </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>)
</xsl:text>
		<xsl:apply-templates select="."/>
		<xsl:text>      ;;
</xsl:text>
	</xsl:for-each>
	<xsl:text>esac
</xsl:text>
</xsl:template>

<xsl:template match="service">
<xsl:apply-templates select="*"/>

</xsl:template>

<xsl:template match="arguments">
<xsl:text>	_arguments </xsl:text>
<xsl:apply-templates select="argoption"/> <xsl:text>\
</xsl:text>

</xsl:template>

<xsl:template match="argoption">
<xsl:if test="(count(@use) = 0) or (@use = false())">
	<xsl:value-of select="name/text()"/>
	<xsl:text> </xsl:text>
</xsl:if>
</xsl:template>

<xsl:template match="argspecs">
<xsl:apply-templates select="*"/>
</xsl:template>

<xsl:template match="argspec">
<xsl:variable name="here" select="."/>
<xsl:variable name="ArgSpec">
	<xsl:apply-templates select="optspec"/>
	<xsl:if test="count(description) != 0">
		<xsl:text>:</xsl:text>
	</xsl:if>
	<xsl:for-each select="description">
		<xsl:apply-templates select="."/>
    	<xsl:if test="position() != last()">
      	   <xsl:text>:</xsl:text>
    	</xsl:if>
	</xsl:for-each>
	<xsl:if test="count(last_description) != 0">
    	<xsl:text>:</xsl:text>
	</xsl:if>
	<xsl:apply-templates select="last_description"/>
</xsl:variable>
<xsl:variable name="apos" select='"&apos;"' />
<xsl:variable name="quot" select="'&quot;'" />
<xsl:choose>
	<xsl:when test="contains($ArgSpec,$apos) and contains($ArgSpec,$quot)">
		<xsl:message>
		Service <xsl:value-of select="ancestor::service/@name"/>
		Flag <xsl:value-of select="optspec/flagarg/@name"/>
		Has both single and double quotes... May have a syntax with
		generated arguments call.
		</xsl:message>
		<!-- What the heck just use ' -->
		<xsl:text>		'</xsl:text>
		<xsl:value-of select="$ArgSpec"/>
		<xsl:text>'</xsl:text>
	</xsl:when>
	<xsl:when test="contains($ArgSpec,$quot)">
		<xsl:text>		'</xsl:text>
		<xsl:value-of select="$ArgSpec"/>
		<xsl:text>'</xsl:text>
	</xsl:when>
	<xsl:when test="contains($ArgSpec,$apos)">
		<xsl:text>		"</xsl:text>
		<xsl:value-of select="$ArgSpec"/>
		<xsl:text>"</xsl:text>
	</xsl:when>
	<xsl:otherwise>
		<xsl:text>		'</xsl:text>
		<xsl:value-of select="$ArgSpec"/>
		<xsl:text>'</xsl:text>
	</xsl:otherwise>
</xsl:choose>
<xsl:variable name="CR"><xsl:text> \
</xsl:text>
</xsl:variable>
<xsl:choose>
	<xsl:when test="position() != last()">
		<xsl:value-of select="$CR"/>
	</xsl:when>
	<xsl:when test="name($here/../following-sibling::*[1]) = 'code'">
		<xsl:if test="$here/../following-sibling::code[1]/@samecommand">
			<xsl:value-of select="$CR"/>
		</xsl:if>
		<xsl:value-of select="$here/../following-sibling::code[1]/text()"/>
		<xsl:value-of select="substring-after($CR,'\')"/>
	</xsl:when>
	<xsl:otherwise>
		<xsl:value-of select="substring-after($CR,'\')"/>
		<xsl:value-of select="$here/../following-sibling::code[1]/text()"/>
	</xsl:otherwise>
</xsl:choose>
</xsl:template>

<xsl:template match="optspec">
	<xsl:if test="count(anyposition) != 0">
		<xsl:text>*</xsl:text>
	</xsl:if>

	<xsl:if test="count(flagarg/more_than_once) != 0">
		<xsl:text>*</xsl:text>
	</xsl:if>
	<xsl:if test="count(exclusionlist) != 0">
		<xsl:text>(</xsl:text>
		<xsl:for-each select="exclusionlist/flag">
			<xsl:value-of select="text()"/>
			<xsl:if test="position() != last()">
				<xsl:text> </xsl:text>
			</xsl:if>
		</xsl:for-each>
		<xsl:text>)</xsl:text>
	</xsl:if>
	<xsl:if test="count(flagarg/@name) != 0">
		<xsl:value-of select="flagarg/@name"/>
	</xsl:if>
	<xsl:if test="count(position) != 0">
		<xsl:value-of select="position/@position"/>
	</xsl:if>
	<xsl:if test="count(flagarg/explanation) != 0">
		<xsl:text>[</xsl:text>
		<xsl:value-of select="normalize-space(flagarg/explanation)"/>
		<xsl:text>]</xsl:text>
	</xsl:if>


</xsl:template>

<xsl:template match="description">
	<xsl:value-of select="normalize-space(message)"/>
	<xsl:apply-templates select="action"/>
</xsl:template>

<xsl:template match="last_description">
     <xsl:text>*</xsl:text>
     <xsl:value-of select="ends_with_pattern/text()"/>
     <xsl:text>:</xsl:text>
     <xsl:if test="count(limit_words_to_arg) != 0">
          <xsl:text>:</xsl:text>
     </xsl:if>
     <xsl:value-of select="normalize-space(message/text())"/>
     <xsl:apply-templates select="action"/>
</xsl:template>

<xsl:template match="action">
	<xsl:text>:</xsl:text>
    <xsl:if test="count(add_no_compadd_args) != 0">
            <xsl:text> </xsl:text>
    </xsl:if>
	<xsl:choose>
	<xsl:when test="count(command) != 0">
		<xsl:value-of select="normalize-space(command)"/>
	</xsl:when>
	<xsl:when test="count(state) != 0 ">
		<xsl:text>-&gt;</xsl:text>
		<xsl:value-of select="state/text()"/>
	</xsl:when>
    <xsl:when test="string-length(fixed_set/fixed_string/description/text()) > 1">
        <xsl:text>((</xsl:text>
		<xsl:for-each select="fixed_set/fixed_string">
                <xsl:value-of select="value"/>
                <xsl:text>\:</xsl:text>
                <xsl:call-template name="backslash-space">
                     <xsl:with-param name="text" select="description/text()"/>
                     <xsl:with-param name="find_string" select="' '"/>
                     <xsl:with-param name="replace_string" select="'\ '"/>
                </xsl:call-template>
                <xsl:if test="position() != last()">
                        <xsl:text> </xsl:text>
                </xsl:if>
        </xsl:for-each>
		<xsl:text>))</xsl:text>
	</xsl:when>
	<xsl:when test="count(fixed_set)">
		<xsl:text>(</xsl:text>
		<xsl:for-each select="fixed_set/fixed_string">
                <xsl:value-of select="value"/>
                <xsl:if test="position() != last()">
                        <xsl:text> </xsl:text>
                </xsl:if>
        </xsl:for-each>
		<xsl:text>)</xsl:text>
	</xsl:when>

	</xsl:choose>
</xsl:template>

<xsl:template match="states">
<xsl:text>case $state in
</xsl:text>
<xsl:apply-templates select="state"/>
<xsl:text>esac
</xsl:text>
</xsl:template>

<xsl:template match="state">
	<xsl:text>  </xsl:text>
	<xsl:value-of select="name"/>
	<xsl:text>)</xsl:text>
	<xsl:value-of select="code"/>
	<xsl:text>;;
</xsl:text>
</xsl:template>

<xsl:template name="backslash-space">
<xsl:param name="text"/>
<xsl:param name="find_string"/>
<xsl:param name="replace_string"/>
<xsl:choose>
<xsl:when test="contains($text,$find_string)">
     <xsl:value-of select="concat(substring-before($text,$find_string),$replace_string)"/>
     <xsl:call-template name="backslash-space">
          <xsl:with-param name="text" select="substring-after($text,$find_string)"/>
          <xsl:with-param name="find_string" select="$find_string"/>
          <xsl:with-param name="replace_string" select="$replace_string"/>
     </xsl:call-template>
</xsl:when>
<xsl:otherwise>
     <xsl:value-of select="$text"/>
</xsl:otherwise>
</xsl:choose>
</xsl:template>

<xsl:template match="*|@*|text()"/>


<xsl:template match="flagarg" mode="list_flags">
    <xsl:value-of select="@name"/>
    <xsl:text> </xsl:text>
</xsl:template>

<xsl:template match="service" mode="list_flags">
    <xsl:param name="service_name"/>
    <xsl:if test="@name = $service_name">
         <xsl:apply-templates select="*" mode="list_flags">
         	<xsl:with-param name="service_name" select="$service_name"/>
         </xsl:apply-templates>
    </xsl:if>
</xsl:template>

<xsl:template match="*" mode="list_flags">

    <xsl:param name="service_name"/>
	<xsl:apply-templates select="*" mode="list_flags">
		<xsl:with-param name="service_name" select="$service_name"/>
	</xsl:apply-templates>
</xsl:template>

</xsl:stylesheet>

EOF_arg.xsl
cat <<'EOF_xalan.xml' > xalan.xml
<?xml version="1.0" encoding="UTF-8"?>
<completion>
<filename>_xalan</filename>
<prolog><code>
local state line context
typeset -A opt_args
</code>
</prolog>
<service name="org.apache.xalan.xslt.Process">
<arguments/>
<argspecs>
<argspec>
<optspec>
<flagarg name="-IN"/>
<explanation>Input file</explanation>
</optspec>
<description>
    <message>XML file </message>
    <action><command>_files</command></action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-XSL"/>
<explanation>XSL Script </explanation>
</optspec>
<description>
    <message>XSL file </message>
    <action><command>_files</command></action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-OUT"/>
<explanation>Output file</explanation>
</optspec>
<description>
    <message>Output file </message>
    <action><command>_files</command></action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-E">
<explanation>Do not expand entity refs</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-QC">
<explanation>Quiet Pattern Conflicts Warnings</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-TT">
<explanation>Trace the templates as they are being called.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-TG">
<explanation>Trace each generation event.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-TS">
<explanation>Trace each selection event.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-TTC">
<explanation>Trace the template children as they are being processed.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-TCLASS">
<explanation>TraceListener class for trace extensions.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-EDUMP">
<explanation>Do stackdump on error.</explanation>
</flagarg>
</optspec>
<description>
    <message>XML file </message>
    <action><command>_files</command></action>
</description>
</argspec>
<argspec>
<optspec>
<exclusionlist>
<flag>-TEXT</flag>
<flag>-HTML</flag>
</exclusionlist>
<flagarg name="-XML">
<explanation>Use XML formatter and add XML header.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<exclusionlist>
<flag>-XML</flag>
<flag>-HTML</flag>
</exclusionlist>
<flagarg name="-TEXT">
<explanation>Use simple Text formatter.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<exclusionlist>
<flag>-XML</flag>
<flag>-TEXT</flag>
</exclusionlist>
<flagarg name="-HTML">
<explanation>Use HTML formatter.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-PARAM">
<more_than_once/>
<explanation>Set a stylesheet parameter</explanation>
</flagarg>
</optspec>
<description>
    <message>Parameter name </message>
    <action><state>parameter_name</state></action>
</description>
<description>
    <message>Parameter value </message>
    <action></action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-L">
<explanation>Use line numbers for source document</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-MEDIA">
<explanation>use media attribute to find stylesheet associated with a document.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-FLAVOR">
<explanation>Explicitly use s2s=SAX or d2d=DOM to do transform.</explanation>
</flagarg>
</optspec>
<description>
    <message>Transform flavor </message>
    <action>
<fixed_set>
   <fixed_string><value>s2s</value><description>SAX</description></fixed_string>
   <fixed_string><value>d2s</value><description>DOM</description></fixed_string>
</fixed_set>
    </action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-DIAG">
<explanation>Print overall milliseconds transform took.</explanation>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-URIRESOLVER">
<explanation>URIResolver to be used to resolve URIs</explanation>
<description>
    <message>Class name</message>
    <action><command>_files</command></action>
</description>
</flagarg>
</optspec>
</argspec>
<argspec>
<optspec>
<flagarg name="-ENTITYRESOLVER">
<explanation>EntityResolver to be used to resolve entities</explanation>
</flagarg>
</optspec>
<description>
    <message>Class name</message>
    <action><command>_files</command></action>
</description>
</argspec>
<argspec>
<optspec>
<flagarg name="-CONTENTHANDLER">
<explanation>ContentHandler to be used to serialize output</explanation>
</flagarg>
</optspec>
<description>
    <message>Class name</message>
    <action><command>_files</command></action>
</description>
</argspec>
</argspecs>
</service>
<states>
<state><name>parameter_name</name>
<code><![CDATA[
        local vars list_xsl
        list_xsl=/tmp/$$.list_xsl_params.xsl
        param_list=/tmp/$$_params.out
        # If the user has already specified XSL then parse that file.
        if (( $+opt_args[-XSL] )) ; then
            # $opt_args[-PARAM] ends up with a value listing all
            # the args to this param. separated by colons.  So we get
            # PARAM1:param1_value:PARAM2:param2_value....
            # So it should be possible to remove values from var that have
            # already been specified...

            #For now just use XSL to extract the parameter names.
            cat <<EOF > $list_xsl
<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:x="namespace-alias">
<xsl:output media-type="text" omit-xml-declaration="yes"/>
<xsl:namespace-alias result-prefix="xsl" stylesheet-prefix="x"/>
<xsl:template match="xsl:stylesheet|/">
<xsl:apply-templates select="*"/> </xsl:template>

<xsl:template match="xsl:param">
        <xsl:value-of select="@name"/><xsl:text> </xsl:text>
</xsl:template>
<xsl:template match="*|@*|text()"/>
</xsl:stylesheet>
EOF

        java org.apache.xalan.xslt.Process -IN $opt_args[-XSL] -XSL $list_xsl -OUT $param_list
        vars=(`cat $param_list`)
        rm -f $list_xsl $param_list
        compadd $vars
        fi
        return 0
]]></code>
</state></states>
</completion>
EOF_xalan.xml
cat <<'EOF__xalan' > _xalan
#compdef org.apache.xalan.xslt.Process 

local state line context
typeset -A opt_args
	_arguments \
		'-IN:XML file:_files' \
		'-XSL:XSL file:_files' \
		'-OUT:Output file:_files' \
		'-E[Do not expand entity refs]' \
		'-QC[Quiet Pattern Conflicts Warnings]' \
		'-TT[Trace the templates as they are being called.]' \
		'-TG[Trace each generation event.]' \
		'-TS[Trace each selection event.]' \
		'-TTC[Trace the template children as they are being processed.]' \
		'-TCLASS[TraceListener class for trace extensions.]' \
		'-EDUMP[Do stackdump on error.]:XML file:_files' \
		'(-TEXT -HTML)-XML[Use XML formatter and add XML header.]' \
		'(-XML -HTML)-TEXT[Use simple Text formatter.]' \
		'(-XML -TEXT)-HTML[Use HTML formatter.]' \
		'*-PARAM[Set a stylesheet parameter]:Parameter name:->parameter_name:Parameter value:' \
		'-L[Use line numbers for source document]' \
		'-MEDIA[use media attribute to find stylesheet associated with a document.]' \
		'-FLAVOR[Explicitly use s2s=SAX or d2d=DOM to do transform.]:Transform flavor:((s2s\:SAX d2s\:DOM))' \
		'-DIAG[Print overall milliseconds transform took.]' \
		'-URIRESOLVER[URIResolver to be used to resolve URIs]' \
		'-ENTITYRESOLVER[EntityResolver to be used to resolve entities]:Class name:_files' \
		'-CONTENTHANDLER[ContentHandler to be used to serialize output]:Class name:_files'
case $state in
  parameter_name)
        local vars list_xsl
        list_xsl=/tmp/$$.list_xsl_params.xsl
        param_list=/tmp/$$_params.out
        # If the user has already specified XSL then parse that file.
        if (( $+opt_args[-XSL] )) ; then
            # $opt_args[-PARAM] ends up with a value listing all
            # the args to this param. separated by colons.  So we get
            # PARAM1:param1_value:PARAM2:param2_value....
            # So it should be possible to remove values from var that have
            # already been specified...

            #For now just use XSL to extract the parameter names.
            cat <<EOF > $list_xsl
<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:x="namespace-alias">
<xsl:output media-type="text" omit-xml-declaration="yes"/>
<xsl:namespace-alias result-prefix="xsl" stylesheet-prefix="x"/>
<xsl:template match="xsl:stylesheet|/">
<xsl:apply-templates select="*"/> </xsl:template>

<xsl:template match="xsl:param">
        <xsl:value-of select="@name"/><xsl:text> </xsl:text>
</xsl:template>
<xsl:template match="*|@*|text()"/>
</xsl:stylesheet>
EOF

        java org.apache.xalan.xslt.Process -IN $opt_args[-XSL] -XSL $list_xsl -OUT $param_list
        vars=(`cat $param_list`)
        rm -f $list_xsl $param_list
        compadd $vars
        fi
        return 0
;;
esac
EOF__xalan

--0-247940966-998402581=:34928--

