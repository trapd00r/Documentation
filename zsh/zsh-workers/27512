From zsh-workers-return-27512-mason-zsh=primenet.com.au@zsh.org Mon Dec 14 13:29:33 2009
Return-Path: <zsh-workers-return-27512-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14872 invoked by alias); 14 Dec 2009 13:29:33 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 27512
Received: (qmail 23563 invoked from network); 14 Dec 2009 13:29:21 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.8 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: pass (ns2.melb.primenet.com.au: SPF record at alea.gnuu.de designates 83.246.114.63 as permitted sender)
X-DKIM: Sendmail DKIM Filter v2.5.2 uucp.gnuu.de AF58F488080
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple; d=gnuu.de; s=banki;
	t=1260797348; i=@alea.gnuu.de; bh=Qg8yAAPdfFOyJvTDhsvzLGI/fFOl9/2bQ
	MGsu+fJw20=; h=To:From:Subject:Date:Message-ID:References:
	 Mime-Version:Content-Type:Content-Transfer-Encoding:Sender; b=vN7p
	40y42AJJWxqOsiUx23T9cis85jptERT/QLDPL1SVwPj5lGsp1R5wGBWQfhD4+8v9/jV
	/42AocDBX4HypsTlkdpTlRpZ9BhyiHdViFX2dD5UWhtZaQywQPrERRBk9hZd2NMe4fO
	/uThx4duc8jDMJp/yxvtbtpOb32uTOsPY=
To: zsh-workers@zsh.org
Path: not-for-mail
From: =?UTF-8?Q?J=C3=B6rg?= Sommer <joerg@alea.gnuu.de>
Newsgroups: local.mailinglist.zsh
Subject: Re: [PATCH] _git: offer files relative to current directory
Date: Mon, 14 Dec 2009 13:20:19 +0000 (UTC)
Lines: 144
Message-ID: <slrnhicesh.2pm.joerg@alea.gnuu.de>
References: <20091205174551.GF3344@altlinux.org>
 <1260136353-20093-1-git-send-email-raorn@altlinux.org>
 <20091213000820.GA20752@altlinux.org> <20091213213334.28bbeb66@pws-pc>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Trace: alea.gnuu.de 1260796819 6709 192.168.0.5 (14 Dec 2009 13:20:19 GMT)
X-Complaints-To: usenet@alea.gnuu.de
User-Agent: slrn/pre1.0.0-11 (Linux)
Sender: news <news@alea.gnuu.de>

Hi Peter,

Peter Stephenson <p.w.stephenson@ntlworld.com> wrote:
> On Sun, 13 Dec 2009 03:08:20 +0300
> "Alexey I. Froloff" <raorn@altlinux.org> wrote:
>> On Mon, Dec 07, 2009 at 12:52:33AM +0300, Alexey I. Froloff wrote:
>> > When offering repository files (cached, deleted, changed, etc), make
>> > sure that paths are relative to current directory, as git expects.
>> So, what about this patch?  Will it be accepted or rejected?
>
> Please can someone who uses git decide.

I've did some tests and this functions seems correct. But I would
refuse it for these reasons:

• The function can be written more self‐contained and generic if the
  prefix would be passed as argument and not determined internally.

• The intention of the function is the make paths relative to a given
  prefix. It should not beautify paths or something. Otherwise name it
  __git_files_relative_and_beatify.

• The function should not take and return a nul‐separated string but an
  array. The code looks as follows:
  call git
  call __git_files_relative
    split output of git
    …
    join output
  split output of __git_files_relative

Here's my test:

#v+
#!/bin/zsh

emulate -R zsh

_call_program () {
    local tmp
    if zstyle -s ":completion:${curcontext}:${1}" command tmp
    then
        if [[ "$tmp" = -* ]]
        then
            eval "$tmp[2,-1]" "$argv[2,-1]"
        else
            eval "$tmp"
        fi
    else
        eval "$argv[2,-1]"
    fi
}
__git_command_successful() { true; }

__git_files_relative () {
  local rawfiles files file f_parts prefix p_parts tmp

  prefix=$(_call_program gitprefix git rev-parse --show-prefix 2>/dev/null)
  __git_command_successful || return

  # Empty prefix, no modifications
  if (( $#prefix == 0 )); then
    print $1
    return
  fi

  rawfiles=(${(ps:\0:)1})
  files=()

  # Now we assume that we've given "absolute" paths list with "root"
  # being repository top directory.  $prefix is also "absolute" path.
  for file in $rawfiles; do
    # Collapse "/./" and "//", strip "/." and "/" from tail (I know,
    # this is a bit paranoid).
    f_parts=(${(s:/:)"${${${${file//\/\///}//\/.\///}%%/.}%%/}"})
    p_parts=(${(s:/:)"${${${${prefix//\/\///}//\/.\///}%%/.}%%/}"})
    tmp=()

    # Strip common path prefix.
    while (( $#f_parts > 0 )) && (( $#p_parts > 0 )) && [[ $f_parts[1] == $p_parts[1] ]]; do
      f_parts[1]=()
      p_parts[1]=()
    done

    # If prefix still not empty, ascend up.
    while (( $#p_parts > 0 )); do
	tmp+=..
	p_parts[1]=()
    done

    # Add remaining path.
    tmp=("$tmp[@]" "$f_parts[@]")

    files+=${(j:/:)tmp}
  done

  print ${(pj:\0:)files}
}

do_test()
{
    local no prefix arg expect
    no=$1
    prefix=$2
    arg=${3//$'\n'/$'\0'}
    expect=${4//$'\n'/$'\0'}

    zstyle ':completion:*:git:gitprefix' command "echo $prefix"
    outp=$(curcontext='git-test:git' __git_files_relative $arg)
    if [[ $outp != $expect ]]
    then
        print "test $no failed"
        print "output:"
        print ${outp//$'\0'/$'\n'}
        print "expected:"
        print ${expect//$'\0'/$'\n'}
        print '===================='
    fi
}

do_test 1 '' "$(print -l 'a/x' 'b')" "$(print -l 'a/x' 'b')"
do_test 2 'a' "$(print -l 'a/x' 'b')" "$(print -l 'x' '../b')"
do_test 3 'b' "$(print -l 'a/x' 'b/y')" "$(print -l '../a/x' 'y')"

do_test 4 'c' "$(print -l a/{1..3} b c/{m/{1..2},n/1,o})" \
  "$(print -l ../a/{1..3} ../b {m/{1..2},n/1,o})"

do_test 5 'c/n' "$(print -l a/{1..3} b c/{m/{1..2},n/1,o})" \
  "$(print -l ../../a/{1..3} ../../b {../m/{1..2},1,../o})"

do_test 6 'a' "$(print -l a/1 b/t/u/../v)" \
  "$(print -l 1 ../b/t/u/../v)"

do_test 7 'a' "$(print -l a/1 b/t/./v)" \
  "$(print -l 1 ../b/t/./v)"

do_test 8 'a' "$(print -l a/1 b/t/.///)" \
  "$(print -l 1 ../b/t/.///)"
#v-

Bye, Jörg.
-- 
Eine Blume geht über eine Wiese, sieht einen schönen Menschen und reißt
ihm den Kopf ab.

