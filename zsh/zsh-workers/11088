From zsh-workers-return-11088-mason-zsh=primenet.com.au@sunsite.auc.dk Wed May 03 07:16:50 2000
Return-Path: <zsh-workers-return-11088-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14780 invoked from network); 3 May 2000 07:16:44 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 3 May 2000 07:16:44 -0000
Received: (qmail 12546 invoked by alias); 3 May 2000 07:16:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11088
Received: (qmail 12520 invoked from network); 3 May 2000 07:16:36 -0000
Date: Wed, 3 May 2000 09:16:35 +0200 (MET DST)
Message-Id: <200005030716.JAA07455@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Tue, 2 May 2000 10:31:08 +0200 (MET
	DST)
Subject: Re: Shell-word splitting (was: Re: Proposed _history completer)


I wrote:

> Bart Schaefer wrote:
> 
> > On Apr 28,  9:20am, Sven Wischnowsky wrote:
> > }
> > } Bart Schaefer wrote:
> > } 
> > } > I think having a way to chop a string into shell words -- something like
> > } > what you did for copy-prev-shell-word -- would be more effective.
> > } 
> > } [...] some parameter flag, most likely. Hm, s and S are taken,
> > } so are c and C. We could use `=' but that would probably be too
> > } irritating.
> > 
> > Hrm.  How would a parameter flag do this on an array?  Parse each word
> > separately?
> 
> I wrote this at the weekend (quite simple) and, yes, it just split the 
> array's elements separately and then returned an array with all words
> from all elements.
> 
> > Hrm, again; maybe the way to do this is with a modifier rather than a
> > flag.  :S is available, and it'd be kinda fun to be able to apply this
> > to history as well as to parameters.  Or maybe it wouldn't ...
> 
> I'm withholding the patch I have because of this. I'll check how
> difficult this is to implement, but I guess it's equally simple.

I should have thought more about this yesterday...

Erm, the history modifier code only ever works on single words
(getting one, modifying it, returning it). So what exactly are we
supposed to do with shell-word splitted history words in a history
expansion? I mean, what should we do with/insert for `!!:S'. This
would only be uesful if there was a way to access the words resulting
from the splitting, right? So, how are we supposed to access them (the 
history word-number code is executed before the modifier code)?

Or maybe I'm missing something (I don't use history expansion that
often any more).

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

