From zsh-workers-request@euclid.skiles.gatech.edu Thu Mar 20 16:36:00 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 27153 invoked from network); 20 Mar 1997 16:35:53 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 20 Mar 1997 16:35:53 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id LAA08697; Thu, 20 Mar 1997 11:22:26 -0500 (EST)
Resent-Date: Thu, 20 Mar 1997 11:22:26 -0500 (EST)
Date: Thu, 20 Mar 1997 16:24:54 GMT
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <295.199703201624@stone.dcs.warwick.ac.uk>
Subject: zmodload cleanup
X-Patch: 213
Resent-Message-ID: <"rgp9-1.0.q72.1HMCp"@euclid>
To: zsh-workers@math.gatech.edu
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3009
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

bin_zmodload() is rather disorganised, internally.  This patch does
two things to make it clearer.  Firstly, it separates the three major
functions of the builtin (dependencies, autoloaded builtins and loading
modules) into separate functions, as has already been done with the
bindkey builtin.  Secondly, the zmodload -d syntax is changed slightly,
to be more orthogonal with the other zmodload syntaxes: -du is required
to remove dependencies, and individual dependencies can be removed.

 *** Doc/Zsh/builtins.yo	1997/03/20 02:24:39	1.9
 --- Doc/Zsh/builtins.yo	1997/03/20 03:42:21
 ***************
 *** 1279,1284 ****
 --- 1279,1285 ----
   xitem(tt(zmodload) [ tt(-iL) ] [ var(name) ... ])
   xitem(tt(zmodload) tt(-u) [ tt(-i) ] var(name) ...)
   xitem(tt(zmodload) tt(-d) [ tt(-L) ] [ var(name) [ var(dep) ... ] ])
 + xitem(tt(zmodload) tt(-du) var(name) [ var(dep) ... ])
   xitem(tt(zmodload) tt(-a) [ tt(-iL) ] [ var(name) [ var(builtin) ... ] ])
   item(tt(zmodload) tt(-au) [ tt(-i) ] var(builtin) ...)(
   Load a binary module.  The module must be in a file named either
 ***************
 *** 1308,1319 ****
   tt(zmodload) commands.
   
   The tt(-d) option can be used to specify module dependencies.
   The modules named in the second and subsequent arguments will be
 ! loaded before the module named in the first argument.  With one
 ! argument all dependencies for that module are removed.  With no
 ! arguments, all module dependencies are printed in Makefile format.
   The tt(-L) option changes this format to a list of
   tt(zmodload -d) commands.
   
   The tt(-a) option defines autoloaded builtins.  It defines the
   specified var(builtin)s.  When any of those builtins is called, the module
 --- 1309,1328 ----
   tt(zmodload) commands.
   
   The tt(-d) option can be used to specify module dependencies.
 + This operation is idempotent regardless of the tt(-i) option.
   The modules named in the second and subsequent arguments will be
 ! loaded before the module named in the first argument.
 ! 
 ! With tt(-d) and one
 ! argument, all dependencies for that module are listed.  With tt(-d) and no
 ! arguments, all module dependencies are listed.
 ! This listing is by default in a Makefile-like format.
   The tt(-L) option changes this format to a list of
   tt(zmodload -d) commands.
 + 
 + If tt(-d) and tt(-u) are both used, dependencies are removed.
 + This operation is idempotent regardless of the tt(-i) option.
 + If only one argument is given, all dependencies for that module are removed.
   
   The tt(-a) option defines autoloaded builtins.  It defines the
   specified var(builtin)s.  When any of those builtins is called, the module
 Index: Src/module.c
 ===================================================================
 RCS file: /home/zefram/usr/cvsroot/zsh/Src/module.c,v
 retrieving revision 1.24
 diff -c -r1.24 module.c
 *** Src/module.c	1997/03/20 02:24:45	1.24
 --- Src/module.c	1997/03/20 03:33:00
 ***************
 *** 408,516 ****
       putchar('\n');
   }
   
   /**/
   int
   bin_zmodload(char *nam, char **args, char *ops, int func)
   {
 !     LinkNode node;
 !     Module m = NULL;
 !     int ret = 0;
 ! 
 !     if((ops['d'] + (ops['a'] || ops['u'])) > 1) {
 ! 	zwarnnam(nam, "-d cannot be combined with -a and -u", NULL, 0);
   	return 1;
       }
 !     if (!*args) {
 ! 	if (ops['u']) {
 ! 	    zwarnnam(nam, "which module do you want to unload?", NULL, 0);
 ! 	    return 1;
 ! 	}
 ! 	if(ops['a']) {
 ! 	    scanhashtable(builtintab, 0, 0, 0,
 ! 		autoloadscan, ops['L'] ? PRINT_LIST : 0);
   	    return 0;
   	}
   	for (node = firstnode(modules); node; incnode(node)) {
   	    m = (Module) getdata(node);
 ! 	    if (ops['d']) {
 ! 		if (m->deps) {
 ! 		    LinkNode n;
 ! 
 ! 		    if(ops['L']) {
 ! 			printf("zmodload -d ");
 ! 			if(m->nam[0] == '-')
 ! 			    fputs("-- ", stdout);
 ! 			quotedzputs(m->nam, stdout);
 ! 		    } else {
 ! 			nicezputs(m->nam, stdout);
 ! 			putchar(':');
 ! 		    }
 ! 		    for (n = firstnode(m->deps); n; incnode(n)) {
 ! 			putchar(' ');
 ! 			if(ops['L'])
 ! 			    quotedzputs((char *) getdata(n), stdout);
 ! 			else
 ! 			    nicezputs((char *) getdata(n), stdout);
 ! 		    }
 ! 		    putchar('\n');
 ! 		}
 ! 	    } else if (m->handle) {
   		if(ops['L']) {
 ! 		    printf("zmodload ");
   		    if(m->nam[0] == '-')
   			fputs("-- ", stdout);
   		    quotedzputs(m->nam, stdout);
 ! 		} else
   		    nicezputs(m->nam, stdout);
   		putchar('\n');
   	    }
   	}
   	return 0;
 !     }
 !     if (ops['d']) {
   	char *tnam = *args++;
   
 - 	if (!*args) {
 - 	    node = find_module(tnam);
 - 	    if (!node)
 - 		return 0;
 - 	    m = (Module) getdata(node);
 - 	    if (m->deps) {
 - 		freelinklist(m->deps, freestr);
 - 		m->deps = NULL;
 - 	    }
 - 	    if (!m->handle) {
 - 		remnode(modules, node);
 - 		zsfree(m->nam);
 - 		zfree(m, sizeof(*m));
 - 	    }
 - 	    return 0;
 - 	}
   	while (*args)
   	    add_dep(tnam, *args++);
       }
 !     if (ops['a']) {
 ! 	char *modnam;
   	if (isset(RESTRICTED)) {
   	    zwarnnam(nam, "-a is not allowed in restricted mode", *args, 0);
   	    return 1;
   	}
 ! 	if (ops['u']) {
 ! 	    for (; *args; args++) {
 ! 		Builtin bn = (Builtin) builtintab->getnode2(builtintab, *args);
 ! 
 ! 		if (!bn) {
 ! 		    if(!ops['i']) {
 ! 			zwarnnam(nam, "%s: no such builtin", *args, 0);
 ! 			ret++;
 ! 		    }
 ! 		} else if (bn->handlerfunc || (bn->flags & BINF_PREFIX)) {
 ! 		    zwarnnam(nam, "%s: builtin is already defined", *args, 0);
 ! 		    ret++;
 ! 		} else
 ! 		    deletebuiltin(*args);
 ! 	    }
 ! 	    return ret;
   	}
   	modnam = *args++;
   	do {
 --- 408,549 ----
       putchar('\n');
   }
   
 + static int bin_zmodload_dep _((char *, char **, char *));
 + static int bin_zmodload_auto _((char *, char **, char *));
 + static int bin_zmodload_load _((char *, char **, char *));
 + 
   /**/
   int
   bin_zmodload(char *nam, char **args, char *ops, int func)
   {
 !     if(ops['d'] && ops['a']) {
 ! 	zwarnnam(nam, "-d cannot be combined with -a", NULL, 0);
   	return 1;
       }
 !     if (ops['u'] && !*args) {
 ! 	zwarnnam(nam, "what do you want to unload?", NULL, 0);
 ! 	return 1;
 !     }
 !     if(ops['d'])
 ! 	return bin_zmodload_dep(nam, args, ops);
 !     else if(ops['a'])
 ! 	return bin_zmodload_auto(nam, args, ops);
 !     else
 ! 	return bin_zmodload_load(nam, args, ops);
 ! }
 ! 
 ! static int
 ! bin_zmodload_dep(char *nam, char **args, char *ops)
 ! {
 !     LinkNode node;
 !     Module m;
 ! 
 !     if(ops['u']) {
 ! 	/* remove dependencies */
 ! 	char *tnam = *args++;
 ! 	node = find_module(tnam);
 ! 	if (!node)
   	    return 0;
 + 	m = (Module) getdata(node);
 + 	if(*args && m->deps) {
 + 	    do {
 + 		for(node = firstnode(m->deps); node; incnode(node))
 + 		    if(!strcmp(*args, getdata(node))) {
 + 			zsfree(getdata(node));
 + 			remnode(m->deps, node);
 + 			break;
 + 		    }
 + 	    } while(*++args);
 + 	    if(empty(m->deps)) {
 + 		freelinklist(m->deps, freestr);
 + 		m->deps = NULL;
 + 	    }
 + 	} else {
 + 	    if (m->deps) {
 + 		freelinklist(m->deps, freestr);
 + 		m->deps = NULL;
 + 	    }
 + 	}
 + 	if (!m->deps && !m->handle) {
 + 	    remnode(modules, node);
 + 	    zsfree(m->nam);
 + 	    zfree(m, sizeof(*m));
   	}
 + 	return 0;
 +     } else if(!args[0] || !args[1]) {
 + 	/* list dependencies */
   	for (node = firstnode(modules); node; incnode(node)) {
   	    m = (Module) getdata(node);
 ! 	    if (m->deps && (!args[0] || !strcmp(args[0], m->nam))) {
 ! 		LinkNode n;
 ! 
   		if(ops['L']) {
 ! 		    printf("zmodload -d ");
   		    if(m->nam[0] == '-')
   			fputs("-- ", stdout);
   		    quotedzputs(m->nam, stdout);
 ! 		} else {
   		    nicezputs(m->nam, stdout);
 + 		    putchar(':');
 + 		}
 + 		for (n = firstnode(m->deps); n; incnode(n)) {
 + 		    putchar(' ');
 + 		    if(ops['L'])
 + 			quotedzputs((char *) getdata(n), stdout);
 + 		    else
 + 			nicezputs((char *) getdata(n), stdout);
 + 		}
   		putchar('\n');
   	    }
   	}
   	return 0;
 !     } else {
 ! 	/* add dependencies */
   	char *tnam = *args++;
   
   	while (*args)
   	    add_dep(tnam, *args++);
 + 	return 0;
       }
 ! }
 ! 
 ! static int
 ! bin_zmodload_auto(char *nam, char **args, char *ops)
 ! {
 !     int ret = 0;
 ! 
 !     if(ops['u']) {
 ! 	/* remove autoloaded builtins */
   	if (isset(RESTRICTED)) {
   	    zwarnnam(nam, "-a is not allowed in restricted mode", *args, 0);
   	    return 1;
   	}
 ! 	for (; *args; args++) {
 ! 	    Builtin bn = (Builtin) builtintab->getnode2(builtintab, *args);
 ! 
 ! 	    if (!bn) {
 ! 		if(!ops['i']) {
 ! 		    zwarnnam(nam, "%s: no such builtin", *args, 0);
 ! 		    ret = 1;
 ! 		}
 ! 	    } else if (bn->handlerfunc || (bn->flags & BINF_PREFIX)) {
 ! 		zwarnnam(nam, "%s: builtin is already defined", *args, 0);
 ! 		ret = 1;
 ! 	    } else
 ! 		deletebuiltin(*args);
 ! 	}
 ! 	return ret;
 !     } else if(!*args) {
 ! 	/* list autoloaded builtins */
 ! 	scanhashtable(builtintab, 0, 0, 0,
 ! 	    autoloadscan, ops['L'] ? PRINT_LIST : 0);
 ! 	return 0;
 !     } else {
 ! 	/* add autoloaded builtins */
 ! 	char *modnam;
 ! 	if (isset(RESTRICTED)) {
 ! 	    zwarnnam(nam, "-a is not allowed in restricted mode", *args, 0);
 ! 	    return 1;
   	}
   	modnam = *args++;
   	do {
 ***************
 *** 525,533 ****
   	} while(*args);
   	return ret;
       }
 !     for (; *args; args++) {
 ! 	node = find_module(*args);
 ! 	if (ops['u']) {
   	    if (node) {
   		LinkNode mn, dn;
   
 --- 558,576 ----
   	} while(*args);
   	return ret;
       }
 ! }
 ! 
 ! static int
 ! bin_zmodload_load(char *nam, char **args, char *ops)
 ! {
 !     LinkNode node;
 !     Module m;
 !     int ret = 0;
 ! 
 !     if(ops['u']) {
 ! 	/* unload modules */
 ! 	for(; *args; args++) {
 ! 	    node = find_module(*args);
   	    if (node) {
   		LinkNode mn, dn;
   
 ***************
 *** 537,550 ****
   			for (dn = firstnode(m->deps); dn; incnode(dn))
   			    if (!strcmp((char *) getdata(dn), *args)) {
   				zwarnnam(nam, "module %s is in use by another module and cannot be unloaded", *args, 0);
 ! 				ret++;
   				goto cont;
   			    }
   		}
   
   		m = (Module) getdata(node);
   		if (m->handle && cleanup_module(m))
 ! 		    ret++;
   		else {
   		    if (m->handle)
   			dlclose(m->handle);
 --- 580,593 ----
   			for (dn = firstnode(m->deps); dn; incnode(dn))
   			    if (!strcmp((char *) getdata(dn), *args)) {
   				zwarnnam(nam, "module %s is in use by another module and cannot be unloaded", *args, 0);
 ! 				ret = 1;
   				goto cont;
   			    }
   		}
   
   		m = (Module) getdata(node);
   		if (m->handle && cleanup_module(m))
 ! 		    ret = 1;
   		else {
   		    if (m->handle)
   			dlclose(m->handle);
 ***************
 *** 556,577 ****
   		}
   	    } else if (!ops['i']) {
   		zwarnnam(nam, "no such module %s", *args, 0);
 ! 		ret++;
   	    }
 ! 	} else if (node && ((Module) getdata(node))->handle) {
 ! 	    if (!ops['i']) {
 ! 		zwarnnam(nam, "module %s already loaded.", *args, 0);
 ! 		ret++;
 ! 	    }
 ! 	} else if (isset(RESTRICTED) && strchr(*args, '/')) {
 ! 	    zwarnnam(nam, "%s: restricted", *args, 0);
 ! 	    ret++;
 ! 	} else if (!load_module(*args))
 ! 	    ret++;
 !       cont:
 ! 	;
       }
 -     return ret;
   }
   
   #endif /* DYNAMIC */
 --- 599,642 ----
   		}
   	    } else if (!ops['i']) {
   		zwarnnam(nam, "no such module %s", *args, 0);
 ! 		ret = 1;
   	    }
 ! 	    cont: ;
 ! 	}
 ! 	return ret;
 !     } else if(!*args) {
 ! 	/* list modules */
 ! 	for (node = firstnode(modules); node; incnode(node)) {
 ! 	    m = (Module) getdata(node);
 ! 	    if (m->handle) {
 ! 		if(ops['L']) {
 ! 		    printf("zmodload ");
 ! 		    if(m->nam[0] == '-')
 ! 			fputs("-- ", stdout);
 ! 		    quotedzputs(m->nam, stdout);
 ! 		} else
 ! 		    nicezputs(m->nam, stdout);
 ! 		putchar('\n');
 ! 	    }
 ! 	}
 ! 	return 0;
 !     } else {
 ! 	/* load modules */
 ! 	for (; *args; args++) {
 ! 	    node = find_module(*args);
 ! 	    if (node && ((Module) getdata(node))->handle) {
 ! 		if (!ops['i']) {
 ! 		    zwarnnam(nam, "module %s already loaded.", *args, 0);
 ! 		    ret = 1;
 ! 		}
 ! 	    } else if (isset(RESTRICTED) && strchr(*args, '/')) {
 ! 		zwarnnam(nam, "%s: restricted", *args, 0);
 ! 		ret = 1;
 ! 	    } else if (!load_module(*args))
 ! 		ret = 1;
 ! 	}
 ! 	return ret;
       }
   }
   
   #endif /* DYNAMIC */

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia
Charset: ascii

iQCVAwUBMzC0kXD/+HJTpU/hAQEKnwP+Jr6jGlYbHky/zL8X5GyNMXNjUlcPgzGD
I0a8DmYd44WbFG7khC7qLDZwyHlx9x99QKtnHXFQ8nC2rUuT+ywK/hbOcAn80bgL
QbziTzhtDEUmQ4IsjzqH33PNdVnoGo6RRqSSxaIwDBTexWzpb0FDeh0+gthIFMVT
L5b7i3wNCDA=
=McH2
-----END PGP SIGNATURE-----

