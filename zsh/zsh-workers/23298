From zsh-workers-return-23298-mason-zsh=primenet.com.au@sunsite.dk Wed Apr 18 08:22:36 2007
Return-Path: <zsh-workers-return-23298-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18660 invoked from network); 18 Apr 2007 08:22:34 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.8 (2007-02-13) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.4 required=5.0 tests=AWL,BAYES_00,FORGED_RCVD_HELO
	autolearn=ham version=3.1.8
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 18 Apr 2007 08:22:34 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 59012 invoked from network); 18 Apr 2007 08:22:29 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 18 Apr 2007 08:22:29 -0000
Received: (qmail 675 invoked by alias); 18 Apr 2007 08:22:25 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 23298
Received: (qmail 658 invoked from network); 18 Apr 2007 08:22:23 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 18 Apr 2007 08:22:23 -0000
Received: (qmail 58676 invoked from network); 18 Apr 2007 08:22:23 -0000
Received: from smtpout0170.sc1.he.tucows.com (HELO n082.sc1.he.tucows.com) (64.97.136.170)
  by a.mx.sunsite.dk with SMTP; 18 Apr 2007 08:22:19 -0000
Received: from sc.homeunix.net (82.26.175.65) by n082.sc1.he.tucows.com (7.2.069.1)
        id 4622D7FD00037043; Wed, 18 Apr 2007 08:22:10 +0000
Received: from chazelas by sc.homeunix.net with local (Exim 4.63)
	(envelope-from <stephane_chazelas@yahoo.fr>)
	id 1He5QT-0001ra-Dv; Wed, 18 Apr 2007 09:22:05 +0100
Date: Wed, 18 Apr 2007 09:22:05 +0100
From: Stephane Chazelas <Stephane_Chazelas@yahoo.fr>
To: Tom Alsberg <alsbergt@cs.huji.ac.il>
Cc: Zsh Workers List <zsh-workers@sunsite.dk>
Subject: Re: (Off-Topic)  Re: Bug in ulimit ?
Message-ID: <20070418082205.GB5267@sc.homeunix.net>
Mail-Followup-To: Tom Alsberg <alsbergt@cs.huji.ac.il>,
	Zsh Workers List <zsh-workers@sunsite.dk>
References: <462493C0.20700@cowan.name> <20070417141526.GA56078@cs.huji.ac.il> <20070417151501.GH4955@sc.homeunix.net> <20070418074656.GA90534@cs.huji.ac.il>
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="tThc/1wpZn/ma/RB"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <20070418074656.GA90534@cs.huji.ac.il>
User-Agent: Mutt/1.5.6i


--tThc/1wpZn/ma/RB
Content-Type: text/plain; charset=iso-8859-15
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

On Wed, Apr 18, 2007 at 10:46:56AM +0300, Tom Alsberg wrote:
> (Repost top zsh-workers in case it may be of interest, original
>  address was misspelled)
[...]

Hi Tom.

Have you got trouble posting to the list as well? At least one
of the emails I posted yesterday didn't make it (the one
attached). Did you receive it (as I think you were in copy)? I
eventually received the email attachment with the patch the
lkml, but as a separate email!

Cheers,
Stéphane

--tThc/1wpZn/ma/RB
Content-Type: message/rfc822
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

Date: Tue, 17 Apr 2007 20:53:09 +0100
From: Stephane Chazelas <Stephane_Chazelas@yahoo.fr>
To: Tom Alsberg <alsbergt@cs.huji.ac.il>
Cc: Zsh Workers List <zsh-workers@zsh.org>
Subject: Re: (Off-Topic)  Re: Bug in ulimit ?
Message-ID: <20070417195309.GA4976@sc.homeunix.net>
Mail-Followup-To: Tom Alsberg <alsbergt@cs.huji.ac.il>,
	Zsh Workers List <zsh-workers@zsh.org>
References: <462493C0.20700@cowan.name> <20070417141526.GA56078@cs.huji.ac.il> <20070417151501.GH4955@sc.homeunix.net> <20070417185925.GA62407@cs.huji.ac.il>
Mime-Version: 1.0
Content-Type: text/plain; charset=iso-8859-15
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <20070417185925.GA62407@cs.huji.ac.il>
User-Agent: Mutt/1.5.6i

On Tue, Apr 17, 2007 at 09:59:25PM +0300, Tom Alsberg wrote:
> On Tue, Apr 17, 2007 at 04:15:01PM +0100, Stephane Chazelas wrote:
> > Hi Tom,
> > 
> > I couldn't find the attachment,
> 
> That is weird - I checked and did attach it, and it even appears in
> the zsh-workers archives at:

Could very well be on my side. I think I've already had issues
like that in the past. Could be yahoo or fetchmail or mutt, I'll
investigate.

Sorry about that.

[...]
> > I don't have time to try it, but I think an easy fix would be to
> > change the sys_setrlimit() code to still keep the value of the
> > cpu-limit timer as 0 as before, but to schedule the processing of
> > CPU timers for the next tick instead of for the next second (which
> > was wrong as it would delay an itimer),
> 
> Since the scheduling is done somewhere else in the code, that may
> require saving some other piece of information to differentiate
> between a zero value meaning "limit not set" and a zero value meaning
> "break immediately".  Thinking of it now, I am not quite sure why a
> value of zero is necessary at all to denote the limit was never set
> (where is that information necessary?), and whether the initial value
> could not be set to infinity or the hard limit.  But again, this logic
> was there already, and is beyond the scope of this small fix.

Sorry, I wasn't very clear. I didn't mean scheduling as in
process/task scheduling, but as in sceduling of the function
that will check the timers to be fired. The "cheat" wasn't
modifying the current value of the rlimit from 0 to 1 second, it
was just scheduling the next checking for whether that limit is
reached or not to 1 second from now. So that the process would
keep running for 1 second of CPU time with a pending SIGXCPU
largely overdue.

That's why I mentionned the setitimer(ITIMER_PROF). If you
install such a timer, you rescedule the function that checks the
timers to be fired (at least the timers that work in CPU time
such as those "PROF" timers and the cpu rlimit). If you install
such an itimer with a very small timeout just after a ulimit -t
0, you'll find that the process receives the SIGXCPU upon the
expiry of that timer, not after the 1 second delay, I don't know
if that was intentional or not.

> 
> > and at the time of the fork, make sure the it_prof_expirer in
> > copy_signal is not set to zero (for instance, schedule it for the
> > first tick, as in the code in copy_process).
> 
> I have very little with the profiling code in Linux, so I am not sure
> whether this alone will do.
[...]

My understanding is that if one does ulimit -t 0, he wants the
process to get a SIGCPU as soon as it uses the CPU.

The fix I had in mind is below:

--- kernel/fork.c~	2007-04-17 20:23:29.000000000 +0100
+++ kernel/fork.c	2007-04-17 20:14:32.000000000 +0100
@@ -830,6 +830,7 @@ static inline int copy_signal(unsigned l
 {
 	struct signal_struct *sig;
 	int ret;
+	unsigned long cpu_rlimit;
 
 	if (clone_flags & CLONE_THREAD) {
 		atomic_inc(&current->signal->count);
@@ -884,13 +885,16 @@ static inline int copy_signal(unsigned l
 	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
 	task_unlock(current->group_leader);
 
-	if (sig->rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY) {
+	cpu_rlimit = sig->rlim[RLIMIT_CPU].rlim_cur;
+	if (cpu_rlimit != RLIM_INFINITY) {
 		/*
 		 * New sole thread in the process gets an expiry time
 		 * of the whole CPU time limit.
 		 */
-		tsk->it_prof_expires =
-			secs_to_cputime(sig->rlim[RLIMIT_CPU].rlim_cur);
+		if (cpu_rlimit == 0)
+			tsk->it_prof_expires = jiffies_to_cputime(1);
+		else
+			tsk->it_prof_expires = secs_to_cputime(cpu_rlimit);
 	}
 	acct_init_pacct(&sig->pacct);
 
--- kernel/sys.c~	2007-04-17 20:09:28.000000000 +0100
+++ kernel/sys.c	2007-04-17 20:16:02.000000000 +0100
@@ -1941,19 +1941,13 @@ asmlinkage long sys_setrlimit(unsigned i
 
 	it_prof_secs = cputime_to_secs(current->signal->it_prof_expires);
 	if (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {
-		unsigned long rlim_cur = new_rlim.rlim_cur;
 		cputime_t cputime;
 
-		if (rlim_cur == 0) {
-			/*
-			 * The caller is asking for an immediate RLIMIT_CPU
-			 * expiry.  But we use the zero value to mean "it was
-			 * never set".  So let's cheat and make it one second
-			 * instead
-			 */
-			rlim_cur = 1;
-		}
-		cputime = secs_to_cputime(rlim_cur);
+		if (new_rlim.rlim_cur == 0)
+			cputime = jiffies_to_cputime(1);
+		else
+			cputime = secs_to_cputime(new_rlim.rlim_cur);
+		
 		read_lock(&tasklist_lock);
 		spin_lock_irq(&current->sighand->siglock);
 		set_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);

instead of scheduling it for in one seconds, it schedules it for
the next tick (jiffy), which is kind of more consistent with my
idea of what ulimit -t does, and doesn't explicitely modify what
the user requested.

To get back on topic (slightly :)), with that patch applied, I
get:

$ zsh -c 'float SECONDS; trap "" XCPU; ulimit -t 0
  (trap "echo \$SECONDS" XCPU; while :; do :; done); echo done'
3.253000000e-03
1.009181000e+00
2.019183000e+00
....


(when SIGXCPU is intercepted, Linux resends it every second
until the hard limit is reached).

-- 
Stéphane

--tThc/1wpZn/ma/RB--

