From zsh-workers-return-7796-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Sep 13 09:47:47 1999
Return-Path: <zsh-workers-return-7796-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4545 invoked from network); 13 Sep 1999 09:47:45 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 13 Sep 1999 09:47:45 -0000
Received: (qmail 1602 invoked by alias); 13 Sep 1999 09:47:40 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7796
Received: (qmail 1595 invoked from network); 13 Sep 1999 09:47:39 -0000
Date: Mon, 13 Sep 1999 11:47:37 +0200 (MET DST)
Message-Id: <199909130947.LAA05599@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: some more fixes in the completion funcs


1) A fix for the `-+/+-' forms for `_arguments'.
2) Make `_arguments' use `describe_values' for `((...))' actions.
   Hope you find this ok.
3) `_values' was doubled.
4) Misc fixes.

Bye
 Sven

diff -u od/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- od/Zsh/compsys.yo	Thu Sep  9 16:31:34 1999
+++ Doc/Zsh/compsys.yo	Sun Sep 12 20:09:31 1999
@@ -797,7 +797,10 @@
 doubled parentheses, as in `tt(:foo:((a\:bar b\:baz)))' should contain 
 strings consisting of the string to complete followed by a colon
 (which needs to be preceded by a backslash) and a description. The
-matches will be listed together with their descriptions.
+matches will be listed together with their descriptions if the
+value of configuration key tt(describe_values) is non-empty and does
+not contain the substring `tt(!)var(command)', where `var(command)' is 
+the name of the command on the line.
 
 An var(action) of the form `tt(->)var(string)' is used by functions
 that implement a state machine. In this case, the `var(string)' (with
diff -u -r oldcompletion/Base/_arguments Completion/Base/_arguments
--- oldcompletion/Base/_arguments	Mon Sep 13 10:37:18 1999
+++ Completion/Base/_arguments	Sun Sep 12 22:34:26 1999
@@ -209,7 +209,7 @@
 
     # Description for both the `-foo' and `+foo' form?
 
-    if [[ "$1" = (\*|)(-+|+-)* ]]; then
+    if [[ "$1" = (\*|)(-+|+-)[^:]* ]]; then
 
       # With a `*' at the beginning, the option may appear more than
       # once.
@@ -257,7 +257,7 @@
         [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
       else
         tmp="${1%%:*}"
-        [[ "$tmp" = *[-+] ]] && tmp="$tmp[1,-2]"
+        [[ "$tmp" = [-+]?*[-+] ]] && tmp="$tmp[1,-2]"
 	xor="$xor ${tmp%\=}"
       fi
 
@@ -275,7 +275,7 @@
       else
         _args_cache_opts[$tmp]=''
       fi
-      _args_cache_odescr=( "$_args_cache_odescr[@]" "${tmp%[-+=]}:$descr" )
+      _args_cache_odescr=( "$_args_cache_odescr[@]" "${tmp%\=}:$descr" )
       [[ -n "$xor" ]] && 
           _args_cache_xors[${tmp%\=}]="${${xor##[ 	]#}%%[ 	]#}"
     elif [[ "$1" = \*::* ]]; then
@@ -774,11 +774,16 @@
 
         eval ws\=\( "${action[3,-3]}" \)
 
-	if _display tmp ws -M 'r:|[_-]=* r:|=*'; then
-          compadd "$expl[@]" -y tmp - "${(@)ws%%:*}"
+	if [[ -n "$compconfig[describe_values]" &&
+              "$compconfig[describe_values]" != *\!${cmd}* ]]; then
+          if _display tmp ws -M 'r:|[_-]=* r:|=*'; then
+            compadd "$expl[@]" -y tmp - "${(@)ws%%:*}"
+          else
+            [[ -n "$matched" ]] && compadd -Q -S -s "$SUFFIX" - "$PREFIX"
+            _message "$descr"
+          fi
         else
-          [[ -n "$matched" ]] && compadd -Q -S -s "$SUFFIX" - "$PREFIX"
-          _message "$descr"
+	  compadd "$expl[@]" - "${(@)ws%%:*}"
         fi
       elif [[ "$action" = \(*\) ]]; then
 
diff -u -r oldcompletion/Base/_values Completion/Base/_values
--- oldcompletion/Base/_values	Mon Sep 13 10:37:18 1999
+++ Completion/Base/_values	Sat Sep 11 00:57:01 1999
@@ -3,7 +3,7 @@
 setopt localoptions extendedglob
 
 local name arg def descr xor str tmp ret=1 expl nm="$compstate[nmatches]"
-local snames odescr gdescr sep
+local snames odescr gdescr sep esep spat
 typeset -A names onames xors _values
 
 # Probably fill our cache.
@@ -11,7 +11,7 @@
 if [[ "$*" != "$_vals_cache_args" ]]; then
   _vals_cache_args="$*"
 
-  unset _vals_cache_{sep,descr,names,onames,snames,xors,odescr}
+  unset _vals_cache_{sep,esep,descr,names,onames,snames,xors,odescr}
 
   typeset -gA _vals_cache_{names,onames,xors}
   _vals_cache_snames=()
@@ -21,6 +21,7 @@
 
   if [[ "$1" = -s ]]; then
     _vals_cache_sep="$2"
+    [[ -z "$2" ]] && _vals_cache_esep=yes
     shift 2
   fi
 
@@ -107,388 +108,34 @@
 odescr=( "$_vals_cache_odescr[@]" )
 gdescr="$_vals_cache_descr"
 sep="$_vals_cache_sep"
+esep="$_vals_cache_esep"
 
-if [[ -n "$sep" ]]; then
+if [[ -n "$sep$esep" ]]; then
 
   # We have a separator character. We parse the PREFIX and SUFFIX to
   # see if any of the values that must not appear more than once are
   # already on the line.
 
-  while [[ "$PREFIX" = *${sep}* ]]; do
-
-    # Get one part, remove it from PREFIX and put it into IPREFIX.
-
-    tmp="${PREFIX%%${sep}*}"
-    PREFIX="${PREFIX#*${sep}}"
-    IPREFIX="${IPREFIX}${tmp}${sep}"
+  if [[ -n "$esep" ]]; then
+    spat='?*'
+  else
+    spat="*${sep}*"
+  fi
 
-    # Get the value `name'.
+  while [[ "$PREFIX" = $~spat ]]; do
 
-    name="${tmp%%\=*}"
+    # Get one part, remove it from PREFIX and put it into IPREFIX.
 
-    if [[ "$tmp" = *\=* ]]; then
-      _values[$name]="${tmp#*\=}"
+    if [[ -n "$esep" ]]; then
+      tmp="$PREFIX[1]"
+      IPREFIX="${IPREFIX}${tmp}"
+      PREFIX="${PREFIX[2,-1]}"
     else
-      _values[$name]=''
-    fi
-
-    # And remove the descriptions for the values this one makes
-    # superfluous.
-
-    if [[ -n "$xors[$name]" ]]; then
-      snames=( "${(@)snames:#(${(j:|:)~${=xors[$name]}})}" )
-      odescr=( "${(@)odescr:#(${(j:|:)~${=xors[$name]}}):*}" )
-      unset {names,onames,xors}\[${^=tmp}\]
-    fi
-  done
-  if [[ "$SUFFIX" =  *${sep}* ]]; then
-
-    # The same for the suffix.
-
-    str="${SUFFIX%%${sep}*}"
-    SUFFIX="${SUFFIX#*${sep}}"
-    while [[ -n "$SUFFIX" ]]; do
       tmp="${PREFIX%%${sep}*}"
-      if [[ "$SUFFIX" = *${sep}* ]]; then
-        SUFFIX="${SUFFIX#*${sep}}"
-      else
-        SUFFIX=''
-      fi
       PREFIX="${PREFIX#*${sep}}"
       IPREFIX="${IPREFIX}${tmp}${sep}"
-
-      name="${tmp%%\=*}"
-
-      if [[ "$tmp" = *\=* ]]; then
-        _values[$name]="${tmp#*\=}"
-      else
-        _values[$name]=''
-      fi
-
-      if [[ -n "$xors[$name]" ]]; then
-        snames=( "${(@)snames:#(${(j:|:)~${=xors[$name]}})}" )
-        odescr=( "${(@)odescr:#(${(j:|:)~${=xors[$name]}}):*}" )
-        unset {names,onames,xors}\[${^=tmp}\]
-      fi
-    done
-    SUFFIX="$str"
-  fi
-fi
-
-descr=''
-str="$PREFIX$SUFFIX"
-
-if [[ "$str" = *\=* ]]; then
-
-  # The string from the line contains a `=', so we get the stuff before
-  # it and after it and see what we can do here...
-
-  name="${str%%\=*}"
-  arg="${str#*\=}"
-
-  if (( $snames[(I)${name}] )); then
-
-    # According to our information, the value doesn't get an argument,
-    # so give up.
-
-    _message "\`${name}' gets no value"
-    return 1
-  elif (( $+names[$name] )); then
-
-    # It has to get an argument, we skip over the name and complete
-    # the argument (below).
-
-    def="$names[$name]"
-    if ! compset -P '*\='; then
-      IPREFIX="${IPREFIX}${name}="
-      PREFIX="$arg"
-      SUFFIX=''
-    fi
-  elif (( $+onames[$name] )); then
-
-    # Gets an optional argument, same as previous case.
-
-    def="$onames[$name]"
-    if ! compset -P '*\='; then
-      IPREFIX="${IPREFIX}${name}="
-      PREFIX="$arg"
-      SUFFIX=''
-    fi
-  else
-    local pre="$PREFIX" suf="$SUFFIX"
-
-    # The part before the `=' isn't a known value name, so we see if
-    # it matches only one of the known names.
-
-    if [[ "$PREFIX" = *\=* ]]; then
-      PREFIX="${PREFIX%%\=*}"
-      pre="${pre#*\=}"
-      SUFFIX=''
-    else
-      SUFFIX="${SUFFIX%%\=*}"
-      pre="${suf#*\=}"
-      suf=''
-    fi
-
-    tmp=( "${(@k)names}" "${(@k)onames}" )
-    compadd -M 'r:|[-_]=* r:|=*' -D tmp - "$tmp[@]"
-
-    if [[ $#tmp -eq 1 ]]; then
-
-      # It does, so we use that name and immediatly start completing
-      # the argument for it.
-
-      IPREFIX="${IPREFIX}${tmp[1]}="
-      PREFIX="$pre"
-      SUFFIX="$suf"
-
-      def="$names[$tmp[1]]"
-      [[ -z "$def" ]] && def="$onames[$tmp[1]]"
-    elif (( $#tmp )); then
-      _message "ambiguous option \`${PREFIX}${SUFFIX}'"
-      return 1
-    else
-      _message "unknown option \`${PREFIX}${SUFFIX}'"
-      return 1
-    fi
-  fi
-else
-
-  # No `=', just complete value names.
-
-  _description expl "$gdescr"
-
-  [[ -n "$sep" && ${#snames}+${#names}+${#onames} -ne 1 ]] &&
-      expl=( "-qS$sep" "$expl[@]" )
-
-  tmp=''
-  if [[ -n "$compconfig[describe_values]" &&
-        "$compconfig[describe_values]" != *\!${words[1]}* ]]; then
-    if _display tmp odescr -M 'r:|[_-]=* r:|=*'; then
-      if (( $#snames )); then
-        compadd "$expl[@]" -y tmp -M 'r:|[_-]=* r:|=*' - \
-                "$snames[@]" && ret=0
-        compadd -n -S= -J "_$gdescr" -M 'r:|[_-]=* r:|=*' - \
-                "${(@k)names}" && ret=0
-        compadd -n -qS= -J "_$gdescr" -M 'r:|[_-]=* r:|=*' - \
-                "${(@k)onames}" && ret=0
-      elif (( $#names )); then
-        compadd -n -S= "$expl[@]" -y tmp -M 'r:|[_-]=* r:|=*' - \
-                "${(@k)names}" && ret=0
-        compadd -n -qS= -J "_$gdescr" -M 'r:|[_-]=* r:|=*' - \
-                "${(@k)onames}" && ret=0
-      else
-        compadd -n -qS= "$expl[@]" -y tmp -M 'r:|[_-]=* r:|=*' - \
-                "${(@k)onames}" && ret=0
-      fi
-    fi
-  fi
-  if [[ -z "$tmp" ]]; then
-    compadd "$expl[@]" -M 'r:|[_-]=* r:|=*' - "$snames[@]" && ret=0
-    compadd -S= "$expl[@]" -M 'r:|[_-]=* r:|=*' - "${(@k)names}" && ret=0
-    compadd -qS= "$expl[@]" -M 'r:|[_-]=* r:|=*' - "${(@k)onames}" && ret=0
-  fi
-  return ret
-fi
-
-if [[ -z "$def" ]]; then
-  _message 'no value'
-  return 1
-else
-  local action
-
-  descr="${${${(M)def#*[^\\]:}[1,-2]}//\\\\:/:}"
-  action="${${def#*[^\\]:}//\\\\:/:}"
-
-  _description expl "$descr"
-
-  # We add the separator character as a autoremovable suffix unless
-  # we have only one possible value left.
-
-  [[ -n "$sep" && ${#snames}+${#names}+${#onames} -ne 1 ]] &&
-      expl=( "-qS$sep" "$expl[@]" )
-
-  if [[ "$action" = -\>* ]]; then
-    values=( "${(@kv)_values}" )
-    state="${${action[3,-1]##[ 	]#}%%[ 	]#}"
-    compstate[restore]=''
-    return 1
-  else
-    typeset -A values
-
-    values=( "${(@kv)_values}" )
-
-    if [[ "$action" = \ # ]]; then
-
-      # An empty action means that we should just display a message.
-
-      _message "$descr"
-      return 1
-
-    elif [[ "$action" = \(\(*\)\) ]]; then
-      local ws
-
-      # ((...)) contains literal strings with descriptions.
-
-      eval ws\=\( "${action[3,-3]}" \)
-
-      if _display tmp ws; then
-        compadd "$expl[@]" -y tmp - "${(@)ws%%:*}"
-      else
-        _message "$descr"
-        return 1
-      fi
-    elif [[ "$action" = \(*\) ]]; then
-
-      # Anything inside `(...)' is added directly.
-
-      compadd "$expl[@]" - ${=action[2,-2]}
-    elif [[ "$action" = \{*\} ]]; then
-
-      # A string in braces is evaluated.
-
-      eval "$action[2,-2]"
-
-    elif [[ "$action" = \ * ]]; then
-
-      # If the action starts with a space, we just call it.
-
-      ${(e)=~action}
-    else
-
-      # Otherwise we call it with the description-arguments built above.
-
-      action=( $=action )
-      ${(e)action[1]} "$expl[@]" ${(e)~action[2,-1]}
-    fi
-  fi
-fi
-
-[[ nm -ne "$compstate[nmatches]" ]]
-#autoload
-
-setopt localoptions extendedglob
-
-local name arg def descr xor str tmp ret=1 expl nm="$compstate[nmatches]"
-local snames odescr gdescr sep
-typeset -A names onames xors _values
-
-# Probably fill our cache.
-
-if [[ "$*" != "$_vals_cache_args" ]]; then
-  _vals_cache_args="$*"
-
-  unset _vals_cache_{sep,descr,names,onames,snames,xors,odescr}
-
-  typeset -gA _vals_cache_{names,onames,xors}
-  _vals_cache_snames=()
-  _vals_cache_odescr=()
-
-  # Get the separator, if any.
-
-  if [[ "$1" = -s ]]; then
-    _vals_cache_sep="$2"
-    shift 2
-  fi
-
-  # This is the description string for the values.
-
-  _vals_cache_descr="$1"
-  shift
-
-  # Now parse the descriptions.
-
-  while (( $# )); do
-
-    # Get the `name', anything before an unquoted colon.
-
-    if [[ "$1" = *[^\\]:* ]]; then
-      name="${${${(M)1#*[^\\]:}[1,-2]}//\\\\:/:}"
-    else
-      name="$1"
     fi
 
-    descr=''
-    xor=''
-
-    # Get a description, if any.
-
-    if [[ "$name" = *\[*\] ]]; then
-      descr="${${name#*\[}[1,-2]}"
-      name="${name%%\[*}"
-    fi
-
-    # Get the names of other values that are mutually exclusive with
-    # this one.
-
-    if [[ "$name" = \(*\)* ]]; then
-      xor="${${name[2,-1]}%%\)*}"
-      name="${name#*\)}"
-    fi
-
-    # Finally see if this value may appear more than once.
-
-    if [[ "$name" = \** ]]; then
-      name="$name[2,-1]"
-    else
-      xor="$xor $name"
-    fi
-
-    # Store the information in the cache.
-
-    _vals_cache_odescr=( "$_vals_cache_odescr[@]" "${name}:$descr" )
-    [[ -n "$xor" ]] && _vals_cache_xors[$name]="${${xor##[ 	]#}%%[ 	]#}"
-
-    # Get the description and store that.
-
-    if [[ "$1" = *[^\\]:* ]]; then
-      descr=":${1#*[^\\]:}"
-    else
-      descr=''
-    fi
-
-    if [[ "$descr" = ::* ]]; then
-
-       # Optional argument.
-
-      _vals_cache_onames[$name]="$descr[3,-1]"
-    elif [[ "$descr" = :* ]]; then
-
-      # Mandatory argument.
-
-      _vals_cache_names[$name]="$descr[2,-1]"
-    else
-
-      # No argument.
-
-      _vals_cache_snames=( "$_vals_cache_snames[@]" "$name" )
-    fi
-    shift
-  done
-fi
-
-snames=( "$_vals_cache_snames[@]" )
-names=( "${(@kv)_vals_cache_names}" )
-onames=( "${(@kv)_vals_cache_onames}" )
-xors=( "${(@kv)_vals_cache_xors}" )
-odescr=( "$_vals_cache_odescr[@]" )
-gdescr="$_vals_cache_descr"
-sep="$_vals_cache_sep"
-
-if [[ -n "$sep" ]]; then
-
-  # We have a separator character. We parse the PREFIX and SUFFIX to
-  # see if any of the values that must not appear more than once are
-  # already on the line.
-
-  while [[ "$PREFIX" = *${sep}* ]]; do
-
-    # Get one part, remove it from PREFIX and put it into IPREFIX.
-
-    tmp="${PREFIX%%${sep}*}"
-    PREFIX="${PREFIX#*${sep}}"
-    IPREFIX="${IPREFIX}${tmp}${sep}"
-
     # Get the value `name'.
 
     name="${tmp%%\=*}"
@@ -505,24 +152,34 @@
     if [[ -n "$xors[$name]" ]]; then
       snames=( "${(@)snames:#(${(j:|:)~${=xors[$name]}})}" )
       odescr=( "${(@)odescr:#(${(j:|:)~${=xors[$name]}}):*}" )
-      unset {names,onames,xors}\[${^=tmp}\]
+      unset {names,onames,xors}\[$name\]
     fi
   done
-  if [[ "$SUFFIX" =  *${sep}* ]]; then
+  if [[ "$SUFFIX" = $~spat ]]; then
 
     # The same for the suffix.
 
-    str="${SUFFIX%%${sep}*}"
-    SUFFIX="${SUFFIX#*${sep}}"
+    if [[ -n "$esep" ]]; then
+      str=''
+    else
+      str="${SUFFIX%%${sep}*}"
+      SUFFIX="${SUFFIX#*${sep}}"
+    fi
+
     while [[ -n "$SUFFIX" ]]; do
-      tmp="${PREFIX%%${sep}*}"
-      if [[ "$SUFFIX" = *${sep}* ]]; then
-        SUFFIX="${SUFFIX#*${sep}}"
-      else
-        SUFFIX=''
+      if [[ -n "$esep" ]]; then
+        tmp="$SUFFIX[-1]"
+        ISUFFIX="${SUFFIX[-1]}$ISUFFIX"
+	SUFFIX="$SUFFIX[1,-2]"
+      else
+        tmp="${SUFFIX##*${sep}}"
+        if [[ "$SUFFIX" = *${sep}* ]]; then
+          SUFFIX="${SUFFIX%${sep}*}"
+        else
+          SUFFIX=''
+        fi
+	ISUFFIX="${sep}${tmp}${ISUFFIX}"
       fi
-      PREFIX="${PREFIX#*${sep}}"
-      IPREFIX="${IPREFIX}${tmp}${sep}"
 
       name="${tmp%%\=*}"
 
@@ -535,7 +192,7 @@
       if [[ -n "$xors[$name]" ]]; then
         snames=( "${(@)snames:#(${(j:|:)~${=xors[$name]}})}" )
         odescr=( "${(@)odescr:#(${(j:|:)~${=xors[$name]}}):*}" )
-        unset {names,onames,xors}\[${^=tmp}\]
+        unset {names,onames,xors}\[$name\]
       fi
     done
     SUFFIX="$str"
diff -u -r oldcompletion/Core/_display Completion/Core/_display
--- oldcompletion/Core/_display	Mon Sep 13 10:37:51 1999
+++ Completion/Core/_display	Sat Sep 11 00:56:42 1999
@@ -23,11 +23,12 @@
 # Remove all descriptions not matched by the string on the line.
 
 if [[ "${2[1]}" = \( ]]; then
-  _arr=( ${(o)=2[2,-2]} )
+  _arr=( ${(Qo)=2[2,-2]} )
 else
   _arr=( "${(@Po)2}" )
 fi
 
+_arr=( "${(@)_arr:#}" )
 compadd -D _arr "${(@)argv[3,-1]}" - "${(@)_arr%%:*}"
 
 [[ "${2[1]}" != \( ]] && eval "${2}=( \"\$_arr[@]\" )"
@@ -68,7 +69,7 @@
   (( $#_simple )) && _tmp="${_tmp}
 $(print -c - $_simple)"
 
-  eval "${_param}=${(q)_tmp[2,-1]}"
+  eval "${_param}=\"\${_tmp[2,-1]}\""
 
   return 0
 else
diff -u -r oldcompletion/Core/_list Completion/Core/_list
--- oldcompletion/Core/_list	Mon Sep 13 10:37:51 1999
+++ Completion/Core/_list	Thu Sep  9 22:05:53 1999
@@ -43,7 +43,7 @@
 # Should we only show a list now?
 
 if [[ ( -z "$compconfig[list_condition]" ||
-        "${(e):-\$[$compconfig[expand_glob]]}" -eq 1 ) &&
+        "${(e):-\$[$compconfig[list_condition]]}" -eq 1 ) &&
       ( "$pre" != "$_list_prefix" || "$suf" != "$_list_suffix" ) ]]; then
 
   # Yes. Tell the completion code about it and save the new values

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

