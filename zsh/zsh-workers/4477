From zsh-workers-request@math.gatech.edu Sat Oct 31 15:52:58 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4907 invoked from network); 31 Oct 1998 15:52:53 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 31 Oct 1998 15:52:53 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id KAA12815;
	Sat, 31 Oct 1998 10:33:53 -0500 (EST)
Resent-Date: Sat, 31 Oct 1998 10:33:53 -0500 (EST)
Message-Id: <9810311518.AA44113@ibmth.df.unipi.it>
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: PATCH: Re: Strange behaviour of zsh-3.1.5 on IRIX 6.2 
In-Reply-To: "Roland Jesse"'s message of "Sat, 31 Oct 1998 00:39:16 NFT."
             <19981031003916.B29500@cs.uni-magdeburg.de> 
Date: Sat, 31 Oct 1998 16:18:35 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>
Resent-Message-ID: <"tn9Jb1.0.A83.WtoEs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4477
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Roland Jesse wrote:
> Zefram wrote:
> 
> > Is anyone else using IRIX?
> 
> Yes, I am. I tried for some time to get 3.1.4 working. That was without
> much success. The compile process went just fine. But when trying to run
> the shell, it failed. Tracing the error down in a debugger showed that it
> crashed when trying to do a wrefresh without even having a window.

It shouldn't be calling wrefresh() at all, ever, since zsh uses
termcap, not curses.  The problem seems to be that the function
refresh() is wrongly coming from the curses library instead of zle
with dynamic loading.  If you're not using dynamic loading, you
probably won't see these problems (you might see a warning from ld
about pre-empted symbols, though I know loading on the machine I'm
using is a little unusual), which might explain differing behaviour.

Three functions seem to be affected: refresh(), beep() and setterm().
The first is treated in Zoli's AIX dynamic loading patch, but the
others have the same problem.  Anyone using dynamic loading under IRIX
6 should try the following patch, which simply sticks a z in front of
the names, and see what happens.

The shell-related building problems from 3.1.5 which IRIX 6.2 had have
gone away, which is why I'm only now in a position to test this (I've
been compiling on an older IRIX 5.3 machine up to now).  I'm compiling
with gcc 2.7.2.2 and haven't seen any trouble with sourcing scripts,
so I can't promise this fixes everything, but in my case limited
testing seems to show everything OK with all possible libraries
dynamically loaded, so it certainly seems possible to get it right.

(If anyone's desperate I can make my binaries available via http, but
I'll need to recompile as my DLLs are in a non-standard place.)

*** Src/Zle/zle.h.r	Sun Oct 25 22:03:52 1998
--- Src/Zle/zle.h	Fri Oct 30 17:17:24 1998
***************
*** 31,37 ****
  #undef zleread
  #undef spaceinline
  #undef gotword
! #undef refresh
  
  typedef struct widget *Widget;
  typedef struct thingy *Thingy;
--- 31,37 ----
  #undef zleread
  #undef spaceinline
  #undef gotword
! #undef zrefresh
  
  typedef struct widget *Widget;
  typedef struct thingy *Thingy;
*** Src/Zle/zle_hist.c.r	Sun Sep 27 20:48:50 1998
--- Src/Zle/zle_hist.c	Fri Oct 30 17:17:24 1998
***************
*** 721,727 ****
  	sbuf[sbptr] = '_';
  	statusll = sbuf - statusline + sbptr + 1;
      ref:
! 	refresh();
  	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
  	    int i;
  	    get_isrch_spot(0, &hl, &pos, &i, &sbptr, &dir, &nomatch);
--- 721,727 ----
  	sbuf[sbptr] = '_';
  	statusll = sbuf - statusline + sbptr + 1;
      ref:
! 	zrefresh();
  	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
  	    int i;
  	    get_isrch_spot(0, &hl, &pos, &i, &sbptr, &dir, &nomatch);
***************
*** 809,815 ****
  	    	cmd == Th(z_quotedinsert)) {
  	    if(cmd == Th(z_viquotedinsert)) {
  		sbuf[sbptr] = '^';
! 		refresh();
  	    }
  	    if ((c = getkey(0)) == EOF)
  		feep();
--- 809,815 ----
  	    	cmd == Th(z_quotedinsert)) {
  	    if(cmd == Th(z_viquotedinsert)) {
  		sbuf[sbptr] = '^';
! 		zrefresh();
  	    }
  	    if ((c = getkey(0)) == EOF)
  		feep();
***************
*** 936,942 ****
      while (sptr) {
  	sbuf[sptr] = '_';
  	statusll = sptr + 1;
! 	refresh();
  	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
  	    ret = 0;
  	    break;
--- 936,942 ----
      while (sptr) {
  	sbuf[sptr] = '_';
  	statusll = sptr + 1;
! 	zrefresh();
  	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
  	    ret = 0;
  	    break;
***************
*** 971,977 ****
  	} else if(cmd == Th(z_viquotedinsert) || cmd == Th(z_quotedinsert)) {
  	    if(cmd == Th(z_viquotedinsert)) {
  		sbuf[sptr] = '^';
! 		refresh();
  	    }
  	    if ((c = getkey(0)) == EOF)
  		feep();
--- 971,977 ----
  	} else if(cmd == Th(z_viquotedinsert) || cmd == Th(z_quotedinsert)) {
  	    if(cmd == Th(z_viquotedinsert)) {
  		sbuf[sptr] = '^';
! 		zrefresh();
  	    }
  	    if ((c = getkey(0)) == EOF)
  		feep();
*** Src/Zle/zle_main.c.r	Sat Oct 31 15:57:05 1998
--- Src/Zle/zle_main.c	Sat Oct 31 16:03:28 1998
***************
*** 112,118 ****
  
  /**/
  void
! setterm(void)
  {
      struct ttyinfo ti;
  
--- 112,118 ----
  
  /**/
  void
! zsetterm(void)
  {
      struct ttyinfo ti;
  
***************
*** 362,368 ****
  		ret = opts[MONITOR];
  		opts[MONITOR] = 1;
  		attachtty(mypgrp);
! 		refresh();	/* kludge! */
  		opts[MONITOR] = ret;
  		die = 1;
  	    } else if (errno != 0) {
--- 362,368 ----
  		ret = opts[MONITOR];
  		opts[MONITOR] = 1;
  		attachtty(mypgrp);
! 		zrefresh();	/* kludge! */
  		opts[MONITOR] = ret;
  		die = 1;
  	    } else if (errno != 0) {
***************
*** 372,378 ****
  	    }
  	}
  	if (cc == '\r')		/* undo the exchange of \n and \r determined by */
! 	    cc = '\n';		/* setterm() */
  	else if (cc == '\n')
  	    cc = '\r';
  
--- 372,378 ----
  	    }
  	}
  	if (cc == '\r')		/* undo the exchange of \n and \r determined by */
! 	    cc = '\n';		/* zsetterm() */
  	else if (cc == '\n')
  	    cc = '\r';
  
***************
*** 485,491 ****
  	initmodifier(&zmod);
  	prefixflag = 0;
  	feepflag = 0;
! 	refresh();
  	while (!done && !errflag) {
  
  	    statusline = NULL;
--- 485,491 ----
  	initmodifier(&zmod);
  	prefixflag = 0;
  	feepflag = 0;
! 	zrefresh();
  	while (!done && !errflag) {
  
  	    statusline = NULL;
***************
*** 516,526 ****
  		    tv.tv_usec = 500000;
  		if (!kungetct && select(SHTTY+1, (SELECT_ARG_2_T) & foofd,
  					NULL, NULL, &tv) <= 0)
! 		    refresh();
  	    } else
  #endif
  		if (!kungetct)
! 		    refresh();
  	    handlefeep();
  	}
  	statusline = NULL;
--- 516,526 ----
  		    tv.tv_usec = 500000;
  		if (!kungetct && select(SHTTY+1, (SELECT_ARG_2_T) & foofd,
  					NULL, NULL, &tv) <= 0)
! 		    zrefresh();
  	    } else
  #endif
  		if (!kungetct)
! 		    zrefresh();
  	    handlefeep();
  	}
  	statusline = NULL;
***************
*** 743,749 ****
  	return;
      statusline = "Describe key briefly: _";
      statusll = strlen(statusline);
!     refresh();
      seq = getkeymapcmd(curkeymap, &func, &str);
      statusline = NULL;
      if(!*seq)
--- 743,749 ----
  	return;
      statusline = "Describe key briefly: _";
      statusll = strlen(statusline);
!     zrefresh();
      seq = getkeymapcmd(curkeymap, &func, &str);
      statusline = NULL;
      if(!*seq)
***************
*** 811,824 ****
  trashzle(void)
  {
      if (zleactive) {
! 	/* This refresh() is just to get the main editor display right and *
  	 * get the cursor in the right place.  For that reason, we disable *
  	 * list display (which would otherwise result in infinite          *
! 	 * recursion [at least, it would if refresh() didn't have its      *
  	 * extra `inlist' check]).                                         */
  	int sl = showinglist;
  	showinglist = 0;
! 	refresh();
  	showinglist = sl;
  	moveto(nlnct, 0);
  	if (clearflag && tccan(TCCLEAREOD)) {
--- 811,824 ----
  trashzle(void)
  {
      if (zleactive) {
! 	/* This zrefresh() is just to get the main editor display right and *
  	 * get the cursor in the right place.  For that reason, we disable *
  	 * list display (which would otherwise result in infinite          *
! 	 * recursion [at least, it would if zrefresh() didn't have its      *
  	 * extra `inlist' check]).                                         */
  	int sl = showinglist;
  	showinglist = 0;
! 	zrefresh();
  	showinglist = sl;
  	moveto(nlnct, 0);
  	if (clearflag && tccan(TCCLEAREOD)) {
***************
*** 848,854 ****
      /* Set up editor entry points */
      trashzleptr = trashzle;
      gotwordptr = gotword;
!     refreshptr = refresh;
      spaceinlineptr = spaceinline;
      zlereadptr = zleread;
  
--- 848,854 ----
      /* Set up editor entry points */
      trashzleptr = trashzle;
      gotwordptr = gotword;
!     refreshptr = zrefresh;
      spaceinlineptr = spaceinline;
      zlereadptr = zleread;
  
*** Src/Zle/zle_misc.c.r	Sat Oct 31 16:02:39 1998
--- Src/Zle/zle_misc.c	Sat Oct 31 16:03:27 1998
***************
*** 426,432 ****
  #endif
      c = getkey(0);
  #ifndef HAS_TIO
!     setterm();
  #endif
      if (c < 0)
  	feep();
--- 426,432 ----
  #endif
      c = getkey(0);
  #ifndef HAS_TIO
!     zsetterm();
  #endif
      if (c < 0)
  	feep();
*** Src/Zle/zle_refresh.c.r	Wed Apr 29 23:42:44 1998
--- Src/Zle/zle_refresh.c	Sat Oct 31 16:03:26 1998
***************
*** 55,61 ****
  
  /* Non-zero if ALWAYS_LAST_PROMPT has been used, meaning that the *
   * screen below the buffer display should not be cleared by       *
!  * refresh(), but should be by trashzle().                        */
  
  /**/
  int clearflag;
--- 55,61 ----
  
  /* Non-zero if ALWAYS_LAST_PROMPT has been used, meaning that the *
   * screen below the buffer display should not be cleared by       *
!  * zrefresh(), but should be by trashzle().                        */
  
  /**/
  int clearflag;
***************
*** 75,81 ****
  #endif
  
  /* Oct/Nov 94: <mason> some code savagely redesigned to fix several bugs -
!    refreshline() & tc_rightcurs() majorly rewritten; refresh() fixed -
     I've put my fingers into just about every routine in here -
     any queries about updates to mason@werple.net.au */
  
--- 75,81 ----
  #endif
  
  /* Oct/Nov 94: <mason> some code savagely redesigned to fix several bugs -
!    refreshline() & tc_rightcurs() majorly rewritten; zrefresh() fixed -
     I've put my fingers into just about every routine in here -
     any queries about updates to mason@werple.net.au */
  
***************
*** 224,230 ****
  
  /**/
  void
! refresh(void)
  {
      static int inlist;		/* avoiding recursion                        */
      int canscroll = 0,		/* number of lines we are allowed to scroll  */
--- 224,230 ----
  
  /**/
  void
! zrefresh(void)
  {
      static int inlist;		/* avoiding recursion                        */
      int canscroll = 0,		/* number of lines we are allowed to scroll  */
***************
*** 240,246 ****
      char **qbuf;		/* tmp					     */
  
      /* If this is called from listmatches() (indirectly via trashzle()), and *
!      * that was called from the end of refresh(), then we don't need to do   *
       * anything.  All this `inlist' code is actually unnecessary, but it     *
       * improves speed a little in a common case.                             */
      if (inlist)
--- 240,246 ----
      char **qbuf;		/* tmp					     */
  
      /* If this is called from listmatches() (indirectly via trashzle()), and *
!      * that was called from the end of zrefresh(), then we don't need to do   *
       * anything.  All this `inlist' code is actually unnecessary, but it     *
       * improves speed a little in a common case.                             */
      if (inlist)
***************
*** 263,269 ****
  	termflags &= ~TERM_SHORT;
      if (resetneeded) {
  	onumscrolls = 0;
! 	setterm();
  #ifdef TIOCGWINSZ
  	if (winchanged) {
  	    moveto(0, 0);
--- 263,269 ----
  	termflags &= ~TERM_SHORT;
      if (resetneeded) {
  	onumscrolls = 0;
! 	zsetterm();
  #ifdef TIOCGWINSZ
  	if (winchanged) {
  	    moveto(0, 0);
***************
*** 547,553 ****
  	inlist = 1;
  	listmatches();
  	inlist = 0;
! 	refresh();
      }
      if (showinglist == -1)
  	showinglist = nlnct;
--- 547,553 ----
  	inlist = 1;
  	listmatches();
  	inlist = 0;
! 	zrefresh();
      }
      if (showinglist == -1)
  	showinglist = nlnct;
*** Src/Zle/zle_tricky.c.r	Sat Oct 31 16:02:48 1998
--- Src/Zle/zle_tricky.c	Sat Oct 31 16:03:22 1998
***************
*** 3677,3683 ****
      /* Maybe we have to ask if the user wants to see the list. */
      if ((listmax && ct > listmax) || (!listmax && up >= lines)) {
  	int qup;
! 	setterm();
  	qup = printfmt("zsh: do you wish to see all %n possibilities? ", ct, 1);
  	fflush(shout);
  	if (getzlequery() != 'y') {
--- 3677,3683 ----
      /* Maybe we have to ask if the user wants to see the list. */
      if ((listmax && ct > listmax) || (!listmax && up >= lines)) {
  	int qup;
! 	zsetterm();
  	qup = printfmt("zsh: do you wish to see all %n possibilities? ", ct, 1);
  	fflush(shout);
  	if (getzlequery() != 'y') {
*** Src/Zle/zle_utils.c.r	Sat Oct 31 15:53:51 1998
--- Src/Zle/zle_utils.c	Sat Oct 31 15:58:48 1998
***************
*** 420,426 ****
  handlefeep(void)
  {
      if(feepflag)
! 	beep();
      feepflag = 0;
  }
  
--- 420,426 ----
  handlefeep(void)
  {
      if(feepflag)
! 	zbeep();
      feepflag = 0;
  }
  
*** Src/Zle/zle_vi.c.r	Sat Oct 31 15:57:21 1998
--- Src/Zle/zle_vi.c	Sat Oct 31 16:03:21 1998
***************
*** 126,132 ****
  	char sav = line[cs];
  
  	line[cs] = '^';
! 	refresh();
  	c = getkey(0);
  	line[cs] = sav;
  	if(c == EOF) {
--- 126,132 ----
  	char sav = line[cs];
  
  	line[cs] = '^';
! 	zrefresh();
  	c = getkey(0);
  	line[cs] = sav;
  	if(c == EOF) {
***************
*** 814,823 ****
  void
  vicapslockpanic(void)
  {
!     beep();
      statusline = "press a lowercase key to continue";
      statusll = strlen(statusline);
!     refresh();
      while (!islower(getkey(0)));
      statusline = NULL;
  }
--- 814,823 ----
  void
  vicapslockpanic(void)
  {
!     zbeep();
      statusline = "press a lowercase key to continue";
      statusll = strlen(statusline);
!     zrefresh();
      while (!islower(getkey(0)));
      statusline = NULL;
  }
***************
*** 891,897 ****
  
      spaceinline(1);
      line[cs] = '^';
!     refresh();
  #ifndef HAS_TIO
      sob = shttyinfo.sgttyb;
      sob.sg_flags = (sob.sg_flags | RAW) & ~ECHO;
--- 891,897 ----
  
      spaceinline(1);
      line[cs] = '^';
!     zrefresh();
  #ifndef HAS_TIO
      sob = shttyinfo.sgttyb;
      sob.sg_flags = (sob.sg_flags | RAW) & ~ECHO;
***************
*** 899,905 ****
  #endif
      c = getkey(0);
  #ifndef HAS_TIO
!     setterm();
  #endif
      foredel(1);
      if(c < 0)
--- 899,905 ----
  #endif
      c = getkey(0);
  #ifndef HAS_TIO
!     zsetterm();
  #endif
      foredel(1);
      if(c < 0)
*** Src/jobs.c.r	Fri Oct 30 17:30:08 1998
--- Src/jobs.c	Fri Oct 30 17:30:51 1998
***************
*** 214,220 ****
      if ((isset(NOTIFY) || job == thisjob) && (jn->stat & STAT_LOCKED)) {
  	printjob(jn, !!isset(LONGLISTJOBS), 0);
  	if (zleactive)
! 	    refresh();
      }
      if (sigtrapped[SIGCHLD] && job != thisjob)
  	dotrap(SIGCHLD);
--- 214,220 ----
      if ((isset(NOTIFY) || job == thisjob) && (jn->stat & STAT_LOCKED)) {
  	printjob(jn, !!isset(LONGLISTJOBS), 0);
  	if (zleactive)
! 	    zrefresh();
      }
      if (sigtrapped[SIGCHLD] && job != thisjob)
  	dotrap(SIGCHLD);
*** Src/utils.c.r	Fri Oct 30 17:30:17 1998
--- Src/utils.c	Sat Oct 31 15:53:26 1998
***************
*** 854,860 ****
      setiparam("LINES", shttyinfo.winsize.ws_row);
      if (zleactive && (oldcols != columns || oldrows != lines)) {
  	resetneeded = winchanged = 1;
! 	refresh();
      }
  #endif   /* TIOCGWINSZ */
  }
--- 854,860 ----
      setiparam("LINES", shttyinfo.winsize.ws_row);
      if (zleactive && (oldcols != columns || oldrows != lines)) {
  	resetneeded = winchanged = 1;
! 	zrefresh();
      }
  #endif   /* TIOCGWINSZ */
  }
***************
*** 1129,1141 ****
      if(isset(RMSTARWAIT)) {
  	fputs("? (waiting ten seconds)", shout);
  	fflush(shout);
! 	beep();
  	sleep(10);
  	fputc('\n', shout);
      }
      fputs(" [yn]? ", shout);
      fflush(shout);
!     beep();
      return (getquery("ny", 1) == 'y');
  }
  
--- 1129,1141 ----
      if(isset(RMSTARWAIT)) {
  	fputs("? (waiting ten seconds)", shout);
  	fflush(shout);
! 	zbeep();
  	sleep(10);
  	fputc('\n', shout);
      }
      fputs(" [yn]? ", shout);
      fflush(shout);
!     zbeep();
      return (getquery("ny", 1) == 'y');
  }
  
***************
*** 1181,1187 ****
  	    write(SHTTY, "\n", 1);
  	    break;
  	}
! 	beep();
  	if (icntrl(c))
  	    write(SHTTY, "\b \b", 3);
  	write(SHTTY, "\b \b", 3);
--- 1181,1187 ----
  	    write(SHTTY, "\n", 1);
  	    break;
  	}
! 	zbeep();
  	if (icntrl(c))
  	    write(SHTTY, "\b \b", 3);
  	write(SHTTY, "\b \b", 3);
***************
*** 1327,1333 ****
  	    zputs(pptbuf, shout);
  	    free(pptbuf);
  	    fflush(shout);
! 	    beep();
  	    x = getquery("nyae ", 0);
  	} else
  	    x = 'y';
--- 1327,1333 ----
  	    zputs(pptbuf, shout);
  	    free(pptbuf);
  	    fflush(shout);
! 	    zbeep();
  	    x = getquery("nyae ", 0);
  	} else
  	    x = 'y';
***************
*** 2286,2292 ****
  
  /**/
  void
! beep(void)
  {
      if (isset(BEEP))
  	write(SHTTY, "\07", 1);
--- 2286,2292 ----
  
  /**/
  void
! zbeep(void)
  {
      if (isset(BEEP))
  	write(SHTTY, "\07", 1);
*** Src/zsh.h.r	Fri Oct 30 17:29:48 1998
--- Src/zsh.h	Fri Oct 30 17:12:57 1998
***************
*** 31,37 ****
  #define zleread(X,Y,H)  zlereadptr(X,Y,H)
  #define spaceinline(X)  spaceinlineptr(X)
  #define gotword()       gotwordptr()
! #define refresh()       refreshptr()
  
  #define compctlread(N,A,O,R) compctlreadptr(N,A,O,R)
  
--- 31,37 ----
  #define zleread(X,Y,H)  zlereadptr(X,Y,H)
  #define spaceinline(X)  spaceinlineptr(X)
  #define gotword()       gotwordptr()
! #define zrefresh()       refreshptr()
  
  #define compctlread(N,A,O,R) compctlreadptr(N,A,O,R)
  
-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarotti 2, 56100 Pisa, Italy

