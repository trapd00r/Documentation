From zsh-workers-return-5889-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Mar 23 09:52:34 1999
Return-Path: <zsh-workers-return-5889-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16893 invoked from network); 23 Mar 1999 09:52:32 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Mar 1999 09:52:32 -0000
Received: (qmail 10886 invoked by alias); 23 Mar 1999 09:51:50 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5889
Received: (qmail 10879 invoked from network); 23 Mar 1999 09:51:48 -0000
Date: Tue, 23 Mar 1999 10:51:44 +0100 (MET)
Message-Id: <199903230951.KAA18666@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Mon, 22 Mar 1999 20:45:22 +0300
Subject: RE: PATCH: cleanup in zle_tricky.c


Andrej Borsenkow wrote:

> > Question to others: do you see the same behavior Andrej does? I.e. is
> > it me or is it the rest of the world who has run out of sync?
> >
> 
> I know now where the problem(s) were - I sent this to Sven as well.
> 
> Bsically, the completion does not work with ambiguous prefix. In my case I
> had /u1/informix* as well - that way _path_files took another branch.

Ah, I thought you had made sure that this didn't happen because we had
this discussion already -- and hence I didn't test for it (the real
problem was that without globcomplete there were no matches). At that
time I had asked if we wanted the path to expand as far as possible in
such cases.
Since you perceived this as a bug, the patch below makes the answer
`yes'.

> In case of `.../*.suffix', the `/.*' was replaced by `/.', that 'course
> could not match.

That was an attempt to make the normal non-globdots behavior simpler
for those who have a matcher making dots word-separators. Trying to do 
too much, one could say. The patch below removes this.

> In case of x*y, first the whole was quoted (that gives you `x\*y') then *
> was replaced by pattern, that should match anything except `/' - leaving
> backslash inside. again, that pattern could not match.

This, too, should be fixed by the patch below (an ugly oversight).


Ok, with the patch below and the ones from 5871, 5872, and 5875: does
everything work as you want (or expect ;-) it now? Including those
`test/{a1,b1,x1y}' problems you mentioned?

Bye
 Sven

diff -u oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Mon Mar 22 14:54:41 1999
+++ Completion/Core/_path_files	Tue Mar 23 10:48:19 1999
@@ -23,13 +23,14 @@
 local nm str linepath realpath donepath patstr prepath testpath rest
 local tmp1 collect tmp2 suffixes i ignore matchflags opt group sopt pats gopt
 local addpfx addsfx expl orig ostr nm=$compstate[nmatches] menu remsfx patlast
-local origflags mflags
+local origflags mflags tmp3 tmp4 exppaths
 
 typeset -U prepaths
 
 setopt localoptions nullglob rcexpandparam extendedglob
 unsetopt markdirs globsubst shwordsplit nounset
 
+exppaths=()
 prepaths=('')
 ignore=()
 group=()
@@ -202,7 +203,7 @@
 # have special meaning for globbing, we remove them. But before that, we
 # add the pattern for matching any characters before a slash.
 
-patstr="$patstr:gs-/-*/-:gs/*.*./../:gs-/*.-/.-:gs/**/*/:gs-.*/-./-"
+patstr="$patstr:gs-/-*/-:gs/*.*./../:gs/**/*/:gs-.*/-./-"
 
 [[ "${compstate[pattern_match]-*}" != \** ]] && patstr="$patstr:gs/*//"
 
@@ -218,16 +219,16 @@
 
 if [[ "$patstr" = */* ]]; then
   if [[ -n "$_comp_correct" && "${#orig##*/}" -le _comp_correct ]]; then
-    patlast="*/${origflags}${${patstr##*/}//\*/[^/]#}"
+    patlast="*/${origflags}${${${patstr##*/}//\*/[^/]#}:gs.\[^/]#.\\\*.}"
   else
-    patlast="*/${matchflags}${${patstr##*/}//\*/[^/]#}"
+    patlast="*/${matchflags}${${${patstr##*/}//\*/[^/]#}:gs.\[^/]#.\\\*.}"
   fi
   patstr="${patstr%/*}/"
 else
   if [[ -n "$_comp_correct" && "$#orig" -le _comp_correct ]]; then
-    patlast="${origflags}${patstr//\*/[^/]#}"
+    patlast="${origflags}${${patstr//\*/[^/]#}:gs.\[^/]#.\\\*.}"
   else
-    patlast="${matchflags}${patstr//\*/[^/]#}"
+    patlast="${matchflags}${${patstr//\*/[^/]#}:gs.\[^/]#.\\\*.}"
   fi
   patstr=""
 fi
@@ -315,6 +316,24 @@
       # next `-W' path.
 
       if [[ $#collect -eq 0 ]]; then
+        # Before giving, we first try to get the longest expandable path-
+	# prefix, though. The result is stored in `exppaths'
+
+        tmp2=()
+	tmp3="$rest"
+	tmp4="${ostr##*/}"
+	ostr="${ostr%/*}"
+	while [[ "$tmp3" = */* ]]; do
+	  tmp2=( ${^tmp1}/${~mflags}${~tmp3} )
+	  if [[ $#tmp2 -eq 1 ]]; then
+	    exppaths=( "$exppaths[@]" "${tmp2[1]}${tmp4}" )
+	    exppaths=( "${(@)exppaths#${prepath}${realpath}}" )
+	    break;
+          fi
+	  tmp3="${tmp3%/*}"
+	  tmp4="${ostr##*/}/${tmp4}"
+	  ostr="${ostr%/*}"
+        done
         continue 2
       elif [[ $#collect -ne 1 ]]; then
         # If we have more than one possible match, this means that the
@@ -426,6 +445,16 @@
 	    -W "$prepath$realpath$testpath" - "${(@)${(@)tmp2#$tmp1}:q}"
   fi
 done
+
+# If no matches were found but we have expanded paths which are different
+# from the original string, use them.
+
+exppaths=( "${(@)exppaths:#$orig}" )
+
+if [[ nm -eq compstate[nmatches] && $#exppaths -ne 0 ]]; then
+  compadd -UQ -S '' "$group[@]" "$expl[@]" -i "$IPREFIX" -I "$ISUFFIX" - \
+          "${linepath}${(@)^exppaths}"
+fi
 
 # This sets the return value to indicate that we added matches (or not).
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

