From zsh-workers-return-5624-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 03 12:00:33 1999
Return-Path: <zsh-workers-return-5624-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8689 invoked from network); 3 Mar 1999 12:00:31 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 3 Mar 1999 12:00:31 -0000
Received: (qmail 12140 invoked by alias); 3 Mar 1999 12:00:07 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5624
Received: (qmail 12132 invoked from network); 3 Mar 1999 12:00:05 -0000
Date: Wed, 3 Mar 1999 12:59:18 +0100 (MET)
Message-Id: <199903031159.MAA21423@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: improving completion correction


The patch below improves the completion correction code:

- You now need to set the parameter `CCORIG' to have the original
  string from the line offered when cycling through the list. Also,
  this string is now the `first' `match', which means that if `CCORIG' 
  is set, the possible corrected strings will be shown but the line
  does not change. Consecutive TABs will then cycle through the list.
- Part of this is done by using `-X' and `-J' in the temporary
  functions. With this, using `%n' in `CCPROMPT' will show the correct 
  number.
  But there is a problem: if someone adds matches with `-J', `-V', or
  `-X', this will stop working since then more than one group name or
  explanation will be given to the `compadd's or `compgen's. In such
  cases the string from the last one is used. For `complist' this is
  no problem, but for `compadd' I didn't bother to make the temporary
  function parse the options to stick the `-J' and `-X' from the
  correction code in the right place.

Bye
 Sven

diff -u oc/Core/_main_complete Completion/Core/_main_complete
--- oc/Core/_main_complete	Tue Mar  2 14:18:55 1999
+++ Completion/Core/_main_complete	Wed Mar  3 12:58:28 1999
@@ -16,15 +16,19 @@
 # `COMPCORRECT' will be used. E.g. with `COMPCORRECT=2n' two errors
 # will be accepted, but if the user gives another number with the
 # numeric argument, this will be prefered. Also, with `COMPCORRECT=0n',
-# normally no automatic correction will be tried. But if a numeric
+# normally no automatic correction will be tried, but if a numeric
 # argument is given, automatic correction will be used. Once the
-# number of errors to accept is determined. the code will repeatedly
+# number of errors to accept is determined, the code will repeatedly
 # try to generate matches by allowing one error, two errors, and so
 # on.
+# If the parameter `CCORIG' is set (independent of the value), the
+# line will first be left unchanged and consecutive TABs cycle through 
+# the list.
 # When using automatic correction, one can also set the parameter
 # `CCPROMPT' to a string that will be shown when multiple
 # correction results are displayed and the code starts cycling
-# through them.
+# through them (this string is used with the `-X' option and thus may
+# contain the control sequences `%n', `%B',...).
 
 local comp name _comp_correct comax
 
@@ -100,11 +104,7 @@
 	# original string as a possible match, let it not be shown in
 	# the list, and probably display the `CCPROMPT'.
 
-        if (( $+CCPROMPT )); then
-          compadd -nX "$CCPROMPT" - "$PREFIX$SUFFIX"
-	else
-          compadd -n - "$PREFIX$SUFFIX"
-	fi
+        (( $+CCORIG )) && builtin compadd -n - "$PREFIX$SUFFIX"
 
 	# If you always want to see the list of possible corrections,
 	# set `compstate[list]=list' here.
@@ -146,11 +146,19 @@
 
       compadd() {
         PREFIX="(#a${_comp_correct})$PREFIX"
-	builtin compadd "$@"
+	if (( $+CCPROMPT )); then
+	  builtin compadd -X "$CCPROMPT" -J _correct "$@"
+	else
+	  builtin compadd -J _correct "$@"
+	fi
       }
       compgen() {
         PREFIX="(#a${_comp_correct})$PREFIX"
-	builtin compgen "$@"
+	if (( $+CCPROMPT )); then
+	  builtin compgen "$@" -X "$CCPROMPT" -J _correct
+	else
+	  builtin compgen "$@" -J _correct
+	fi
       }
       # Now initialise our counter. We also set `compstate[matcher]'
       # to `-1'. This allows completion functions to use the simple

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

