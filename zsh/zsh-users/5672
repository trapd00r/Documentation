From zsh-users-return-5672-mason-zsh=primenet.com.au@sunsite.dk Sat Jan 11 18:41:06 2003
Return-Path: <zsh-users-return-5672-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23957 invoked from network); 11 Jan 2003 18:41:05 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 11 Jan 2003 18:41:05 -0000
Received: (qmail 17644 invoked by alias); 11 Jan 2003 18:40:50 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5672
Received: (qmail 17631 invoked from network); 11 Jan 2003 18:40:48 -0000
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <1030111184020.ZM11764@candle.brasslantern.com>
Date: Sat, 11 Jan 2003 18:40:19 +0000
In-Reply-To: <15903.36155.716460.639226@fisica.ufpr.br>
Comments: In reply to Carlos Carvalho <carlos@fisica.ufpr.br>
        "Re: aliases not getting expanded inside functions?" (Jan 11,  1:19am)
References: <15893.44217.393956.262362@fisica.ufpr.br> 
	<20030103164552.A28966@globnix.org> 
	<15893.50996.646711.184945@fisica.ufpr.br> 
	<20030103184455.A5692@globnix.org> 
	<15893.53780.524763.695176@fisica.ufpr.br> 
	<20030103185407.GA11836@fysh.org> 
	<15897.15986.562636.628562@fisica.ufpr.br> 
	<1030106125404.ZM4660@candle.brasslantern.com> 
	<15903.36155.716460.639226@fisica.ufpr.br>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.dk
Subject: Re: aliases not getting expanded inside functions?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Jan 11,  1:19am, Carlos Carvalho wrote:
>
> Sorry I couldn't follow up earlier :-( Anyway the below told me how to
> pass parameters by name to a function so that it changes the values.
> Good!

That isn't the only way to do that, and not even the most readable in my
opinion.  For scalars, each of the following has the same effects:

	: ${(P)1::=$2}
	eval $1='$2'
	typeset -g $1=$2

For arrays:

	eval $1='( $3 $2 )'
	set -A $1 $3 $2

The array form ${(P)=1::=$3 $2} is almost but not quite the same, because
field splitting is applied *after* expanding $3 and $2 in that case, even
if they're quoted, so you can't preserve embedded whitespace.

> Bart Schaefer (schaefer@brasslantern.com) wrote on 6 January 2003 12:54:
>  >Nearly as often, the right thing is instead to ask the list how to solve
>  >problem X, because there's a better solution than Y.
> 
> Agreed, so here's the story, with two questions. I read a csv file
> that comes from a spreadsheet and need to split the fields to
> different variables. Instead of doing the full parsing of the data
> line by hand, it's easier to have zsh do the split:
> 
> fields=( ${(s:;:)dataline} )

How did you get the data into $dataline in the first place?

Rather than:

    while read dataline
    do
      fields=( "${(@s:;:)dataline}" )	# Answers your other question
      rate=$fields[1] capital=$fields[2] etc.
      # manipulate $rate $capital and so on ...
    done

You can simply do:

    while IFS=';' read rate capital etc.
    do
      # manipulate $rate $capital and so on ...
    done

> rate_prev=$rate capital_prev=$capital etc.
> 
> Instead of copying manually I'd like to do
> 
> rate_prev=$fields_prev[1] capital_prev=$fields_prev[2] etc.
> 
> only once, and then just do fields_prev=( $fields ) whenever I have to
> copy the values.

A much better way to do this is to use two associative arrays:

    typeset -A fields fields_prev
    while IFS=';' noglob read fields[rate] fields[capital] etc.
    do
      fields_prev=( ${(kv)fields} )	# Save all keys and values
      # manipulate $fields[rate] $fields[capital] and so on ...
    done

The "noglob" above is to avoid having to quote all the square brackets
in the "read" command (otherwise they'd be treated as file patterns).

> I mentioned some variant of a loop like
> 
> for ((i=1; i<= num_fields; i++)) {
>     : ${(P)${fields_prev[i]}::=${(P)${fields[i]}}}
> }
> 
> However this doesn't work because I cannot assign to the individual
> variables (ex. capital=$((capital+interest)) ) without losing the
> connection with the fields array.

If you're unwilling to use $fields[capital] everywhere -- that is, if
you insist on being able to write $capital in some cases -- then there
is no solution I can suggest.  However, if it's OK to write e.g.

    fields[capital]=$((fields[capital]+fields[interest]))

or, more succinctly,

    (( fields[capital] += fields[interest] ))

then there is no connection to worry about being lost.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

