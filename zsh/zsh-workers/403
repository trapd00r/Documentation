From zsh-workers-request@math.gatech.edu  Sun Sep 24 11:42:54 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.mira.net.au (8.6.12/8.6.12) with SMTP id LAA06714 for <mason@werple.mira.net.au>; Sun, 24 Sep 1995 11:42:45 +1000
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA02275
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Sat, 23 Sep 1995 21:43:09 -0400
Received: by math (5.x/SMI-SVR4)
	id AA03935; Sat, 23 Sep 1995 21:36:51 -0400
Resent-Date: Sun, 24 Sep 1995 02:39:32 +0100 (MET)
Old-Return-Path: <hzoli@cs.elte.hu>
From: Zoltan Hidvegi  <hzoli@cs.elte.hu>
Message-Id: <199509240139.CAA00975@bolyai.cs.elte.hu>
Subject: Tokenize comma only if it is part of a brace expansion
To: zsh-workers@math.gatech.edu (zsh-workers)
Date: Sun, 24 Sep 1995 02:39:32 +0100 (MET)
X-Mailer: ELM [version 2.4 PL24]
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"yu1Va2.0.Pz.pOBPm"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/403
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

I often use *(:s@RCS/@@:s/\,v//) to convert rcs-filename to working filename.
I think that this should work without the backslash before the comma but this
does not work since the comma is tokenized.  The only place where this is
needed is brace expansion, in all other cases the comma token requires an
additional test.  I modified the lexer to tokenize comma only if it is part of
a brace-expansion.  The patch applies to the vanilla version or to hzoli10.3.

Zoltan

rcsdiff -qc -kk -r1.14 -r1.15 Src/lex.c
*** Src/lex.c
--- Src/lex.c	1995/09/23 10:37:32
***************
*** 252,258 ****
  #define LX2_QUOTE 14
  #define LX2_DQUOTE 15
  #define LX2_BQUOTE 16
! #define LX2_OTHER 17
  
  unsigned char lexact1[256], lexact2[256], lextok2[256];
  
--- 252,259 ----
  #define LX2_QUOTE 14
  #define LX2_DQUOTE 15
  #define LX2_BQUOTE 16
! #define LX2_COMMA 17
! #define LX2_OTHER 18
  
  unsigned char lexact1[256], lexact2[256], lextok2[256];
  
***************
*** 262,268 ****
  {
      int t0;
      static char *lx1 = "\\q\n;!&|(){}[]<>xx";
!     static char *lx2 = "x)|$[]~({}><=\\\'\"`x";
  
      for (t0 = 0; t0 != 256; t0++) {
  	lexact1[t0] = LX1_OTHER;
--- 263,269 ----
  {
      int t0;
      static char *lx1 = "\\q\n;!&|(){}[]<>xx";
!     static char *lx2 = "x)|$[]~({}><=\\\'\"`,x";
  
      for (t0 = 0; t0 != 256; t0++) {
  	lexact1[t0] = LX1_OTHER;
***************
*** 277,283 ****
  	    lexact2[(int)lx2[t0]] = t0;
      lexact2[';'] = LX2_BREAK;
      lexact2['&'] = LX2_BREAK;
-     lextok2[','] = Comma;
      lextok2['*'] = Star;
      lextok2['?'] = Quest;
      lextok2['{'] = Inbrace;
--- 278,283 ----
***************
*** 730,735 ****
--- 730,739 ----
  	    if (bct-- == in_brace_param)
  		in_brace_param = 0;
  	    c = Outbrace;
+ 	    break;
+ 	case LX2_COMMA:
+ 	    if (unset(IGNOREBRACES) && bct > in_brace_param)
+ 		c = Comma;
  	    break;
  	case LX2_OUTANG:
  	    if (!intpos)
rcsdiff -qc -kk -r1.8 -r1.9 Src/glob.c
*** Src/glob.c
--- Src/glob.c	1995/09/23 10:37:32
***************
*** 177,183 ****
  		    data = 0;
  		    while (idigit(*s))
  			data = data * 010 + (*s++ - '0');
! 		} else if (*s == ',' || *s == Comma) {
  		    /* A comma separates alternative sets of qualifiers */
  		    s++;
  		    if (qualct) {
--- 177,183 ----
  		    data = 0;
  		    while (idigit(*s))
  			data = data * 010 + (*s++ - '0');
! 		} else if (*s == ',') {
  		    /* A comma separates alternative sets of qualifiers */
  		    s++;
  		    if (qualct) {
rcsdiff -qc -kk -r1.13 -r1.14 Src/params.c
*** Src/params.c
--- Src/params.c	1995/09/23 10:37:32
***************
*** 234,240 ****
  	return 0;
      noeval = 1;
      (void)mathevalarg(++ss, &ss);
!     if (*ss == ',' || *ss == Comma)
  	(void)mathevalarg(++ss, &ss);
      noeval = ne;		/* restore the value of noeval */
      if (*ss != ']' || ss[1])
--- 234,240 ----
  	return 0;
      noeval = 1;
      (void)mathevalarg(++ss, &ss);
!     if (*ss == ',')
  	(void)mathevalarg(++ss, &ss);
      noeval = ne;		/* restore the value of noeval */
      if (*ss != ']' || ss[1])
***************
*** 373,379 ****
  		r = rr;
  	    }
  
! 	    if (!a2 && *tt != ',' && *tt != Comma)
  		*w = (long)(s - t) - 1;
  	}
      } else {
--- 373,379 ----
  		r = rr;
  	    }
  
! 	    if (!a2 && *tt != ',')
  		*w = (long)(s - t) - 1;
  	}
      } else {
***************
*** 431,437 ****
  		     i++, t = findword(&d, sep))
  		    if (!--r) {
  			r = (long)(t - s + (a2 ? -1 : 1));
! 			if (!a2 && *tt != ',' && *tt != Comma)
  			    *w = r + strlen(ta[i]) - 2;
  			return r;
  		    }
--- 431,437 ----
  		     i++, t = findword(&d, sep))
  		    if (!--r) {
  			r = (long)(t - s + (a2 ? -1 : 1));
! 			if (!a2 && *tt != ',')
  			    *w = r + strlen(ta[i]) - 2;
  			return r;
  		    }
***************
*** 566,572 ****
  			s++;
  		    v->isarr = 0;
  		    v->a = v->b = a;
! 		    if (*s == ',' || *s == Comma) {
  			zerr("invalid subscript", NULL, 0);
  			while (*s != ']' && *s != Outbrack)
  			    s++;
--- 566,572 ----
  			s++;
  		    v->isarr = 0;
  		    v->a = v->b = a;
! 		    if (*s == ',') {
  			zerr("invalid subscript", NULL, 0);
  			while (*s != ']' && *s != Outbrack)
  			    s++;
***************
*** 574,580 ****
  			return v;
  		    }
  		} else {
! 		    if (*s == ',' || *s == Comma) {
  			s++;
  			b = getarg(&s, &inv, v, 1, &dummy);
  			if (b > 0)
--- 574,580 ----
  			return v;
  		    }
  		} else {
! 		    if (*s == ',') {
  			s++;
  			b = getarg(&s, &inv, v, 1, &dummy);
  			if (b > 0)

