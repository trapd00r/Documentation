From zsh-workers-return-15770-mason-zsh=primenet.com.au@sunsite.dk Mon Sep 10 00:00:06 2001
Return-Path: <zsh-workers-return-15770-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14550 invoked from network); 10 Sep 2001 00:00:04 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Sep 2001 00:00:04 -0000
Received: (qmail 13415 invoked by alias); 9 Sep 2001 23:59:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15770
Received: (qmail 13399 invoked from network); 9 Sep 2001 23:59:56 -0000
Date: Sun, 9 Sep 2001 19:24:58 -0400
From: Clint Adams <clint@zsh.org>
To: zsh-workers@sunsite.dk
Subject: PATCH: ztcp -a
Message-ID: <20010909192458.A17265@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i

Now you have to do ztcp -a $fd to accept connections.
The port will remain open indefinitely.

Index: Src/Modules/tcp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.c,v
retrieving revision 1.8
diff -u -r1.8 tcp.c
--- Src/Modules/tcp.c	2001/09/09 22:08:56	1.8
+++ Src/Modules/tcp.c	2001/09/09 23:16:33
@@ -257,6 +257,7 @@
     }
     else {
 	ztcp_tail->next = sess;
+	ztcp_tail = sess;
     }
     return sess;
 }
@@ -328,7 +329,6 @@
     {
 	prev = sess;
 	tcp_close(sess);
-	zts_delete(sess);
     }
 }
 
@@ -338,7 +338,7 @@
 {
     int err;
     
-    if (sess->fd != -1)
+    if (sess && sess->fd != -1)
     {  
 	err = close(sess->fd);
 	if (err)
@@ -346,9 +346,11 @@
 	    zwarn("connection close failed: %e", NULL, errno);
 	    return -1;
 	}
+	zts_delete(sess);
 	return 0;
     }
 
+    zts_delete(sess);
     return -1;
 }
 
@@ -381,7 +383,7 @@
 static int
 bin_ztcp(char *nam, char **args, char *ops, int func)
 {
-    int herrno, err=1, destport, force=0, verbose=0, len, rfd;
+    int herrno, err=1, destport, force=0, verbose=0, len;
     char **addrp, *desthost, *localname, *remotename;
     struct hostent *zthost = NULL, *ztpeer = NULL;
     struct servent *srv;
@@ -409,7 +411,6 @@
 		    return 1;
 		}
 		tcp_close(sess);
-		zts_delete(sess);
 		return 0;
 	    }
 	    else
@@ -435,7 +436,7 @@
 	if (!lport) { zwarnnam(nam, "bad service name or port number", NULL, 0);
 	return 1;
 	}
-	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, ZTCP_INBOUND);
+	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, ZTCP_LISTEN);
 
 	if (!sess) {
 	    zwarnnam(nam, "unable to allocate a TCP session slot", NULL, 0);
@@ -468,22 +469,53 @@
 	    tcp_close(sess);
 	    return 1;
 	}
+
+	/* move the fd since no one will want to read from it */
+	sess->fd = movefd(sess->fd);
+
+	setiparam("REPLY", sess->fd);
+
+	if(verbose)
+	    fprintf(shout, "%d listener is on fd %d\n", ntohs(sess->sock.in.sin_port), sess->fd);
+
+	return 0;
 
-	if ((rfd = accept(sess->fd, (struct sockaddr *)&sess->peer.in, &len)) == -1)
+    }
+    else if (ops['a'])
+    {
+	int lfd, rfd;
+
+	if (!args[0]) {
+	    zwarnnam(nam, "-a requires an argument", NULL, 0);
+	    return 1;
+	}
+
+	lfd = atoi(args[0]);
+
+	if (!lfd) {
+	    zwarnnam(nam, "invalid numerical argument", NULL, 0);
+	    return 1;
+	}
+
+	sess = zts_byfd(lfd);
+	if (!sess) {
+	    zwarnnam(nam, "fd is not registered as a tcp connection", NULL, 0);
+	    return 1;
+	}
+
+	if (!(sess->flags & ZTCP_LISTEN))
 	{
-	    zwarnnam(nam, "could not accept connection: %e", NULL, errno);
-	    tcp_close(sess);
+	    zwarnnam(nam, "tcp connection not a listener", NULL, 0);
 	    return 1;
 	}
 
-	/* move the fd since it doesn't seem to be closing well */
-	sess->fd = movefd(sess->fd);
+	sess = zts_alloc(ZTCP_INBOUND);
 
-	err = close(sess->fd);
-	if (err)
+	if ((rfd = accept(lfd, (struct sockaddr *)&sess->peer.in, &len)) == -1)
 	{
-	    zwarn("listener close failed: %e", NULL, errno);
-	    return -1;
+	    zwarnnam(nam, "could not accept connection: %e", NULL, errno);
+	    tcp_close(sess);
+	    return 1;
 	}
 	sess->fd = rfd;
 
@@ -492,10 +524,9 @@
 	if(verbose)
 	    fprintf(shout, "%d is on fd %d\n", ntohs(sess->peer.in.sin_port), sess->fd);
 
-	return 0;
-
     }
-    else {
+    else
+    {
 	
 	if (!args[0]) {
 	    for(sess = zts_head(); sess != NULL; sess = zts_next(sess))
@@ -512,7 +543,7 @@
 			remotename = ztpeer->h_name;
 		    else
 			remotename = ztrdup(inet_ntoa(sess->sock.in.sin_addr));
-		    fprintf(shout, "%s:%d %s %s:%d is on fd %d%s\n", localname, ntohs(sess->sock.in.sin_port), (sess->flags & ZTCP_INBOUND) ? "<-" : "->", remotename, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "");
+		    fprintf(shout, "%s:%d %s %s:%d is on fd %d%s\n", localname, ntohs(sess->sock.in.sin_port), (sess->flags & ZTCP_LISTEN) ? "-<" : (sess->flags & ZTCP_INBOUND) ? "<-" : "->", remotename, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "");
 		}
 	    }
 	    return 0;
@@ -582,7 +613,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("ztcp", 0, bin_ztcp, 0, 2, 0, "cflv", NULL),
+    BUILTIN("ztcp", 0, bin_ztcp, 0, 2, 0, "acflv", NULL),
 };
 
 /* The load/unload routines required by the zsh library interface */
Index: Src/Modules/tcp.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.h,v
retrieving revision 1.4
diff -u -r1.4 tcp.h
--- Src/Modules/tcp.h	2001/09/09 09:39:25	1.4
+++ Src/Modules/tcp.h	2001/09/09 23:16:33
@@ -72,8 +72,9 @@
 
 typedef struct tcp_session *Tcp_session;
 
-#define ZTCP_INBOUND 1
-#define ZTCP_ZFTP 16
+#define ZTCP_LISTEN  1
+#define ZTCP_INBOUND 2
+#define ZTCP_ZFTP    16
 
 struct tcp_session {
     int fd;				/* file descriptor */

