From zsh-users-return-8681-mason-zsh=primenet.com.au@sunsite.dk Fri Apr 15 03:12:20 2005
Return-Path: <zsh-users-return-8681-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8294 invoked from network); 15 Apr 2005 03:12:20 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 15 Apr 2005 03:12:20 -0000
Received: (qmail 81479 invoked from network); 15 Apr 2005 03:12:13 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 15 Apr 2005 03:12:13 -0000
Received: (qmail 23218 invoked by alias); 15 Apr 2005 03:12:05 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 8681
Received: (qmail 23205 invoked from network); 15 Apr 2005 03:12:05 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 15 Apr 2005 03:12:05 -0000
Received: (qmail 80349 invoked from network); 15 Apr 2005 03:12:05 -0000
Received: from vms040pub.verizon.net (206.46.252.40)
  by a.mx.sunsite.dk with SMTP; 15 Apr 2005 03:12:01 -0000
Received: from candle.brasslantern.com ([4.11.1.68])
 by vms040.mailsrvcs.net (Sun Java System Messaging Server 6.2 HotFix 0.04
 (built Dec 24 2004)) with ESMTPA id <0IEY009NWWVZPI25@vms040.mailsrvcs.net> for
 zsh-users@sunsite.dk; Thu, 14 Apr 2005 22:12:00 -0500 (CDT)
Received: from candle.brasslantern.com (IDENT:schaefer@localhost [127.0.0.1])
	by candle.brasslantern.com (8.12.11/8.12.11) with ESMTP id j3F3BwOS014625	for
 <zsh-users@sunsite.dk>; Thu, 14 Apr 2005 20:11:58 -0700
Received: (from schaefer@localhost)	by candle.brasslantern.com
 (8.12.11/8.12.11/Submit) id j3F3BwQu014624	for zsh-users@sunsite.dk; Thu,
 14 Apr 2005 20:11:58 -0700
Date: Fri, 15 Apr 2005 03:11:58 +0000
From: Bart Schaefer <schaefer@brasslantern.com>
Subject: Re: Optimal use of zparseopts
In-reply-to: <20050415014635.GA7437@globtel.pl>
To: zsh-users@sunsite.dk
Message-id: <1050415031158.ZM14623@candle.brasslantern.com>
MIME-version: 1.0
X-Mailer: Z-Mail (5.0.0 30July97)
Content-type: text/plain; charset=us-ascii
References: <20050415014635.GA7437@globtel.pl>
Comments: In reply to Mariusz Gniazdowski <cellsan@interia.pl>
 "Optimal use of zparseopts" (Apr 15,  3:46am)
X-Spam-Checker-Version: SpamAssassin 3.0.2 on a.mx.sunsite.dk
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=6.0 tests=AWL,BAYES_00 autolearn=ham 
	version=3.0.2
X-Spam-Hits: -2.6

On Apr 15,  3:46am, Mariusz Gniazdowski wrote:
}
} I'm trying to use zparseopts but it can be done in many ways.
} Which is the most optimal?

As usual, it depends on what you're eventually going to do with the
values you've parsed.

One use of zparseopts is in a wrapper function, where the only purpose
is to consume the options and arguments that actually belong to some
*other* program, and store them until that other program is called.  In
this case you don't care what you parsed, only that you can reguritate
it at need, so tossing them into a single array may be adequate.  The
completion system uses zparseopts this way a lot.

Another use is to parse options that are actually meaninful to the
function that calls zparseopts.  In this case you're more likely to want
either an associative array, or one array per option, or a mixture.

Still another use is to throw away options that you're not interested in,
perhaps because you've already examined them some other way.  That's what
the -D option is for.  And so on.

} - zparseopts can put options into arrays, like ( -l -h -t )
} 
} 	How to best test if some value is in array?

Any of a number of ways; for example:

    if (( ${+array[(r)-l]} )); then ...

} - It can put values into arrays too
} 
} 	How to reach it? Find key, then take [keyidx+1] ?

Normally you would not need to do this.  Instead of

    zparseopts -a array l: h t:

and then trying to examine $array, you'd do

    zparseopts l:=lop h=hop t:=top

which sets any or all of the three arrays $lop, $hop, and $top, so you
can examine them separately in whatever manner you like.

    if [[ $lop[1] == -l ]]; then echo The -l option is $lop[2] ; fi
    if [[ $top[1] != -t ]]; then echo There is no -t option ; fi

} - It can put values into associative arrays
} 
} 	How to test if option without argument has ben given?

    if (( ${+hash[-h]} )); then ...

} 	I tried to use -K option, but it's like not working:

It's working.  The doc says:

    -K
          With this option, the arrays specified with the -a and -A
          options and with the `=array' forms are kept unchanged when
          none of the specs for them is used.  This allows assignment
          of default values to them before calling zparseopts.

Note "when *none* of the specs" are used.  In your example, you used
the spec for the -si option, which is not "none", so the entire default
value of the hash is discarded.

It also appears that your example is missing the trailing colons on all
of the option names, to indicate that they each want an argument.

} - How to handle the same option given many times?
} 
} 	Like:
} 		fun -s abab -s ab -s x

RTFM.

    name+
          If a `+' appears after name, the option is appended to array
          each time it is found in the positional parameters; without
          the `+' only the _last_ occurrence of the option is preserved.

Hence

    zparseopts s+:=sop

would set sop=(-s abab -s ab -s x) given the "fun" call above.  This is
a case where "zparseopts -A" may not be very useful, because

    zparseopts -A hash s+:

would set hash[-s]="abababx" in that same situation.

