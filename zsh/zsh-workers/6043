From zsh-workers-return-6043-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Apr 15 12:08:48 1999
Return-Path: <zsh-workers-return-6043-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8416 invoked from network); 15 Apr 1999 12:08:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Apr 1999 12:08:47 -0000
Received: (qmail 12558 invoked by alias); 15 Apr 1999 12:08:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6043
Received: (qmail 12551 invoked from network); 15 Apr 1999 12:08:37 -0000
Date: Thu, 15 Apr 1999 14:08:28 +0200 (MET DST)
Message-Id: <199904151208.OAA08105@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Thu, 15 Apr 1999 04:03:10 -0700
Subject: Re: BUG: zsh-3.1.5-pws-14: parameter expansion not working properly


Bart Schaefer wrote:

> In what direction is the data flowing at this point?  Up or down the call
> stack?  I think you mean up; but paramsubst() is of course the caller of
> multsub() as well ...

I was slightly confused by this up/down thing, too. Again:

We have this call chain:

   A paramsubst(), calls
   B    multsub(), calls
   C       paramsubst()

Now, we could make the multsub() save (and at the end restore) the
value of, say `static int mult_isarr'. It then sets it to zero and
calls paramsubst() (via prefork(), as usual). At the end of
paramsubst() we set `mult_isarr = isarr'.

After the prefork(), multsub() now knows that the list it gets was an
array expression if `mult_isarr != 0'.

This was the first part of what I meant -- getting information about
the array'ness. With the other part I meant the call to multsub() we
are talking about here (line 980). There we have to decide if we give
`&aval' or `NULL' to multsub() where it is used to decide if the
joining should be done -- the problem to solve, as you said.

> Ideally, I think, it should still happen after, but the (non-)array-ness
> of whatever comes back from prefork() should be propagated up through
> isarr by multsub() -- which brings us back to the static global.

And this is what I meant (I just think less in terms of `isarr' then
in terms of `aval' -- and deciding when to give it to multsub()).

> No, that's too confusing and not necessary.  The only real issue is the
> "precedence" if you will, of subscripting vs. joining.  We "solved" the
> problem of subscripting scalars that were accidentally treated as arrays,
> by forcing all quoted arrays to be taken as scalars; I think we need to
> back off from that and concentrate on not accidentally treating scalars
> as arrays.

I don't think I understand this. And I thought I kept it from arrays
being accidentally being treated as scalars.

>From your first mail about this I got the impression that you wanted
nested expressions to keep their knowledge about whether they are
arrays or not, so that (with foo being an array) in "${${${${(@)foo}}}[1]}"
the outer paramsubst() (A) gets notified by multsub() (B) that the
inner paramsubst() (C) returned an array and the subscripting gives
the first array element. This `notification' would be done by having
multsub() use `&aval' instead of `&val' and by setting `*isarr', of
course.
With respect to the outer paramsubst()s this would make things
independent of whether the whole thing is in quotes or not, only the
inner paramsubst()s `control' if the outer ones work on an array
by testing if the thing is in quotes and if the `(@)' flag (or
something similar like the `s' flag or `=') is used.

Hope this makes it clearer.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

