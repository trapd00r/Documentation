From zsh-workers-return-6116-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Apr 26 22:52:41 1999
Return-Path: <zsh-workers-return-6116-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4516 invoked from network); 26 Apr 1999 22:52:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Apr 1999 22:52:39 -0000
Received: (qmail 21350 invoked by alias); 26 Apr 1999 22:52:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6116
Received: (qmail 21343 invoked from network); 26 Apr 1999 22:52:21 -0000
Message-Id: <199904262252.HAA00691@pop1.ngy.3web.ne.jp>
From: Tatsuo Furukawa <frkwtto@osk3.3web.ne.jp>
To: mason@primenet.com.au, schaefer@brasslantern.com
CC: zsh-workers@sunsite.auc.dk
In-reply-to: <slrn7i5f7d.5bm.mason@coral.primenet.com.au>
Subject: Re: Patch available for 3.0.6-pre-0
Mime-Version: 1.0 (generated by tm-edit 7.52)
Content-Type: text/plain; charset=US-ASCII
Date: Tue, 27 Apr 1999 00:22:47 +0900
X-Dispatcher: impost version 0.99i (Apr. 6, 1997)
Lines: 152


Hi, Bart & Geoff.

Bart> In particular, emitting the ch capability may require up to six
Bart> or seven bytes, where a relative horizontal or vertical move
Bart> might require fewer (depending on distance).

I didn't know that...

Geoff> This is a replacement for the zle_refresh.c patch (not the
Geoff> globals.h or zsh.h patch parts) moving a couple of things
Geoff> around and moving comments back to their appropriate spot.
Geoff> I've compiled it but haven't tested it a lot yet.

Geoff> Comments welcome.

I tested on hpterm, and (of course!) it worked well.  No problem!

So, I hope that Geoff's patch will be applied new zsh.


Geoff> It's against virgin 3.0.5 sources.

Now, the newest is 3.0.6-pre-1.  So, I made Geoff's patch againt
3.0.6-pre-1 version.  I hope that it will help reducing maintainer's
work.



diff -ur zsh-3.0.6-pre1-orig/Src/globals.h zsh-3.0.6-pre1-new/Src/globals.h
--- zsh-3.0.6-pre1-orig/Src/globals.h	Wed Apr 21 18:53:47 1999
+++ zsh-3.0.6-pre1-new/Src/globals.h	Mon Apr 26 20:33:08 1999
@@ -614,7 +614,7 @@
 {
     "cl", "le", "LE", "nd", "RI", "up", "UP", "do",
     "DO", "dc", "DC", "ic", "IC", "cd", "ce", "al", "dl", "ta",
-    "md", "so", "us", "me", "se", "ue"
+    "md", "so", "us", "me", "se", "ue", "ch"
 };
 #else
 extern char *tccapnams[TC_COUNT];
diff -ur zsh-3.0.6-pre1-orig/Src/zle_refresh.c zsh-3.0.6-pre1-new/Src/zle_refresh.c
--- zsh-3.0.6-pre1-orig/Src/zle_refresh.c	Mon Apr 26 20:21:08 1999
+++ zsh-3.0.6-pre1-new/Src/zle_refresh.c	Mon Apr 26 20:31:26 1999
@@ -810,20 +810,8 @@
 	}
     }
 
-    if (cl == vcs)
-	return;
-
-/* choose cheapest movements for ttys without multiple movement capabilities -
-   do this now because it's easier (to code) */
-    if (cl <= vcs / 2) {
-	zputc('\r', shout);
-	vcs = 0;
-    }
-    if (vcs < cl)
-	tc_rightcurs(cl);
-    else if (vcs > cl)
-	tc_leftcurs(vcs - cl);
-    vcs = cl;
+    if (cl != vcs)
+       singmoveto(cl);
 }
 
 /**/
@@ -841,16 +829,17 @@
     return 0;
 }
 
+/* ct: number of characters to move across */
 /**/
 void
-tc_rightcurs(int cl)
+tc_rightcurs(int ct)
 {
-    int ct,			/* number of characters to move across	    */
+    int cl,			/* ``desired'' absolute horizontal position */
 	i = vcs,		/* cursor position after initial movements  */
 	j;
     char *t;
 
-    ct = cl - vcs;
+    cl = ct + vcs;
 
 /* do a multright if we can - it's the most reliable */
     if (tccan(TCMULTRIGHT)) {
@@ -858,6 +847,13 @@
 	return;
     }
 
+/* do an absolute horizontal position if we can */
+    if (tccan(TCHORIZPOS)) {
+	tcoutarg(TCHORIZPOS, cl);
+	return;
+    }
+
+/* XXX: should really check "it" in termcap and use / and % */
 /* try tabs if tabs are non destructive and multright is not possible */
     if (!oxtabs && tccan(TCNEXTTAB) && ((vcs | 7) < cl)) {
 	i = (vcs | 7) + 1;
@@ -1062,23 +1058,21 @@
 {
     if (pos == vcs)
 	return;
-    if (pos <= vcs / 2) {
+
+/* choose cheapest movements for ttys without multiple movement capabilities -
+   do this now because it's easier (to code) */
+
+    if ((!tccan(TCMULTLEFT) || pos == 0) && (pos <= vcs / 2)) {
 	zputc('\r', shout);
 	vcs = 0;
     }
-    if (pos < vcs) {
+
+    if (pos < vcs)
 	tc_leftcurs(vcs - pos);
-	vcs = pos;
-    }
-    if (pos > vcs) {
-	if (tcmultout(TCRIGHT, TCMULTRIGHT, pos - vcs))
-	    vcs = pos;
-	else
-	    while (pos > vcs) {
-		zputc(nbuf[0][vcs], shout);
-		vcs++;
-	    }
-    }
+    else if (pos > vcs)
+	tc_rightcurs(pos - vcs);
+
+    vcs = pos;
 }
 
 /* generate left and right prompts */
diff -ur zsh-3.0.6-pre1-orig/Src/zsh.h zsh-3.0.6-pre1-new/Src/zsh.h
--- zsh-3.0.6-pre1-orig/Src/zsh.h	Wed Apr 21 18:53:49 1999
+++ zsh-3.0.6-pre1-new/Src/zsh.h	Mon Apr 26 20:33:54 1999
@@ -1249,7 +1249,8 @@
 #define TCALLATTRSOFF  21
 #define TCSTANDOUTEND  22
 #define TCUNDERLINEEND 23
-#define TC_COUNT       24
+#define TCHORIZPOS     24
+#define TC_COUNT       25
 
 #define tccan(X) (tclen[X])

-- 
Tatsuo Furukawa (frkwtto@osk3.3web.ne.jp)

