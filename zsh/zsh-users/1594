From zsh-workers-request@math.gatech.edu Fri Jun 12 09:17:59 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25544 invoked from network); 12 Jun 1998 09:17:58 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 12 Jun 1998 09:17:58 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id FAA20823;
	Fri, 12 Jun 1998 05:13:56 -0400 (EDT)
Resent-Date: Fri, 12 Jun 1998 05:13:45 -0400 (EDT)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <980612021435.ZM20682@candle.brasslantern.com>
Date: Fri, 12 Jun 1998 02:14:35 -0700
In-Reply-To: <199806120816.EAA22173@luomat.peak.org>
Comments: In reply to Timothy J Luoma <luomat+Lists/Zsh/users@luomat.peak.org>
        "help with 'rename' function" (Jun 12,  4:15am)
References: <199806120816.EAA22173@luomat.peak.org>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Timothy J Luoma <luomat+Lists/Zsh/users@luomat.peak.org>,
        zsh-users@math.gatech.edu
Subject: Re: help with 'rename' function
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"0YaTz1.0.g45.75FWr"@math>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/1594
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Jun 12,  4:15am, Timothy J Luoma wrote:
} Subject: help with 'rename' function
}
} I used to have a binary that did this, but I've lost it.
} 
} What it did was simple: it changed extensions of filenames.
} 
} For example, say you have a bunch of files which ended with .THIS and you  
} wanted to change them to end with .THAT
} 
} You would do
} 
} 	rename *.THIS THIS=THAT

I've had the following sitting around for a -long- time; in fact, I seem
not to have used it since sometime before installing 3.0, as I had to fix
some things to make it work.  It should probably be rewritten to use the
"getopts" builtin, and there's probably other things that are being done
in old-fashioned ways.

I have this in a file named "ren" in a directory in my fpath.  Probably
best invoked as "noglob ren ...." rather than with all the glob patterns
quoted (as they are in the examples).  Note that the patterns are glued
together as strings, without first checking for directory-ness etc., so
you have to be careful of where you put your "/" characters.

I doubt the core dump mentioned in the comments below still afflicts zsh,
but ....


#! /usr/local/bin/zsh -f
#
# Rename files according to a pattern.
#
#    ren \*.foo .bar			Renames all *.foo files to *.bar
#    ren -h foo\* bar			Renames all foo* files to bar*
#    ren -c cp \*.foo .bar		Copies all *.foo files to *.bar
#    ren \*.foo .bar /tmp/		Renames *.foo files to /tmp/*.bar
#    ren /tmp/\*.bar .foo /usr/tmp/	Renames /tmp/*.bar to /usr/tmp/*.foo
#    ren -h /tmp/bar\* /foo /usr/tmp	Renames /tmp/bar* to /usr/tmp/foo*
#    ren -h /tmp/bar\* /usr/tmp/foo	Renames /tmp/bar* to /usr/tmp/foo*
#
# To check what ren will execute, use something like:
#	ren -c echo /tmp/\*.bar .foo /usr/tmp
#
# (Note, the above example has a deliberate error, missing a /.)
#
# To use I/O redirection instead of arguments ("filter" mode):
#	ren -c head\< /tmp/\*bar .foo \>
#	ren -c cat\< /tmp/\*bar .foo \>/usr/tmp/
#
# The -e option (error) causes ren to exit if any command fails.
#
# The -s option (swap) switches the positions of the pattern and the
# replacement:
#
#    ren -s \*.foo .bar			For all *.foo renames .bar to .foo
#
# The -x option (eXchange) executes the command only on the replacements
# (i.e., passes only one argument to the command, which is the replacement):
#
#    ren -x -c touch \*.o .c		For each *.o, touches the .c

local files="" prefix="" chop=% head="" tail="" cmd=mv error="" xchg=false i

while [[ $# -gt 2 ]]
do
    case $1 in
    -c) cmd=$2; shift 2;;
    -e) error='|| break';;
    -h) chop='#*'; shift;;
    -t) chop='%'; shift;;
    -s) xchg=true; shift;;
    -x) xchg=drop; shift;;
    *) break;;
    esac
done

if [[ $# -lt 2 || $# -gt 3 || -z "$cmd" ]]
then
    echo "usage: ${0:t} [-h|-t] [-e] [-c command] pat repl [prefix]" 1>&2
    if [[ $# -gt 3 ]]
    then
	echo 'Did you remember to quote metacharacters in the pattern?' 1>&2
    fi
    return -1
elif [[ $# -eq 3 ]]
then
    prefix=$3
fi

case $chop in
%) tail=$2;;
*) head=$2;;
esac

# Use globbing to get the target files
files=($~1)

for i in $files
do
    case $xchg in
    drop)
	eval $cmd $prefix$head\$\{\$\{i$chop$1:t\}:r\}$tail $error
	;;
    true)
	eval $cmd $prefix$head\$\{\$\{i$chop$1:t\}:r\}$tail $i $error
	;;
    *)
	eval $cmd $i $prefix$head\$\{\$\{i$chop$1:t\}:r\}$tail $error
	;;
    esac	# Omit this and zsh dumps core in gettext2()
done

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

