From zsh-workers-return-16737-mason-zsh=primenet.com.au@sunsite.dk Thu Feb 28 05:48:01 2002
Return-Path: <zsh-workers-return-16737-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6956 invoked from network); 28 Feb 2002 05:48:00 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 28 Feb 2002 05:48:00 -0000
Received: (qmail 3748 invoked by alias); 28 Feb 2002 05:47:52 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16737
Received: (qmail 3735 invoked from network); 28 Feb 2002 05:47:51 -0000
Date: Wed, 27 Feb 2002 21:47:43 -0800 (PST)
From: Bart Schaefer <schaefer@brasslantern.com>
Sender: schaefer@ns1.sodaware.com
To: zsh-workers@sunsite.dk
cc: DervishD <raul@viadomus.com>
Subject: Re: About 'test' compatibility
In-Reply-To: <Pine.LNX.4.33.0202261404420.14523-100000@ns1.sodaware.com>
Message-ID: <Pine.LNX.4.44.0202272144350.31219-100000@ns1.sodaware.com>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

On Tue, 26 Feb 2002, Bart Schaefer wrote:

> > >No, it's the -d in $DEFAULT that's confusing it.  When $DEFAULT is
> > >-d, zsh is treating the above as "if there is a directory named `='
> > >..."
>
> It appears that bash gives the infix '=' higher precedence than the prefix
> '-d' or the infix '-a'

This really is a bug in zsh.  `[ -d = -d ]' is correctly parsed as an
infix `=' comparison, but `[ -d = -d anything ... ]' is not.

Does anybody know why the parser cares about !testargs[2] in the fragment
below?  Everything seems to work fine with it commented out.

Index: parse.c
===================================================================
RCS file: /extra/cvsroot/zsh/zsh-4.0/Src/parse.c,v
retrieving revision 1.11
diff -c -r1.11 parse.c
--- parse.c	2002/01/07 15:18:23	1.11
+++ parse.c	2002/02/28 05:40:49
@@ -1859,7 +1859,7 @@
 	    condlex();
 	    return par_cond_double(dupstring("-n"), s1);
 	}
-	if (testargs[1] && !testargs[2]) {
+	if (testargs[1] /* && !testargs[2] */) {
 	    /* three arguments: if the second argument is a binary operator, *
 	     * perform that binary test on the first and the trird argument  */
 	    if (!strcmp(*testargs, "=")  ||


