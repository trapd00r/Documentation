From zsh-users-return-15583-mason-zsh=primenet.com.au@zsh.org Sat Nov 27 04:13:58 2010
Return-Path: <zsh-users-return-15583-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 310 invoked by alias); 27 Nov 2010 04:13:57 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15583
Received: (qmail 371 invoked from network); 27 Nov 2010 04:13:45 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <101126201324.ZM27265@torch.brasslantern.com>
Date: Fri, 26 Nov 2010 20:13:24 -0800
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Updated "sticky-note" application
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

I'm just going to include the whole file here, the diff is 25% larger.

On Oct 26,  9:47pm, Bart Schaefer wrote:
} Subject: Re: scratchpad text
}
}     zle-line-init() {
}       local STICKYFILE=${STICKYFILE:-$HOME/.zsticky}
}       local STICKYSIZE=${STICKYSIZE:-1000}
} 
}       if [[ -n "$STICKYFILE" && -s "$STICKYFILE" ]]
}       then
} 	fc -ap $STICKYFILE $STICKYSIZE $STICKYSIZE
} 	print -nr "$terminfo[sc]$terminfo[home]"
} 	print -nr "$bg[yellow]$fg[black]"
} 	print -n -- "$(fc -n -l -1)"
} 	print -nr "$reset_color$terminfo[rc]"
}       fi
}     }
}     zle -N zle-line-init

A variant on the above is now folded into sticky-note so that you can
simply put a call to sticky-note in the zle-line-init widget.  There
are also styles for controlling the look and behavior.

--- 8< --- snip --- 8< ---
#!/bin/zsh -fi
# A zsh sticky-note ("post-it") application.  Load this file as a function:
#    autoload -Uz sticky-note
#
# It may then be bound as a widget:
#    zle -N sticky-note
# And/or run as a command:
#    sticky-note
#    sticky-note -b
#    sticky-note -l ...
# The -b option is like "zed -b": it installs keymaps/bindings only.
# Use the -l option to list previous sticky notes.  Most options of the
# "fc -l" command are supported, for selecting which notes to display.
# If "sticky-note -l" is run from inside a widget, the cursor is moved
# to the top left of the terminal before display and returned to its
# original position after display.  The -l option is implicitly added
# when sticky-note is called from zle-line-init, to avoid inadvertently
# trapping the user inside the note editor.
#
# Otherwise, invoke the line editor with the previous notes available
# as an editor history.  Two quick taps on the return/enter key finish
# the note, or you can use use ^X^W as usual (ZZ in vicmd mode).

# The application is configured by three zstyles, all using the context
# ":sticky-note".  The first two styles are "notefile" and "maxnotes"
# to name the file in which notes are stored and the maximum number of
# notes to retain:
#   zstyle :sticky-note notefile ~/.zsticky
#   zstyle :sticky-note maxnotes 1000

# The "theme" style may be set to control the appearance of the notes.
# The style is an associative array; the current set of values (defaults
# in parens) are:
#   bg    => name or ANSI escape for background color (yellow)
#   fg    => name or ANSI escape for foreground color (black)
#   color => ANSI escape for color scheme ($theme[bg]$theme[fg])
#   reset => ANSI escape to restore "normal" colors
# Values given as names are looked up in the $bg and $fg arrays from the
# "colors" function.  If a "color" field is set, the "bg" and "fg" fields
# are not used.  Example:
#   zstyle :sticky-note theme \
#     bg red \
#     fg $fg_bold[yellow]

# For backwards compatibility with an earlier version, the notefile may
# also be named by the STICKYFILE variable (defaults to $HOME/.zsticky).
# The number of notes stored may be given by STICKYSIZE (1000).

# I encourage all you creative people to contribute enhancements ...

emulate -LR zsh
setopt nobanghist extendedhistory histignoredups

local STICKYFILE=${STICKYFILE:-$HOME/.zsticky}
local STICKYSIZE=${STICKYSIZE:-1000}
local sticky stickyfile stickysize

zstyle -s :sticky-note notefile stickyfile || stickyfile=$STICKYFILE
zstyle -s :sticky-note maxnotes stickysize || stickysize=$STICKYSIZE

# Set up keybindings (adapted from "zed")
if ! bindkey -M sticky >& /dev/null
then
  bindkey -N sticky main
  bindkey -M sticky ^X^W accept-line
  bindkey -M sticky ^M^M accept-line	# Two quick RETs ends note
  bindkey -M sticky ^M self-insert-unmeta
fi
if ! bindkey -M sticky-vicmd >& /dev/null 
then
  bindkey -N sticky-vicmd vicmd
  bindkey -M sticky-vicmd ZZ accept-line
fi

[[ "$1" == -b ]] && return 0

# Look up color theme
local -A theme
(($+bg && $+fg)) || { autoload -Uz colors; colors }
zstyle -m :sticky-note theme '*' || {
    zstyle :sticky-note theme bg yellow fg black
}
zstyle -a :sticky-note theme theme
(( ${+bg[$theme[bg]]} )) && theme[bg]=$bg[$theme[bg]]
(( ${+fg[$theme[fg]]} )) && theme[fg]=$fg[$theme[fg]]
(( ${+theme[color]} )) || theme[color]=$theme[bg]$theme[fg]
(( ${+theme[reset]} )) || theme[reset]=$reset_color

# If invoked as a widget, behave a bit like run-help
if zle
then
  zmodload -i zsh/parameter
  if [[ $* == -*l* || $functrace == *zle-line-init:* ]]
  then
    fc -ap $stickyfile $stickysize $stickysize
    echoti sc
    echoti home
    print -nr "$theme[color]"
    fc -l "${@:--1}" | while read -r sticky; do print -- "$sticky"; done
    print -nr "$theme[reset]"
    echoti rc
  elif [[ $CONTEXT = (cont|select|vared) ]]
  then
    zle -M "No stickies during ${${(z)PREBUFFER}[1]:-$CONTEXT}, sorry"
    zle .beep
    zle -R
  else
    zle .push-line
    BUFFER=sticky-note
    zle .accept-line
  fi
  return 0
fi

# Invoked as a command, behave like zed, but write a history file
fc -ap $stickyfile $stickysize $stickysize

# With a -l option, list the existing sticky notes
if [[ "$*" == -*l* ]]
then
  print -nr "$theme[color]"
  # Use read/print loop to interpolate "\n" in history lines
  fc -f "$@" | while read -r sticky; do print -- "$sticky"; done
  print -nr "$theme[reset]"
  return 0
fi

# Edit a new sticky note and add it to the stickyfile
while vared -h -p "%{$theme[color]%}" -M sticky -m sticky-vicmd sticky
do
  {
    [[ -n "$sticky" ]] && print -s -- "$sticky"
  } always {
    (( TRY_BLOCK_ERROR = 0 ))
  } && break
  echo -n -e '\a'
done
return 0

