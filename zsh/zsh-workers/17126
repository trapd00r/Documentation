From zsh-workers-return-17126-mason-zsh=primenet.com.au@sunsite.dk Sun May 12 10:42:31 2002
Return-Path: <zsh-workers-return-17126-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2234 invoked from network); 12 May 2002 10:42:31 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 12 May 2002 10:42:31 -0000
Received: (qmail 16012 invoked by alias); 12 May 2002 10:42:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 17126
Received: (qmail 15995 invoked from network); 12 May 2002 10:42:23 -0000
From: Borsenkow Andrej <Andrej.Borsenkow@mow.siemens.ru>
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: Peter Stephenson <pws@csr.com>,
   Zsh hackers list
	 <zsh-workers@sunsite.dk>
Subject: Re: PATCH: zselect builtin.
In-Reply-To: <1020508155545.ZM7875@candle.brasslantern.com>
References: <8259.1020851945@csr.com> 
	<1020508155545.ZM7875@candle.brasslantern.com>
Content-Type: text/plain; charset=KOI8-R
Content-Transfer-Encoding: quoted-printable
X-Mailer: Ximian Evolution 1.0.3-1mdk 
Date: 12 May 2002 14:42:07 +0400
Message-Id: <1021200133.2915.12.camel@localhost.localdomain>
Mime-Version: 1.0

=F7 =F3=D2=C4, 08.05.2002, =D7 19:55, Bart Schaefer =
=CE=C1=D0=C9=D3=C1=CC:
> On May 8, 10:59am, Peter Stephenson wrote:
> } Subject: Re: PATCH: zselect builtin.
> }
> } > Aso you probably can't fully utilize select without non-blocking =
I/O.
> }=20
> } I don't see this; you can already poll a blocking fd using a zero
> } timeout.
>=20
> The problem is not blocking reads, but blocking *writes*.
>=20
> However, even non-blocking write is not sufficient if you can't find =
out
> what subset of the bytes got written and try again with the =
remainder.
>=20

Right. We could make print return number of characters written. For
non-printf case it is pretty trivial - it just amounts to

	iocount =3D 0;
	for (; *args; args++, len++) {
	    iocount +=3D fwrite(*args, *len, 1, fout);
	    if (args[1] && (EOF !=3D
		fputc(ops['l'] ? '\n' : ops['N'] ? '\0' : ' ', fout))
		iocount++;
	}
        setiparam("IOCONUNT", iocount);

for printf-like case it is not quite as simple due to large number of
idividual putc's; also it is not clear if it is needed at all (I do not
see how it can be used).

The same is true of read of course. Both can set IOCOUNT indicating
number of characters transmitted in last call.

Alternative is to add raw write function.=20

It is user responsibility then to ensure print does not mangle output
string (i.e. call it with -r and possible -n). Usage is obvious

while true; do
  ....
  zselect -w $d
  print -rnu$d $buffer
  (( IOCOUNT )) || break # EOF
  (( IOCOUNT =3D=3D $#buffer )) || break # IO error
  ....
done

-andrej

