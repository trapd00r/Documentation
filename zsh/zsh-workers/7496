From zsh-workers-return-7496-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Aug 26 11:36:21 1999
Return-Path: <zsh-workers-return-7496-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27563 invoked from network); 26 Aug 1999 11:36:18 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Aug 1999 11:36:18 -0000
Received: (qmail 7603 invoked by alias); 26 Aug 1999 11:36:06 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7496
Received: (qmail 7596 invoked from network); 26 Aug 1999 11:36:05 -0000
Date: Thu, 26 Aug 1999 13:35:54 +0200 (MET DST)
Message-Id: <199908261135.NAA15733@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Zefram's message of Thu, 26 Aug 1999 10:58:06 +0100 (BST)
Subject: Re: PATCH: Re: Files modified after a given date


Zefram wrote:

> Sven Wischnowsky wrote:
> >Hmm, yes that may be an interesting alternative. Wouldn't be hard to
> >implement either and we wouldn't really need any meta character-
> >sequence, we could just set `$FILE' or something like that before
> >evaluating the whole thing.
> 
> I'm in two minds as to which arrangement is better.  I think this one just
> has the edge, in that it makes it possible to invent impromptu functions
> on the command line.  But make it $_ instead of $FILE -- not only is it
> shorter, but it's already used in comparable ways (mail notification).

The patch would be something like the one below. It allows `*(e:string:)'
with `$_' being the filename. `reply' and `REPLY' are still used.

This goes on top of 7482.

Bye
 Sven

diff -u os/glob.c Src/glob.c
--- os/glob.c	Thu Aug 26 11:28:40 1999
+++ Src/glob.c	Thu Aug 26 13:23:51 1999
@@ -107,7 +107,7 @@
 #define TT_MEGABYTES 3
 
 
-typedef int (*TestMatchFunc) _((char *, struct stat *, off_t, LinkList));
+typedef int (*TestMatchFunc) _((char *, struct stat *, off_t, char *));
 
 struct qual {
     struct qual *next;		/* Next qualifier, must match                */
@@ -118,7 +118,7 @@
     int amc;			/* Flag for which time to test (a, m, c)     */
     int range;			/* Whether to test <, > or = (as per signum) */
     int units;			/* Multiplier for time or size, respectively */
-    LinkList ldata;		/* currently only: shell function to call    */
+    char *sdata;		/* currently only: expression to eval        */
 };
 
 /* Qualifiers pertaining to current pattern */
@@ -263,7 +263,7 @@
 	    /* Reject the file if the function returned zero *
 	     * and the sense was positive (sense&1 == 0), or *
 	     * vice versa.                                   */
-	    if ((!((qn->func) (news, bp, qn->data, qn->ldata)) ^ qn->sense) & 1) {
+	    if ((!((qn->func) (news, bp, qn->data, qn->sdata)) ^ qn->sense) & 1) {
 		/* Try next alternative, or return if there are no more */
 		if (!(qo = qo->or))
 		    return;
@@ -853,18 +853,18 @@
 	    int sense = 0;	   /* bit 0 for match (0)/don't match (1)   */
 				   /* bit 1 for follow links (2), don't (0) */
 	    off_t data = 0;	   /* Any numerical argument required       */
-	    LinkList ldata = NULL; /* Any list argument required            */
-	    int (*func) _((char *, Statptr, off_t, LinkList));
+	    char *sdata = NULL; /* Any list argument required            */
+	    int (*func) _((char *, Statptr, off_t, char *));
 
 	    str[sl-1] = 0;
 	    *s++ = 0;
 	    while (*s && !colonmod) {
-		func = (int (*) _((char *, Statptr, off_t, LinkList)))0;
+		func = (int (*) _((char *, Statptr, off_t, char *)))0;
 		if (idigit(*s)) {
 		    /* Store numeric argument for qualifier */
 		    func = qualflags;
 		    data = 0;
-		    ldata = NULL;
+		    sdata = NULL;
 		    while (idigit(*s))
 			data = data * 010 + (*s++ - '0');
 		} else if (*s == ',') {
@@ -1189,44 +1189,28 @@
 			    s++;
 			    break;
 			}
-		    case 'F':
+		    case 'e':
 			{
 			    char sav, *tt = get_strarg(s);
 
 			    if (!*tt) {
-				zerr("missing end of function name", NULL, 0);
+				zerr("missing end of string", NULL, 0);
 				data = 0;
 			    } else {
-				char sep = *s;
-
 				sav = *tt;
 				*tt = '\0';
-				func = qualshfunc;
-				ldata = newlinklist();
-				addlinknode(ldata, dupstring(s + 1));
-				addlinknode(ldata, NULL);
-				*tt = sav;
-				if (sav)
-				    s = tt + 1;
-				else
-				    s = tt;
-				while (*s == sep) {
-				    tt = get_strarg(s);
-				    if (!*tt) {
-					zerr("missing end of argument", NULL, 0);
-					data = 0;
-					ldata = NULL;
-					break;
-				    } else {
-					sav = *tt;
-					*tt = '\0';
-					addlinknode(ldata, dupstring(s + 1));
-					*tt = sav;
-					if (sav)
-					    s = tt + 1;
-					else
-					    s = tt;
-				    }
+				func = qualsheval;
+				sdata = dupstring(s + 1);
+				untokenize(sdata);
+				if (!parsestr(sdata)) {
+				    *tt = sav;
+				    if (sav)
+					s = tt + 1;
+				    else
+					s = tt;
+				} else {
+				    func = NULL;
+				    sdata = NULL;
 				}
 			    }
 			    break;
@@ -1265,7 +1249,7 @@
 		    qn->func = func;
 		    qn->sense = sense;
 		    qn->data = data;
-		    qn->ldata = ldata;
+		    qn->sdata = sdata;
 		    qn->range = range;
 		    qn->units = units;
 		    qn->amc = amc;
@@ -2239,7 +2223,7 @@
 
 /**/
 static int
-qualdev(char *name, struct stat *buf, off_t dv, LinkList dummy)
+qualdev(char *name, struct stat *buf, off_t dv, char *dummy)
 {
     return buf->st_dev == dv;
 }
@@ -2248,7 +2232,7 @@
 
 /**/
 static int
-qualnlink(char *name, struct stat *buf, off_t ct, LinkList dummy)
+qualnlink(char *name, struct stat *buf, off_t ct, char *dummy)
 {
     return (range < 0 ? buf->st_nlink < ct :
 	    range > 0 ? buf->st_nlink > ct :
@@ -2259,7 +2243,7 @@
 
 /**/
 static int
-qualuid(char *name, struct stat *buf, off_t uid, LinkList dummy)
+qualuid(char *name, struct stat *buf, off_t uid, char *dummy)
 {
     return buf->st_uid == uid;
 }
@@ -2268,7 +2252,7 @@
 
 /**/
 static int
-qualgid(char *name, struct stat *buf, off_t gid, LinkList dummy)
+qualgid(char *name, struct stat *buf, off_t gid, char *dummy)
 {
     return buf->st_gid == gid;
 }
@@ -2277,7 +2261,7 @@
 
 /**/
 static int
-qualisdev(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualisdev(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISBLK(buf->st_mode) || S_ISCHR(buf->st_mode);
 }
@@ -2286,7 +2270,7 @@
 
 /**/
 static int
-qualisblk(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualisblk(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISBLK(buf->st_mode);
 }
@@ -2295,7 +2279,7 @@
 
 /**/
 static int
-qualischr(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualischr(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISCHR(buf->st_mode);
 }
@@ -2304,7 +2288,7 @@
 
 /**/
 static int
-qualisdir(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualisdir(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISDIR(buf->st_mode);
 }
@@ -2313,7 +2297,7 @@
 
 /**/
 static int
-qualisfifo(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualisfifo(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISFIFO(buf->st_mode);
 }
@@ -2322,7 +2306,7 @@
 
 /**/
 static int
-qualislnk(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualislnk(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISLNK(buf->st_mode);
 }
@@ -2331,7 +2315,7 @@
 
 /**/
 static int
-qualisreg(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualisreg(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISREG(buf->st_mode);
 }
@@ -2340,7 +2324,7 @@
 
 /**/
 static int
-qualissock(char *name, struct stat *buf, off_t junk, LinkList dummy)
+qualissock(char *name, struct stat *buf, off_t junk, char *dummy)
 {
     return S_ISSOCK(buf->st_mode);
 }
@@ -2349,7 +2333,7 @@
 
 /**/
 static int
-qualflags(char *name, struct stat *buf, off_t mod, LinkList dummy)
+qualflags(char *name, struct stat *buf, off_t mod, char *dummy)
 {
     return mode_to_octal(buf->st_mode) & mod;
 }
@@ -2358,7 +2342,7 @@
 
 /**/
 static int
-qualmodeflags(char *name, struct stat *buf, off_t mod, LinkList dummy)
+qualmodeflags(char *name, struct stat *buf, off_t mod, char *dummy)
 {
     long v = mode_to_octal(buf->st_mode), y = mod & 07777, n = mod >> 12;
 
@@ -2369,7 +2353,7 @@
 
 /**/
 static int
-qualiscom(char *name, struct stat *buf, off_t mod, LinkList dummy)
+qualiscom(char *name, struct stat *buf, off_t mod, char *dummy)
 {
     return S_ISREG(buf->st_mode) && (buf->st_mode & S_IXUGO);
 }
@@ -2378,7 +2362,7 @@
 
 /**/
 static int
-qualsize(char *name, struct stat *buf, off_t size, LinkList dummy)
+qualsize(char *name, struct stat *buf, off_t size, char *dummy)
 {
 #if defined(LONG_IS_64_BIT) || defined(OFF_T_IS_64_BIT)
 # define QS_CAST_SIZE()
@@ -2413,7 +2397,7 @@
 
 /**/
 static int
-qualtime(char *name, struct stat *buf, off_t days, LinkList dummy)
+qualtime(char *name, struct stat *buf, off_t days, char *dummy)
 {
     time_t now, diff;
 
@@ -2444,28 +2428,32 @@
 	    diff == days);
 }
 
-/* call shell function */
+/* evaluate a string */
 
 /**/
 static int
-qualshfunc(char *name, struct stat *buf, off_t days, LinkList args)
+qualsheval(char *name, struct stat *buf, off_t days, char *str)
 {
     List list;
-    char *func = (char *) getdata(firstnode(args));
+    char *usav = underscore;
 
-    if ((list = getshfunc(func)) && list != &dummy_list) {
-	int osc = sfcontext, ef = errflag, lv = lastval, ret;
+    underscore = name;
+    str = dupstring(str);
+    singsub(&str);
+    underscore = usav;
+    untokenize(str);
+
+    if ((list = parse_string(str, 0))) {
+	int ef = errflag, lv = lastval, ret;
 
 	unsetparam("reply");
 	unsetparam("REPLY");
 
-	setdata(nextnode(firstnode(args)), dupstring(name));
-	sfcontext = SFC_GLOB;
-	doshfunc(func, list, args, 0, 0);
+	execlist(list, 1, 0);
+
 	ret = lastval;
 	errflag = ef;
 	lastval = lv;
-	sfcontext = osc;
 
 	if (!(inserts = getaparam("reply")) &&
 	    !(inserts = gethparam("reply"))) {
diff -u os/zsh.h Src/zsh.h
--- os/zsh.h	Thu Aug 26 11:28:43 1999
+++ Src/zsh.h	Thu Aug 26 13:30:26 1999
@@ -819,7 +819,6 @@
 #define SFC_WIDGET   3		/* user defined widget */
 #define SFC_COMPLETE 4		/* called from completion code */
 #define SFC_CWIDGET  5		/* new style completion widget */
-#define SFC_GLOB     6		/* called from the `F' glob qualifier */
 
 /* node in list of function call wrappers */
 
diff -u od/Zsh/expn.yo Doc/Zsh/expn.yo
--- od/Zsh/expn.yo	Thu Aug 26 11:28:35 1999
+++ Doc/Zsh/expn.yo	Thu Aug 26 13:34:23 1999
@@ -1377,23 +1377,24 @@
 permission, and for which other users don't have read or execute
 permission.
 )
-item(tt(F)var(name)[var(args)...])(
-The shell function var(name) will be called with the generated
-filename as its first argument and the return value determines if the
+item(tt(e)var(string))(
+The var(string) will be executed and the return value determines if the
 filename should be included in the list (if it is zero) or not (if it
-is non-zero). The first character after the `tt(F)' will be used as a
+is non-zero). The first character after the `tt(e)' will be used as a
 separator and anything up to the next matching separator will be taken 
-as the name of the function (`tt([)', `tt({)', and `tt(<)' match
-`tt(])', `tt(})', and `tt(>)' respectively, any other character
-matches itself). Arguments may be given inside consecutive pairs of
-the same separator(s). These strings will be given literally to the
-shell function as the second to last argument.
+as the var(string) (`tt([)', `tt({)', and `tt(<)' match `tt(])',
+`tt(})', and `tt(>)' respectively, any other character matches
+itself). Before the string is executed, expansion is performed on it
+with the parameter tt($_) being set to the filename currently being
+tested. Note that parameter expansions in the var(string) have to be
+quoted to prevent them from being expanded before globbing is done.
 
-If the function sets the parameter tt(reply) to an array or to a
-string or if it sets the parameter tt(REPLY) to a string, then these
-strings will be inserted into the generated list instead of the
-original string. For security reasons, these parameters will be unset
-by the shell before the function is called.
+If during the execution of var(string) the parameter tt(reply) is set
+to an array or to a string or if the parameter tt(REPLY) is set to a
+string, then these strings will be inserted into the generated list
+instead of the original filename. For security reasons, these
+parameters will be unset by the shell before the var(string) is
+executed.
 )
 item(tt(d)var(dev))(
 files on the device var(dev)

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

