From zsh-workers-request@euclid.skiles.gatech.edu Mon Jan 27 22:04:23 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 22921 invoked from network); 27 Jan 1997 22:04:20 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 27 Jan 1997 22:04:20 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id RAA05416; Mon, 27 Jan 1997 17:00:53 -0500 (EST)
Resent-Date: Mon, 27 Jan 1997 17:00:53 -0500 (EST)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199701272202.XAA13587@bolyai.cs.elte.hu>
Subject: Re: time builtin
In-Reply-To: <m0voxzo-000X3aC@lorelei.approve.se> from Goran Larsson at "Jan 27, 97 09:49:40 pm"
To: hoh@approve.se (Goran Larsson)
Date: Mon, 27 Jan 1997 23:02:25 +0100 (MET)
Cc: zsh-workers@math.gatech.edu
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL27 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"LAqFO2.0.ZK1.KMIxo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2825
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Goran Larsson wrote:
> Now printtime() in 2.6-beta13 had this code:
> 
>     if (percent > 100)
>         percent = 100;   /* just to make it look right */
> 
> but that was removed in 3.0.0. Reinserting those two lines
> in 3.0.0 obviously ``fixes'' the problem, or perhaps it is
> more accurate to say that it hides the real problem again.
> 
> Is it possible to fix this, or are the times here just to
> close to the resolution provided by the kernel?

Perhaps.  Or it may be a kernel bug.  Solaris has one.  Try the program
below.  It prints three time lines, and the last two shoud be the same.
That's not the case on Solaris.

What happens:

A forks B, B forks C and exits.  C consumes CPU time then exits.  This is
accounted for A but A does not receive the child signal when C dies so it
siply accounts this time to its next child.

Zoltan


#include <unistd.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/times.h>
#include <stdio.h>

void
printsig(int signum)
{
    printf("Received signal %d\n", signum);
}

void
install_handler(int sig, void (*handler)(int))
{
    struct sigaction act;
 
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);        /* only block sig while in handler */
    act.sa_flags = 0;
    sigaction(sig, &act, (struct sigaction *)NULL);
}

int
main(int argc, char *argv[])
{
    pid_t ppid = getpid();
    pid_t pid, wpid;
    int status;
    struct tms tms;
    double clktck = sysconf(_SC_CLK_TCK);

    pid = fork();
    if (pid < 0) {
	perror(argv[0]);
	exit(1);
    } else if (!pid) {
	int i;

	if (fork())
	    exit(0);
	for (i = 100000000; i--;);
	kill(ppid, SIGUSR1);
	exit(1);
    }
    install_handler(SIGUSR1, printsig);
    install_handler(SIGCHLD, printsig);
    while ((wpid = wait(&status)) == -1)
	perror(argv[0]);
    if (wpid != pid) {
	fprintf(stderr, "%s: unknown child: %d instead of %d.\n",
		argv[0], (int) wpid, (int) pid);
	exit(1);
    }
    times(&tms);
    printf("%.2fs system, %.2fs user\n",
	   tms.tms_cstime / clktck, tms.tms_cutime / clktck);
    pause();
    times(&tms);
    printf("%.2fs system, %.2fs user\n",
	   tms.tms_cstime / clktck, tms.tms_cutime / clktck);
    sleep(2);
    times(&tms);
    printf("%.2fs system, %.2fs user\n",
	   tms.tms_cstime / clktck, tms.tms_cutime / clktck);
    exit(0);
}

