From zsh-workers-return-12354-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jul 24 12:51:30 2000
Return-Path: <zsh-workers-return-12354-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19425 invoked from network); 24 Jul 2000 12:51:28 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Jul 2000 12:51:28 -0000
Received: (qmail 7967 invoked by alias); 24 Jul 2000 12:51:12 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12354
Received: (qmail 7960 invoked from network); 24 Jul 2000 12:51:11 -0000
Date: Mon, 24 Jul 2000 14:50:55 +0200 (MET DST)
Message-Id: <200007241250.OAA05728@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: _multi_parts


This makes _multi_parts a bit faster.

Is _multi_parts interesting enough to make us add C-support for it?

Bye
 Sven

Index: Completion/Core/_multi_parts
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_multi_parts,v
retrieving revision 1.3
diff -u -r1.3 _multi_parts
--- Completion/Core/_multi_parts	2000/05/31 09:38:26	1.3
+++ Completion/Core/_multi_parts	2000/07/24 12:47:27
@@ -7,9 +7,9 @@
 # The parts of words from the array that are separated by the
 # separator character are then completed independently.
 
-local sep matches pref npref i tmp1 group expl menu pre suf opre osuf cpre
+local sep pref npref i tmp2 group expl menu pre suf opre osuf cpre
 local opts sopts matcher imm
-typeset -U tmp2
+typeset -U tmp1 matches
 
 # Get the options.
 
@@ -25,15 +25,15 @@
 fi
 
 # Get the arguments, first the separator, then the array. The array is 
-# stored in `matches'. Further on this array will always contain those 
-# words from the original array that still match everything we have
+# stored in `tmp1'. Further on the array `matches' will always contain
+# those words from the original array that still match everything we have
 # tried to match while we walk through the string from the line.
 
 sep="$1"
 if [[ "${2[1]}" = '(' ]]; then
-  matches=( ${=2[2,-2]} )
+  tmp1=( ${=2[2,-2]} )
 else
-  matches=( "${(@P)2}" )
+  tmp1=( "${(@P)2}" )
 fi
 
 # In `pre' and `suf' we will hold the prefix and the suffix from the
@@ -59,9 +59,9 @@
 # If the string from the line matches at least one of the strings,
 # we use only the matching strings.
 
-compadd -O tmp1 -M "r:|${sep}=* r:|=* $matcher" -a matches
+compadd -O matches -M "r:|${sep}=* r:|=* $matcher" -a tmp1
 
-(( $#tmp1 )) && matches=( "$tmp1[@]" )
+(( $#matches )) || matches=( "$tmp1[@]" )
 
 while true; do
 
@@ -96,8 +96,6 @@
     [[ $#tmp1 -eq 0 && -n "$_comp_correct" ]] &&
       compadd -O tmp1 - "${(@)matches%%${sep}*}"
 
-    tmp2=( "$tmp1[@]" )
-
     if [[ $#tmp1 -eq 1 ]]; then
 
       # Only one match. If there are still separators from the line
@@ -118,9 +116,7 @@
 	  compadd "$group[@]" "$expl[@]" "$opts[@]" \
                   -M "r:|${sep}=* r:|=* $matcher" - "$pref$matches[1]"
         else
-	  tmp2=( "${(@M)matches:#${tmp1[1]}${sep}*}" )
-
-	  if (( $#tmp2 )); then
+	  if (( $matches[(I)${tmp1[1]}${sep}*] )); then
 	    compadd "$group[@]" "$expl[@]" -p "$pref" -r "$sep" -S "$sep" "$opts[@]" \
                     -M "r:|${sep}=* r:|=* $matcher" - "$tmp1[1]"
           else
@@ -148,6 +144,8 @@
 	SUFFIX="$suf"
       fi
 
+      matches=( "${(@M)matches:#(${(j:|:)~tmp1})*}" )
+
       if ! zstyle -t ":completion:${curcontext}:" expand suffix ||
          [[ -n "$menu" || -z "$compstate[insert]" ]]; then
 
@@ -161,44 +159,33 @@
         else
 	  tmp2=()
         fi
-        for i in "${(@M)matches:#(${(j:|:)~tmp1})*}"; do
-	  case "$i" in
-	  *${sep})
-            compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" \
-	            -p "$pref" \
-                    -M "r:|${sep}=* r:|=* $matcher" - "${i%%${sep}*}" && ret=0
-            ;;
-	  ${sep}*)
+
+
+        compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" \
+	        -p "$pref" "$tmp2[@]" -M "r:|${sep}=* r:|=* $matcher" - \
+                "${(@)${(@M)matches:#*${sep}}%%${sep}*}" && ret=0
+        (( $matches[(I)${sep}*] )) &&
             compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
 	            -p "$pref" \
                     -M "r:|${sep}=* r:|=* $matcher" - "$sep" && ret=0
-            ;;
-	  *${sep}*)
-            compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" \
-	            -p "$pref" \
-                    -M "r:|${sep}=* r:|=* $matcher" - "${i%%${sep}*}" && ret=0
-            ;;
-          *)
-            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" \
-                    -M "r:|${sep}=* r:|=* $matcher" - "$i" && ret=0
-            ;;
-          esac
-        done
+        compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" \
+                -p "$pref" "$tmp2[@]" -M "r:|${sep}=* r:|=* $matcher" - \
+                "${(@)${(@M)matches:#*?${sep}?*}%%${sep}*}" && ret=0
+        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" "$tmp2[@]" \
+                -M "r:|${sep}=* r:|=* $matcher" - \
+                "${(@)matches:#*${sep}*}" && ret=0
       else
         # With normal completion we add all matches one-by-one with
 	# the unmatched part as a suffix. This will insert the longest
 	# unambiguous string for all matching strings.
 
-        for i in "${(@M)matches:#(${(j:|:)~tmp1})*}"; do
-	  if [[ "$i" = *${sep}* ]]; then
-            compadd "$group[@]" "$expl[@]" "$opts[@]" \
-	            -p "$pref" -s "${i#*${sep}}" \
-                    -M "r:|${sep}=* r:|=* $matcher" - "${i%%${sep}*}" && ret=0
-          else
-            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" \
-                    -M "r:|${sep}=* r:|=* $matcher" - "$i" && ret=0
-          fi
-        done
+        compadd "$group[@]" "$expl[@]" "$opts[@]" \
+	        -p "$pref" -s "${i#*${sep}}" \
+                -M "r:|${sep}=* r:|=* $matcher" - \
+                "${(@)${(@M)matches:#*${sep}*}%%${sep}*}" && ret=0
+        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" \
+                -M "r:|${sep}=* r:|=* $matcher" - \
+                "${(@)matches:#*${sep}*}" && ret=0
       fi
       return ret
     else

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

