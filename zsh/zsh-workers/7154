From zsh-workers-return-7154-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jul 15 08:51:55 1999
Return-Path: <zsh-workers-return-7154-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15270 invoked from network); 15 Jul 1999 08:51:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Jul 1999 08:51:53 -0000
Received: (qmail 22561 invoked by alias); 15 Jul 1999 08:51:45 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7154
Received: (qmail 22554 invoked from network); 15 Jul 1999 08:51:45 -0000
Date: Thu, 15 Jul 1999 10:51:43 +0200 (MET DST)
Message-Id: <199907150851.KAA14072@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Vin Shelton's message of 14 Jul 1999 12:08:31 -0400
Subject: Re: Extra List in 3.1.6-test1


Vin Shelton wrote:

> I'm getting an extra list with ambiguous completion in 3.1.6-test1.
> 3.1.6-test1 with no patches applied.  Start with a clear screen.

This was a bug. The test at the end of do_ambiguous() thought there
wasn't a list. The patch makes listshown be set to 1 if a list is
below the prompt and to -1 if one is above it, so that we can test for 
both and zrefresh() is able to set listshown=0 only if it really just
cleared the list.

This also made me test noalwayslastprompt with complist for the first
time (ahem). So this patch also avoids using menu-selection if no
alwayslastprompt behaviour was requested (one way or another).


Bye
 Sven

diff -u os/Zle/complist.c Src/Zle/complist.c
--- os/Zle/complist.c	Thu Jul 15 09:49:52 1999
+++ Src/Zle/complist.c	Thu Jul 15 10:42:06 1999
@@ -308,7 +308,7 @@
     Cmatch *p, m;
     Cexpl *e;
     int nlines = 0, ncols, nlist = 0, longest = 1, pnl = 0, opl = 0;
-    int of = isset(LISTTYPES);
+    int of = isset(LISTTYPES), cf;
     int mc, ml = 0, cc, hasm = 0, cl;
     struct listcols col;
 
@@ -394,8 +394,10 @@
 			nlines += 1 + ((1 + niceztrlen(m->str)) / columns);
 	}
     }
-    if (!nlines) {
+    cf = (isset(USEZLE) && !termflags && complastprompt && *complastprompt);
+    if (!nlines || (mselect >= 0 && (!cf || (nlines + nlnct - 1) >= lines))) {
 	showinglist = listshown = 0;
+	noselect = 1;
 	return 1;
     }
     /* Set the cursor below the prompt. */
@@ -404,8 +406,7 @@
     trashzle();
     showinglist = listshown = 0;
 
-    clearflag = (isset(USEZLE) && !termflags &&
-		 complastprompt && *complastprompt);
+    clearflag = cf;
 
     /* Maybe we have to ask if the user wants to see the list. */
     if ((!minfo.cur || !minfo.asked) &&
@@ -657,20 +658,20 @@
 	    pnl = 1;
 	g = g->next;
     }
-
     if (clearflag) {
 	/* Move the cursor up to the prompt, if always_last_prompt *
 	 * is set and all that...                                  */
 	if ((nlines += nlnct - 1) < lines) {
 	    tcmultout(TCUP, TCMULTUP, nlines);
 	    showinglist = -1;
-	    listshown = 1;
 	} else
 	    clearflag = 0, putc('\n', shout);
     } else
 	putc('\n', shout);
+    listshown = (clearflag ? 1 : -1);
     if (!hasm || nlines >= lines)
 	noselect = 1;
+
     return noselect;
 }
 
diff -u os/Zle/zle_refresh.c Src/Zle/zle_refresh.c
--- os/Zle/zle_refresh.c	Thu Jul 15 09:49:53 1999
+++ Src/Zle/zle_refresh.c	Thu Jul 15 10:28:44 1999
@@ -53,7 +53,8 @@
 /**/
 int showinglist;
 
-/* Non-zero if a completion list was displayed. */
+/* > 0 if a completion list is displayed below the prompt,
+ * < 0 if a list is displayed above the prompt. */
 
 /**/
 int listshown;
@@ -265,7 +266,7 @@
     if (inlist)
 	return;
 
-    if (clearlist && listshown) {
+    if (clearlist && listshown > 0) {
 	if (tccan(TCCLEAREOD)) {
 	    int ovln = vln, ovcs = vcs;
 	    char *nb = nbuf[vln];
@@ -331,7 +332,8 @@
                 tcout(TCCLEAREOD);
             else
                 cleareol = 1;   /* request: clear to end of line */
-	    listshown = 0;
+	    if (listshown > 0)
+		listshown = 0;
 	}
         if (t0 > -1)
             olnct = t0;
diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Thu Jul 15 09:49:54 1999
+++ Src/Zle/zle_tricky.c	Thu Jul 15 10:27:26 1999
@@ -7520,11 +7520,13 @@
      * if it is needed.                                                     */
     if (isset(LISTBEEP))
 	ret = 1;
-    if (uselist && (usemenu != 2 || (!showinglist && !oldlist)) &&
+
+    if (uselist && (usemenu != 2 || (!listshown && !oldlist)) &&
 	((!showinglist && (!listshown || !oldlist)) ||
 	 (usemenu == 3 && !oldlist)) &&
 	(smatches >= 2 || (compforcelist && *compforcelist)))
 	showinglist = -2;
+
     return ret;
 }
 
@@ -8174,18 +8176,18 @@
 	    pnl = 1;
 	g = g->next;
     }
-
     if (clearflag) {
 	/* Move the cursor up to the prompt, if always_last_prompt *
 	 * is set and all that...                                  */
 	if ((nlines += nlnct - 1) < lines) {
 	    tcmultout(TCUP, TCMULTUP, nlines);
 	    showinglist = -1;
-	    listshown = 1;
 	} else
 	    clearflag = 0, putc('\n', shout);
     } else
 	putc('\n', shout);
+    listshown = (clearflag ? 1 : -1);
+
     return 0;
 }
 
diff -u od/Zsh/mod_complist.yo Doc/Zsh/mod_complist.yo
--- od/Zsh/mod_complist.yo	Thu Jul 15 09:49:59 1999
+++ Doc/Zsh/mod_complist.yo	Thu Jul 15 10:50:26 1999
@@ -79,7 +79,12 @@
 
 subsect(Menu selection)
 The tt(complist) module also offers an alternative style of selecting
-matches from a list, called menu-selection. It can be invoked directly by
+matches from a list, called menu-selection, which can be used if the
+shell is set up to return to the last prompt after showing a
+completion list (see the tt(ALWAYS_LAST_PROMPT) option in
+ifzman(zmanref(zshoptions))\
+ifnzman(noderef(Options))\
+). It can be invoked directly by
 the widget tt(menu-select) defined by the module.  Alternatively,
 the parameter tt(SELECTMIN) can be set to an integer, which give the
 minimum number of matches that must be present before menu selection is

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

