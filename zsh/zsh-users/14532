From zsh-users-return-14532-mason-zsh=primenet.com.au@zsh.org Wed Nov 04 06:29:57 2009
Return-Path: <zsh-users-return-14532-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 843 invoked by alias); 4 Nov 2009 06:29:57 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14532
Received: (qmail 16557 invoked from network); 4 Nov 2009 06:29:55 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <091103212914.ZM24133@torch.brasslantern.com>
Date: Tue, 03 Nov 2009 21:29:12 -0800
In-reply-to: <2d460de70911031601o69b4bf40u9ba8a4939618e8fe@mail.gmail.com>
Comments: In reply to Richard Hartmann <richih.mailinglist@gmail.com>
 "Re: strictly literal command lines?" (Nov  4,  1:01am)
References: <87k4y79xxp.fsf@ixian.com>
	<237967ef0911031316n64d6e1c4q671a2bfc0b496287@mail.gmail.com>
	<2d460de70911031601o69b4bf40u9ba8a4939618e8fe@mail.gmail.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: strictly literal command lines?
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Nov 4,  1:01am, Richard Hartmann wrote:
}
} While url-quote-magic is extremely handy, a way to force literal
} interpretation could make sense and ease handling, sometimes.

Which is why the shell grammar has quotation marks. ;-)

More seriously, what does "literal interpretation" mean?  If it
includes whitespace, then how do you distinguish words (especially
the command word from the argument words)?  Does it include only
command separators, or is it any non-whitespace?  Do quotes become
literal as well -- in which case whitespace inside what appears to
be a quoted string becomes neither quoted nor literal?  If quotes
don't become literal, what happens to variable references inside
double quotes inside "literal interpretation"?  What happens to
backslashes and the characters following backslashes?

Nevertheless, here's a widget that you might find handy.  I tied it
to the CSH_JUNKIE_QUOTES option because when that option is not set,
an unbalanced quote should continue the word on the next line; but
you can easily remove that dependency if you prefer.

    accept-line-and-close-quote () {
	if [[ -o cshjunkiequotes ]]
	then
	    local L="$({: ${(XQ)BUFFER}} 2>&1)"
	    case $L in
		(* unmatched \") BUFFER+=\"  ;;
		(* unmatched \') BUFFER+=\'  ;;
	    esac
	fi
	zle .accept-line "$@"
    }
    zle -N accept-line accept-line-and-close-quote

This lets you type only the first quote and automatically matches it
when you accept the line.

Or maybe you'd rather type only the second quote ... this does not need
any special options set (though I don't promise that some settings won't
break it).

    autoload match-words-by-style
    magic-matching-quote () {
	setopt localoptions no_ksharrays
	zle .self-insert "$@" || return
	local Q="${LBUFFER[-1]}"
	if [[ "$Q" = [\"\'] ]]
	then
	    local curcontext=":zle:$WIDGET"
	    match-words-by-style
	    (( ${#matched_words[2]} > 1 )) || return 0
	    local L="$({: ${(XQ)matched_words[2]}} 2>&1)"
	    if [[ "$L" = *unmatched* ]]
	    then
		matched_words[2]="$Q$matched_words[2]" 
	    fi
	    LBUFFER="${(j::)matched_words[1,3]}" 
	fi
    }

    zstyle ':zle:magic-matching-quote' word-style whitespace
    bindkey \" magic-matching-quote
    bindkey \' magic-matching-quote

Note that magic-matching-quote works only with "whitespace" or "shell"
word-styles, as the other styles parse out the quotes.  (You may be
able to adjust this with skip-chars and other styles.)  Using this
widget makes it rather difficult to insert quotes in the middles of
strings.

So here's another alternative, which extends magic-space to cause it
to recognize an immediately-preceding unbalanced quote and match it.
This makes it simpler to type mixtures of quotes, but probably still
gets some cases wrong.

    magic-space-match-quote () {
	setopt localoptions no_ksharrays
	local Q="${LBUFFER[-1]}"
	zle .magic-space "$@" || return
        if [[ "$Q" == [\"\'] ]]
	then
	    local curcontext=":zle:$WIDGET"
	    match-words-by-style
	    (( ${#matched_words[2]} > 1 )) || return 0
	    local L="$({: ${(XQ)matched_words[2]}} 2>&1)"
	    if [[ "$L" == *" unmatched $Q" ]]
	    then
		matched_words[2]="$Q$matched_words[2]"
	    fi
	    LBUFFER="${(j::)matched_words[1,3]}"
	fi
    }
    zle -N magic-space magic-space-match-quote
    bindkey ' ' magic-space

    zstyle ':zle:magic-space' word-style whitespace

I don't recommend using accept-line-and-close-quote in combination with
either of these magic-* functions; depending on where on the line your
mismatched quote is, simply closing it at end of line might radically
change your word boundaries.  You can probably figure out how to adapt
magic-space-match-quote to be a stand-in for accept-line.

-- 

