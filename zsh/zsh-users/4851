From zsh-users-return-4851-mason-zsh=primenet.com.au@sunsite.dk Sun Apr 21 18:32:51 2002
Return-Path: <zsh-users-return-4851-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9326 invoked from network); 21 Apr 2002 18:32:50 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 21 Apr 2002 18:32:50 -0000
Received: (qmail 15418 invoked by alias); 21 Apr 2002 18:32:19 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4851
Received: (qmail 15367 invoked from network); 21 Apr 2002 18:32:16 -0000
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <1020421183201.ZM16791@candle.brasslantern.com>
Date: Sun, 21 Apr 2002 18:32:00 +0000
In-Reply-To: <m2u1q7x9ez.fsf@zion.rcn.com>
Comments: In reply to Vin Shelton <acs@alumni.princeton.edu>
        "Re: Convert absolute paths to relative paths" (Apr 20, 12:48am)
References: <Pine.LNX.4.44.0204191752460.16750-100000@ns1.sodaware.com> 
	<m2u1q7x9ez.fsf@zion.rcn.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Vin Shelton <acs@alumni.princeton.edu>
Subject: Re: Convert absolute paths to relative paths
Cc: zsh-users@sunsite.dk
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Apr 20, 12:48am, Vin Shelton wrote:
} Subject: Re: Convert absolute paths to relative paths
}
} It turned out I did care about minimizing the path, so here's what I
} came up with:

That's a more interesting algorithm than mine.  Assorted suggestions ...

} [[ $1 != /* ]] && print $1 && return

Add something like:

[[ -f $1 ]] && 1=$1:h
[[ -d $1 ]] || return 1

} local dir=${2:-$PWD}
} [[ $1 == $dir ]] && print . && return

Replace with:

[[ $1 -ef ${2:=$PWD} ]] && print . && return

} cur=(${(ps:/:)dir})	# Split 'current' directory into cur
} abs=(${(ps:/:)1})	# Split target directory into abs

You don't need the (p) flag there, you aren't using any prompt escapes.
To be really thorough, you should also eliminate any uses of ./ or ../
in either path.

} # Figure out how many parents to get to common root
} local relpath=
} while ((i <= $#cur))
} do
}   relpath=../$relpath
}   ((i=i+1))
} done

Replace with:

local relpath=${(j:/:)cur/*/..}

} relpath=$relpath${(j:/:)abs}
} print ${relpath%/}

In case of symlinks, you should test that the resulting $relpath actually
exists.

So the whole thing becomes:

---- 8< ----
# Print the a relative path from the second directory to the first,
# defaulting the second directory to $PWD if none is specified.
emulate -L zsh || return 1

[[ $1 != /* ]] && print $1 && return
[[ -f $1 ]] && 3=$1:t 1=$1:h
[[ -d $1 && -d ${2:=$PWD} ]] || return 1
[[ $1 -ef $2 ]] && print ${3:-.} && return

# The simplest way to eliminate symlinks and ./ and ../ in the paths:
1=$(cd $1; pwd -r)
2=$(cd $2; pwd -r)

local -a cur abs
cur=(${(s:/:)2})	# Split 'current' directory into cur
abs=(${(s:/:)1} $3)	# Split target directory into abs

# Compute the length of the common prefix, or discover a subdiretory:
integer i=1
while [[ i -le $#abs && $abs[i] == $cur[i] ]]
do
    ((++i > $#cur)) && print ${(j:/:)abs[i,-1]} && return
done

2=${(j:/:)cur[i,-1]/*/..}	# Up to the common prefix directory and
1=${(j:/:)abs[i,-1]}		# down to the target directory or file

print $2${1:+/$1}

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

