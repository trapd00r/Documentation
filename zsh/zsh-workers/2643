From zsh-workers-request@euclid.skiles.gatech.edu Fri Dec 27 11:16:17 1996
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 17753 invoked from network); 27 Dec 1996 11:16:13 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 27 Dec 1996 11:16:13 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id GAA24355; Fri, 27 Dec 1996 06:14:36 -0500 (EST)
Resent-Date: Fri, 27 Dec 1996 06:14:36 -0500 (EST)
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <6577.199612271115@stone.dcs.warwick.ac.uk>
Subject: extending addbuiltin()
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Fri, 27 Dec 1996 11:15:43 +0000 (GMT)
X-Patch: 162
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]8637.34
X-US-Congress: Moronic fuckers
Content-Type: text
Resent-Message-ID: <"UNNE1.0.Uy5.S-wmo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2643
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

This patch extends addbuiltin() to allow setting of all members of the
builtin structure.  Another function, add_autobin(), is added to make
creation of autoloadable builtins cleaner.

 -zefram

      *** Src/init.c	1996/12/24 03:45:30	1.31
      --- Src/init.c	1996/12/24 15:34:43
      ***************
      *** 521,528 ****
            createparamtable();     /* create paramater hash table             */
        
        #ifdef UNLINKED_XMOD_zle
      !     addbuiltin("bindkey", 0, NULL, 0, -1, "zle");
      !     addbuiltin("vared", 0, NULL, 1, 7, "zle");
        #endif /* UNLINKED_XMOD_zle */
        
        #ifdef LINKED_XMOD_zle
      --- 521,528 ----
            createparamtable();     /* create paramater hash table             */
        
        #ifdef UNLINKED_XMOD_zle
      !     add_autobin("bindkey", "zle");
      !     add_autobin("vared", "zle");
        #endif /* UNLINKED_XMOD_zle */
        
        #ifdef LINKED_XMOD_zle
      ***************
      *** 532,538 ****
        #endif
        
        #ifdef UNLINKED_XMOD_compctl
      !     addbuiltin("compctl", 0, NULL, 0, -1, "compctl");
            ZLE_DEP("compctl");
        #endif /* UNLINKED_XMOD_compctl */
        
      --- 532,538 ----
        #endif
        
        #ifdef UNLINKED_XMOD_compctl
      !     add_autobin("compctl", "compctl");
            ZLE_DEP("compctl");
        #endif /* UNLINKED_XMOD_compctl */
        
      *** Src/module.c	1996/12/24 02:46:01	1.18
      --- Src/module.c	1996/12/24 15:35:55
      ***************
      *** 31,54 ****
        
        #include "zsh.h"
        
      ! /* addbuiltin() can be used to add a new builtin.  It has six arguments: *
      !  *  - the name of the new builtin                                        *
      !  *  - BINF_* flags (see zsh.h).  Normally it is 0.                       *
      !  *  - the handler function of the builtin                                *
      !  *  - minimum number of arguments                                        *
      !  *  - maximum number of argument (-1 means unlimited)                    *
      !  *  - possible option leters                                             *
      !  * It returns zero on succes -1 on failure                               */
        
        /**/
        int
      ! addbuiltin(char *nam, int flags, HandlerFunc hfunc, int minargs, int maxargs, char *optstr)
        {
            Builtin bn;
        
            bn = (Builtin) builtintab->getnode2(builtintab, nam);
            if (bn && bn->handlerfunc)
      ! 	return -1;
            if (!bn) {
        	bn = zcalloc(sizeof(*bn));
        	bn->nam = ztrdup(nam);
      --- 31,57 ----
        
        #include "zsh.h"
        
      ! /* addbuiltin() can be used to add a new builtin.  It has eight arguments: *
      !  *  - the name of the new builtin                                          *
      !  *  - BINF_* flags (see zsh.h).  Normally it is 0.                         *
      !  *  - the handler function of the builtin                                  *
      !  *  - minimum number of arguments                                          *
      !  *  - maximum number of argument (-1 means unlimited)                      *
      !  *  - BIN_* ID for overloaded builtins (normally 0)                        *
      !  *  - possible option leters                                               *
      !  *  - default options for overloaded builtins (normally NULL)              *
      !  * It returns zero on success, 1 on failure.  The only possible type of    *
      !  * failure is that a builtin with the specified name already exists.       */
        
        /**/
        int
      ! addbuiltin(char *nam, int flags, HandlerFunc hfunc, int minargs, int maxargs, int funcid, char *optstr, char *defopts)
        {
            Builtin bn;
        
            bn = (Builtin) builtintab->getnode2(builtintab, nam);
            if (bn && bn->handlerfunc)
      ! 	return 1;
            if (!bn) {
        	bn = zcalloc(sizeof(*bn));
        	bn->nam = ztrdup(nam);
      ***************
      *** 60,72 ****
      --- 63,89 ----
            bn->handlerfunc = hfunc;
            bn->minargs = minargs;
            bn->maxargs = maxargs;
      +     bn->funcid = funcid;
            zsfree(bn->optstr);
            bn->optstr = ztrdup(optstr);
      +     zsfree(bn->defopts);
      +     bn->defopts = ztrdup(defopts);
            return 0;
        }
        
        #ifdef DYNAMIC
        
      + /* Define an autoloadable builtin.  It returns 0 on success, or 1 on *
      +  * failure.  The only possible cause of failure is that a builtin    *
      +  * with the specified name already exists.                           */
      + 
      + /**/
      + int
      + add_autobin(char *nam, char *module)
      + {
      +     return addbuiltin(nam, 0, NULL, 0, 0, 0, module, NULL);
      + }
      + 
        /* Remove the builtin added previously by addbuiltin().  Returns *
         * zero on succes and -1 if there is no builtin with that name.  *
         * Attempt to delete a builtin which is not defined by           *
      ***************
      *** 418,424 ****
        	    zwarnnam(nam, "too many arguments for `zmodload -a'", NULL, 0);
        	    return 1;
        	}
      ! 	if (addbuiltin(args[0], 0, NULL, 0, -1, args[1] ? args[1] : args[0])) {
        	    zwarnnam(nam, "failed to add builtin %s", args[0], 0);
        	    return 1;
        	}
      --- 435,441 ----
        	    zwarnnam(nam, "too many arguments for `zmodload -a'", NULL, 0);
        	    return 1;
        	}
      ! 	if (add_autobin(args[0], args[1] ? args[1] : args[0])) {
        	    zwarnnam(nam, "failed to add builtin %s", args[0], 0);
        	    return 1;
        	}
      *** Src/Modules/example.c	1996/12/22 04:50:54	1.3
      --- Src/Modules/example.c	1996/12/24 15:22:46
      ***************
      *** 57,76 ****
        
        /*
         * boot_example is executed when the module is loaded.
      -  * addbuiltin() can be used to add a new builtin.  It has six arguments:
      -  *  - the name of the new builtin
      -  *  - BINF_* flags (see zsh.h).  Normally it is 0.
      -  *  - the handler function of the builtin
      -  *  - minimum number of arguments
      -  *  - maximum number of argument (-1 means unlimited)
      -  *  - possible option leters
         */
        
        /**/
        int
        boot_example(Module m)
        {
      !     if (addbuiltin("example", 0, bin_example, 0, -1, "flags")) {
        	zwarnnam(m->nam, "name clash when adding builtin `example'", NULL, 0);
        	return -1;
            }
      --- 57,69 ----
        
        /*
         * boot_example is executed when the module is loaded.
         */
        
        /**/
        int
        boot_example(Module m)
        {
      !     if (addbuiltin("example", 0, bin_example, 0, -1, 0, "flags", NULL)) {
        	zwarnnam(m->nam, "name clash when adding builtin `example'", NULL, 0);
        	return -1;
            }
      *** Src/Modules/files.c	1996/12/24 14:29:19	1.3
      --- Src/Modules/files.c	1996/12/24 15:40:29
      ***************
      *** 301,313 ****
            return 0;
        }
        
      - /**/
      - static int
      - bin_mv(char *nam, char **args, char *ops, int func)
      - {
      -     return bin_ln(nam, args, ops, BIN_MV);
      - }
      - 
        /* rm builtin */
        
        /**/
      --- 301,306 ----
      ***************
      *** 412,432 ****
            char *name;
            int binf;
            HandlerFunc func;
      !     int min, max;
      !     char *optstr;
            int added;
        } bins[] = {
        #ifdef HAVE_LSTAT
      !     { "ln",    0, bin_ln,    1, -1, "dfis", 0 },
        #else
      !     { "ln",    0, bin_ln,    1, -1, "dfi",  0 },
        #endif
      !     { "mkdir", 0, bin_mkdir, 1, -1, "pm",   0 },
      !     { "mv",    0, bin_mv,    2, -1, "fi",   0 },
      !     { "rm",    0, bin_rm,    1, -1, "dfir", 0 },
      !     { "rmdir", 0, bin_rmdir, 1, -1, NULL,   0 },
      !     { "sync",  0, bin_sync,  0,  0, NULL,   0 },
      !     { NULL, 0, NULL, 0, 0, NULL, 0 }
        };
        
        /**/
      --- 405,425 ----
            char *name;
            int binf;
            HandlerFunc func;
      !     int min, max, funcid;
      !     char *optstr, *defopts;
            int added;
        } bins[] = {
        #ifdef HAVE_LSTAT
      !     { "ln",    0, bin_ln,    1, -1, BIN_LN, "dfis", NULL, 0 },
        #else
      !     { "ln",    0, bin_ln,    1, -1, BIN_LN, "dfi",  NULL, 0 },
        #endif
      !     { "mkdir", 0, bin_mkdir, 1, -1, 0,      "pm",   NULL, 0 },
      !     { "mv",    0, bin_ln,    2, -1, BIN_MV, "fi",   NULL, 0 },
      !     { "rm",    0, bin_rm,    1, -1, 0,      "dfir", NULL, 0 },
      !     { "rmdir", 0, bin_rmdir, 1, -1, 0,      NULL,   NULL, 0 },
      !     { "sync",  0, bin_sync,  0,  0, 0,      NULL,   NULL, 0 },
      !     { NULL, 0, NULL, 0, 0, 0, NULL, NULL, 0 }
        };
        
        /**/
      ***************
      *** 438,444 ****
        
            for(bin = bins; bin->name; bin++) {
        	if (!bin->added && addbuiltin(bin->name, bin->binf, bin->func,
      ! 	    bin->min, bin->max, bin->optstr))
        	    zwarnnam(m->nam, "name clash when adding builtin `%s'",
        		bin->name, 0);
        	else
      --- 431,437 ----
        
            for(bin = bins; bin->name; bin++) {
        	if (!bin->added && addbuiltin(bin->name, bin->binf, bin->func,
      ! 	    bin->min, bin->max, bin->funcid, bin->optstr, bin->defopts))
        	    zwarnnam(m->nam, "name clash when adding builtin `%s'",
        		bin->name, 0);
        	else
      *** Src/Zle/compctl.c	1996/12/24 03:07:09	1.2
      --- Src/Zle/compctl.c	1996/12/24 15:24:59
      ***************
      *** 1024,1030 ****
        int
        boot_compctl(Module m)
        {
      !     if (addbuiltin("compctl", 0, bin_compctl, 0, -1, NULL)) {
        	zwarnnam(m->nam, "name clash when adding builtin `compctl'", NULL, 0);
        	return -1;
            }
      --- 1024,1030 ----
        int
        boot_compctl(Module m)
        {
      !     if (addbuiltin("compctl", 0, bin_compctl, 0, -1, 0, NULL, NULL)) {
        	zwarnnam(m->nam, "name clash when adding builtin `compctl'", NULL, 0);
        	return -1;
            }
      *** Src/Zle/zle_main.c	1996/12/24 03:07:09	1.6
      --- Src/Zle/zle_main.c	1996/12/24 15:25:15
      ***************
      *** 1566,1572 ****
        
            initkeybindings();	    /* initialize key bindings */
            compctlsetup();
      !     addbuiltin("bindkey", 0, bin_bindkey, 0, -1, "asvemdruU");
      !     addbuiltin("vared", 0, bin_vared, 1, 7, NULL);
            return 0;
        }
      --- 1566,1572 ----
        
            initkeybindings();	    /* initialize key bindings */
            compctlsetup();
      !     addbuiltin("bindkey", 0, bin_bindkey, 0, -1, 0, "asvemdruU", NULL);
      !     addbuiltin("vared", 0, bin_vared, 1, 7, 0, NULL, NULL);
            return 0;
        }

-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBMr/7KXD/+HJTpU/hAQEsDwP/bb55wnFjhVJ7CqMFVYq1QWSeZcAiPczk
tgtCG1euKkx2uATFauTlDXtUWBAvP6PgDxtZIdz/B2tXu4SaFeX3tgUIkAB8kK78
/cYrpBFAHXbk6zICWQsAXgxagjFY8lSJQiYldQ1509kTXvPbDsXucCyUg+LFingV
eCNtiEi33Oo=
=L1/n
-----END PGP SIGNATURE-----

