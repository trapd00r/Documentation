From zsh-workers-return-14053-mason-zsh=primenet.com.au@sunsite.dk Fri Apr 20 13:24:55 2001
Return-Path: <zsh-workers-return-14053-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5327 invoked from network); 20 Apr 2001 13:24:53 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Apr 2001 13:24:53 -0000
Received: (qmail 16104 invoked by alias); 20 Apr 2001 13:24:40 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14053
Received: (qmail 16083 invoked from network); 20 Apr 2001 13:24:39 -0000
Date: Fri, 20 Apr 2001 09:24:36 -0400
From: Clint Adams <schizo@debian.org>
To: zsh-workers@sunsite.dk
Subject: PATCH: termcap parameter support
Message-ID: <20010420092436.A31032@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i

As promised, here is ${termcap}.  This breaks the TERMCAP_H/TERM_H check
in Src/prototypes.h.

Index: Src/Modules/termcap.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/termcap.c,v
retrieving revision 1.4
diff -u -r1.4 termcap.c
--- Src/Modules/termcap.c	2001/04/13 16:29:28	1.4
+++ Src/Modules/termcap.c	2001/04/20 13:10:14
@@ -28,9 +28,12 @@
  */
 
 #define USES_TERMCAP_H 1
+#define USES_TERM_H 1
 #include "termcap.mdh"
 #include "termcap.pro"
 
+static char termcap_nam[] = "termcap";
+
 /* echotc: output a termcap */
 
 #ifdef HAVE_TGETENT
@@ -38,6 +41,15 @@
 #  include <termcap.h>
 # endif
 
+# ifdef HAVE_CURSES_H
+#  include <curses.h>
+# endif
+# ifdef HAVE_TERM_H
+#  include <term.h>
+# endif
+
+static Param termcap_pm;
+
 /**/
 static int
 bin_echotc(char *name, char **argv, char *ops, int func)
@@ -116,10 +128,220 @@
     BUILTIN("echotc", 0, bin_echotc, 1, -1, 0, NULL, NULL),
 };
 
+/* This says if we are cleaning up when the module is unloaded. */
+
+static int incleanup;
+
+/**/
+#ifdef HAVE_TGETENT
+
+/* Empty dummy function for special hash parameters. */
+
+/**/
+static void
+shempty(void)
+{
+}
+
+/* Create a simple special hash parameter. */
+
+/**/
+static Param
+createtchash()
+{
+    Param pm;
+    HashTable ht;
+
+    unsetparam(termcap_nam);
+
+    if (!(pm = createparam(termcap_nam, PM_SPECIAL|PM_HIDE|PM_HIDEVAL|
+			   PM_REMOVABLE|PM_HASHED)))
+	return NULL;
+
+    pm->level = pm->old ? locallevel : 0;
+    pm->gets.hfn = hashgetfn;
+    pm->sets.hfn = hashsetfn;
+    pm->unsetfn = stdunsetfn;
+    pm->u.hash = ht = newhashtable(7, termcap_nam, NULL);
+
+    ht->hash        = hasher;
+    ht->emptytable  = (TableFunc) shempty;
+    ht->filltable   = NULL;
+    ht->addnode     = (AddNodeFunc) shempty;
+    ht->getnode     = ht->getnode2 = gettermcap;
+    ht->removenode  = (RemoveNodeFunc) shempty;
+    ht->disablenode = NULL;
+    ht->enablenode  = NULL;
+    ht->freenode    = (FreeNodeFunc) shempty;
+    ht->printnode   = printparamnode;
+    ht->scantab     = scantermcap;
+
+    return (termcap_pm = pm);
+}
+
 /**/
+static HashNode
+gettermcap(HashTable ht, char *name)
+{
+    int len, num;
+    char *tcstr, buf[2048], *u;
+    Param pm = NULL;
+
+    /* This depends on the termcap stuff in init.c */
+    if (termflags & TERM_BAD)
+	return NULL;
+    if ((termflags & TERM_UNKNOWN) && (isset(INTERACTIVE) || !init_term()))
+	return NULL;
+
+    unmetafy(name, &len);
+
+    pm = (Param) zhalloc(sizeof(struct param));
+    pm->nam = dupstring(name);
+    pm->flags = PM_READONLY;
+    pm->sets.cfn = NULL;
+    pm->gets.cfn = strgetfn;
+    pm->unsetfn = NULL;
+    pm->ct = 0;
+    pm->env = NULL;
+    pm->ename = NULL;
+    pm->old = NULL;
+    pm->level = 0;
+    u = buf;
+
+    if ((num = tgetnum(name)) != -1) {
+	pm->u.val = num;
+	pm->flags |= PM_INTEGER;
+    }
+    else if ((num = tgetflag(name)) != -1) {
+	pm->u.str = num ? dupstring("yes") : dupstring("no");
+	pm->flags |= PM_SCALAR;
+    }
+    else if ((tcstr = (char *)tgetstr(name,&u)) != NULL && tcstr != (char *)-1)
+    {
+	pm->u.str = dupstring(tcstr);
+	pm->flags |= PM_SCALAR;
+    }
+    else
+    {
+	/* zwarn("no such capability: %s", name, 0); */
+	pm->u.str = dupstring("");
+	pm->flags |= PM_UNSET;
+    }
+    return (HashNode) pm;
+}
+
+/**/
+static void
+scantermcap(HashTable ht, ScanFunc func, int flags)
+{
+    Param pm = NULL;
+    int num;
+    char **capcode, *tcstr, buf[2048], *u;
+
+#ifndef HAVE_BOOLCODES
+    static char *boolcodes[] = {
+	"bw", "am", "ut", "cc", "xs", "YA", "YF", "YB", "xt", "xn", "eo",
+	"gn", "hc", "HC", "km", "YC", "hs", "hl", "in", "YG", "da", "db",
+	"mi", "ms", "nx", "xb", "NP", "ND", "NR", "os", "5i", "YD", "YE",
+	"es", "hz", "ul", "xo", NULL};
+#endif
+    
+#ifndef HAVE_NUMCODES
+    static char *numcodes[] = {
+	"co", "it", "lh", "lw", "li", "lm", "sg", "ma", "Co", "pa", "MW",
+	"NC", "Nl", "pb", "vt", "ws", "Yo", "Yp", "Ya", "BT", "Yc", "Yb",
+	"Yd", "Ye", "Yf", "Yg", "Yh", "Yi", "Yk", "Yj", "Yl", "Ym", "Yn",
+	NULL};
+#endif
+
+#ifndef HAVE_STRCODES
+    static char *strcodes[] = {
+	"ac", "bt", "bl", "cr", "ZA", "ZB", "ZC", "ZD", "cs", "rP", "ct",
+	"MC", "cl", "cb", "ce", "cd", "ch", "CC", "CW", "cm", "do", "ho",
+	"vi", "le", "CM", "ve", "nd", "ll", "up", "vs", "ZE", "dc", "dl",
+	"DI", "ds", "DK", "hd", "eA", "as", "SA", "mb", "md", "ti", "dm",
+	"mh", "ZF", "ZG", "im", "ZH", "ZI", "ZJ", "ZK", "ZL", "mp", "mr",
+	"mk", "ZM", "so", "ZN", "ZO", "us", "ZP", "SX", "ec", "ae", "RA",
+	"me", "te", "ed", "ZQ", "ei", "ZR", "ZS", "ZT", "ZU", "se", "ZV",
+	"ZW", "ue", "ZX", "RX", "PA", "fh", "vb", "ff", "fs", "WG", "HU",
+	"i1", "is", "i3", "if", "iP", "Ic", "Ip", "ic", "al", "ip", "K1",
+	"K3", "K2", "kb", "@1", "kB", "K4", "K5", "@2", "ka", "kC", "@3",
+	"@4", "@5", "@6", "kt", "kD", "kL", "kd", "kM", "@7", "@8", "kE",
+	"kS", "@9", "k0", "k1", "k;", "F1", "F2", "F3", "F4", "F5", "F6",
+	"F7", "F8", "F9", "k2", "FA", "FB", "FC", "FD", "FE", "FF", "FG",
+	"FH", "FI", "FJ", "k3", "FK", "FL", "FM", "FN", "FO", "FP", "FQ",
+	"FR", "FS", "FT", "k4", "FU", "FV", "FW", "FX", "FY", "FZ", "Fa",
+	"Fb", "Fc", "Fd", "k5", "Fe", "Ff", "Fg", "Fh", "Fi", "Fj", "Fk",
+	"Fl", "Fm", "Fn", "k6", "Fo", "Fp", "Fq", "Fr", "k7", "k8", "k9",
+	"@0", "%1", "kh", "kI", "kA", "kl", "kH", "%2", "%3", "%4", "%5",
+	"kN", "%6", "%7", "kP", "%8", "%9", "%0", "&1", "&2", "&3", "&4",
+	"&5", "kr", "&6", "&9", "&0", "*1", "*2", "*3", "*4", "*5", "*6",
+	"*7", "*8", "*9", "kF", "*0", "#1", "#2", "#3", "#4", "%a", "%b",
+	"%c", "%d", "%e", "%f", "kR", "%g", "%h", "%i", "%j", "!1", "!2",
+	"kT", "!3", "&7", "&8", "ku", "ke", "ks", "l0", "l1", "la", "l2",
+	"l3", "l4", "l5", "l6", "l7", "l8", "l9", "Lf", "LF", "LO", "mo",
+	"mm", "ZY", "ZZ", "Za", "Zb", "Zc", "Zd", "nw", "Ze", "oc", "op",
+	"pc", "DC", "DL", "DO", "Zf", "IC", "SF", "AL", "LE", "Zg", "RI",
+	"Zh", "SR", "UP", "Zi", "pk", "pl", "px", "pn", "ps", "pO", "pf",
+	"po", "PU", "QD", "RC", "rp", "RF", "r1", "r2", "r3", "rf", "rc",
+	"cv", "sc", "sf", "sr", "Zj", "sa", "Sb", "Zk", "Zl", "SC", "sp",
+	"Sf", "ML", "Zm", "MR", "Zn", "st", "Zo", "Zp", "wi", "Zq", "Zr",
+	"Zs", "Zt", "Zu", "Zv", "ta", "Zw", "ts", "TO", "uc", "hu", "u0",
+	"u1", "u2", "u3", "u4", "u5", "u6", "u7", "u8", "u9", "WA", "XF",
+	"XN", "Zx", "S8", "Yv", "Zz", "Xy", "Zy", "ci", "Yw", "Yx", "dv",
+	"S1", "Yy", "S2", "S4", "S3", "S5", "Gm", "Km", "Mi", "S6", "xl",
+	"RQ", "S7", "s0", "s1", "s2", "s3", "AB", "AF", "Yz", "ML", "YZ",
+	"MT", "Xh", "Xl", "Xo", "Xr", "Xt", "Xv", "sA", "sL", NULL};
+#endif
+
+    pm = (Param) zhalloc(sizeof(struct param));
+    pm->sets.cfn = NULL;
+    pm->gets.cfn = strgetfn;
+    pm->unsetfn = NULL;
+    pm->ct = 0;
+    pm->env = NULL;
+    pm->ename = NULL;
+    pm->old = NULL;
+    u = buf;
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    for (capcode = (char **)boolcodes; *capcode; capcode++) {
+	if ((num = tgetflag(*capcode)) != -1) {
+	    pm->u.str = num ? dupstring("yes") : dupstring("no");
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_INTEGER;
+    for (capcode = (char **)numcodes; *capcode; capcode++) {
+	if ((num = tgetnum(*capcode)) != -1) {
+	    pm->u.val = num;
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    for (capcode = (char **)strcodes; *capcode; capcode++) {
+	if ((tcstr = (char *)tgetstr(*capcode,&u)) != NULL &&
+	    tcstr != (char *)-1) {
+	    pm->u.str = dupstring(tcstr);
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+}
+
+/**/
+#endif /* HAVE_TGETENT */
+
+/**/
 int
 setup_(Module m)
 {
+    incleanup = 0;
+
     return 0;
 }
 
@@ -127,13 +349,34 @@
 int
 boot_(Module m)
 {
-    return !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
+#ifdef HAVE_TGETENT
+    setupterm((char *)0, 1, (int *)0);
+
+    if (!createtchash())
+    	return 1;
+#else
+    unsetparam(termcap_nam);
+#endif
+    return  !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
 }
 
 /**/
 int
 cleanup_(Module m)
 {
+#ifdef HAVE_TGETENT
+    Param pm;
+#endif
+
+    incleanup = 1;
+
+#ifdef HAVE_TGETENTR
+    if ((pm = (Param) paramtab->getnode(paramtab, termcap_nam)) &&
+	pm == termcap_pm) {
+	pm->flags &= ~PM_READONLY;
+	unsetparam_pm(pm, 0, 1);
+    }
+#endif
     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
     return 0;
 }
Index: Src/Modules/termcap.mdd
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/termcap.mdd,v
retrieving revision 1.7
diff -u -r1.7 termcap.mdd
--- Src/Modules/termcap.mdd	2001/04/19 17:55:02	1.7
+++ Src/Modules/termcap.mdd	2001/04/20 13:10:14
@@ -13,6 +13,7 @@
 load=yes
 
 autobins="echotc"
+autoparams="termcap"
 
 objects="termcap.o"
 

