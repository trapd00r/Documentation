From suzuki@otsl.oki.co.jp Mon Jul  8 10:53:13 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3/2) with ESMTP id KAA09063 for <mason@werple.mira.net.au>; Mon, 8 Jul 1996 10:53:11 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id UAA29176; Sun, 7 Jul 1996 20:41:08 -0400 (EDT)
Resent-Date: Sun, 7 Jul 1996 20:41:08 -0400 (EDT)
X-Authentication-Warning: dorothy.fantasy.otsl.oki.co.jp: mail set sender to <suzuki@oz.fantasy.otsl.oki.co.jp> using -f
Date: Mon, 8 Jul 96 09:38:47 JST
Message-Id: <9607080038.AA01466@oz.fantasy.otsl.oki.co.jp>
From: suzuki@otsl.oki.co.jp (SUZUKI Hisao)
Organization: Oki Technosystems Laboratory, Inc., Nagoya, Japan
To: zsh-workers@math.gatech.edu
Subject: zsh-3.0-pre1: speed up the "list-choices" etc.
Resent-Message-ID: <"1_tZL.0.l77.aa5un"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/1554
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 5728
Status: OR

Dear z-shell workers,

     Recently I found an inconvenience in doing "list-choices"
or "delete-char-or-list" (typically by typing Control-d) on a
character terminal connected to an i860-sysv4 box with RS-232C.
The speed of displaying completion lists is _forbiddingly_ slow
on this terminal.

     Certainly it is mainly because of the terminal and its
device interface, it is possible to speed up the "list-choices"
etc. by improving the z-shell.  It is `nicezputs' in Src/utils.c
that displays the string of completion list, and its current
implementation calls `fputs' for each character in the string.
Modifying Src/utils.c so that `nicezputs' calls `fputs' once for
all characters, the speed becomes tolerable even on the slow
terminal.

     The following is the sample fix; it defines a new function
<<static int to_nicechar(int c, char *buf)>>, which turns `c'
into a "nice string" on `buf' and returns its length as the
result value.  In the function `nicezputs', the local buffer
<<auto char buf[200]>> is used to store each nice string by the
statement <<i += to_nicechar(c, buf + i)>> for each character,
and is dumped with <<fputs(buf, stream)>> when it is filled or
all characters are stored.

     In addition, <<char *nicechar(int c)>> is redefined in
terms of `to_nicechar' to avoid duplication of the code, and
<<size_t nicestrlen(char *s)>> and <<size_t niceztrlen(char
const *s)>> are modified slightly so as to invoke `to_nicechar'
instead of `nicechar' to improve efficiency by counting the
length of strings without re-scanning them.

Regards,

SUZUKI Hisao		# `Begin at the beginning and go on till
suzuki@otsl.oki.co.jp	# you come to the end:  then stop.'

----------------------------------------------------------------
*** utils.c.orig	Fri Jun 28 13:43:51 1996
--- utils.c	Sun Jul  7 12:50:04 1996
***************
*** 148,168 ****
      return 0;
  }
  
! /* Turn a character into a visible representation thereof.  The visible *
!  * string is put together in a static buffer, and this function returns *
!  * a pointer to it.  Printable characters stand for themselves, DEL is  *
!  * represented as "^?", newline and tab are represented as "\n" and     *
!  * "\t", and normal control characters are represented in "^C" form.    *
   * Characters with bit 7 set, if unprintable, are represented as "\M-"  *
   * followed by the visible representation of the character with bit 7   *
   * stripped off.  Tokens are interpreted, rather than being treated as  *
   * literal characters.                                                  */
  
! /**/
! char *
! nicechar(int c)
  {
-     static char buf[6];
      char *s = buf;
      c &= 0xff;
      if (isprint(c))
--- 148,170 ----
      return 0;
  }
  
! /* Turn a character which is given as the first argument into a visible *
!  * representation thereof.  The visible string is put together in a     *
!  * buffer which is given as the second argument.  This function returns *
!  * the length of the string, which is less than NICECHAR_MAX.           *
!  * Printable characters stand for themselves, DEL is represented as     *
!  * "^?", newline and tab are represented as "\n" and "\t" respectively, *
!  * and normal control characters are represented in "^C" form.          *
   * Characters with bit 7 set, if unprintable, are represented as "\M-"  *
   * followed by the visible representation of the character with bit 7   *
   * stripped off.  Tokens are interpreted, rather than being treated as  *
   * literal characters.                                                  */
  
! #define NICECHAR_MAX 6
! 
! static int
! to_nicechar(int c, char *buf)
  {
      char *s = buf;
      c &= 0xff;
      if (isprint(c))
***************
*** 191,196 ****
--- 193,211 ----
      done:
      *s++ = c;
      *s = 0;
+     return s - buf;		/* length of the resulting string */
+ }
+ 
+ /* Turn a character into a visible representation thereof.  The visible *
+  * string is put together in a static buffer, and this function returns *
+  * a pointer to it.                                                     */
+ 
+ /**/
+ char *
+ nicechar(int c)
+ {
+     static char buf[NICECHAR_MAX];
+     to_nicechar(c, buf);
      return buf;
  }
  
***************
*** 212,221 ****
  size_t
  nicestrlen(char *s)
  {
      size_t l = 0;
  
      for (; *s; s++)
! 	l += strlen(nicechar(STOUC(*s)));
      return l;
  }
  
--- 227,237 ----
  size_t
  nicestrlen(char *s)
  {
+     char buf[NICECHAR_MAX];
      size_t l = 0;
  
      for (; *s; s++)
! 	l += to_nicechar(STOUC(*s), buf);
      return l;
  }
  
***************
*** 3071,3077 ****
--- 3087,3095 ----
  int
  nicezputs(char const *s, FILE *stream)
  {
+     char buf[200];
      int c;
+     int i = 0;
  
      while ((c = *s++)) {
  	if (itok(c))
***************
*** 3081,3089 ****
  		continue;
  	if (c == Meta)
  	    c = *s++ ^ 32;
! 	if(fputs(nicechar(c), stream) < 0)
! 	    return EOF;
      }
      return 0;
  }
  
--- 3099,3113 ----
  		continue;
  	if (c == Meta)
  	    c = *s++ ^ 32;
! 	i += to_nicechar(c, buf + i);
! 	if (i + NICECHAR_MAX > 200) {
! 	    if (fputs(buf, stream) < 0) return EOF;
! 	    i = 0;
! 	}
      }
+     if (i > 0) {
+ 	if (fputs(buf, stream) < 0) return EOF;
+     }
      return 0;
  }
  
***************
*** 3093,3098 ****
--- 3117,3123 ----
  size_t
  niceztrlen(char const *s)
  {
+     char buf[NICECHAR_MAX];
      size_t l = 0;
      int c;
  
***************
*** 3104,3110 ****
  		continue;
  	if (c == Meta)
  	    c = *s++ ^ 32;
! 	l += strlen(nicechar(STOUC(c)));
      }
      return l;
  }
--- 3129,3135 ----
  		continue;
  	if (c == Meta)
  	    c = *s++ ^ 32;
! 	l += to_nicechar(STOUC(c), buf);
      }
      return l;
  }


