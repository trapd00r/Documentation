From zsh-workers-return-6973-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jul 05 10:22:40 1999
Return-Path: <zsh-workers-return-6973-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23433 invoked from network); 5 Jul 1999 10:22:38 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 5 Jul 1999 10:22:38 -0000
Received: (qmail 3710 invoked by alias); 5 Jul 1999 10:22:28 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6973
Received: (qmail 3703 invoked from network); 5 Jul 1999 10:22:27 -0000
Message-Id: <9907050953.AA14988@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: pws-25: _read_comp and friends again
Date: Mon, 05 Jul 1999 11:53:36 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

This fixes one infelicity with _read_comp --- you couldn't enter an
argument for a completion function, e.g. you might want `_files -/'.  It
also handles ^U for deleting the whole string.

Since the widgets in Completion/Commands aren't called transparently like
the other completion functions, I've added some documentation for them to
the zshcompsys manual.

--- Completion/Commands/_read_comp.c3	Sun Jul  4 18:28:14 1999
+++ Completion/Commands/_read_comp	Mon Jul  5 11:10:23 1999
@@ -23,6 +23,7 @@
 #  _read_comp         Last completion string read from user
 
 emulate -L zsh
+setopt extendedglob nobadpattern
 
 # Took me ages to work this out.  If we're not on the first global
 # matcher specification, we mustn't do any I/O.
@@ -57,10 +58,17 @@
     zle -R ''
     return 1
   fi
-  if [[ '#key' -eq 8 || '#key' -eq 127 ]]; then
+  if [[ ( '#key' -eq 8 || '#key' -eq 127 ) && -n $str ]]; then
+    # delete character
     str="$str[1,-2]"
     exact=
-  elif [[ -n $exact ]]; then
+  elif [[ '#key' -eq 21 ]]; then
+    # ^U: delete line
+    str=
+    exact=
+  elif [[ ( -n $exact && $key != ' ' ) || '#key & 127' -lt 32 ]]; then
+    # If we've got an exact function, only allow a space after it.
+    # Don't try to insert non-printing characters.
     if [[ -n $ZBEEP ]]; then
       print -nb $ZBEEP
     elif [[ -o beep ]]; then
@@ -68,9 +76,10 @@
     fi
   else
     str="$str$key"
-    if [[ $str = _* ]]; then
+    if [[ $str = _[^\ ]# ]]; then
       # Rudimentary completion for function names.
-      funcs=(${$(whence -m "$str*")%: function})
+      # Allow arguments, i.e. don't do this after we've got a space.
+      funcs=(${$(whence -m "$str*" 2>/dev/null)%: function})
       if (( $#funcs == 1 )); then
 	# Exact match; prompt the user for a newline to confirm
 	str=$funcs[1]
@@ -99,6 +108,8 @@
 	  str=$str2
 	done
       fi
+    else
+      exact=
     fi
   fi
   zle -R "$msg$str$exact"
@@ -111,7 +122,7 @@
 if [[ -z $str ]]; then
   # string must be non-zero
   return 1
-elif [[ $str = _* ]] && ! whence $str >& /dev/null; then
+elif [[ $str = _* ]] && ! whence ${str%% *} >& /dev/null; then
   # a function must be known to the shell
   return 1
 else
--- Doc/Zsh/compsys.yo.c3	Sat Jul  3 13:31:23 1999
+++ Doc/Zsh/compsys.yo	Mon Jul  5 11:35:11 1999
@@ -17,6 +17,7 @@
 menu(Control Functions)
 menu(Completion Functions)
 menu(Completion Directories)
+menu(Bindable commands)
 endmenu()
 
 texinode(Initialization)(Control Functions)()(Completion System)
@@ -769,7 +770,7 @@
 )
 enditem()
 
-texinode(Completion Directories)()(Completion Functions)(Completion System)
+texinode(Completion Directories)(Bindable Commands)(Completion Functions)(Completion System)
 sect(Completion Directories)
 
 In the source distribution, the files are contained in various
@@ -800,5 +801,62 @@
 item(tt(Commands))(
 Functions which implement special types of completion to be bound to
 keystrokes rather than called by context.
+)
+enditem()
+
+texinode(Bindable Commands)()(Completion Directories)(Completion System)
+sect(Bindable Commands)
+
+In addition to the context-dependent completions provided, which are
+expected to work in an intuitively obvious way, there are a few widgets
+implementing special behaviour which can be bound separately to keys.  The
+following is a list of these and their default bindings.
+
+startitem()
+item(tt(_correct_filename (^XC)))(
+Correct the filename path at the cursor position.  Allows up to six errors
+in the name.  Can also be correctly called with an argument to correct
+a filepath, independently of zle.
+)
+item(tt(_correct_word) (^Xc))(
+Performs correction of the current argument using the usual contextual
+completions as possible choices.
+)
+item(tt(_expand_word (^Xe)))(
+Performs expansion on the current word:  equivalent to the standard
+tt(expand-word) command, but using all the `tt(expand_*)' configuration
+keys described previously.  In addition, each such key can be overridden by
+a key starting with the string `tt(expandword_)'; for example, the
+tt(expandword_substitute) key if defined overrides the
+tt(expand_substitute) key.
+)
+item(tt(_most_recent_file (^Xm)))(
+Complete the name of the most recently modified file matching the pattern
+on the command line (which may be blank).  If given a numeric argument
+var(N), complete the var(N)th most recently modified file.  Note the
+completion, if any, is always unique.
+)
+item(tt(_read_comp (^X^R)))(
+Prompt the user for a string, and use that to perform completion on the
+current word.  There are two possibilities for the string.  First, it can
+be a set of words beginning `tt(_)', for example `tt(_files -/)', in which
+case the function with any arguments will be called to generate the
+completions.  Unambiguous parts of the function name will be completed
+automatically (normal completion is not available at this point) until a
+space is typed.
+
+Otherwise, any other string, for example `tt(-b)', will be passed as
+arguments to tt(compgen) and should hence be a set of flags specifying the
+type of completion.
+
+A very restricted set of editing commands is available when reading the
+string:  `tt(DEL)' and `tt(^H)' delete the last character; `tt(^U)' deletes
+the line, and `tt(^C)' and `tt(^G)' abort the function, while `tt(RET)'
+accepts the completion.  Note the string is used verbatim as a command
+line, so arguments must be quoted in accordance with standard shell rules.
+
+Once a string has been read, the next call to tt(_read_comp) will use the
+existing string instead of reading a new one.  To force a new string to be
+read, call tt(_read_comp) with a numeric argument.
 )
 enditem()

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

