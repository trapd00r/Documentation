From zsh-workers-request@euclid.skiles.gatech.edu  Sat Nov 16 00:49:41 1996
Return-Path: zsh-workers-request@euclid.skiles.gatech.edu
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.6/8.7.3) with ESMTP id AAA02506 for <mason@primenet.com.au>; Sat, 16 Nov 1996 00:49:37 +1100 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id IAA17018; Fri, 15 Nov 1996 08:37:53 -0500 (EST)
Resent-Date: Fri, 15 Nov 1996 08:37:53 -0500 (EST)
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <6555.199611151337@stone.dcs.warwick.ac.uk>
Subject: squashing key bindings
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Fri, 15 Nov 1996 13:37:10 +0000 (GMT)
X-Patch: 127
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]8427.83
X-US-Congress: Moronic fuckers
Content-Type: text
Resent-Message-ID: <"k-D5Z1.0.n94.m87Zo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2418
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

Peter's patch 2370, to remove all bindings of a ZLE function when it
goes away, doesn't look at the command saved by execute-named-command.
It is possible to load a module, execute its ZLE function with
execute-named-command, unload the module and load a different one, and
then execute the newly loaded function with execute-last-named-command.
This patch fixes this.

 -zefram

      Index: Src/zle_main.c
      ===================================================================
      RCS file: /home/zefram/usr/cvsroot/zsh/Src/zle_main.c,v
      retrieving revision 1.25
      diff -c -r1.25 zle_main.c
      *** zle_main.c	1996/11/15 00:30:55	1.25
      --- zle_main.c	1996/11/15 12:09:02
      ***************
      *** 981,987 ****
        		zerr("undefined function: %s", *argv, 0);
        		return 1;
        	    }
      ! 	    unbindzlefunc(func, ops['U'] ? 0 : ops['a'] ? 2 : 1);
        	    argv++;
        	    continue;
        	}
      --- 981,987 ----
        		zerr("undefined function: %s", *argv, 0);
        		return 1;
        	    }
      ! 	    unbindzlefunc(func, ops['U'] ? 0 : ops['a'] ? 6 : 5);
        	    argv++;
        	    continue;
        	}
      ***************
      *** 1238,1244 ****
            showinglist = 0;
        }
        
      ! LinkList bindremlist;
        
        /**/
        void
      --- 1238,1244 ----
            showinglist = 0;
        }
        
      ! static LinkList bindremlist;
        
        /**/
        void
      ***************
      *** 1250,1258 ****
        
        /*
         * Unbind the given zle function ifunc wherever it occurs.
      !  * With notall = 0, do this for all binding tables.
      !  *	       = 1, do this in the main binding table.
      !  *             = 2, do this in the alternate binding table.
         * Note that the main and alternate binding tables share
         * the same table for sequences with prefixes.
         */
      --- 1250,1259 ----
        
        /*
         * Unbind the given zle function ifunc wherever it occurs.
      !  * With notall &3 == 0, do this for all binding tables.
      !  *             &3 == 1, do this only in the main binding table.
      !  *             &3 == 2, do this only in the alternate binding table.
      !  *             &4, don't mangle the last named command.
         * Note that the main and alternate binding tables share
         * the same table for sequences with prefixes.
         */
      ***************
      *** 1271,1277 ****
        	for (keybindptr = keybindlist; *keybindptr; keybindptr++) {
        	    LinkNode ln;
        	    bindremlist = newlinklist();
      ! 	    if (notall)
        		keybindptr = &keybindtab;
        
        	    /*
      --- 1272,1278 ----
        	for (keybindptr = keybindlist; *keybindptr; keybindptr++) {
        	    LinkNode ln;
        	    bindremlist = newlinklist();
      ! 	    if (notall & 3)
        		keybindptr = &keybindtab;
        
        	    /*
      ***************
      *** 1291,1312 ****
        	    }
        
        	    freelinklist(bindremlist, NULL);
      ! 	    if (notall)
        		break;
        	}
        	bindremlist = NULL;
            } LASTALLOC;
        
            for (bindptr = bindlist; *bindptr; bindptr++) {
      ! 	/* if notall == 2, we are doing altbindtab first anyway */
      ! 	if (notall == 1)
        	    bindptr = &mainbindtab;
        	for (i = 0; i < 256; i++)
        	    if ((*bindptr)[i] == ifunc)
        		(*bindptr)[i] = z_undefinedkey;
      ! 	if (notall)
        	    break;
            }
        }
        
        /**/
      --- 1292,1316 ----
        	    }
        
        	    freelinklist(bindremlist, NULL);
      ! 	    if (notall & 3)
        		break;
        	}
        	bindremlist = NULL;
            } LASTALLOC;
        
            for (bindptr = bindlist; *bindptr; bindptr++) {
      ! 	/* if (notall & 3) == 2, we are doing altbindtab first anyway */
      ! 	if ((notall & 3) == 1)
        	    bindptr = &mainbindtab;
        	for (i = 0; i < 256; i++)
        	    if ((*bindptr)[i] == ifunc)
        		(*bindptr)[i] = z_undefinedkey;
      ! 	if (notall & 3)
        	    break;
            }
      + 
      +     if(!(notall & 4) && lastnamed == ifunc)
      + 	lastnamed = z_undefinedkey;
        }
        
        /**/

-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBMoxeCnD/+HJTpU/hAQGEiQP8D4ukJMC/uxYgnmKWObQ2H7xTVT2kOcD9
YW5Hp9fCvepdjAEZIBdG2YZ0QyWqxIv3ATwVS8T3Zoh3V1RdPUL7WMsHFgDQ1Zhs
AFfJer0TP9ChGMZr8Knym9FEJRBnAGCMpAgKrgENCnmfb0wCyjhfpgGzVBbefjw6
89exgSL3RCk=
=SoYA
-----END PGP SIGNATURE-----

