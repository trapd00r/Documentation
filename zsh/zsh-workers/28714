From zsh-workers-return-28714-mason-zsh=primenet.com.au@zsh.org Sun Feb 06 20:26:22 2011
Return-Path: <zsh-workers-return-28714-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 26076 invoked by alias); 6 Feb 2011 20:26:22 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28714
Received: (qmail 21026 invoked from network); 6 Feb 2011 20:26:11 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <110206122557.ZM20918@torch.brasslantern.com>
Date: Sun, 06 Feb 2011 12:25:57 -0800
In-reply-to: <20110206190051.423887bb@pws-pc.ntlworld.com>
Comments: In reply to Peter Stephenson <p.w.stephenson@ntlworld.com>
 "Re: I/O to shell function in zsh coproc" (Feb  6,  7:00pm)
References: <alpine.DEB.2.00.1102051117470.6077@MyComp2.rgm-web.net>
	<110205100816.ZM26346@torch.brasslantern.com>
	<20110206190051.423887bb@pws-pc.ntlworld.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: "Zsh Hackers' List" <zsh-workers@zsh.org>
Subject: Re: I/O to shell function in zsh coproc
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Feb 6,  7:00pm, Peter Stephenson wrote:
} Subject: Re: I/O to shell function in zsh coproc
}
} On Sat, 05 Feb 2011 10:08:16 -0800
} Bart Schaefer <schaefer@brasslantern.com> wrote:
} > The bug is that when you do 'coproc shellfunction', zsh has to fork a
} > subshell to run the shellfunction in another process.  The trouble is
} > that the subshell therefore gets copies of the coprocess descriptors
} > that are open in the parent shell.
} 
} It's not as simple as setting FD_CLOEXEC for coproc descriptors, then?

No, because the subshell never performs an exec().  This all happens only
when a shell construct is involved -- if, case, loops, functions, etc.

The right thing almost happens if I modify entersubsh() to close coprocin
and coprocout when ESUB_ASYNC is set:

schaefer<501> coproc while read line; do print -r -- "$line:u"; done
[1] 27394
schaefer<502> print -p foo
schaefer<503> read -ep
FOO
schaefer<504> coproc exit
[2] 27395
[1]  - done       while read line; do; print -r -- "$line:u"; done
[2]  + done       exit

So far, so good, but:

schaefer<505> coproc while read line; do print -r -- "$line:u"; done
[1] 27396
schaefer<506> ( print -p foo )
schaefer<507> read -ep
FOO
schaefer<508> ( print -p foo ) &
print: -p: no coprocess
[2] 27398
[2]  + exit 1     ( print -p foo; )

Oops, that last should not fail; entersubsh() [or execpline2() if we
want to handle it one step higher up the call stack] needs to know
exactly when the job that it's forking *is* the coprocess job, not
just that it's an asynchronous shell job.

Currently that appears to mean adding both another Z_* flag alongside
Z_ASYNC et al., and a corresponding ESUB_* flag -- I tried but failed
to figure out a way to use only the latter.  Maybe there's some other
clue that I'm missing, here.

