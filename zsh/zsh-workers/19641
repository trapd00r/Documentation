From zsh-workers-return-19641-mason-zsh=primenet.com.au@sunsite.dk Tue Mar 16 21:50:48 2004
Return-Path: <zsh-workers-return-19641-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9263 invoked from network); 16 Mar 2004 21:50:45 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 16 Mar 2004 21:50:45 -0000
Received: (qmail 24476 invoked by alias); 16 Mar 2004 21:50:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 19641
Received: (qmail 24423 invoked from network); 16 Mar 2004 21:50:33 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 16 Mar 2004 21:50:33 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [216.254.112.45] by sunsite.dk (MessageWall 1.0.8) with SMTP; 16 Mar 2004 21:50:32 -0000
Received: by acolyte.scowler.net (Postfix, from userid 1000)
	id B9B0B7004A; Tue, 16 Mar 2004 16:50:31 -0500 (EST)
Date: Tue, 16 Mar 2004 16:50:31 -0500
From: Clint Adams <clint@zsh.org>
To: Oliver Kiddle <okiddle@yahoo.co.uk>
Cc: zsh-workers@sunsite.dk
Subject: Re: (Fwd) segfault with pcre_study alone
Message-ID: <20040316215031.GA25663@scowler.net>
References: <1040316145551.ZM8418@candle.brasslantern.com> <20040316150753.GA21121@scowler.net> <20040316152006.GA21815@scowler.net> <11530.1079460328@trentino.logica.co.uk>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <11530.1079460328@trentino.logica.co.uk>
User-Agent: Mutt/1.5.5.1+cvs20040105i

> Are you aware that zsh modules can define condition codes that can be
> used inside [[ ... ]]? The completion module defines a -prefix
> condition for example. This could be much nicer than the current
> interface which is just a mapping onto the C calls. We'd be able to do:
>   if [[ value -pcre-anchored pattern ]]; then

Here goes.

Index: Src/Modules/pcre.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/pcre.c,v
retrieving revision 1.7
diff -u -r1.7 pcre.c
--- Src/Modules/pcre.c	16 Mar 2004 19:41:02 -0000	1.7
+++ Src/Modules/pcre.c	16 Mar 2004 21:39:32 -0000
@@ -31,6 +31,8 @@
 #include "pcre.mdh"
 #include "pcre.pro"
 
+#define CPCRE_PLAIN 0
+
 /**/
 #if defined(HAVE_PCRE_COMPILE) && defined(HAVE_PCRE_EXEC)
 #include <pcre.h>
@@ -99,10 +101,30 @@
 
 /**/
 static int
+zpcre_get_substrings(char *arg, int *ovec, int ret, char *receptacle)
+{
+    char **captures, **matches;
+
+	if(!pcre_get_substring_list(arg, ovec, ret, (const char ***)&captures)) {
+	    
+	    matches = zarrdup(&captures[1]); /* first one would be entire string */
+	    if (receptacle == NULL)
+		setaparam("match", matches);
+	    else
+		setaparam(receptacle, matches);
+	    
+	    pcre_free_substring_list((const char **)captures);
+	}
+
+	return 0;
+}
+
+/**/
+static int
 bin_pcre_match(char *nam, char **args, Options ops, int func)
 {
     int ret, capcount, *ovec, ovecsize;
-    char **captures, **matches, *receptacle = NULL;
+    char *receptacle = NULL;
     
     if(OPT_ISSET(ops,'a')) {
 	receptacle = *args++;
@@ -112,7 +134,7 @@
 	}
     }
     
-    if (ret = pcre_fullinfo(pcre_pattern, pcre_hints, PCRE_INFO_CAPTURECOUNT, &capcount))
+    if ((ret = pcre_fullinfo(pcre_pattern, pcre_hints, PCRE_INFO_CAPTURECOUNT, &capcount)))
     {
 	zwarnnam(nam, "error %d in fullinfo", NULL, ret);
 	return 1;
@@ -126,17 +148,8 @@
     if (ret==0) return 0;
     else if (ret==PCRE_ERROR_NOMATCH) return 1; /* no match */
     else if (ret>0) {
-	if(!pcre_get_substring_list(*args, ovec, ret, (const char ***)&captures)) {
-	    
-	    matches = zarrdup(&captures[1]); /* first one would be entire string */
-	    if (receptacle == NULL)
-		setaparam("match", matches);
-	    else
-		setaparam(receptacle, matches);
-	    
-	    pcre_free_substring_list((const char **)captures);
-	    return 0;
-      	}
+	zpcre_get_substrings(*args, ovec, ret, receptacle);
+	return 0;
     }
     else {
 	zwarnnam(nam, "error in pcre_exec", NULL, 0);
@@ -147,11 +160,43 @@
 }
 
 /**/
+static int
+cond_pcre_match(char **a, int id)
+{
+    pcre *pcre_pat;
+    const char *pcre_err;
+    char *lhstr, *rhre;
+    int r = 0, pcre_opts = 0, pcre_errptr, capcnt, *ov, ovsize;
+
+    lhstr = cond_str(a,0,0);
+    rhre = cond_str(a,1,0);
+
+    switch(id) {
+	 case CPCRE_PLAIN:
+		 pcre_pat = pcre_compile(rhre, pcre_opts, &pcre_err, &pcre_errptr, NULL);
+                 pcre_fullinfo(pcre_pat, NULL, PCRE_INFO_CAPTURECOUNT, &capcnt);
+    		 ovsize = (capcnt+1)*3;
+		 ov = zalloc(ovsize*sizeof(int));
+    		 r = pcre_exec(pcre_pat, NULL, lhstr, strlen(lhstr), 0, 0, ov, ovsize);
+    		if (r==0) return 1;
+	        else if (r==PCRE_ERROR_NOMATCH) return 0; /* no match */
+                else if (r>0) {
+		    zpcre_get_substrings(lhstr, ov, r, NULL);
+		    return 1;
+		}
+		break;
+    }
+
+    return 0;
+}
+
+/**/
 #else /* !(HAVE_PCRE_COMPILE && HAVE_PCRE_EXEC) */
 
 # define bin_pcre_compile bin_notavail
 # define bin_pcre_study bin_notavail
 # define bin_pcre_match bin_notavail
+# define cond_pcre_match cond_match
 
 /**/
 #endif /* !(HAVE_PCRE_COMPILE && HAVE_PCRE_EXEC) */
@@ -162,6 +207,11 @@
     BUILTIN("pcre_match",   0, bin_pcre_match,   1, 2, 0, "a",    NULL)
 };
 
+static struct conddef cotab[] = {
+    CONDDEF("pcre-match", CONDF_INFIX, cond_pcre_match, 0, 0, CPCRE_PLAIN)
+};
+
+
 /**/
 int
 setup_(Module m)
@@ -173,7 +223,8 @@
 int
 boot_(Module m)
 {
-    return !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
+    return !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab)) ||
+	   !addconddefs(m->nam, cotab, sizeof(cotab)/sizeof(*cotab));
 }
 
 /**/
@@ -181,6 +232,7 @@
 cleanup_(Module m)
 {
     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
+    deleteconddefs(m->nam, cotab, sizeof(cotab)/sizeof(*cotab));
     return 0;
 }

