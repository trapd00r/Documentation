From zsh-users-return-4241-mason-zsh=primenet.com.au@sunsite.dk Tue Sep 18 12:33:41 2001
Return-Path: <zsh-users-return-4241-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24059 invoked from network); 18 Sep 2001 12:33:40 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Sep 2001 12:33:40 -0000
Received: (qmail 23077 invoked by alias); 18 Sep 2001 12:33:23 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4241
Received: (qmail 23065 invoked from network); 18 Sep 2001 12:33:22 -0000
Date: Tue, 18 Sep 2001 14:32:51 +0200
From: Goran Koruga <goran.koruga@hermes.si>
To: zsh-users@sunsite.dk
Subject: Question about completion
Message-ID: <20010918143251.I31900@isis.hermes.si>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.3.12i
Sender: Goran Koruga <goran.koruga@hermes.si>
X-AntiVirus: scanned for viruses by AMaViS 0.2.1 (http://amavis.org/)

Hi all,

I am working on a programmable completion for ClearCase (versioning
system ala CVS but commercial and more advanced). I have used _cvs file,
distributed with zsh 4.0.2, as an example. cleartool command is similar
to cvs command in a way. Unlike cvs, it accepts no switches, so I am not
sure if I can take the cvs example directly.

So far I have done the following :

---------------------------- cut ---------------------------
#compdef cleartool

# redefine _cleartool.
_cleartool () {
  _arguments -s \
    '*::clearcase command:_cc_command'
}

# define cleartool command dispatch function.

(( $+functions[_cc_command] )) ||
_cc_command () {
  if (( ! $+_cc_cmds )); then
    typeset -gA _cc_cmds
    _cc_cmds=()
    for a in annotate apropos catcs checkin checkout chevent describe diff \
             edcs find findmerge help hostinfo ln ls lscheckout lsdo       \
             lshistory lsprivate lsview lsvtree man merge mkbranch mkdir   \
             mkelem mklabel mklbtype mkview mount mv protect pwv rename    \
             rmbranch rmelem rmlabel rmver setcs setview umount uncheckout
    do
      _cc_cmds[$a]=" "
    done
    _cc_cmds[checkin]=" ci "
    _cc_cmds[checkout]=" co "
    _cc_cmds[lscheckout]=" lsco "
    _cc_cmds[uncheckout]=" unco "
  fi

  if (( CURRENT == 1 )); then
    _tags commands && { compadd "$@" -k _cc_cmds || compadd "$@" ${(kv)=_cc_cmds
} }
  else
    local curcontext="$curcontext"

    cmd="${${(k)_cc_cmds[(R)* $words[1] *]}:-${(k)_cc_cmds[(i)$words[1]]}}"
    if (( $#cmd )); then
      curcontext="${curcontext%:*:*}:cc-${cmd}:"
      _cc_$cmd
    else
      _message "unknown clearcase command: $words[1]"
    fi
  fi
}

# define completion functions for each cvs command

(( $+functions[_cc_annotate] )) ||
_cc_annotate () {
  _arguments -s \
    '-all[include all lines]' \
    '-rm[include removed lines]' \
    '-nco[use non checked-out version]' \
    '(-s)-short[use annotation format strings that yield an abbreviated report]'
 \
    '(-l)-long[use annotation format strings that yield a verbose report]' \
    '-fmt+[specify display format]:display format:' \
    '(-rmf)-rmfmt+[specify a format for deletion annotations]:deletion format:' 
\
    '(-f)-force[display even duplicated annotation lines]' \
    '(-nhe)-nheader[suppress the header section]' \
    '(-nda)-ndata[suppress the annotated text lines]' \
    '*:cc file:_cc_files'
}

(( $+functions[_cc_apropos] )) ||
_cc_apropos () {
  _arguments -s \
    '(-glo)-glossary+[show header lines that match entire string]'
}

(( $+functions[_cc_catcs] )) ||
_cc_catcs () {
  _arguments -s \
    '-tag+[show config specs for given view-tag]:cc view:_cc_views'
}

# define completion functions for files in clearcase

(( $+functions[_cc_views] )) ||
_cc_views () {
  _wanted ccviews expl 'cc view' compadd - ${(@)${(@)${(@f)"$(cleartool lsview)"}#[ *][ ]}/ *}
}

(( $+functions[_cc_files] )) ||
_cc_files () {
  _wanted ccfiles expl 'cc file' compadd - ${(@)${(@M)${(@f)"$(cleartool ls)"}:#* Rule:*-mkbranch *}/@@*}
}

(( $+functions[_cc_co_files] )) ||
_cc_co_files() {
  _wanted ccfilesco expl 'cc file (checked-out)' compadd - ${(@)${(@f)"$(cleartool lsprivate -co)"}/ *}
}
---------------------------- cut ---------------------------

This somehow works. However I get unexepected behaviour when I type the
following :

cleartool annotate -<ctrl-d>

This is where all options should be listed. They get listed, but my
problem is, that also _cc_files completion is attempted. Is there a way
to overcome this ? What I am looking for, is to complete options and only
options if string starts with '-'.

My second question is more complicated. In ClearCase, one can access
different version of file with syntax like this : filename@@version,
where version is /main/1 for example. So full path for a file may look
like "foo@@/main/1". Right now, my completion lists only the filenames,
that is, only "foo" is listed. Is there a way to program completion so
that if a strng ends with "@@", I could run a custom function which would
list all the versions available ? I have looked at the manual pages and
examples, but I can't figure this out.

Hopefully this is not too long and indescriptive.

Thank you in advance.

Regards,
Goran
--

Writing about music is like dancing about architecture.
    -- Frank Zappa 

