From zsh-workers-request@euclid.skiles.gatech.edu  Wed Nov 20 08:01:26 1996
Return-Path: zsh-workers-request@euclid.skiles.gatech.edu
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.6/8.7.3) with ESMTP id IAA09161 for <mason@primenet.com.au>; Wed, 20 Nov 1996 08:01:20 +1100 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id PAA08129; Tue, 19 Nov 1996 15:40:43 -0500 (EST)
Resent-Date: Tue, 19 Nov 1996 15:40:43 -0500 (EST)
Message-Id: <m0vPx3J-00008PC@aglaia.aball.DE>
Subject: 3.1.0-test3: gcc -ansi -pedantic
To: zsh-workers@math.gatech.edu
Date: Tue, 19 Nov 1996 21:45:51 +0100 (MET)
From: Thorsten Meinecke <kaefer@aglaia.aball.DE>
Organization: none. Location: Berlin, Germany
X-Mailer: ELM [version 2.4 PL23]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"Hd6X-3.0.x-1.AjXao"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2431
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Hello, did anyone bother before to build zsh with gcc -ansi -pedantic?

It looks like some of the module-related changes aren't ANSI/ISO C,
and from some of the older stuff it elicits warnings about variable
sized arrays and conversions w/o cast as well.  Furthermore, there's
trouble in module.c, because gcc says ANSI forbids assignment between
function pointer and `void *'.  Most serious:

  ../Src> gcc -c -I.. -I. -I. -DHAVE_CONFIG_H -Wall -Wno-implicit \
  -Wmissing-prototypes -g -ansi -pedantic  zle_main.c
  zle_main.c: In function `zleread':
  zle_main.c:439: warning: ANSI C forbids use of conditional expressions as lvalues
  zle_main.c: In function `unbindzlefunc':
  zle_main.c:1257: initializer element for `keybindlist[0]' is not computable at load time
  zle_main.c:1257: initializer element for `keybindlist[1]' is not computable at load time
  make: *** [zle_main.o] Error 1

I can offer fixes for the error (and the warnings) in the zle_*
module-related code, by introducing yet another level of indirection
to both underlying problems.


*** Src/zle.h	1996/11/19 06:16:34	2.11
--- Src/zle.h	1996/11/19 19:57:02
***************
*** 455,462 ****
   * Commands up to, but not including, ZLECMDCOUNT are in the compiled array *
   * zlecmds.  Anything higher is in the malloc'd array zlecmdadd, so we need *
!  * to subtract ZLECMDCOUNT to get the offset.                               */
  
! #define ZLEGETCMD(X)  ((X) >= ZLECMDCOUNT ? zlecmdadd[(X)-ZLECMDCOUNT] \
! 		       : zlecmds[X])
  
  /* How many new commands to reserve space for at a time */
--- 455,463 ----
   * Commands up to, but not including, ZLECMDCOUNT are in the compiled array *
   * zlecmds.  Anything higher is in the malloc'd array zlecmdadd, so we need *
!  * to subtract ZLECMDCOUNT to get the offset.                               *
!  * ZLEGETCMD expands into an expression of the type (struct zlecmd *).      */ 
  
! #define ZLEGETCMD(X)  ((X) >= ZLECMDCOUNT ? &zlecmdadd[(X)-ZLECMDCOUNT] \
! 		       : &zlecmds[X])
  
  /* How many new commands to reserve space for at a time */
*** Src/zle_main.c	1996/11/19 06:16:35	2.30
--- Src/zle_main.c	1996/11/19 19:36:20
***************
*** 437,441 ****
  		int ce = complexpect;
  
! 		zc = &ZLEGETCMD(bindk);
  		if (!(lastcmd & ZLE_ARG)) {
  		    zmult = 1;
--- 437,441 ----
  		int ce = complexpect;
  
! 		zc = ZLEGETCMD(bindk);
  		if (!(lastcmd & ZLE_ARG)) {
  		    zmult = 1;
***************
*** 881,885 ****
  	putc('\n', bindout);
      } else
! 	fprintf(bindout, "%s\n", ZLEGETCMD(k->func).name);
  }
  
--- 881,885 ----
  	putc('\n', bindout);
      } else
! 	fprintf(bindout, "%s\n", ZLEGETCMD(k->func)->name);
  }
  
***************
*** 954,958 ****
  		printbind(buf, 1, 1);
  	    }
! 	    printf("\t%s\n", ZLEGETCMD(tab[i]).name);
  	}
  	scanhashtable(keybindtab, 1, 0, 0, printbinding, 0);
--- 954,958 ----
  		printbind(buf, 1, 1);
  	    }
! 	    printf("\t%s\n", ZLEGETCMD(tab[i])->name);
  	}
  	scanhashtable(keybindtab, 1, 0, 0, printbinding, 0);
***************
*** 1013,1017 ****
  		putchar('\n');
  	    } else
! 		printf("%s\n", ZLEGETCMD(func).name);
  	    zfree(s, len);
  	    return 0;
--- 1013,1017 ----
  		putchar('\n');
  	    } else
! 		printf("%s\n", ZLEGETCMD(func)->name);
  	    zfree(s, len);
  	    return 0;
***************
*** 1165,1169 ****
      }
      else
! 	fprintf(shout, "%s", ZLEGETCMD(cmd).name);
      if (clearflag)
  	putc('\r', shout), tcmultout(TCUP, TCMULTUP, nlnct);
--- 1165,1169 ----
      }
      else
! 	fprintf(shout, "%s", ZLEGETCMD(cmd)->name);
      if (clearflag)
  	putc('\r', shout), tcmultout(TCUP, TCMULTUP, nlnct);
***************
*** 1205,1211 ****
  	(unset(ALWAYSLASTPROMPT) && zmult != 1);
      if (func == z_selfinsert || func == z_undefinedkey)
! 	fprintf(shout, "%s is on many keys", ZLEGETCMD(func).name);
      else {
! 	fprintf(shout, "%s is", ZLEGETCMD(func).name);
  	for (i = 0; funcfound < MAXFOUND && i < 256; i++)
  	    if (mainbindtab[i] == func) {
--- 1205,1211 ----
  	(unset(ALWAYSLASTPROMPT) && zmult != 1);
      if (func == z_selfinsert || func == z_undefinedkey)
! 	fprintf(shout, "%s is on many keys", ZLEGETCMD(func)->name);
      else {
! 	fprintf(shout, "%s is", ZLEGETCMD(func)->name);
  	for (i = 0; funcfound < MAXFOUND && i < 256; i++)
  	    if (mainbindtab[i] == func) {
***************
*** 1255,1260 ****
      int *bindlist[] = { altbindtab, emacs_cur_bindtab, viins_cur_bindtab,
  			    NULL };
!     HashTable keybindlist[] = { emkeybindtab, vikeybindtab, NULL };
!     HashTable *keybindptr;
  
      PERMALLOC {
--- 1255,1260 ----
      int *bindlist[] = { altbindtab, emacs_cur_bindtab, viins_cur_bindtab,
  			    NULL };
!     HashTable ktab, **keybindptr;
!     HashTable *keybindlist[] = { &emkeybindtab, &vikeybindtab, NULL };
  
      PERMALLOC {
***************
*** 1262,1267 ****
  	    LinkNode ln;
  	    bindremlist = newlinklist();
! 	    if (notall & 3)
! 		keybindptr = &keybindtab;
  
  	    /*
--- 1262,1267 ----
  	    LinkNode ln;
  	    bindremlist = newlinklist();
! 
! 	    ktab = (notall & 3) ? keybindtab : **keybindptr;
  
  	    /*
***************
*** 1271,1275 ****
  	     * delete the bindings one by one later.
  	     */
! 	    scanhashtable(*keybindptr, 0, 0, 0, zerobinding, ifunc);
  
  	    for (ln = firstnode(bindremlist); ln; incnode(ln)) {
--- 1271,1275 ----
  	     * delete the bindings one by one later.
  	     */
! 	    scanhashtable(ktab, 0, 0, 0, zerobinding, ifunc);
  
  	    for (ln = firstnode(bindremlist); ln; incnode(ln)) {
***************
*** 1277,1281 ****
  		char *s = ztrdup(k->nam);
  		int sl = strlen(s);
! 		delprefbinding(*keybindptr, k, s, sl);
  		zfree(s, sl);
  	    }
--- 1277,1281 ----
  		char *s = ztrdup(k->nam);
  		int sl = strlen(s);
! 		delprefbinding(ktab, k, s, sl);
  		zfree(s, sl);
  	    }
*** Src/zle_misc.c	1996/11/19 06:16:35	2.31
--- Src/zle_misc.c	1996/11/19 19:24:08
***************
*** 639,643 ****
  		    *ptr = 0;
  		    for (t0 = 0; t0 != zlecmdtot; t0++) {
! 			struct zlecmd *zc = &ZLEGETCMD(t0);
  			if (!(zc->flags & ZLE_DELETED)
  			    && strpfx(buf, zc->name)) {
--- 639,643 ----
  		    *ptr = 0;
  		    for (t0 = 0; t0 != zlecmdtot; t0++) {
! 			struct zlecmd *zc = ZLEGETCMD(t0);
  			if (!(zc->flags & ZLE_DELETED)
  			    && strpfx(buf, zc->name)) {
*** Src/zle_tricky.c	1996/11/19 06:16:36	2.83
--- Src/zle_tricky.c	1996/11/19 19:24:08
***************
*** 3911,3915 ****
  	return;
      }
!     t = ZLEGETCMD(bindk).name;
      zmult = 1;
      pushline();
--- 3911,3915 ----
  	return;
      }
!     t = ZLEGETCMD(bindk)->name;
      zmult = 1;
      pushline();
*** Src/zle_vi.c	1996/11/19 06:16:37	2.12
--- Src/zle_vi.c	1996/11/19 19:24:08
***************
*** 145,149 ****
  	    return -1;
  	}
! 	zc = &ZLEGETCMD(k2);
  	if (!(zc->flags & ZLE_ARG))
  	    break;
--- 145,149 ----
  	    return -1;
  	}
! 	zc = ZLEGETCMD(k2);
  	if (!(zc->flags & ZLE_ARG))
  	    break;

