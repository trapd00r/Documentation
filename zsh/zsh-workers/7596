From zsh-workers-return-7596-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Sep 01 09:46:09 1999
Return-Path: <zsh-workers-return-7596-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19189 invoked from network); 1 Sep 1999 09:46:07 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 1 Sep 1999 09:46:07 -0000
Received: (qmail 834 invoked by alias); 1 Sep 1999 09:25:50 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7596
Received: (qmail 827 invoked from network); 1 Sep 1999 09:25:49 -0000
Date: Wed, 1 Sep 1999 11:25:47 +0200 (MET DST)
Message-Id: <199909010925.LAA32701@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Tanaka Akira's message of 01 Sep 1999 00:03:57 +0900
Subject: Re: PATCH: Completion/Cvs/


Tanaka Akira wrote:

> Also, I found a problem about _arguments.
> 
> Z(2):akr@is27e1u11% ./Src/zsh -f
> is27e1u11% bindkey -e; fpath=($PWD/Completion/*(/)); autoload -U compinit; compinit -D; compdef _tst tst
> is27e1u11% compconf group_matches=yes
> is27e1u11% compconf message_format='%d'
> is27e1u11% compconf description_format='%d'
> 
> is27e1u11% cvs login -e<TAB>
> ->
> is27e1u11% cvs login -evi 
> 
> is27e1u11% _tst () { _arguments '-e+:editor:(vi)' '*::mesg:false' }   
> is27e1u11% tst a -e<TAB>
> ->
> is27e1u11% tst a -evi 
> 
> Becase _tst use '*::...', "vi" should not be completed.

I'm not so sure about this, so no patch for this now, but some
comments and questions.

In this example I think I would like to have it complete `vi' if the
cursor is directly after the `-e' (same word), because the `*::...'
should only take affect on whole words, i.e. in this case the word
after the `-e...'.

With that, this is just a special case of a more general problem with
completion after a `-e+:...' option. Currently we use the description
for the first option-argument to complete the next word after the `-e' 
only if there really is nothing after the `-e' in the same word (so
that `foo -e <TAB>' completes the option-argument and `foo -ebar <TAB>'
completes normal arguments). But what if the empty string is a valid
option-argument? I think `-e+::...' should give us that (that's what
the patch below does).

So, is this ok? By changing your example to `-e::...' it would give
you what you want, I think (you could also use `-e-:...', btw). What
I'm really asking is if everyone thinks that the behavior with this
patch is what everyone would expect.

Or maybe I'm overlooking something here -- the patch is independent of 
the way the `rest'-arguments are described.

Bye
 Sven

diff -u oc/Base/_arguments Completion/Base/_arguments
--- oc/Base/_arguments	Wed Sep  1 10:52:58 1999
+++ Completion/Base/_arguments	Wed Sep  1 11:20:39 1999
@@ -464,9 +464,9 @@
 	  # option, we skip over the first description only if there
 	  # is something after the option name on the line.
 
-	  if [[ ( -z "$sopts" && "$ws[1]" != "$tmp[1]" ) ||
-                ( -n "$sopts" && ( ( $tmp[1] = [-+]? && "$ws[1]" != "${tmp[1][1]}"${~soptseq}"${tmp[1][2]}" ) ||
-		  		   ( $tmp[1] != [-+]? && "$ws[1]" != "$tmp[1]" ) ) ) ]]; then
+	  if [[ ( -z "$sopts" && ( "$def" = :* || "$ws[1]" != "$tmp[1]" ) ) ||
+                ( -n "$sopts" && ( ( $tmp[1] = [-+]? && ( "$def" = :* || "$ws[1]" != "${tmp[1][1]}"${~soptseq}"${tmp[1][2]}" ) ) ||
+		  		   ( $tmp[1] != [-+]? && ( "$def" = :* || "$ws[1]" != "$tmp[1]" ) ) ) ) ]]; then
 	    if [[ "$def" = [^*]*[^\\]:*[^\\]:* ]]; then
               def="${def#?*[^\\]:*[^\\]:}"
 	      optbeg="$beg"

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

