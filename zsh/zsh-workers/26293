From zsh-workers-return-26293-mason-zsh=primenet.com.au@sunsite.dk Mon Jan 12 04:49:48 2009
Return-Path: <zsh-workers-return-26293-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1743 invoked from network); 12 Jan 2009 04:49:33 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 12 Jan 2009 04:49:33 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 23732 invoked from network); 12 Jan 2009 04:49:29 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 12 Jan 2009 04:49:29 -0000
Received: (qmail 7056 invoked by alias); 12 Jan 2009 04:49:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 26293
Received: (qmail 7040 invoked from network); 12 Jan 2009 04:49:24 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 12 Jan 2009 04:49:24 -0000
Received: from vms173005pub.verizon.net (vms173005pub.verizon.net [206.46.173.5])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 5BBC580271F0
	for <zsh-workers@sunsite.dk>; Mon, 12 Jan 2009 05:49:17 +0100 (CET)
Received: from torch.brasslantern.com ([96.238.220.215])
 by vms173005.mailsrvcs.net
 (Sun Java System Messaging Server 6.2-6.01 (built Apr  3 2006))
 with ESMTPA id <0KDC00KNBDDU7FL3@vms173005.mailsrvcs.net> for
 zsh-workers@sunsite.dk; Sun, 11 Jan 2009 22:49:12 -0600 (CST)
Received: from torch.brasslantern.com (localhost.localdomain [127.0.0.1])
	by torch.brasslantern.com (8.13.1/8.13.1) with ESMTP id n0C4n4aa012765; Sun,
 11 Jan 2009 20:49:05 -0800
Received: (from schaefer@localhost)	by torch.brasslantern.com
 (8.13.1/8.13.1/Submit) id n0C4n4Nq012764; Sun, 11 Jan 2009 20:49:04 -0800
Date: Sun, 11 Jan 2009 20:49:04 -0800
From: Bart Schaefer <schaefer@brasslantern.com>
Subject: Re: embedding C code in a shell script
In-reply-to: <pdy9883062408eec590187d09e8@[192.168.1.2]>
To: Dave Yost <Dave@Yost.com>, zsh-workers@sunsite.dk
Message-id: <090111204904.ZM12763@torch.brasslantern.com>
MIME-version: 1.0
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
Content-type: text/plain; charset=us-ascii
References: <pdy9883062408eec590187d09e8@[192.168.1.2]>
Comments: In reply to Dave Yost <Dave@Yost.com>
 "embedding C code in a shell script" (Jan 11,  2:12pm)
X-Virus-Scanned: ClamAV 0.92.1/8853/Mon Jan 12 01:26:44 2009 on bifrost
X-Virus-Status: Clean

On Jan 11,  2:12pm, Dave Yost wrote:
}
} It just occurred to me that with very little work, zsh could add this 
} feature using similar techniques to the what you can read about here:
}    http://yost.com/computers/compileAndGo/index.html#Future

[Aside:  To answer the question in your script at that web page, the
reason you have to use backticks instead of $(...) is because of the
unbalanced right-parens in the case ... esac syntax.  In recent shells
you can add opening left parens in case statements and then it's OK to
put $(...) around the whole thing.  Also, please forgive me for the
following commentary, but if you're going to post a link to something
you've got to expect some critique.]

Years ago, like 1990+/-, I had a friend who used a csh alias "cx"
which stood for "compile and execute" and which boiled down to:
    alias cx "cc *.c && ./a.out"
This still gives me the willies when I think about it, and it's giving
me an unpleasant first reaction to this discussion.

Suppressing that flashback for the moment, compileAndGo seems like an
application begging for here-documents.  Why make the compileAndGo
program do the work of parsing the variable declarations and so forth
(especially since it does it with sed), when one could let the shell
do the parsing, pass those values through the environment, and just
compile standard input ala:

  #!/bin/sh
  compiled=realpath compiler=gcc compileAndGo <<\EOCAG
  #include <stdio.h>
  // ... etc ...
  EOCAG

??  This allows you to do things like compute the compiled name from
the file name, e.g.

  #!/bin/zsh -f
  compiled=${0:t:r} compiler=gcc compileAndGo ...

And as long as you're at it, you might as well provide the option
to have compileAndGo create the main() routine for you so all you
have to write is the code that forms the function body.

} You could compile the code as a separate command, or you could do 
} more work and dynamically link it in and call it.

The way to do that in zsh would be to have a template zsh module
source file, insert the function name and body into it, compile it
(which probably still requires a zsh source tree although I think
Clint (?) spent some time working on being able to compile modules
on their own), drop it in a directory in $module_path, and zmodload.
The bootup function for the module could check whether it needs to
be recompiled, I *think*, though it might be tricky to get it to
re-zmodload something with which it just overwrote itself.

Your next exercise is to write compileAndGo as a zsh module that can
recompile itself as you update it. :-)

