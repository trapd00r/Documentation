From zsh-workers-return-6240-mason-zsh=primenet.com.au@sunsite.auc.dk Sat May 08 17:01:11 1999
Return-Path: <zsh-workers-return-6240-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16382 invoked from network); 8 May 1999 17:01:09 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 May 1999 17:01:09 -0000
Received: (qmail 18532 invoked by alias); 8 May 1999 17:00:46 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6240
Received: (qmail 18524 invoked from network); 8 May 1999 17:00:46 -0000
Message-Id: <9905081636.AA46827@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: 3.1.5-pws-17: read after pipeline bug
Date: Sat, 08 May 1999 18:36:26 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

This looks like being an old bug, it's also in 3.0.5.

zsh -f
% echo foo | read foo; read foo
%

The (interactive) shell doesn't wait.  It turns out the read gets an EIO
--- repeatedly, so it's not a hang over from the previous read.

I discovered read foo </dev/tty also didn't work, while if there was an
intervening external command it did.  After almost two hours of fruitless
searching when I'd almost given up (oddly enough, this has happened to me
before, even with zsh), it occurred to me to wonder about tty process
groups, which get reset after an external command but not an internal one.
This seemed to be the problem.  So the following does the check for
resetting the process group even if the pipeline which just finished had a
builtin at its tail end.  Some version of this should go into 3.0.6.

--- Src/jobs.c.eio	Sat May  8 14:50:27 1999
+++ Src/jobs.c	Sat May  8 18:33:45 1999
@@ -180,11 +180,16 @@
     } else {                   /* job is done, so remember return value */
 	lastval2 = val;
 	/* If last process was run in the current shell, keep old status
-	 * and let it handle its own traps
+	 * and let it handle its own traps, but always allow the test
+	 * for the pgrp.
 	 */
-	if (job == thisjob && !(jn->stat & STAT_CURSH)) {
-	  lastval = val;
-	  inforeground = 1;
+	if (job == thisjob) {
+	    if (jn->stat & STAT_CURSH)
+		inforeground = 1;
+	    else {
+		lastval = val;
+		inforeground = 2;
+	    }
 	}
     }
 
@@ -223,7 +228,7 @@
      * process group from the shell, so the shell will not receive     *
      * terminal signals, therefore we we pretend that the shell got    *
      * the signal too.                                                 */
-    if (inforeground && isset(MONITOR) && WIFSIGNALED(status)) {
+    if (inforeground == 2 && isset(MONITOR) && WIFSIGNALED(status)) {
 	int sig = WTERMSIG(status);
 
 	if (sig == SIGINT || sig == SIGQUIT) {

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

