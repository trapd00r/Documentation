From zsh-workers-return-12960-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Oct 11 12:18:20 2000
Return-Path: <zsh-workers-return-12960-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28600 invoked from network); 11 Oct 2000 12:18:18 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Oct 2000 12:18:18 -0000
Received: (qmail 29446 invoked by alias); 11 Oct 2000 12:17:26 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12960
Received: (qmail 29437 invoked from network); 11 Oct 2000 12:17:24 -0000
Date: Wed, 11 Oct 2000 14:17:22 +0200 (MET DST)
Message-Id: <200010111217.OAA27801@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: all completions


Here's an improved patch. It gets the string displayed for the
all-matches special match right (as described in 12936) and it has
another style, `avoid-completer' (any suggestions for a better
name?). That gives a list of completer-names for which no all-matches
string should be added. It has what I think is a sensible default
value.

I haven't found a better option character than `C', though.  And of
the other things I suggested in 12936 -- none of that is implemented,
either, I'll wait until there are requests, if there will be any...


And I forgot too mention: the patch looks slightly larger than it is,
because I moved the old code for compstate[insert]=all into a function 
which is then shared with the new all-matches-match code.

Bye
 Sven

Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.19
diff -u -r1.19 _zstyle
--- Completion/Builtins/_zstyle	2000/10/10 14:12:41	1.19
+++ Completion/Builtins/_zstyle	2000/10/11 12:13:59
@@ -58,7 +58,8 @@
   max-errors		 c:
   menu			 c:boolauto
   numbers		 c:bool
-  old-list		 c:bool 
+  old-list		 c:bool
+  old-matches            c:oldmatches
   old-menu		 c:bool 
   original		 c:bool
   packageset		 c:packageset
@@ -275,15 +276,19 @@
       ;;
 
     ignline) 
-      _wanted values expl boolean compadd true false current current-shown other
+      _wanted values expl 'ignore strings on the line' compadd true false current current-shown other
       ;;
 
     keep-prefix) 
-      _wanted values expl boolean compadd true false changed
+      _wanted values expl 'keep prefix' compadd true false changed
       ;;
 
     match-orig) 
-      _wanted values expl boolean compadd only both
+      _wanted values expl "match without inserting \`*'" compadd only both
+      ;;
+
+    oldmatches) 
+      _wanted values expl 'use list of old matches' compadd true false only
       ;;
 
     urgh) 
Index: Completion/Commands/_expand_word
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Commands/_expand_word,v
retrieving revision 1.6
diff -u -r1.6 _expand_word
--- Completion/Commands/_expand_word	2000/10/06 05:18:25	1.6
+++ Completion/Commands/_expand_word	2000/10/11 12:13:59
@@ -6,7 +6,6 @@
 unsetopt markdirs globsubst shwordsplit shglob ksharrays cshnullglob
 
 local curcontext="$curcontext"
-local -ah completers
 
 if [[ -z "$curcontext" ]]; then
   curcontext="expand-word:::"
@@ -14,12 +13,4 @@
   curcontext="expand-word:${curcontext#*:}"
 fi
 
-if zstyle -t ":completion:${curcontext}:" completions; then
-    zstyle -a ":completion:${curcontext}:" completer completers
-    completers[1,(i)_expand]=_expand
-    (( $#completers == 1 )) && completers=(_expand _complete)
-else
-    completers=(_expand)
-fi
-
-_main_complete $completers
+_main_complete _expand
Index: Completion/Core/_all_matches
===================================================================
RCS file: _all_matches
diff -N _all_matches
--- /dev/null	Tue May  5 13:32:27 1998
+++ _all_matches	Wed Oct 11 05:13:59 2000
@@ -0,0 +1,43 @@
+#autoload
+
+_all_matches() {
+  local old
+
+  zstyle -s ":completion:${curcontext}:" old-matches old
+
+  if [[ "$old" = (only|true|yes|1|on) ]]; then
+
+    if [[ -n "$compstate[old_list]" ]]; then
+      compstate[insert]=all
+      compstate[old_list]=keep
+      return 0
+    fi
+
+    [[ "$old" = *only* ]] && return 1
+  fi
+
+  (( $comppostfuncs[(I)_all_matches_end] )) ||
+      comppostfuncs=( "$comppostfuncs[@]" _all_matches_end )
+
+  _all_matches_context=":completion:${curcontext}:"
+
+  return 1
+}
+
+_all_matches_end() {
+  local not
+
+  zstyle -s "$_all_matches_context" avoid-completer not ||
+      not=( _expand _old_list _correct _approximate )
+
+  if [[ "$compstate[nmatches]" -gt 1 && $not[(I)(|_)$_completer] -eq 0 ]]; then
+    local expl
+
+    _description all-matches expl 'all matches'
+    compadd "$expl[@]" -C
+  fi
+
+  unset _all_matches_context
+}
+
+_all_matches "$@"
Index: Completion/Core/_expand
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_expand,v
retrieving revision 1.32
diff -u -r1.32 _expand
--- Completion/Core/_expand	2000/10/10 15:06:31	1.32
+++ Completion/Core/_expand	2000/10/11 12:13:59
@@ -18,14 +18,6 @@
       force="$force$opt"
     done
 
-# First, see if we should insert all *completions*.
-
-if [[ "$force" = *c* ]] ||
-   zstyle -t ":completion:${curcontext}:" completions; then
-  compstate[insert]=all
-  return 1
-fi
-
 if [[ "$funcstack[2]" = _prefix ]]; then
   word="$IPREFIX$PREFIX$SUFFIX"
 else
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.99
diff -u -r1.99 compsys.yo
--- Doc/Zsh/compsys.yo	2000/10/10 14:12:41	1.99
+++ Doc/Zsh/compsys.yo	2000/10/11 12:14:01
@@ -901,6 +901,18 @@
 it may be useful to set this style to something like `tt(specify: %d)'. 
 Note that this may not work for some commands.
 )
+kindex(avoid-completer, completion style)
+item(tt(avoid-completer))(
+This is used by the tt(_all_matches) completer to decide if the string 
+consisting of all matches should be added to the list currently being
+generated.  Its value is a list of names of completers.  If any of
+these is the name of the completer that generated the matches in this
+completion, the string will not be added.
+
+The default value for this style is `tt(_expand _old_list _correct
+_approximate)', i.e. it contains the completers for which a string
+with all matches will almost never be wanted.
+)
 kindex(cache-path, completion style)
 item(tt(cache-path))(
 This style defines the path where any cache files containing dumped
@@ -966,14 +978,6 @@
 tt(ignored-patterns) style and the tt($fignore) array and then without 
 ignoring matches.
 )
-kindex(completions, completion style)
-item(tt(completions))(
-This style is used by the tt(_expand) completer function. If it is set 
-to `true', the completer will not generate expansions, but instead the
-completions will be generated as normal and all of them will be
-inserted into the command line.  This style is most useful when set
-only for very specific completion contexts.
-)
 kindex(condition, completion style)
 item(tt(condition))(
 This style is used by the tt(_list) completer function to decide if
@@ -1159,7 +1163,7 @@
 )
 kindex(glob, completion style)
 item(tt(glob))(
-Like tt(completions), this is used by the tt(_expand) completer.  If
+This is used by the tt(_expand) completer.  If
 it is set to `true' (the default), globbing will be attempted on the
 words resulting from substitution (see the tt(substitute) style) or
 the original string from the line.
@@ -1650,6 +1654,15 @@
 to tt(_match), the list of matches generated on the first attempt will be
 used again.
 )
+kindex(old-matches, completion style)
+item(tt(old-matches))(
+This is used by the tt(_all_matches) completer to decide if an old
+list of matches should be used if one exists.  It may be set to one of 
+the `true' values or to the string `tt(only)' to use such a list.  If
+it is set to `tt(only)', tt(_all_matches) will only use an old list
+and won't have any effect on the list of matches currently being
+generated.
+)
 kindex(old-menu, completion style)
 item(tt(old-menu))(
 This is used by the tt(_oldlist) completer.  It controls how menu
@@ -2109,6 +2122,34 @@
 
 cindex(completion system, completers)
 startitem()
+findex(_all_matches)
+item(tt(_all_matches))(
+This completer can be used to add a string consisting of all other
+matches.  To ensure, that this string is always added, this completer
+has to be used as the first completer in the list.  The
+tt(avoid-completer) style is used to decide if the string should be
+added.  This will only be done if the matches were generated by a
+completer not named by one of the values of the style.
+
+This function also uses the style tt(old-matches).  If it is set to
+`true' or to the string `tt(only)' and there is a list of matches from 
+a previous completion, those matches will be inserted in the command
+line.  If it is set to the the string `tt(only)', it will only insert
+an old list and won't add the string for all matches of the list
+currently being generated.
+
+With the tt(old-matches) style set, this completer should probably not 
+be called unconditionally.  Instead one could use the tt(-e) option of 
+the tt(zstyle) builtin command to add a condition to the tt(completer) 
+or to the tt(old-matches) style.  Alternatively, one could use the
+tt(_generic) function to bind tt(_all_matches) to a separate key
+binding, for example:
+
+example(zle -C all-matches complete-word _generic
+bindkey '^Xa' all-matches
+zstyle ':completion:all-matches:*' old-matches only
+zstyle ':completion:all-matches:*' completer _all_matches)
+)
 findex(_approximate)
 item(tt(_approximate))(
 This completer function uses the tt(_complete) completer to generate
@@ -2312,14 +2353,9 @@
 Which kind of expansion is tried is controlled by the tt(substitute),
 tt(glob) and tt(subst-globs-only) styles.
 
-There is another style, tt(completions), which causes tt(_expand) to
-unconditionally insert all em(completions) generated for the current
-word (even if the word is empty).
-
 When tt(_expand) is called as a function, the different modes may be
-selected with options.  The tt(-c) corresponds to the tt(completions)
-style, tt(-s) to tt(substitute), tt(-g) to tt(glob) and tt(-o) to
-tt(subst-globs-only).
+selected with options.  The tt(-s) to tt(substitute), tt(-g) to
+tt(glob) and tt(-o) to tt(subst-globs-only).
 )
 findex(_history)
 item(tt(_history))(
@@ -2495,12 +2531,6 @@
 Performs expansion on the current word:  equivalent to the standard
 tt(expand-word) command, but using the tt(_expand) completer.  Before
 calling it, the var(function) field is set to `tt(expand-word)'.
-
-The tt(completions) style is also tested in the resulting context.  When
-it is true, the list of functions from the tt(completer) style is shifted
-to remove any that would be called ahead of tt(_expand).  If tt(_expand)
-does not appear in the tt(completer) style, then only the two completers
-tt(_expand) and tt(_complete) are used (in that order).
 )
 findex(_generic)
 item(tt(_generic))(
Index: Doc/Zsh/compwid.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compwid.yo,v
retrieving revision 1.26
diff -u -r1.26 compwid.yo
--- Doc/Zsh/compwid.yo	2000/10/05 14:08:47	1.26
+++ Doc/Zsh/compwid.yo	2000/10/11 12:14:02
@@ -418,7 +418,7 @@
 startitem()
 findex(compadd)
 cindex(completion widgets, adding specified matches)
-xitem(tt(compadd) [ tt(-akqQfenUl12) ] [ tt(-F) var(array) ])
+xitem(tt(compadd) [ tt(-akqQfenUl12C) ] [ tt(-F) var(array) ])
 xitem([ tt(-P) var(prefix) ] [ tt(-S) var(suffix) ])
 xitem([ tt(-p) var(hidden-prefix) ] [ tt(-s) var(hidden-suffix) ])
 xitem([ tt(-i) var(ignored-prefix) ] [ tt(-I) var(ignored-suffix) ])
@@ -639,6 +639,15 @@
 in turn matches what is on the line.  If the var(n)'th var(word) does not
 match, the var(n)'th element of the var(array) is removed.  Elements
 for which the corresponding var(word) is matched are retained.
+)
+item(tt(-C))(
+This option adds a special match which expands to all other metches
+when inserted into the line, even those that are added after this
+option is used.  Together with the tt(-d) option it is possible to
+specify a string that should be displayed in the list for this special 
+match.  If no string is given, it will be shown as a string containing 
+the strings that would be inserted for the other matches, truncated to 
+the width of the screen.
 )
 xitem(tt(-))
 item(tt(-)tt(-))(
Index: Src/Zle/comp.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/comp.h,v
retrieving revision 1.8
diff -u -r1.8 comp.h
--- Src/Zle/comp.h	2000/07/03 08:05:28	1.8
+++ Src/Zle/comp.h	2000/10/11 12:14:02
@@ -124,6 +124,7 @@
 #define CMF_ROWS     (1<<10)	/* prefer LIST_ROWS_FIRST */
 #define CMF_MULT     (1<<11)	/* string appears more than once */
 #define CMF_FMULT    (1<<12)	/* first of multiple equal strings */
+#define CMF_ALL      (1<<13)	/* a match representing all other matches */
 
 /* Stuff for completion matcher control. */
 
@@ -236,6 +237,7 @@
 #define CAF_UNIQALL 16
 #define CAF_ARRAYS  32
 #define CAF_KEYS    64
+#define CAF_ALL    128
 
 /* Data for compadd and addmatches() */
 
Index: Src/Zle/compcore.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compcore.c,v
retrieving revision 1.40
diff -u -r1.40 compcore.c
--- Src/Zle/compcore.c	2000/10/11 10:57:41	1.40
+++ Src/Zle/compcore.c	2000/10/11 12:14:02
@@ -143,6 +143,11 @@
 /**/
 mod_export int hasoldlist, hasperm;
 
+/* Non-zero if we have a match representing all other matches. */
+
+/**/
+int hasallmatch;
+
 /* Non-zero if we have newly added matches. */
 
 /**/
@@ -331,6 +336,7 @@
     maxmlen = -1;
     compignored = 0;
     nmessages = 0;
+    hasallmatch = 0;
 
     /* Make sure we have the completion list and compctl. */
     if (makecomplist(s, incmd, lst)) {
@@ -366,41 +372,8 @@
 	cs = origcs;
 	showinglist = -2;
     } else if (useline == 2 && nmatches > 1) {
-	int first = 1, nm = nmatches;
-	Cmatch *mc;
-
-	menucmp = 1;
-	menuacc = 0;
-
-	for (minfo.group = amatches;
-	     minfo.group && !(minfo.group)->mcount;
-	     minfo.group = (minfo.group)->next);
-
-	mc = (minfo.group)->matches;
+	do_allmatches(1);
 
-	while (1) {
-	    if (!first)
-		accept_last();
-	    first = 0;
-
-	    if (!--nm)
-		menucmp = 0;
-
-	    do_single(*mc);
-	    minfo.cur = mc;
-
-	    if (!*++(minfo.cur)) {
-		do {
-		    if (!(minfo.group = (minfo.group)->next))
-			break;
-		} while (!(minfo.group)->mcount);
-		if (!minfo.group)
-		    break;
-		minfo.cur = minfo.group->matches;
-	    }
-	    mc = minfo.cur;
-	}
-	menucmp = 0;
 	minfo.cur = NULL;
 
 	if (forcelist)
@@ -1604,7 +1577,7 @@
     Brinfo bp, bpl = brbeg, obpl, bsl = brend, obsl;
     Heap oldheap;
 
-    if (!*argv) {
+    if (!*argv && !(dat->aflags & CAF_ALL)) {
 	SWITCHHEAPS(oldheap, compheap) {
 	    /* Select the group in which to store the matches. */
 	    gflags = (((dat->aflags & CAF_NOSORT ) ? CGF_NOSORT  : 0) |
@@ -2042,6 +2015,36 @@
 	    set_list_array(dat->dpar, dparl);
 	if (dat->exp)
 	    addexpl();
+	if (!hasallmatch && (dat->aflags & CAF_ALL)) {
+	    Cmatch cm = (Cmatch) zhalloc(sizeof(struct cmatch));
+
+	    memset(cm, 0, sizeof(struct cmatch));
+	    cm->str = dupstring("<all>");
+	    cm->flags = (dat->flags | CMF_ALL |
+			 (complist ?
+			  ((strstr(complist, "packed") ? CMF_PACKED : 0) |
+			   (strstr(complist, "rows")   ? CMF_ROWS   : 0)) : 0));
+	    if (disp) {
+		if (!*++disp)
+		    disp = NULL;
+		if (disp)
+		    cm->disp = dupstring(*disp);
+	    } else {
+		cm->disp = dupstring("");
+		cm->flags |= CMF_DISPLINE;
+	    }
+	    mnum++;
+	    ainfo->count++;
+	    if (curexpl)
+		curexpl->count++;
+
+	    addlinknode(matches, cm);
+
+	    newmatches = 1;
+	    mgroup->new = 1;
+
+	    hasallmatch = 1;
+	}
     } SWITCHBACKHEAPS(oldheap);
 
     /* We switched back to the current heap, now restore the stack of
@@ -2695,7 +2698,7 @@
     r->pre = ztrdup(m->pre);
     r->suf = ztrdup(m->suf);
     r->flags = m->flags;
-    if (nbeg) {
+    if (m->brpl) {
 	int *p, *q, i;
 
 	r->brpl = (int *) zalloc(nbeg * sizeof(int));
@@ -2704,7 +2707,7 @@
 	    *p = *q;
     } else
 	r->brpl = NULL;
-    if (nend) {
+    if (m->brsl) {
 	int *p, *q, i;
 
 	r->brsl = (int *) zalloc(nend * sizeof(int));
@@ -2888,8 +2891,10 @@
     zsfree(m->remf);
     zsfree(m->disp);
     zsfree(m->autoq);
-    zfree(m->brpl, nbeg * sizeof(int));
-    zfree(m->brsl, nend * sizeof(int));
+    if (m->brpl)
+	zfree(m->brpl, nbeg * sizeof(int));
+    if (m->brsl)
+	zfree(m->brsl, nend * sizeof(int));
 
     zfree(m, sizeof(m));
 }
Index: Src/Zle/complete.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complete.c,v
retrieving revision 1.13
diff -u -r1.13 complete.c
--- Src/Zle/complete.c	2000/06/19 10:48:21	1.13
+++ Src/Zle/complete.c	2000/10/11 12:14:03
@@ -452,6 +452,9 @@
 	    case 'Q':
 		dat.aflags |= CAF_QUOTE;
 		break;
+	    case 'C':
+		dat.aflags |= CAF_ALL;
+		break;
 	    case 'f':
 		dat.flags |= CMF_FILE;
 		break;
@@ -604,7 +607,7 @@
  ca_args:
 
     if (!*argv && !dat.group && !dat.mesg &&
-	!(dat.aflags & (CAF_NOSORT|CAF_UNIQALL|CAF_UNIQCON)))
+	!(dat.aflags & (CAF_NOSORT|CAF_UNIQALL|CAF_UNIQCON|CAF_ALL)))
 	return 1;
 
     dat.match = match = cpcmatcher(match);
Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.33
diff -u -r1.33 complist.c
--- Src/Zle/complist.c	2000/10/11 10:57:41	1.33
+++ Src/Zle/complist.c	2000/10/11 12:14:03
@@ -1375,6 +1375,10 @@
 	return 0;
     }
     m = *mp;
+
+    if ((m->flags & CMF_ALL) && (!m->disp || !m->disp[0]))
+	bld_all_str(m);
+
     mlastm = m->gnum;
     if (m->disp && (m->flags & CMF_DISPLINE)) {
 	if (mselect >= 0) {
Index: Src/Zle/compresult.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compresult.c,v
retrieving revision 1.24
diff -u -r1.24 compresult.c
--- Src/Zle/compresult.c	2000/10/01 23:43:56	1.24
+++ Src/Zle/compresult.c	2000/10/11 12:14:04
@@ -570,36 +570,40 @@
 mod_export int
 hasbrpsfx(Cmatch m, char *pre, char *suf)
 {
-    char *op = lastprebr, *os = lastpostbr;
-    VARARR(char, oline, ll);
-    int oll = ll, ocs = cs, ole = lastend, opcs = brpcs, oscs = brscs, ret;
-
-    memcpy(oline, line, ll);
-
-    lastprebr = lastpostbr = NULL;
-
-    instmatch(m, NULL);
-
-    cs = 0;
-    foredel(ll);
-    spaceinline(oll);
-    memcpy(line, oline, oll);
-    cs = ocs;
-    lastend = ole;
-    brpcs = opcs;
-    brscs = oscs;
-
-    ret = (((!pre && !lastprebr) ||
-	    (pre && lastprebr && !strcmp(pre, lastprebr))) &&
-	   ((!suf && !lastpostbr) ||
-	    (suf && lastpostbr && !strcmp(suf, lastpostbr))));
-
-    zsfree(lastprebr);
-    zsfree(lastpostbr);
-    lastprebr = op;
-    lastpostbr = os;
+    if (m->flags & CMF_ALL)
+	return 1;
+    else {
+	char *op = lastprebr, *os = lastpostbr;
+	VARARR(char, oline, ll);
+	int oll = ll, ocs = cs, ole = lastend, opcs = brpcs, oscs = brscs, ret;
+
+	memcpy(oline, line, ll);
+
+	lastprebr = lastpostbr = NULL;
+
+	instmatch(m, NULL);
+
+	cs = 0;
+	foredel(ll);
+	spaceinline(oll);
+	memcpy(line, oline, oll);
+	cs = ocs;
+	lastend = ole;
+	brpcs = opcs;
+	brscs = oscs;
+
+	ret = (((!pre && !lastprebr) ||
+		(pre && lastprebr && !strcmp(pre, lastprebr))) &&
+	       ((!suf && !lastpostbr) ||
+		(suf && lastpostbr && !strcmp(suf, lastpostbr))));
+
+	zsfree(lastprebr);
+	zsfree(lastpostbr);
+	lastprebr = op;
+	lastpostbr = os;
 
-    return ret;
+	return ret;
+    }
 }
 
 /* Handle the case were we found more than one match. */
@@ -748,6 +752,65 @@
     }
 }
 
+/* Insert all matches in the command line. */
+
+/**/
+void
+do_allmatches(int end)
+{
+    int first = 1, nm = nmatches - 1, omc = menucmp, oma = menuacc, e;
+    Cmatch *mc;
+    struct menuinfo mi;
+    char *p = (brbeg ? ztrdup(lastbrbeg->str) : NULL);
+
+    memcpy(&mi, &minfo, sizeof(struct menuinfo));
+    menucmp = 1;
+    menuacc = 0;
+
+    for (minfo.group = amatches;
+	 minfo.group && !(minfo.group)->mcount;
+	 minfo.group = (minfo.group)->next);
+
+    mc = (minfo.group)->matches;
+
+    while (1) {
+	if (!((*mc)->flags & CMF_ALL)) {
+	    if (!first)
+		accept_last();
+	    first = 0;
+
+	    if (!omc && !--nm)
+		menucmp = 0;
+
+	    do_single(*mc);
+	}
+	minfo.cur = mc;
+
+	if (!*++(minfo.cur)) {
+	    do {
+		if (!(minfo.group = (minfo.group)->next))
+		    break;
+	    } while (!(minfo.group)->mcount);
+	    if (!minfo.group)
+		break;
+	    minfo.cur = minfo.group->matches;
+	}
+	mc = minfo.cur;
+    }
+    menucmp = omc;
+    menuacc = oma;
+
+    e = minfo.end;
+    memcpy(&minfo, &mi, sizeof(struct menuinfo));
+    minfo.end = e;
+    minfo.len = e - minfo.pos;
+
+    if (p) {
+	zsfree(lastbrbeg->str);
+	lastbrbeg->str = p;
+    }
+}
+
 /* Insert a single match in the command line. */
 
 /**/
@@ -785,6 +848,10 @@
     cs = minfo.pos;
     foredel(l);
 
+    if (m->flags & CMF_ALL)
+	do_allmatches(0);
+    else {
+
     /* And then we insert the new string. */
     minfo.len = instmatch(m, &scs);
     minfo.end = cs;
@@ -956,6 +1023,7 @@
 	runhookdef(INSERTMATCHHOOK, (void *) &dat);
 	minfo.cur = om;
     }
+    }
 }
 
 /* Do completion, given that we are in the middle of a menu completion.  We *
@@ -1886,6 +1954,54 @@
 }
 
 /**/
+mod_export void
+bld_all_str(Cmatch all)
+{
+    Cmgroup g;
+    Cmatch *mp, m;
+    int len = columns - 5, t, add = 0;
+    VARARR(char, buf, columns + 1);
+
+    buf[0] = '\0';
+
+    for (g = amatches; g && !g->mcount; g = g->next);
+
+    mp = g->matches;
+    while (1) {
+	m = *mp;
+	if (!(m->flags & (CMF_ALL | CMF_HIDE)) && m->str) {
+	    t = strlen(m->str) + add;
+	    if (len >= t) {
+		if (add)
+		    strcat(buf, " ");
+		strcat(buf, m->str);
+		len -= t;
+		add = 1;
+	    } else {
+		if (len > add + 2) {
+		    if (add)
+			strcat(buf, " ");
+		    strncat(buf, m->str, len);
+		}
+		strcat(buf, " ...");
+		break;
+	    }
+	}
+	if (!*++mp) {
+	    do {
+		if (!(g = g->next))
+		    break;
+	    } while (!g->mcount);
+	    if (!g)
+		break;
+	    mp = g->matches;
+	}
+    }
+    zsfree(all->disp);
+    all->disp = ztrdup(buf);
+}
+
+/**/
 static void
 iprintm(Cmgroup g, Cmatch *mp, int mc, int ml, int lastc, int width,
 	char *path, struct stat *buf)
@@ -1897,6 +2013,8 @@
 	return;
 
     m = *mp;
+    if ((m->flags & CMF_ALL) && (!m->disp || !m->disp[0]))
+	bld_all_str(m);
     if (m->disp) {
 	if (m->flags & CMF_DISPLINE) {
 	    printfmt(m->disp, 0, 1, 0);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

