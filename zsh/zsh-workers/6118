From zsh-workers-return-6118-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Apr 27 10:24:05 1999
Return-Path: <zsh-workers-return-6118-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10248 invoked from network); 27 Apr 1999 10:24:03 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Apr 1999 10:24:03 -0000
Received: (qmail 199 invoked by alias); 27 Apr 1999 10:23:41 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6118
Received: (qmail 192 invoked from network); 27 Apr 1999 10:23:40 -0000
Message-Id: <9904270959.AA43000@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk
Subject: Re: PATCH: was Re: Closing quotes in completion 
In-Reply-To: "Sven Wischnowsky"'s message of "Tue, 27 Apr 1999 11:03:14 DFT."
             <199904270903.LAA09306@beta.informatik.hu-berlin.de> 
Date: Tue, 27 Apr 1999 11:59:14 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

Sven Wischnowsky wrote:
> [ Sorry for the late response... ]

Oh, yes, just compare it with Microsoft... as soon as anybody makes a minor
suggestion about Windows, the new program is in the shops in a couple of
hours.  Compared with that, this is distinctly sloppy.  Not!

> First, this showed a problem in the code, where the automatically
> inserted suffixes (e.g. a slash for directories) were inserted after
> the ignored suffix, which was wrong.

That seems to fix the problem I was worried about.  One difficulty is you
get a (removable) space between the end of the completion and the quote
(where the cursor ends up) when there's a unique match.  That's not so bad,
but it is it really correct deliberately to insert a space *before* a
suffix?  (There's also the old problems with completing in quotes where you
expect "filename wi<TAB> to complete to "filename with spaces", but if I
remember right that's made difficult by the lexer.)

(Or is it `an unique match'?)

> This also reminds me of the last thing I'm still thinking about for
> the new style completion stuff: a way to access and probably modify
> the completions added.
> 
> Because of these problems I haven't implemented anything of this yet,
> so I'd like to hear comments/suggestions about all this.

The only thing that strikes me is the idea of having a fairly raw access to
the structures, i.e. if you really know what you're doing there's some
option for you to modify pretty much anything.  But I don't know either the
uses for or the difficulties with that.

> P.S.: What has become of the `re-use-old-list'-completer/patch?

Sorry, I lost interest when I discovered it worked :-).  Here are the
_oldlist and _closequotes completers.  I'm sure there are obvious
extensions I've missed.  (I've put them in Core with all the other
completers, although they're rather optional.)

--- Completion/Core/_closequotes.olcq	Tue Apr 27 11:37:29 1999
+++ Completion/Core/_closequotes	Tue Apr 27 11:37:48 1999
@@ -0,0 +1,11 @@
+#autoload
+
+# If the current completion is in quotes, add the closing quote.
+# This can clash with some of the more sophisticated forms of completion
+
+if [[ -n $compstate[quote] && $RBUFFER != *${compstate[quote]}* ]]; then
+  compstate[restore]=''
+  ISUFFIX="$ISUFFIX$compstate[quote]"
+fi
+
+return 1
--- Completion/Core/_oldlist.olcq	Tue Apr 27 11:37:29 1999
+++ Completion/Core/_oldlist	Tue Apr 27 11:37:48 1999
@@ -0,0 +1,29 @@
+#autoload
+
+# If this is a listing widget and there is already an old list,
+# and either the compconfig key oldlist_list is `always', or it is not `never'
+# and the list is not already shown, then use the existing list for listing
+# (even if it was generated by another widget).
+if [[ -n $compstate[old_list] && $compconfig[oldlist_list] != never &&
+  $WIDGET = *list* &&
+  ( $compconfig[oldlist_list] = always || $compstate[old_list] != shown ) ]]
+then
+  compstate[old_list]=keep
+  return 0
+fi
+
+# If this is a completion widget, and we have a completion inserted already,
+# and the compconfig key oldlist_menu is not never, then we cycle through the
+# existing list (even if it was generated by another widget).
+if [[ -n $compstate[old_insert] && $WIDGET = *complete(|-prefix) &&
+  $compconfig[oldlist_menu] != never ]]; then
+  compstate[old_list]=keep
+  if [[ $WIDGET = *reverse* ]]; then
+    compstate[insert]=$(( compstate[old_insert] - 1 ))
+  else
+    compstate[insert]=$(( compstate[old_insert] + 1 ))
+  fi
+  return 0
+fi
+
+return 1
--- Doc/Zsh/compsys.yo.olcq	Tue Apr 27 11:16:04 1999
+++ Doc/Zsh/compsys.yo	Tue Apr 27 11:36:30 1999
@@ -528,6 +528,53 @@
 menucompletion widgets such as tt(reverse-menu-complete), or
 tt(accept-and-menu-complete).
 )
+item(tt(_oldlist))(
+This completer controls how the standard completion widgets behave when
+there is an existing list of completions which may have been generated by a
+special completion (i.e. a separately-bound completion command).  It should
+appear in the list of completers before any of the widgets which generate
+matches.  It understands two configuration keys:
+
+startitem()
+item(tt(oldlist_list))(
+If this is set to tt(always), then standard widgets which perform listing
+will retain the current list of matches, however they were generated.  If
+it is set to tt(never), this will not be done (the behaviour without the
+tt(_oldlist) completer).  If it is unset, or any other value, then the
+existing list of completions will be displayed if it is not already;
+otherwise, the standard completion list will be generated:  this is the
+default behaviour of tt(_oldlist).
+
+For example, suppose you type tt(^Xc) to use the tt(_correct_word)
+widget, which generates a list of corrections for the word under the
+cursor.  Usually, typing tt(^D) would generate a standard list of
+completions for the word on the command line, and show that.  With
+tt(_oldlist), it will instead show the list of corrections already
+generated.
+)
+item(tt(oldlist_menu))(
+Controls how menu completion behaves when a completion has already been
+inserted and the user types a standard completion key type as tt(TAB).
+The default behaviour of tt(_oldlist) is that menu completion always
+continues with the existing list of completions.  If this key is set to
+tt(never), however, a new completion is started if the old list was
+generated by a different completion command (the behaviour without the
+tt(_oldlist) completer).
+For example, suppose you type tt(^Xc) to generate a list of corrections,
+and menu completion is started in one of the usual ways.  Usually, typing
+tt(TAB) at this point would start trying to complete the line as it now
+appears.  With tt(_oldlist), it will instead continue to cycle through the
+list of completions. 
+)
+enditem()
+)
+item(tt(_closequotes))(
+When a completion starts in quotes, this completer will recognise the fact
+and insert a matching closing quote if there is not already one later on
+the line.  It should come earlier in the list of completers than any of the
+completers which generate matches.  It can be confused by some of the more
+sophisticated forms of completion.
+)
 enditem()
 
 texinode(Completion Functions)()(Control Functions)(Completion System)

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

