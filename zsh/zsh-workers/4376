From zsh-workers-request@math.gatech.edu Thu Sep 03 05:51:22 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3178 invoked from network); 3 Sep 1998 05:51:21 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 3 Sep 1998 05:51:21 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id BAA21303;
	Thu, 3 Sep 1998 01:40:46 -0400 (EDT)
Resent-Date: Thu, 3 Sep 1998 01:40:46 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199809030543.AAA18620@hzoli.home>
Subject: Re: zsh-3.1.4 bug, parsing case ... esac
In-Reply-To: <980902205229.ZM1419@candle.brasslantern.com> from Bart Schaefer at "Sep 2, 98 08:52:29 pm"
To: schaefer@brasslantern.com (Bart Schaefer)
Date: Thu, 3 Sep 1998 00:43:31 -0500 (CDT)
Cc: steve@xemacs.org, zsh-workers@math.gatech.edu
X-Mailer: ELM [version 2.4ME+ PL31 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"CdbrB1.0.oC5.TlYxr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4376
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

> On Sep 2,  5:53pm, SL Baur wrote:
> } Subject: zsh-3.1.4 bug, parsing case ... esac
> }
> } zsh: parse error near `echo'
> } zsh: parse error in command substitution
> } 
> } 		esac else echo bison ;
> } 
> } adding a semicolon after the esac makes the messages go away, but I
> } think this should work as is.
> 
> Blech.  That sure doesn't parse according to the bash manual.  The
> stuff between "then" and "else" has to be a properly-terminated list,
> which means it has to end with ; & or newline.

Actually, the shell grammar allows this, this is really a zsh bug.
For example,

if true; then if true; then echo foo; fi else echo bar; fi

is accepted by zsh although there is no semicolon between fi and else.
Similarily

if ((some math)) then ((some other math)) fi

works.  Same for [[ ... ]].

Zoli


*** Src/parse.c~	Sat May  2 03:45:37 1998
--- Src/parse.c	Thu Sep  3 00:36:33 1998
***************
*** 542,557 ****
  
  	while (tok == SEPER)
  	    yylex();
! 	if (tok == OUTBRACE) {
! 	    yylex();
  	    break;
- 	}
  	if (tok != STRING)
  	    YYERRORV;
! 	if (!strcmp(tokstr, "esac")) {
! 	    yylex();
  	    break;
- 	}
  	str = ncalloc(strlen(tokstr) + 2);
  	*str = ';';
  	strcpy(str + 1, tokstr);
--- 542,553 ----
  
  	while (tok == SEPER)
  	    yylex();
! 	if (tok == OUTBRACE)
  	    break;
  	if (tok != STRING)
  	    YYERRORV;
! 	if (!strcmp(tokstr, "esac"))
  	    break;
  	str = ncalloc(strlen(tokstr) + 2);
  	*str = ';';
  	strcpy(str + 1, tokstr);
***************
*** 618,627 ****
  	addlinknode(pats, str);
  	addlinknode(lists, par_list());
  	n++;
! 	if ((tok == ESAC && !brflag) || (tok == OUTBRACE && brflag)) {
! 	    yylex();
  	    break;
- 	}
  	if(tok == SEMIAMP)
  	    *str = '&';
  	else if (tok != DSEMI)
--- 614,621 ----
  	addlinknode(pats, str);
  	addlinknode(lists, par_list());
  	n++;
! 	if ((tok == ESAC && !brflag) || (tok == OUTBRACE && brflag))
  	    break;
  	if(tok == SEMIAMP)
  	    *str = '&';
  	else if (tok != DSEMI)
***************
*** 630,635 ****
--- 624,632 ----
  	incmdpos = 0;
  	yylex();
      }
+ 
+     incmdpos = 1;
+     yylex();
  
      cc->pats = (char **)alloc((n + 1) * sizeof(char *));
  

