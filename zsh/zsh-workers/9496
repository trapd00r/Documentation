From zsh-workers-return-9496-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jan 31 12:05:10 2000
Return-Path: <zsh-workers-return-9496-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 12062 invoked from network); 31 Jan 2000 12:05:05 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 31 Jan 2000 12:05:05 -0000
Received: (qmail 2052 invoked by alias); 31 Jan 2000 12:05:00 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9496
Received: (qmail 2032 invoked from network); 31 Jan 2000 12:04:59 -0000
Date: Mon, 31 Jan 2000 13:04:58 +0100 (MET)
Message-Id: <200001311204.NAA01734@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Sun, 30 Jan 2000 17:36:29 +0000
Subject: Re: Infinite loop (bug in wordcode evaluation?)


Bart Schaefer wrote:

> The following function reproduces the bug in an interactive shell with ZLE
> active:
> 
>     function hang() {
> 	emulate -L zsh
> 	trap return HUP INT QUIT                                         
> 	for ((i=0; 1; i=0)) do
>             tmp=()                                                  
>             vared -p "Type ^C here: " tmp                       
>         done                            
>     }
> 
> If you interrupt this with ^C, 3.1.6-dev.16 goes into a loop repeatedly
> evaluating the "for" expressions on an empty loop body.  The "trap" is
> important.

The problem is that none of the functions in loop.c check if retflag
is set and hence don't return. But this was not changed by the
wordcode stuff  -- and a older zsh without that I have here behaves
the same. In fact, I think that zsh behaved this way either always or
for a long time.


Bye
 Sven

diff -ru ../z.old/Src/loop.c Src/loop.c
--- ../z.old/Src/loop.c	Mon Jan 31 11:35:50 2000
+++ Src/loop.c	Mon Jan 31 12:50:08 2000
@@ -138,6 +138,8 @@
 		break;
 	    contflag = 0;
 	}
+	if (retflag)
+	    break;
 	if (iscond && !errflag) {
 	    str = dupstring(advance);
 	    if (isset(XTRACE)) {
@@ -258,7 +260,7 @@
 		break;
 	    contflag = 0;
 	}
-	if (errflag)
+	if (retflag || errflag)
 	    break;
     }
   done:
@@ -357,6 +359,10 @@
 	    lastval = oldval;
 	    break;
 	}
+	if (retflag) {
+	    lastval = oldval;
+	    break;
+	}
 	execlist(state, 1, 0);
 	if (breaks) {
 	    breaks--;
@@ -364,11 +370,13 @@
 		break;
 	    contflag = 0;
 	}
-	freeheap();
 	if (errflag) {
 	    lastval = 1;
 	    break;
 	}
+	if (retflag)
+	    break;
+	freeheap();
 	oldval = lastval;
     }
     cmdpop();
@@ -410,6 +418,8 @@
 	    lastval = 1;
 	    break;
 	}
+	if (retflag)
+	    break;
     }
     cmdpop();
     popheap();
@@ -447,6 +457,8 @@
 	    run = 1;
 	    break;
 	}
+	if (retflag)
+	    break;
 	s = 1;
 	state->pc = next;
     }
@@ -532,7 +544,7 @@
 	if (pprog && pattry(pprog, word)) {
 	    execlist(state, 1, ((WC_CASE_TYPE(code) == WC_CASE_OR) &&
 				do_exec));
-	    while (wc_code(code) == WC_CASE &&
+	    while (!retflag && wc_code(code) == WC_CASE &&
 		   WC_CASE_TYPE(code) == WC_CASE_AND) {
 		state->pc = next;
 		code = *state->pc;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

