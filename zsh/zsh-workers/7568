From zsh-workers-return-7568-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Aug 31 10:02:17 1999
Return-Path: <zsh-workers-return-7568-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19303 invoked from network); 31 Aug 1999 10:02:16 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 31 Aug 1999 10:02:16 -0000
Received: (qmail 2081 invoked by alias); 31 Aug 1999 09:11:51 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7568
Received: (qmail 2074 invoked from network); 31 Aug 1999 09:11:50 -0000
Date: Tue, 31 Aug 1999 10:50:36 +0200 (MET DST)
Message-Id: <199908310850.KAA27246@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Mon, 30 Aug 1999 16:05:58 +0000
Subject: Re: PATCH: new parameter expansion type?


Bart Schaefer wrote:

> On Aug 30, 11:49am, Sven Wischnowsky wrote:
> } Subject: PATCH: new parameter expansion type?
> }
> }   ${name^pattern^then^else}
> } 
> } Gives you the (substituted) `then' string if the expansion of `name'
> } matches the `pattern' and otherwise it gives you the `else' string.
> 
> Isn't this just the same as
> 
> 	${${${(M)name#pattern}:+then}:-else}
> 
> except of course that you have to be a little selective about whether
> you use # or % to delimit the pattern?

Nice, hadn't thought about that.

> I'm not particularly excited by the ^test^true^false syntax nor by the
> trick of making "." magic in the true/false strings.  I vote against this
> patch, in its current form at least.  Sorry, Sven.

Especially with the thing above I have absolutely no problems with
that.

> } Ok, the `.' thingy is just because I couldn't think of a better
> } character/syntax (suggestions?) and this isn't as powerful as I would
> } like it because `then' and `else' can't expand to arrays. Maybe we
> } could make `${(A)foo^?^$arr1^$arr2}' do that (and maybe we could do
> } the same for `${(A)foo:-$arr}'.
> 
> This is essentially the same problem as ${(A)foo:=string} where it would
> be nice to be able to have "string" be interpreted as an array.  I pointed
> out the parsing problem with this back at that time.  It would be nice to
> have a solution; Andrej suggested ${(A)foo:=(val1 val2 ...)} but it will
> require a change to the parser to make that work.

Or we could add a flag that says that the string is to be split into
different words and change `dquote_parse()' to allow us to say that
the `endchar' is any white-space (or any seperator character). I would 
have suggested using the forms with a double character (as in
`${(A)arr:==a b c}') if that weren't too incompatible.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

