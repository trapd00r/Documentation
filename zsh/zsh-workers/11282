From zsh-workers-return-11282-mason-zsh=primenet.com.au@sunsite.auc.dk Tue May 09 16:50:49 2000
Return-Path: <zsh-workers-return-11282-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19120 invoked from network); 9 May 2000 16:50:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 May 2000 16:50:47 -0000
Received: (qmail 28334 invoked by alias); 9 May 2000 16:50:32 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11282
Received: (qmail 28319 invoked from network); 9 May 2000 16:50:31 -0000
Message-ID: <391841D2.E294FEFF@u.genie.co.uk>
Date: Tue, 09 May 2000 17:50:26 +0100
From: Oliver Kiddle <opk@u.genie.co.uk>
X-Mailer: Mozilla 4.72 [en] (Win95; I)
X-Accept-Language: en
MIME-Version: 1.0
To: Zsh workers <zsh-workers@sunsite.auc.dk>
Subject: PATCH: arguments for typeset (and variants)
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

I've included here a patch to complete options after the typeset
command and its variants (_vars_eq). When the function directories are
rearranged, it might be better to rename it to _typeset.

Should I incorporate completion for autoload and functions into this? I
think they should be in here and that unfunction should be handled by a
new _unhash. _functions should still exist but should be moved to be
alongside _options etc and should be called from other completion
functions. Do you agree - if so, I'll do this tomorrow?

I had a few problems with the + options in _vars_eq but I must have been
doing something wrong. There should be +g, +h, +r, +t, +x (any maybe
some others) options but when I put them in the completion spec as
something like '(-f)-+x[ex...', completion for typeset hangs zsh.

I've done this _vars_eq in a slightly weird way because there didn't
seem to be an easy way to handle all the different variants to typeset.
If you can think if a better way, please change it. I think there are
still a few things missing from the mutexes but I'm not very sure of
which options really make sense together. What should be the case for
example with arrays and lowercase. The array values are never actually
converted so it would never make sense to use them together though the
variable is actually tagged as lower and typeset will not give you an
error. My opinion is that they should be considered mutually exclusive
because completion is more useful if fewer things are completed.

Oliver

Index: Completion/Builtins/_vars_eq
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_vars_eq,v
retrieving revision 1.3
diff -u -r1.3 _vars_eq
--- Completion/Builtins/_vars_eq	2000/04/17 08:22:44	1.3
+++ Completion/Builtins/_vars_eq	2000/05/09 16:45:53
@@ -1,9 +1,70 @@
-#compdef declare export integer local readonly typeset
+#compdef declare export integer float local readonly typeset
 
-if [[ "$PREFIX" = *\=* ]]; then
-  compstate[parameter]="${PREFIX%%\=*}"
-  compset -P 1 '*='
-  _value
-else
-  _parameters -q -S '='
+local expl state line func i use curcontext="$curcontext"
+local -A allargs
+local -a args
+
+allargs=( \
+  A '(-E -F -L -R -T -U -Z -a -f -i -m)-A[specify that arguments refer to associative arrays]' \
+  E '(-A -F -L -R -T -U -Z -a -f -i -m)-E[represent internally as floating point, use engineering notation on output]' \
+  F '(-A -E -L -R -T -U -Z -a -f -i -m)-F[represent internally as floating point, use fixed point decimal on output]' \
+  L '(-A -E -F -f -i)-L+[left justify and remove leading blanks from value]:width' \
+  R '(-A -E -F -f -i)-R+[right justify and fill with leading blanks]:width' \
+  T '(-A -E -F -a -f -g -h -i -l -m -t)-T[tie scalar to array]' \
+  U '(-A -E -F -i)-U[keep array values unique and suppress alias expansion for functions]' \
+  Uf '(-E -F -i)-U[suppress alias expansion for functions]' \
+  Up '(-E -F -i)-U[keep array values unique]' \
+  Z '(-A -E -F -f -i)-Z+[right justify and fill with leading zeros]:width' \
+  a '(-A -E -F -T -f -i)-a[specify that arguments refer to arrays]' \
+  f '(-A -E -F -L -R -T -Z -a -g -h -i -l -r -x)-f[specify that arguments refer to functions]' \
+  g '(-T -f)-g[do not restrict parameter to local scope]' \
+  h '(-T -f)-h[hide parameter]' \
+  i '(-A -E -F -T -f)-i[represent internally as an integer]' \
+  l '(-T -f)-l[convert the value to lowercase]' \
+  m '(-A -E -F -T -i)-m[treat arguments as patterns]' \
+  r '(-f)-r[mark parameters as readonly]' \
+  t '(-T)-t[tag parameters and turn on execution tracing for functions]' \
+  tf '(-T)-t[turn on execution tracing for functions]' \
+  tp '(-T)-t[tag parameters]' \
+  u '-u[convert the value to uppercase or mark function for autoloading]' \
+  uf '-u[mark function for autoloadling]' \
+  up '-u[convert the value to uppercase]' \
+  x '(-f)-x[export parameter]' )
+
+use="AEFLRTUZafghilmrtux"
+
+case ${words[1]} in
+  float) use="EFghlrtux";;
+  functions)
+    use="Umtu"
+    func=f
+  ;;
+  integer) use="ghlrtux" ;;
+  readonly) use="${use/r/}" ;;
+  local) use="${use/f/}" ;&
+  export) use="${${use/g/}/x/}" ;;
+esac
+
+[[ -z "${words[(r)-*f*]]}" ]] || func=f
+[[ -z "${words[(r)-*[aA]*]}" ]] || func=p
+   
+for ((i=1;i<=$#use;++i)); do
+  args=( "${args[@]}" \
+      ${allargs[${use[$i]}${${(s::)use[$i]}[(r)[Uut]]:+$func}]} )
+done
+
+_arguments -C -s "${args[@]}" '*:vars:->vars_eq'
+
+if [[ "$state" = vars_eq ]]; then
+  if [[ $func = f ]]; then
+    _functions
+  elif [[ "$PREFIX" = *\=* ]]; then
+    compstate[parameter]="${PREFIX%%\=*}"
+    compset -P 1 '*='
+    _value
+  elif (( $+opt_args[-a] || $+opt_args[-A] )); then
+    _parameters -q
+  else
+    _parameters -q -S '='
+  fi
 fi

