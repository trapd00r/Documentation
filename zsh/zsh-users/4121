From zsh-users-return-4121-mason-zsh=primenet.com.au@sunsite.dk Tue Aug 14 06:48:42 2001
Return-Path: <zsh-users-return-4121-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19771 invoked from network); 14 Aug 2001 06:48:40 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Aug 2001 06:48:40 -0000
Received: (qmail 26326 invoked by alias); 14 Aug 2001 06:48:24 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4121
Received: (qmail 26311 invoked from network); 14 Aug 2001 06:48:22 -0000
From: Bart Schaefer <schaefer@brasslantern.com>
Message-Id: <1010814064813.ZM7010@candle.brasslantern.com>
Date: Tue, 14 Aug 2001 06:48:13 +0000
In-Reply-To: <OF0DBC7C20.AA591973-ON80256AA7.005F1DD0@uk.jpmorgan.com>
Comments: In reply to martin.ebourne@arcordia.com
        "Delaying menu completion" (Aug 13,  6:53pm)
References: <OF0DBC7C20.AA591973-ON80256AA7.005F1DD0@uk.jpmorgan.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: martin.ebourne@arcordia.com, zsh-users@sunsite.dk
Subject: Re: Delaying menu completion
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Aug 13,  6:53pm, martin.ebourne@arcordia.com wrote:
}
} complete, added the style menu = select, and bound the menu-complete widget
} onto a key. In addition to being a really easy change, this does almost
} exactly what I want. However,
} 
} Problem 1
} 
} It falls down with _match and _approximate. These two both launch into menu
} selection on their own and I can't seem to stop them. Setting style
} insert-unambiguous = yes gets me part of the way there, but they still
} won't stop fully.

It's hard to say exactly what's going on without knowing your styles, and
Sven may know better ... but have you tried

    zstyle ':completion::match:*' insert-unambiguous pattern
    zstyle ':completion::approximate*:*' insert-unambiguous yes

??  That seems to me to do what you want, with one caveat which I will
get to in a moment.  The reason for "approximate*" above is that the
contexts "approximate" and "correct" are never tested by themselves;
they always have the number of corrections appended.

The caveat I mentioned is that _approximate has this strange test in it:

    [[ "${#compstate[unambiguous]}" -ge "${#:-$PREFIX$SUFFIX}" ]]

That means that the unambiguous prefix must be longer than the word on
the command line.  I.e., there's no way to prevent it dropping into
menu completion unless all the matches have a common prefix longer than
what's on the line right now.  I don't remember what that was supposed
to accomplish, but it seems a rather unlikely situation.  Sven?

} Problem 2
} 
} Currently I've bound a function key to menu-complete. However, what I'd
} really like is to use the down arrow key.
} 
} So I tried this:
} 
} _menu_or_down() {
}   if [[ $compstate[old_list] == shown ]]
}   then
}     zle menu-complete
}   else
}     zle .history-beginning-search-forward
}   fi
} }
} 
} zle -C menu-or-down menu-complete _menu_or_down
} bindkey "^[[B" menu-or-down

No, you can't use "zle -C ..." there.  You're not defining a new
completion widget, you're defining an "ordinary" widget that happens
to call a completion command; and you can't call other zle commands
from a completion widget.  So what you'd want is

    zle -N menu-or-down _menu_or_down

Then "zle menu-complete" will call the completion widgets as needed.
Unfortunately $compstate[old_list] is not available until after you
enter one of the completion widgets, so you're going to need a helper
function of some kind, that will be used as the non-menu completion
widget, and that sets a global variable that can be tested in place
of $compstate when you invoke _menu_or_down.

} Also, the second parameter after zle -C (menu-complete here) - the
} documentation says that this is the built in widget it behaves like. I
} couldn't understand from the documentation though what exactly this was
} used for and why it was needed.

The code that controls the display, decides whether to expand or list
or perform menu completion, etc., is all still in C.  You can override
most of it by poking values into compstate et al., but the defaults are
set up based on the behavior indicated by zle -C.  There are probably
a few other details that I'm forgetting, as well.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

