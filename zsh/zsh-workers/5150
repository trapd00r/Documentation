Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Mon, 1 Feb 1999 11:48:11 +0100 (MET)
Message-Id: <199902011048.LAA07559@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 26 Jan 1999 16:37:43 -0800
Subject: Re: Example function
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5150


Bart Schaefer wrote:

> (One of the things on the associative-array wishlist is "reverse pattern"
> lookup, that is, treat the array keys as patterns and match them against
> the subscript.  Then you could do silly stuff like
> 
> 	typeset -A map
> 	map=('*.(gz|Z)'	zcat
> 	     '*.bz2' 'bzip2 -dc'
> 	     '*.bz' 'bzip -dc'
> 	     '*' '<')
> 	eval ${(q)map[$argv[i]]} '$argv[i]'
> 
> where I'm using (q) as the fictional reverse-pattern query flag; probably
> there's a better letter.)
> 
> Incidentally, the reason this isn't there already is that associative arrays
> are unordered hashes, so you can't predict _which_ pattern will match the
> subscript when you do the query -- '*' might match before '*.bz' is tried.

I was thinking about this... we could make the code keep a counter in
assoc arrays, increment it whenever a new key is added and store the
current value in the structure for this new element. Then we can treat 
the whole thing as being sorted by `time of addition'.

Hm, does this sound like the right thing?

Bye
 Sven

P.S.: Is `foo=( ${(kv)foo[(I)^key]} )' the easiest way to remove a
      key/value-pair from an associative array?

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

