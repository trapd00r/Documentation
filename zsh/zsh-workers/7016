From zsh-workers-return-7016-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jul 07 15:32:59 1999
Return-Path: <zsh-workers-return-7016-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15598 invoked from network); 7 Jul 1999 15:32:57 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Jul 1999 15:32:57 -0000
Received: (qmail 1744 invoked by alias); 7 Jul 1999 15:32:50 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7016
Received: (qmail 1737 invoked from network); 7 Jul 1999 15:32:50 -0000
X-Envelope-Sender-Is: Andrej.Borsenkow@mow.siemens.ru (at relayer david.siemens.de)
From: "Andrej Borsenkow" <Andrej.Borsenkow@mow.siemens.ru>
To: "ZSH workers mailing list" <zsh-workers@sunsite.auc.dk>
Subject: ${(A)=xxx} - second go - now real bug.
Date: Wed, 7 Jul 1999 19:32:42 +0400
Message-ID: <002501bec88d$f467f470$21c9ca95@mow.siemens.ru>
MIME-Version: 1.0
Content-Type: text/plain;
	charset="koi8-r"
Content-Transfer-Encoding: 7bit
X-Priority: 3 (Normal)
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook IMO, Build 9.0.2416 (9.0.2910.0)
Importance: Normal
X-MimeOLE: Produced By Microsoft MimeOLE V5.00.2314.1300

Reading docs once more I noted this:

A
     Create an array parameter with ${...=...}, ${...:=...} or
     ${...::=...}.  If this flag is repeated (as in AA), create an
     associative array parameter.  Assignment is made before sorting or
     padding.  The NAME part may be a subscripted range for ordinary
     arrays; the WORD part *must* be converted to an array, for example
     by using ${(AA)=...} to activate word splitting, when creating an
     associative array.

Please, note the last sentence. It implies, that in case of array/hash
assignment the word is treated as in array assignment - that is, ${(A)foo=bar
baz} is basically the same as foo=(bar baz). At least, I find this natural and
useful. And I have a feeling, that it was once so. Currently we have:

bor@itsrm2:~%> : ${(AA)foo::=bar baz}
zsh: bad set of key/value pairs for associative array

bor@itsrm2:~%> print -l $foo

bor@itsrm2:~%> print ${(t)foo}
association
bor@itsrm2:~%> unset foo
bor@itsrm2:~%> : ${(A)foo::=bar baz}
bor@itsrm2:~%> print -l $foo
bar baz
bor@itsrm2:~%> print ${(t)foo}
array


I suggest changing it to the described. That is,

${foo=bar} - the same as foo=bar (with blanks quoted, 'course)
${(A)foo=bar}, ${(AA)foo=bar} -
             the same as foo=(bar)

A good question is, if we should do globbing in above cases. I dare to say, that
it may be useful ... following the usual rules. That is, no globbing in
${foo=bar} and normal globbing in ${(A)foo=bar}

Additional suggestion - what about iterpreting the (A) and (AA) flags in
${(A):-bar} ? The main reason is, currently it is always producing scalar; but
there are cases (mostly globbing) where I'd like to have array. Again, splitting
is _not_ the same. This would allow to use

${(A):-*.txt}

to get a list of files instead of current

${(f)"$(print -l *.txt)"}

that always has a problem with new lines in file names. And it is more simple
and arguably faster.

And final question: how should the following (from parameter expansion) be
interpreted:

s:STRING:
     Force field splitting (see the option SH_WORD_SPLIT) at the
     separator STRING.  Splitting only occurs in places where an array
     value is valid.

I mean the last sentence?

regards

/andrej

