From hzoli@cs.elte.hu Sat Jul 20 05:40:57 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3/2) with ESMTP id FAA25779 for <mason@werple.mira.net.au>; Sat, 20 Jul 1996 05:40:54 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id PAA24401; Fri, 19 Jul 1996 15:31:01 -0400 (EDT)
Resent-Date: Fri, 19 Jul 1996 15:31:01 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199607191930.VAA09905@bolyai.cs.elte.hu>
Subject: Re: Misc. unresolved stuff
To: schaefer@nbn.com
Date: Fri, 19 Jul 1996 21:30:30 +0200 (MET DST)
Cc: zsh-workers@math.gatech.edu
In-Reply-To: <960719111210.ZM3055@candle.brasslantern.com> from Bart Schaefer at "Jul 19, 96 11:12:10 am"
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL16 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"bPgEk2.0.Cz5.r9-xn"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/1720
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 3828
Status: O

> In article 1397, Zoltan said he'd fix $[$[1+2]+3], and apparently he has.
> Is there some reason why $((...)) doesn't nest?  I asked in article 1414
> whether there other differences between $[...] and $((...)).  There's
> exactly one mention of $((...)) in zshexpn.man, which says only that it's
> the same as $[...].

That's a bug again.  The fix is below.

> In article 1426, I asked why array subscript flags such as $foo[(f)...]
> don't work with $foo[@] and $foo[*].  Does anyone else want them to?

That's a bit more difficult because in this case $foo should be split.
$foo[(f)@] is interpreted in params.c while splitting is done in subst.c so
this cahnge is not trivial (but it is probably not difficult).

> In article 1428, I pointed out that zsh's "getopts" builtin doesn't seem
> to properly handle some error cases, by comparison to bash.  I don't have
> ksh to compare to that.  Does anyone think "getopts" is a problem?

I think that zsh getopts is ksh and POSIX compatible.  I do not use getopts
but you can compare it with the ksh version.  pdksh is free and the AT&T
ksh93 can also be downloaded and used free from
http://www.research.att.com/orgs/ssr/book/reuse/.

> In zsh-users article 257, I asked why there's no (:L) modifier, to go
> with the (L) flag; similarly (U) and (:U).  I also hoped for a better
> error message for unrecognized modifiers.  Any comment?

I think we can live with this inconsistency.  The biggest problem here that
there are too few letters in the alphabet.  Probably that's why (L) is not
(l).  But there is a bug in the parameter modifier code when a modifier is
used on an empty array and the diagnostics can certainly be improved.
Tell me if you like the behaviour after applying this patch.

Zoltan


rcsdiff -qc -kk -r2.41 -r2.43 Src/subst.c
*** Src/subst.c
--- Src/subst.c	1996/07/19 19:25:14	2.43
***************
*** 128,148 ****
  	    char endchar;
  	    int l1, l2;
  
! 	    if (*str == Inpar)
! 		endchar = Outpar, str[-1] = '\0';
! 	    else
! 		endchar = *str, *str = '\0';
! 
! 	    while (*++str != endchar)
! #ifdef DEBUG
! 		if (!*str) {
! 		    /* This shoud never happen */
! 		    zerr("Oops. parse error in command substitution", NULL, 0);
! 		    return NULL;
! 		}
! #else
! 		;
! #endif
  	    *str++ = '\0';
  	    if (endchar == Outpar && str2[1] == '(' && str[-2] == ')') {
  		/* Math substitution of the form $((...)) */
--- 128,146 ----
  	    char endchar;
  	    int l1, l2;
  
! 	    if (*str == Inpar) {
! 		endchar = Outpar;
! 		str[-1] = '\0';
! 		if (skipparens(Inpar, Outpar, &str))
! 		    DPUTS(1, "Oops. parse error in command substitution");
! 		str--;
! 	    } else {
! 		endchar = *str;
! 		*str = '\0';
! 
! 		while (*++str != endchar)
! 		    DPUTS(!*str, "Oops. parse error in command substitution");
! 	    }
  	    *str++ = '\0';
  	    if (endchar == Outpar && str2[1] == '(' && str[-2] == ')') {
  		/* Math substitution of the form $((...)) */
***************
*** 1201,1207 ****
  		if (!isarr)
  		    modify(&val, &s);
  		else {
! 		    char *ss = s;
  		    char **ap = aval;
  		    char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));
  
--- 1199,1205 ----
  		if (!isarr)
  		    modify(&val, &s);
  		else {
! 		    char *ss;
  		    char **ap = aval;
  		    char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));
  
***************
*** 1209,1215 ****
--- 1207,1226 ----
  			ss = s;
  			modify(pp++, &ss);
  		    }
+ 		    if (pp == aval) {
+ 			char t[] = "";
+ 			ss = s;
+ 			s = t;
+ 			modify(&s, &ss);
+ 		    }
  		    s = ss;
+ 		}
+ 		if (inbrace && *s != Outbrace) {
+ 		    if (*s == ':' && !imeta(s[1]))
+ 			zerr("unrecognized modifier `%c'", NULL, s[1]);
+ 		    else
+ 			zerr("unrecognized modifier", NULL, 0);
+ 		    return NULL;
  		}
  	    }
  	}


