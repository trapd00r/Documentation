From zsh-workers-request@math.gatech.edu Thu Sep 25 06:19:03 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 21398 invoked from network); 25 Sep 1997 06:19:00 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 25 Sep 1997 06:19:00 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id BAA13324;
	Thu, 25 Sep 1997 01:54:37 -0400 (EDT)
Resent-Date: Thu, 25 Sep 1997 01:54:37 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@frontiernet.net>
Message-Id: <199709250555.BAA03669@hzoli.home>
Subject: rlimits.awk in 3.0.5-test2
To: zsh-workers@math.gatech.edu (Zsh hacking and development)
Date: Thu, 25 Sep 1997 01:55:04 -0400 (EDT)
X-Mailer: ELM [version 2.4ME+ PL31 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"OpKuQ.0.4G3.SoVAq"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3522
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

I've just tried to compile zsh-3.0.5-test2 on an ancient SunOS 4.1.2 with
K&R compiler, and rlimits.awk failed, since it does not seem to support
|| in the pattern part.  Could you please everyone check with his own awk
(the older the better) if the fix below works?  The included patch should
be applied to zsh-3.0.5-test2, and besides the awk patch, it has a little
fix for the a='a '; print -l ${(o)=a}b problem and a trivial fix to
mem.c.  If noone complains, that will be released as zsh-3.0.5 tomorrow.

Thanks,

Zoltan


*** Src/mem.c.3.0.4	Sun Sep  1 18:57:23 1996
--- Src/mem.c	Wed Sep 24 23:38:40 1997
***************
*** 49,55 ****
  	pushheap() saves the states of all currently allocated heaps and
  	popheap() resets them to the last state saved and destroys the
  	information about that state.  If you called pushheap() and
! 	allocated some meory on the heaps and then come to a place where
  	you don't need the allocated memory anymore but you still want
  	to allocate memory on the heap, you should call freeheap().  This
  	works like popheap(), only that it doesn't free the information
--- 49,55 ----
  	pushheap() saves the states of all currently allocated heaps and
  	popheap() resets them to the last state saved and destroys the
  	information about that state.  If you called pushheap() and
! 	allocated some memory on the heaps and then come to a place where
  	you don't need the allocated memory anymore but you still want
  	to allocate memory on the heap, you should call freeheap().  This
  	works like popheap(), only that it doesn't free the information
***************
*** 72,81 ****
  	If we use zsh's own allocator we use a simple trick to avoid that
  	the (*real*) heap fills up with empty zsh-heaps: we allocate a
  	large block of memory before allocating a heap pool, this memory
! 	is freed again immediatly after the pool is allocated. If there
! 	are only small blocks on the free list this guarentees that the
  	memory for the pool is at the end of the memory which means that
! 	we can give it back to the systems when the pool is freed.
  */
  
  #ifdef ZSH_MEM_WARNING
--- 72,81 ----
  	If we use zsh's own allocator we use a simple trick to avoid that
  	the (*real*) heap fills up with empty zsh-heaps: we allocate a
  	large block of memory before allocating a heap pool, this memory
! 	is freed again immediately after the pool is allocated. If there
! 	are only small blocks on the free list this guarantees that the
  	memory for the pool is at the end of the memory which means that
! 	we can give it back to the system when the pool is freed.
  */
  
  #ifdef ZSH_MEM_WARNING
***************
*** 348,356 ****
  zrealloc(void *ptr, size_t size)
  {
      if (ptr) {
! 	if (size)
  	    /* Do normal realloc */
! 	    return realloc(ptr, size);
  	else
  	    /* If ptr is not NULL, but size is zero, *
  	     * then object pointed to is freed.      */
--- 348,361 ----
  zrealloc(void *ptr, size_t size)
  {
      if (ptr) {
! 	if (size) {
  	    /* Do normal realloc */
! 	    if (!(ptr = (void *) realloc(ptr, size))) {
! 		zerr("fatal error: out of memory", NULL, 0);
! 		exit(1);
! 	    }
! 	    return ptr;
! 	}
  	else
  	    /* If ptr is not NULL, but size is zero, *
  	     * then object pointed to is freed.      */
*** Src/subst.c~	Sat Aug  2 02:11:08 1997
--- Src/subst.c	Wed Sep 24 23:24:44 1997
***************
*** 420,425 ****
--- 420,427 ----
      return dest;
  }
  
+ typedef int (*CompareFn) _((const void *, const void *));
+ 
  /**/
  int
  strpcmp(const void *a, const void *b)
***************
*** 704,710 ****
      int vunset = 0;
      int spbreak = isset(SHWORDSPLIT) && !ssub && !qt;
      char *val = NULL, **aval = NULL;
!     int fwidth = 0;
      Value v;
      int flags = 0;
      int flnum = 0;
--- 706,712 ----
      int vunset = 0;
      int spbreak = isset(SHWORDSPLIT) && !ssub && !qt;
      char *val = NULL, **aval = NULL;
!     unsigned int fwidth = 0;
      Value v;
      int flags = 0;
      int flnum = 0;
***************
*** 1005,1011 ****
  		fwidth = v->pm->ct ? v->pm->ct : strlen(val);
  		switch (v->pm->flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
  		    char *t;
! 		    int t0;
  
  		case PM_LEFT:
  		case PM_LEFT | PM_RIGHT_Z:
--- 1007,1013 ----
  		fwidth = v->pm->ct ? v->pm->ct : strlen(val);
  		switch (v->pm->flags & (PM_LEFT | PM_RIGHT_B | PM_RIGHT_Z)) {
  		    char *t;
! 		    unsigned int t0;
  
  		case PM_LEFT:
  		case PM_LEFT | PM_RIGHT_Z:
***************
*** 1383,1402 ****
  	    setdata(n, y);
  	    return n;
  	}
! 	if (sortit && !copied)
! 	    aval = arrdup(aval);
! 	if (sortit == 1)
! 	    qsort(aval, arrlen(aval), sizeof(char *), strpcmp);
! 
! 	else if (sortit == 2)
! 	    qsort(aval, arrlen(aval), sizeof(char *), invstrpcmp);
! 
! 	else if (sortit == 3)
! 	    qsort(aval, arrlen(aval), sizeof(char *), cstrpcmp);
  
! 	else if (sortit)
! 	    qsort(aval, arrlen(aval), sizeof(char *), invcstrpcmp);
  
  	if (plan9) {
  	    LinkList tl = newlinklist();
  	    LinkNode tn;
--- 1385,1402 ----
  	    setdata(n, y);
  	    return n;
  	}
! 	if (sortit) {
! 	    static CompareFn sortfn[] = {
! 		strpcmp, invstrpcmp, cstrpcmp, invcstrpcmp
! 	    };
  
! 	    if (!copied)
! 		aval = arrdup(aval);
  
+ 	    i = arrlen(aval);
+ 	    if (i && (*aval[i-1] || --i))
+ 		qsort(aval, i, sizeof(char *), sortfn[sortit-1]);
+ 	}
  	if (plan9) {
  	    LinkList tl = newlinklist();
  	    LinkNode tn;
*** Src/rlimits.awk.orig	Sun Sep 21 02:15:17 1997
--- Src/rlimits.awk	Thu Sep 25 01:43:09 1997
***************
*** 9,16 ****
  #
  BEGIN {limidx = 0}
  
! /^[\t ]*#[\t ]*define[\t _]*RLIMIT_[A-Z]*[\t ]*[0-9][0-9]*/ ||
! /^[\t ]*RLIMIT_[A-Z]*,[\t ]*/ {
      limindex = index($0, "RLIMIT_")
      limtail = substr($0, limindex, 80)
      split(limtail, tmp)
--- 9,15 ----
  #
  BEGIN {limidx = 0}
  
! /^[\t ]*(#[\t ]*define[\t _]*RLIMIT_[A-Z]*[\t ]*[0-9][0-9]*|RLIMIT_[A-Z]*,[\t ]*)/ {
      limindex = index($0, "RLIMIT_")
      limtail = substr($0, limindex, 80)
      split(limtail, tmp)

