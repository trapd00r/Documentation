From zsh-workers-request@math.gatech.edu Thu Nov 06 17:50:19 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 20290 invoked from network); 6 Nov 1997 17:50:18 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 6 Nov 1997 17:50:18 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id MAA28474;
	Thu, 6 Nov 1997 12:45:58 -0500 (EST)
Resent-Date: Thu, 6 Nov 1997 12:44:41 -0500 (EST)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <971106094437.ZM25281@candle.brasslantern.com>
Date: Thu, 6 Nov 1997 09:44:37 -0800
In-Reply-To: <3461E726.5327813E@rrz.uni-hamburg.de>
Comments: In reply to Bernd Eggink <eggink@rrz.uni-hamburg.de>
        "Word split" (Nov  6,  4:49pm)
References: <3461E726.5327813E@rrz.uni-hamburg.de>
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: zsh-users mailing list <zsh-users@math.gatech.edu>
Subject: Re: Word split
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"CS-Fj2.0.yx6.88WOq"@math>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/1128
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Nov 6,  4:49pm, Bernd Eggink wrote:
} Subject: Word split
}
} 	x='a::b'
} 	y=(${(s(:)x})
                  ^
        y=(${(s(:))x})
                  ^
} I wanted $y to hold 3 elements, with an empty $y[2], but the result is
} an array with 2 elements, 'a' and 'b'. This would be OK if at least 
} 
} 	y=("${(@s(:)x}")
                    ^
  	y=("${(@s(:))x}")
                    ^
} gave 3 elements, but it doesn't either.

I thought perhaps this was a problem with using it in the array context,
but ${(ws(:))#x} yeilds 2, so it really is dropping the empty word when
doing the split.

While we're on the subject, is there any chance the manual could get some
more examples added to the parameter expansion section?  It's really not
very easy to understand from the one-line descriptions what something like
${(SI(1)B)x%:} will produce.

"Include the index of the beginning of the match in the result."

Whaddaya mean, "include?"

Well, what you mean is that if you use multiple flags, you get multiple
words in the result:

    zagzig[144] echo ${(SI(1)BE)x%:}
    3 4

But the order of the flags doesn't make any difference:

    zagzig[145] echo ${(SI(1)EB)x%:}
    3 4

And nowhere is it explained what order they're going to show up in:

    zagzig[146] echo ${(SI(1)BR)x%:}
    a:b 3
    zagzig[147] echo ${(SI(1)MR)x%:}
    : a:b
    zagzig[148] echo ${(SI(1)RBM)x%:}
    : a:b 3
    zagzig[149] echo ${(SI(1)RBMN)x%:}
    : a:b 3 1
    zagzig[150] echo ${(SI(1)RBMNE)x%:}
    : a:b 3 4 1

Lots of zsh's features lurk behind this kind of veil of semidocumentation.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

