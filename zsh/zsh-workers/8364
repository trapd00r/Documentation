From zsh-workers-return-8364-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Oct 21 16:41:40 1999
Return-Path: <zsh-workers-return-8364-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20767 invoked from network); 21 Oct 1999 16:41:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 21 Oct 1999 16:41:39 -0000
Received: (qmail 10454 invoked by alias); 21 Oct 1999 16:41:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8364
Received: (qmail 10447 invoked from network); 21 Oct 1999 16:41:30 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <991021164052.ZM12659@candle.brasslantern.com>
Date: Thu, 21 Oct 1999 16:40:52 +0000
In-Reply-To: <199910210710.JAA04616@beta.informatik.hu-berlin.de>
Comments: In reply to Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
        "Re: Completeinword and ambiguous completions" (Oct 21,  9:10am)
References: <199910210710.JAA04616@beta.informatik.hu-berlin.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: predict-on (Re: Completeinword and ambiguous completions)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Oct 21,  9:10am, Sven Wischnowsky wrote:
} Subject: Re: Completeinword and ambiguous completions
}
} Bart Schaefer wrote:
} > zsh% setopt prompt
} > (feep, cursor stays on "m")
} > 
} > What I'd like is, in the first of those cases, the cursor doesn't stay
} > on the "m" but rather moves to the end of the unambiguous prefix, so that
} > I can immediately start menu completion for the rest of the word.
} 
}   compmatchers=('' 'r:|=*')
} 
} Is that good enough?

It seems to work some, but not all, of the time.  For example:

zagzig<4> setopt promptt

If the cursor is on the second `t' there are two possible completions
(promptsubst and promptpercent).  So when the cursor is on the `m' I
expect TAB to move it to the second `t'.  Instead I get a feep.

Maybe the following will explain why I'm interested in this.  I want to
press TAB in the middle of a predictivly-inserted line to jump ahead to
the next spot where I might want to edit.

Index: Functions/Zle/predict-on
===================================================================
@@ -1,31 +1,43 @@
 # This set of functions implements a sort of magic history searching.
 # After predict-on, typing characters causes the editor to look backward
-# in the history for the first line beginning with what you have typed
-# so far.  After predict-off, editing returns to normal for the line found.
+# in the history for the first line beginning with what you have typed so
+# far.  After predict-off, editing returns to normal for the line found.
 # In fact, you often don't even need to use predict-off, because if the
-# line doesn't match something in the history, adding a key at the end
-# behaves as normal --- though editing in the middle is liable to delete
+# line doesn't match something in the history, adding a key performs
+# standard completion --- though editing in the middle is liable to delete
 # the rest of the line.
 #
+# The setting of compmatchers means that if you use the completion system,
+# you should be able to type TAB at almost any point to advance the cursor
+# to the next "interesting" character position (usually the end of the
+# current word, but sometimes somewhere in the middle of the word).  And
+# of course as soon as the entire line is what you want, you can accept
+# with RETURN, without needing to move the cursor to the end first.
+#
 # To use it:
 #   autoload -U predict-on
 #   zle -N predict-on
 #   zle -N predict-off
 #   bindkey '...' predict-on
 #   bindkey '...' predict-off
-# Note that all the functions are defined when you first call type the
-# predict-on key, which means typing the predict-off key before that gives
-# a harmless error message.
+# Note that all functions are defined when you first type the predict-on
+# key, which means typing the predict-off key before that gives a harmless
+# error message.
 
 predict-on() {
+    setopt localoptions nounset noksharrays
     zle -N self-insert insert-and-predict
     zle -N magic-space insert-and-predict
     zle -N backward-delete-char delete-backward-and-predict
+    [[ $compmatchers[2] != 'r:|=*' ]] &&
+      compmatchers=('' 'r:|=*' $compmatchers)
 }
 predict-off() {
+    setopt localoptions nounset noksharrays
     zle -A .self-insert self-insert
     zle -A .magic-space magic-space
     zle -A .backward-delete-char backward-delete-char
+    [[ $compmatchers[2] != 'r:|=*' ]] || shift 2 compmatchers
 }
 insert-and-predict () {
   emulate -L zsh
@@ -37,7 +49,16 @@
     LBUFFER="$LBUFFER$KEYS"
     if [[ $LASTWIDGET == (self-insert|magic-space|backward-delete-char) ]]
     then
-      zle .history-beginning-search-backward || RBUFFER=""
+      if ! zle .history-beginning-search-backward
+      then
+	RBUFFER=""
+	if [[ ${KEYS[-1]} != ' ' ]]
+	then
+	  integer curs=$CURSOR
+	  zle complete-word
+	  CURSOR=$curs
+	fi
+      fi
     fi
   fi
   return 0

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

