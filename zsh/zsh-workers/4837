From zsh-workers-request@math.gatech.edu Thu Dec 17 14:17:03 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4998 invoked from network); 17 Dec 1998 14:17:01 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 17 Dec 1998 14:17:01 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id JAA06042;
	Thu, 17 Dec 1998 09:06:33 -0500 (EST)
Resent-Date: Thu, 17 Dec 1998 09:06:33 -0500 (EST)
Date: Thu, 17 Dec 1998 15:04:55 +0100 (MET)
Message-Id: <199812171404.PAA11699@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
Subject: PATCH: module-cleanup part II
Resent-Message-ID: <"sQ36s2.0.LU1.f_GUs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4837
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


While playing with conditions for my new style completion thing I
realised that we probably should make the conddef-table more like the
builtin-table. So the patch below does some re-arranging and makes
condition- handler functions get an integer like the funcid for builtins.

I should have done from the beginning, sorry.

Bye
 Sven

diff -cr os/Modules/example.c Src/Modules/example.c
*** os/Modules/example.c	Thu Dec 17 12:20:40 1998
--- Src/Modules/example.c	Thu Dec 17 14:42:12 1998
***************
*** 51,57 ****
  
  /**/
  static int
! cond_p_len(Conddef c, char **a)
  {
      char *s1 = cond_str(a, 0);
  
--- 51,57 ----
  
  /**/
  static int
! cond_p_len(char **a, int id)
  {
      char *s1 = cond_str(a, 0);
  
***************
*** 66,72 ****
  
  /**/
  static int
! cond_i_ex(Conddef c, char **a)
  {
      char *s1 = cond_str(a, 0), *s2 = cond_str(a, 1);
  
--- 66,72 ----
  
  /**/
  static int
! cond_i_ex(char **a, int id)
  {
      char *s1 = cond_str(a, 0), *s2 = cond_str(a, 1);
  
***************
*** 99,106 ****
  };
  
  static struct conddef cotab[] = {
!     CONDDEF("len", 0, 1, 2, cond_p_len),
!     CONDDEF("ex", CONDF_INFIX, 0, 0, cond_i_ex),
  };
  
  static struct funcwrap wrapper[] = {
--- 99,106 ----
  };
  
  static struct conddef cotab[] = {
!     CONDDEF("len", 0, cond_p_len, 1, 2, 0),
!     CONDDEF("ex", CONDF_INFIX, cond_i_ex, 0, 0, 0),
  };
  
  static struct funcwrap wrapper[] = {
diff -cr os/cond.c Src/cond.c
*** os/cond.c	Thu Dec 17 12:20:21 1998
--- Src/cond.c	Thu Dec 17 14:48:40 1998
***************
*** 57,63 ****
  			return 0;
  		    }
  		}
! 		return cd->handler(cd, (char **) c->right);
  	    }
  	    else
  		zerr("unrecognized condition: `-%s'", (char *) c->left, 0);
--- 57,63 ----
  			return 0;
  		    }
  		}
! 		return cd->handler((char **) c->right, cd->condid);
  	    }
  	    else
  		zerr("unrecognized condition: `-%s'", (char *) c->left, 0);
diff -cr os/zsh.h Src/zsh.h
*** os/zsh.h	Thu Dec 17 12:20:25 1998
--- Src/zsh.h	Thu Dec 17 14:52:40 1998
***************
*** 460,482 ****
  #define COND_MOD   16
  #define COND_MODI  17
  
! typedef int (*CondHandler) _((Conddef, char **));
  
  struct conddef {
      Conddef next;		/* next in list                       */
      char *name;			/* the condition name                 */
      int flags;			/* see CONDF_* below                  */
      int min;			/* minimum number of strings          */
      int max;			/* maximum number of strings          */
!     CondHandler handler;	/* handler function                   */
      char *module;		/* module to autoload                 */
  };
  
  #define CONDF_INFIX  1
  #define CONDF_ADDED  2
  
! #define CONDDEF(name, flags, min, max, handler) \
!     { NULL, name, flags, min, max, handler, NULL }
  
  struct forcmd {			/* for/select */
  /* Cmd->args contains list of words to loop thru */
--- 460,483 ----
  #define COND_MOD   16
  #define COND_MODI  17
  
! typedef int (*CondHandler) _((char **, int));
  
  struct conddef {
      Conddef next;		/* next in list                       */
      char *name;			/* the condition name                 */
      int flags;			/* see CONDF_* below                  */
+     CondHandler handler;	/* handler function                   */
      int min;			/* minimum number of strings          */
      int max;			/* maximum number of strings          */
!     int condid;			/* for overloading handler functions  */
      char *module;		/* module to autoload                 */
  };
  
  #define CONDF_INFIX  1
  #define CONDF_ADDED  2
  
! #define CONDDEF(name, flags, handler, min, max, condid) \
!     { NULL, name, flags, handler, min, max, condid, NULL }
  
  struct forcmd {			/* for/select */
  /* Cmd->args contains list of words to loop thru */
*** Util/zsh-development-guide.old	Thu Dec 17 14:40:59 1998
--- Util/zsh-development-guide	Thu Dec 17 14:46:25 1998
***************
*** 238,245 ****
  we need a table with the descriptions:
  
    static struct conddef cotab[] = {
!     CONDDEF("len", 0, 1, 2, cond_p_len),
!     CONDDEF("ex", CONDF_INFIX, 0, 0, cond_i_ex),
    };
  
  Again a macro is used, with the following arguments:
--- 238,245 ----
  we need a table with the descriptions:
  
    static struct conddef cotab[] = {
!     CONDDEF("len", 0, cond_p_len, 1, 2, 0),
!     CONDDEF("ex", CONDF_INFIX, cond_i_ex, 0, 0, 0),
    };
  
  Again a macro is used, with the following arguments:
***************
*** 250,275 ****
    - an optional flag which for now can only be CONDF_INFIX; if this is 
      given, an infix operator is created (i.e. the above makes
      `[[ -len str ]]' and `[[ s1 -ex s2 ]]' available)
    - for non-infix condition codes the next two arguments give the
      minimum and maximum number of string the conditional can handle
      (i.e. `-len' can get one or two strings); as with builtins giving
      -1 as the maximum number means that the conditional accepts any
      number of strings
!   - finally as the last argument the C-function implementing the
!     conditional is given
  
  The definition for the function looks like:
  
    /**/
    static int
!   cond_p_len(Conddef c, char **a)
    {
      ...
    }
  
! The first argument is the table entry defining the condition code and
! the second argument is an array containing the strings
! (NULL-terminated like the array of arguments for builtins).
  The value returned by the function should be non-zero if the condition 
  is true and zero otherwise.
  
--- 250,278 ----
    - an optional flag which for now can only be CONDF_INFIX; if this is 
      given, an infix operator is created (i.e. the above makes
      `[[ -len str ]]' and `[[ s1 -ex s2 ]]' available)
+   - the C-function implementing the conditional
    - for non-infix condition codes the next two arguments give the
      minimum and maximum number of string the conditional can handle
      (i.e. `-len' can get one or two strings); as with builtins giving
      -1 as the maximum number means that the conditional accepts any
      number of strings
!   - finally as the last argument an integer that is passed to the
!     handler function that can be used to distinguish different
!     condition codes if the same C-function implements more than one of 
!     them
  
  The definition for the function looks like:
  
    /**/
    static int
!   cond_p_len(char **a, int id)
    {
      ...
    }
  
! The first argument is an array containing the strings (NULL-terminated
! like the array of arguments for builtins), the second argument is the
! integer value stored in the table (the last argument to `CONDDEF(...)').
  The value returned by the function should be non-zero if the condition 
  is true and zero otherwise.
  


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

