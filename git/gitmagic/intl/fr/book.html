<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>Git Magique</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
alink="#0000FF">
  <div lang="fr" class="book" title="Git Magique">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="idp130112" id=
          "idp130112"></a>Git Magique</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="firstname">Ben</span>
            <span class="surname">Lynn</span></h3>
          </div>
        </div>

        <div>
          <div class="revhistory">
            <table border="1" width="100%" summary=
            "Revision history">
              <tr>
                <th align="left" valign="top" colspan="3">
                <b>Historique des versions</b></th>
              </tr>

              <tr>
                <td align="left"></td>

                <td align="left">Août 2007</td>

                <td align="left">BL</td>
              </tr>
            </table>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Table des matières</b></p>

      <dl>
        <dt><span class="preface"><a href=
        "#_pr%C3%A9face">Préface</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_merci">Merci&nbsp;!</a></span></dt>

            <dt><span class="section"><a href=
            "#_licence">Licence</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_introduction">1.
        Introduction</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_le_travail_comme_un_jeu">Le travail comme un
            jeu</a></span></dt>

            <dt><span class="section"><a href=
            "#_gestion_de_versions">Gestion de
            versions</a></span></dt>

            <dt><span class="section"><a href=
            "#_gestion_distribu%C3%A9e">Gestion
            distribuée</a></span></dt>

            <dt><span class="section"><a href=
            "#_une_superstition_idiote">Une superstition
            idiote</a></span></dt>

            <dt><span class="section"><a href=
            "#_conflits_fusionnels">Conflits
            fusionnels</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_astuces_de_base">2.
        Astuces de base</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_enregistrer_l_%C3%A9tat_courant">Enregistrer l'état
            courant</a></span></dt>

            <dt><span class="section"><a href=
            "#_ajouter_supprimer_renommer">Ajouter, supprimer,
            renommer</a></span></dt>

            <dt><span class="section"><a href=
            "#_annuler_reprendre_avanc%C3%A9">Annuler/Reprendre
            avancé</a></span></dt>

            <dt><span class="section"><a href=
            "#_reprise_revert">Reprise (revert)</a></span></dt>

            <dt><span class="section"><a href=
            "#_g%C3%A9n%C3%A9ration_du_journal_des_modifications_changelog">
            Génération du journal des modifications
            (changelog)</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%C3%A9l%C3%A9charger_des_fichiers">Télécharger des
            fichiers</a></span></dt>

            <dt><span class="section"><a href="#_le_dernier_cri">Le
            dernier cri</a></span></dt>

            <dt><span class="section"><a href=
            "#_publication_instantan%C3%A9e">Publication
            instantanée</a></span></dt>

            <dt><span class="section"><a href=
            "#_qu_8217_ai_je_fait">Qu’ai-je
            fait&nbsp;?</a></span></dt>

            <dt><span class="section"><a href=
            "#_exercice">Exercice</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_clonons_gaiement">3.
        Clonons gaiement</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_synchronisation_entre_machines">Synchronisation
            entre machines</a></span></dt>

            <dt><span class="section"><a href=
            "#_gestion_classique_des_sources">Gestion classique des
            sources</a></span></dt>

            <dt><span class="section"><a href=
            "#_d%C3%A9p%C3%B4ts_nus">Dépôts nus</a></span></dt>

            <dt><span class="section"><a href=
            "#_envoi_vs_rapatriement_push_vs_pull">Envoi vs
            rapatriement (push vs pull)</a></span></dt>

            <dt><span class="section"><a href=
            "#_forker_un_projet">Forker un projet</a></span></dt>

            <dt><span class="section"><a href=
            "#_syst%C3%A8me_ultime_de_sauvegarde">Système ultime de
            sauvegarde</a></span></dt>

            <dt><span class="section"><a href=
            "#_le_multi_t%C3%A2che_%C3%A0_la_vitesse_de_la_lumi%C3%A8re">
            Le multi-tâche à la vitesse de la
            lumière</a></span></dt>

            <dt><span class="section"><a href=
            "#_gu%C3%A9rilla_de_la_gestion_de_versions">Guérilla de
            la gestion de versions</a></span></dt>

            <dt><span class="section"><a href=
            "#_mercurial">Mercurial</a></span></dt>

            <dt><span class="section"><a href=
            "#_bazaar">Bazaar</a></span></dt>

            <dt><span class="section"><a href=
            "#_pourquoi_j_8217_utilise_git">Pourquoi j’utilise
            Git</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_la_sorcellerie_des_branches">4. La sorcellerie des
        branches</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_la_touche_du_chef">La touche du chef</a></span></dt>

            <dt><span class="section"><a href=
            "#_travail_temporaire">Travail
            temporaire</a></span></dt>

            <dt><span class="section"><a href=
            "#_corrections_rapides">Corrections
            rapides</a></span></dt>

            <dt><span class="section"><a href=
            "#_fusionner">Fusionner</a></span></dt>

            <dt><span class="section"><a href=
            "#_workflow_sans_interruption">Workflow sans
            interruption</a></span></dt>

            <dt><span class="section"><a href=
            "#_r%C3%A9organiser_le_foutoir">Réorganiser le
            foutoir</a></span></dt>

            <dt><span class="section"><a href=
            "#_gestion_des_branches">Gestion des
            branches</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_branches_temporaires">Les branches
            temporaires</a></span></dt>

            <dt><span class="section"><a href=
            "#_travailler_comme_il_vous_chante">Travailler comme il
            vous chante</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_les_le%C3%A7ons_de_l_8217_histoire">5. Les leçons de
        l’histoire</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_je_me_corrige_8230">Je me corrige…</a></span></dt>

            <dt><span class="section"><a href=
            "#_8230_et_bien_plus">… et bien plus</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_changements_locaux_en_dernier">Les changements
            locaux en dernier</a></span></dt>

            <dt><span class="section"><a href=
            "#_r%C3%A9%C3%A9criture_de_l_8217_histoire">Réécriture
            de l’histoire</a></span></dt>

            <dt><span class="section"><a href=
            "#_faire_l_8217_histoire">Faire
            l’histoire</a></span></dt>

            <dt><span class="section"><a href=
            "#_qu_8217_est_ce_qui_a_tout_cass%C3%A9">Qu’est-ce qui
            a tout cassé&nbsp;?</a></span></dt>

            <dt><span class="section"><a href=
            "#_qui_a_tout_cass%C3%A9">Qui a tout
            cassé&nbsp;?</a></span></dt>

            <dt><span class="section"><a href=
            "#_exp%C3%A9rience_personnelle">Expérience
            personnelle</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_git_multijoueur">6.
        Git multijoueur</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#_qui_suis_je">Qui
            suis-je&nbsp;?</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_via_ssh_et_http">Git via SSH et
            HTTP</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_via_n_8217_importe_quoi">Git via n’importe
            quoi</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_patches_la_monnaie_d_%C3%A9change_globale">Les
            patches&nbsp;: la monnaie d'échange
            globale</a></span></dt>

            <dt><span class="section"><a href=
            "#_le_num%C3%A9ro_de_votre_correspondant_a_chang%C3%A9">
            Le numéro de votre correspondant a
            changé</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_branches_distantes">Les branches
            distantes</a></span></dt>

            <dt><span class="section"><a href=
            "#_d%C3%A9p%C3%B4ts_distants_multiples">Dépôts distants
            multiples</a></span></dt>

            <dt><span class="section"><a href=
            "#_mes_pr%C3%A9f%C3%A9rences">Mes
            préférences</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_la_ma%C3%AEtrise_de_git">7. La maîtrise de
        Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_publication_de_sources">Publication de
            sources</a></span></dt>

            <dt><span class="section"><a href=
            "#_g%C3%A9rer_le_changement">Gérer le
            changement</a></span></dt>

            <dt><span class="section"><a href=
            "#_mon_commit_est_trop_gros">Mon commit est trop
            gros&nbsp;!</a></span></dt>

            <dt><span class="section"><a href=
            "#_l_8217_index_l_8217_aire_d_8217_assemblage">L’index&nbsp;:
            l’aire d’assemblage</a></span></dt>

            <dt><span class="section"><a href=
            "#_ne_perdez_pas_la_t%C3%AAte">Ne perdez pas la
            tête</a></span></dt>

            <dt><span class="section"><a href=
            "#_chasseur_de_t%C3%AAte">Chasseur de
            tête</a></span></dt>

            <dt><span class="section"><a href=
            "#_construire_au_dessus_de_git">Construire au-dessus de
            Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_audacieuses_acrobaties">Audacieuses
            acrobaties</a></span></dt>

            <dt><span class="section"><a href=
            "#_se_pr%C3%A9munir_des_commits_erron%C3%A9s">Se
            prémunir des commits erronés</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_les_secrets_r%C3%A9v%C3%A9l%C3%A9s">8. Les secrets
        révélés</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_l_8217_invisibilit%C3%A9">L’invisibilité</a></span></dt>

            <dt><span class="section"><a href=
            "#_l_8217_int%C3%A9grit%C3%A9">L’intégrité</a></span></dt>

            <dt><span class="section"><a href=
            "#_l_8217_intelligence">L’intelligence</a></span></dt>

            <dt><span class="section"><a href=
            "#_l_8217_indexation">L’indexation</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_origines_de_git">Les origines de
            Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_la_base_d_8217_objets">La base
            d’objets</a></span></dt>

            <dt><span class="section"><a href="#_les_blobs">Les
            blobs</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_arbres_literal_trees_literal">Les arbres
            (<code class="literal">trees</code>)</a></span></dt>

            <dt><span class="section"><a href="#_les_commits">Les
            commits</a></span></dt>

            <dt><span class="section"><a href=
            "#_indiscernable_de_la_magie">Indiscernable de la
            magie</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_appendix_a_les_lacunes_de_git">9. Appendix A: Les
        lacunes de Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_les_faiblesses_de_sha1">Les faiblesses de
            SHA1</a></span></dt>

            <dt><span class="section"><a href=
            "#_microsoft_windows">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href=
            "#_des_fichiers_sans_relation">Des fichiers sans
            relation</a></span></dt>

            <dt><span class="section"><a href=
            "#_qui_modifie_quoi">Qui modifie
            quoi&nbsp;?</a></span></dt>

            <dt><span class="section"><a href=
            "#_l_8217_historique_d_8217_un_fichier">L’historique
            d’un fichier</a></span></dt>

            <dt><span class="section"><a href=
            "#_le_clone_initial">Le clone initial</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_projets_versatiles">Les projets
            versatiles</a></span></dt>

            <dt><span class="section"><a href=
            "#_compteur_global">Compteur global</a></span></dt>

            <dt><span class="section"><a href=
            "#_les_dossiers_vides">Les dossiers
            vides</a></span></dt>

            <dt><span class="section"><a href=
            "#_le_premier_commit">Le premier commit</a></span></dt>

            <dt><span class="section"><a href=
            "#_bizarreries_de_l_8217_interface">Bizarreries de
            l’interface</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_appendix_b_traduire_ce_guide">10. Appendix B: Traduire
        ce guide</a></span></dt>
      </dl>
    </div>

    <div class="preface" title="Préface">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_pr%C3%A9face"></a>Préface</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_merci">Merci&nbsp;!</a></span></dt>

          <dt><span class="section"><a href=
          "#_licence">Licence</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target=
      "_top">Git</a> est un couteau suisse de la gestion de
      versions. Un outil de gestion de révisions multi-usage,
      pratique et fiable, dont la flexibilité en rend
      l’apprentissage pas si simple, sans parler de le
      maîtriser&nbsp;!</p>

      <p>Comme Arthur C. Clarke le fait observer, toute technologie
      suffisamment avancée se confond avec la magie. C’est une
      approche intéressante pour Git&nbsp;: les débutants peuvent
      ignorer ses mécanismes internes et l’utiliser comme une
      baguette magique afin d'époustoufler les amis et rendre
      furieux les ennemis par ses fabuleuses capacités.</p>

      <p>Plutôt que de rentrer dans le détails, nous donnons des
      instructions pour obtenir tel ou tel effet. À force
      d’utilisation, petit à petit, vous comprendrez comment
      fonctionne chaque truc et comment composer vos propres
      recettes pour répondre à vos besoins.</p>

      <div class="itemizedlist" title="Traductions">
        <p class="title"><b>Traductions</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href=
          "http://docs.google.com/View?id=dfwthj68_675gz3bw8kj"
          target="_top">Chinois (Simplifié)</a>&nbsp;: par JunJie,
          Meng et JiangWei.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/fr/" target=
          "_top">Française</a>&nbsp;: par Alexandre Garel, Paul
          Gaborit et Nicolas Deram. Hébergé aussi chez <a class=
          "ulink" href="http://tutoriels.itaapy.com/" target=
          "_top">itaapy</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/de/" target=
          "_top">Allemande</a>&nbsp;: par Benjamin Bellee et Armin
          Stebich. Hébergé aussi sur <a class="ulink" href=
          "http://gitmagic.lordofbikes.de/" target="_top">le site
          web d’Armin</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git" target=
          "_top">Portugaise</a>&nbsp;: par Leonardo Siqueira
          Rodrigues [<a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git-verso-odt"
          target="_top">version ODT</a>].</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/ru/" target="_top">Russe</a>: par
          Tikhon Tarnavsky, Mikhail Dymskov et d’autres.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/es/" target=
          "_top">Espagnole</a>&nbsp;: par Rodrigo Toledo et Ariset
          Llerena Tapia.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/vi/" target=
          "_top">Vietnamienne</a>: par Trần Ngọc Quân. Hébergé
          aussi sur <a class="ulink" href=
          "http://vnwildman.users.sourceforge.net/gitmagic.html"
          target="_top">son site Web</a>.</li>
        </ul>
      </div>

      <div class="itemizedlist" title="Autres éditions">
        <p class="title"><b>Autres éditions</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href="book.html"
          target="_top">sur une seule page web</a>&nbsp;: HTML nu,
          sans CSS&nbsp;;</li>

          <li class="listitem"><a class="ulink" href="book.pdf"
          target="_top">fichier PDF</a>&nbsp;: version
          imprimable.</li>

          <li class="listitem"><a class="ulink" href=
          "http://packages.debian.org/gitmagic" target=
          "_top">package Debian</a>, <a class="ulink" href=
          "http:://packages.ubuntu.com/gitmagic" target=
          "_top">package Ubuntu</a>&nbsp;: obtenez rapidement une
          copie locale de ce site. Pratique lorsque <a class=
          "ulink" href="http://csdcf.stanford.edu/status/" target=
          "_top">ce serveur</a> est arrêté.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.amazon.com/Git-Magic-Ben-Lynn/dp/1451523343/"
          target="_top">un vrai livre [Amazon.com</a>]&nbsp;: 64
          pages, 15.24cm x 22.86cm, noir et blanc, en anglais.
          Pratique en cas de panne courant.</li>
        </ul>
      </div>

      <div class="section" title="Merci&nbsp;!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_merci"></a>Merci&nbsp;!</h2>
            </div>
          </div>
        </div>

        <p>Je reste modeste devant le travail fourni par tant de
        monde pour traduire ces pages. J’apprécie beaucoup
        d'élargir mon audience grâce aux efforts des personnes déjà
        citées.</p>

        <p>Dustin Sallings, Alberto Bertogli, James Cameron,
        Douglas Livingstone, Michael Budde, Richard Albury,
        Tarmigan, Derek Mahar, Frode Aannevik, Keith Rarick, Andy
        Somerville, Ralf Recker, Øyvind A. Holm, Miklos Vajna,
        Sébastien Hinderer, Thomas Miedema, Joe Malin et Tyler
        Breisacher ont contribué aux corrections et aux
        améliorations.</p>

        <p>François Marier maintient le paquet Debian, créé à
        l’origine par Daniel Baumarr.</p>

        <p>Ma gratitude va également à beaucoup d’autres pour leurs
        encouragements et compliments. Je suis tenté de vous citer
        ici, toutefois ceci risquerait de porter vos attentes à des
        sommets ridicules.</p>

        <p>Si par erreur je vous ai oublié, merci de me le signaler
        ou, plus simplement, envoyez-moi un patch&nbsp;!</p>

        <div class="itemizedlist" title="Hébergement Git gratuit">
          <p class="title"><b>Hébergement Git gratuit</b></p>

          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://repo.or.cz/" target=
            "_top">http://repo.or.cz/</a> héberge des projets
            libres. C’est le premier hébergement Git, fondé et
            maintenu par les premiers développeurs Git.</li>

            <li class="listitem"><a class="ulink" href=
            "http://gitorious.org/" target=
            "_top">http://gitorious.org/</a> est un autre site
            d’hébergement Git fait pour les projets
            Open-Source.</li>

            <li class="listitem"><a class="ulink" href=
            "http://github.com/" target=
            "_top">http://github.com/</a> héberge des projets
            Open-Source gratuitement et des projets privés contre
            paiement.</li>
          </ul>
        </div>

        <p>Un grand merci à ces sites pour l’hébergement de ce
        guide.</p>
      </div>

      <div class="section" title="Licence">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_licence"></a>Licence</h2>
            </div>
          </div>
        </div>

        <p>Ce guide est publié sous <a class="ulink" href=
        "http://www.gnu.org/licenses/gpl-3.0.html" target="_top">la
        GNU General Public License version 3</a>. Bien évidement,
        les sources sont dans un dépôt Git et peuvent être obtenues
        en saisissant&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git  # Pour créer le dossier gitmagic
</pre>

        <p>ou à partir d’un des miroirs&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git
</pre>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;1.&nbsp;Introduction">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_introduction"></a>Chapitre&nbsp;1.&nbsp;Introduction</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_le_travail_comme_un_jeu">Le travail comme un
          jeu</a></span></dt>

          <dt><span class="section"><a href=
          "#_gestion_de_versions">Gestion de
          versions</a></span></dt>

          <dt><span class="section"><a href=
          "#_gestion_distribu%C3%A9e">Gestion
          distribuée</a></span></dt>

          <dt><span class="section"><a href=
          "#_une_superstition_idiote">Une superstition
          idiote</a></span></dt>

          <dt><span class="section"><a href=
          "#_conflits_fusionnels">Conflits
          fusionnels</a></span></dt>
        </dl>
      </div>

      <p>Je vais me servir d’une analogie pour présenter la gestion
      de versions. Référez-vous à <a class="ulink" href=
      "http://fr.wikipedia.org/wiki/Gestion_de_versions" target=
      "_top">la page de wikipedia sur la gestion de versions</a>
      pour une explication plus censée.</p>

      <div class="section" title="Le travail comme un jeu">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_travail_comme_un_jeu"></a>Le travail comme un
              jeu</h2>
            </div>
          </div>
        </div>

        <p>J’ai joué à des jeux vidéos presque toute ma vie. Par
        contre, je n’ai commencé à utiliser des systèmes de gestion
        de versions qu'à l'âge adulte. Je pense ne pas être le seul
        dans ce cas et la comparaison entre les deux peut rendre
        les concepts plus simples à expliquer et à comprendre.</p>

        <p>Pensez à l'édition de votre code, ou de votre document,
        comme s’il s’agissait de jouer à un jeu. Quand vous avez
        bien progressé, vous aimeriez faire une sauvegarde. Pour
        cela vous cliquez sur le bouton <span class=
        "emphasis"><em>enregistrer</em></span> de votre fidèle
        éditeur.</p>

        <p>Mais ceci va écraser l’ancienne version. C’est comme ces
        anciens jeux qui n’avaient qu’un emplacement&nbsp;: oui
        vous pouviez faire une sauvegarde mais vous ne pouviez pas
        revenir dans un état précédent. Quel dommage, vu que votre
        sauvegarde précédente pouvait éventuellement être située à
        un passage du jeu particulièrement amusant sur lequel vous
        seriez bien revenu un de ces jours. Ou, encore pire, votre
        seule sauvegarde était dans un état qui ne permettait pas
        de gagner et vous deviez tout recommencer à zéro.</p>
      </div>

      <div class="section" title="Gestion de versions">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gestion_de_versions"></a>Gestion de versions</h2>
            </div>
          </div>
        </div>

        <p>Lorsque vous modifiez un document, dans le but de
        conserver les anciennes versions, vous pouvez
        l'"Enregistrer Sous…" un nom de fichier différent ou le
        recopier ailleurs avant de l’enregistrer. Vous pouvez même
        compresser ces copies pour gagner de l’espace. C’est une
        forme primitive et laborieuse de gestion de versions. Les
        jeux vidéo se sont améliorés sur ce point depuis longtemps
        pusique la plupart proposent différents emplacements de
        sauvegarde automatiquement horodatés.</p>

        <p>Rendons le problème légèrement plus coriace. Imaginez
        que vous ayez un ensemble de fichiers qui vont ensemble
        comme le code source d’un projet ou les fichiers d’un site
        web. Dans ce cas si vous voulez conserver une ancienne
        version, vous devez archiver le dossier en entier.
        Conserver un grand nombre de versions à la main n’est pas
        pratique et devient rapidement fastidieux.</p>

        <p>Dans le cas de certains jeux vidéo, l’enregistrement
        d’une partie est réellement constitué d’un dossier rempli
        de fichiers. Ces jeux cachent ce détail au joueur et
        présentent une interface adaptée pour gérer différentes
        versions de ce dossier.</p>

        <p>Les systèmes de gestion de versions ne font pas autre
        chose. Ils offrent tous une belle interface pour gérer un
        dossier rempli de plein de choses. Vous pouvez enregistrer
        l'état du dossier aussi souvent que vous voulez et, plus
        tard, vous pouvez recharger l’un des états enregistrés. À
        la différence de la plupart des jeux vidéos, ils sont
        généralement habiles pour économiser l’espace nécessaire.
        Typiquement, seuls quelques fichiers changent d’une version
        à une autre, et pas de beaucoup. Stocker ces différences au
        lieu des nouvelles copies complètes économise de
        l’espace.</p>
      </div>

      <div class="section" title="Gestion distribuée">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gestion_distribu%C3%A9e"></a>Gestion
              distribuée</h2>
            </div>
          </div>
        </div>

        <p>Imaginez maintenant un jeu vidéo très difficile. Si
        difficile à terminer que plein de joueurs expérimentés de
        toute la planète décident de faire équipe et de partager
        leurs parties enregistrées pour essayer d’en venir à bout.
        <a class="ulink" href=
        "http://fr.wikipedia.org/wiki/Speedrun" target="_top">Les
        Speedruns</a> en sont un exemple concret&nbsp;: des joueurs
        qui se spécialisent dans différents niveaux du même jeu
        collaborent pour produire des résultats surprenants.</p>

        <p>Quel système mettriez-vous en place pour qu’ils puissent
        accéder facilement aux sauvegardes des uns et des
        autres&nbsp;? Et pour qu’ils puissent en téléverser de
        nouvelles&nbsp;?</p>

        <p>Dans le passé, tous les projets utilisaient une gestion
        de versions centralisée. Quelque part un serveur contenait
        l’ensemble des sauvegardes du jeu et personne d’autre.
        Chaque joueur conservait au plus quelques sauvegardes de
        parties sur leur machine. Quand un joueur voulait
        progresser, il téléchargeait les dernières sauvegardes du
        serveur, jouait un moment, puis sauvegardait et téléversait
        ses nouvelles sauvegardes vers le serveur pour les mettre à
        disposition de tous les autres.</p>

        <p>Qu’en était-il si pour une raison quelconque, des
        joueurs voulaient obtenir une partie enregistrée
        antérieurement&nbsp;? Peut-être la sauvegarde actuelle de
        la partie était-elle dans un état sans possibilité de
        victoire parce que quelqu’un avait oublié de prendre un
        objet au niveau trois, et voulaient-ils retrouver la
        dernière partie enregistrée au moment où la partie pouvait
        encore être gagnée. Ou peut-être souhaitaient-ils comparer
        deux parties enregistrées précédemment pour voir le travail
        réalisé par un joueur précis.</p>

        <p>Il peut y avoir de nombreuses raisons de vouloir
        récupérer une ancienne version, mais le résultat est le
        même&nbsp;: ils devaient demander au serveur central cette
        partie précédemment sauvegardée. Et plus ils voulaient de
        parties sauvegardées, plus ils devaient communiquer.</p>

        <p>La nouvelle génération des systèmes de gestion de
        versions, dont Git fait partie, sont dits systèmes
        distribués et peuvent être vus comme une généralisation des
        systèmes centralisés. Quand les joueurs téléchargent du
        serveur principal ils obtiennent toutes les parties
        sauvegardées, pas uniquement la dernière. C’est comme s’ils
        faisaient un <a class="ulink" href=
        "http://fr.wikipedia.org/wiki/Site_miroir" target=
        "_top">miroir</a> du serveur central.</p>

        <p>Cette opération initiale de clonage peut être coûteuse,
        surtout s’il y a un long historique, mais ça paie sur le
        long terme. Un avantage immédiat est que lorsqu’on désire
        une partie enregistrée, quelle qu’en soit la raison, aucune
        communication avec le serveur central n’est nécessaire.</p>
      </div>

      <div class="section" title="Une superstition idiote">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_une_superstition_idiote"></a>Une superstition
              idiote</h2>
            </div>
          </div>
        </div>

        <p>Un croyance populaire veut que les systèmes distribués
        ne soient pas adaptés aux projets qui ont besoin d’un dépôt
        central officiel. Rien n’est moins vrai. Photographier
        quelqu’un n’a jamais eu pour effet de voler son âme. De
        même, cloner le dépôt principal ne diminue pas son
        importance.</p>

        <p>Une première approximation assez bonne est que tout ce
        qu’un système centralisé de gestion de versions peut faire,
        un système distribué bien conçu peut le faire en mieux. Les
        ressources réseau sont simplement plus coûteuses que les
        ressources locales. Bien que nous verrons plus loin qu’il
        peut y avoir quelques inconvénients à l’approche
        distribuée, il y a moins de risques de faire des
        comparaisons erronées en utilisant cette approximation.</p>

        <p>Un petit projet peut ne nécessiter qu’une fraction des
        fonctionnalités offertes par un tel système, mais utiliser
        un système qui n’autorise pas les changements d'échelle
        pour les petits projets c’est comme utiliser les chiffres
        romains pour les calculs sur des petits nombres.</p>

        <p>De plus, votre projet peut grossir au-delà de vos
        prévisions initiales. Utiliser Git même pour les cas
        simples est comparable au fait d’avoir sur soi un couteau
        Suisse que vous utilisez surtout pour déboucher des
        bouteilles. Le jour où vous avez besoin d’un tournevis vous
        êtes content d’avoir plus qu’un simple tire-bouchon.</p>
      </div>

      <div class="section" title="Conflits fusionnels">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_conflits_fusionnels"></a>Conflits fusionnels</h2>
            </div>
          </div>
        </div>

        <p>Pour aborder ce sujet, notre analogie avec le jeu vidéo
        serait trop tirée par les cheveux. En revanche, revenons au
        cas de l'édition d’un document.</p>

        <p>Imaginons que Alice insère une ligne au début d’un
        fichier, et que Bob en ajoute une à la fin de sa propre
        copie. Ils envoient tout les deux leurs modifications. La
        plupart des systèmes vont automatiquement déduire un
        traitement raisonnable des actions&nbsp;: accepter et
        fusionner leur modifications, ainsi les modifications de
        Alice et de Bob sont appliquées.</p>

        <p>Maintenant imaginez que Alice et Bob ont fait des
        modifications différentes sur la même ligne. Il devient
        alors impossible de procéder sans intervention humaine.
        Celui qui envoie ses modifications en second est informé
        d’un <span class="emphasis"><em>conflit de
        fusion</em></span> (<span class="emphasis"><em>merge
        conflict</em></span>), et doit choisir l’une des deux
        versions de la ligne, ou revoir complètement cette
        ligne.</p>

        <p>Des situations plus complexes peuvent se présenter. Les
        systèmes de gestion de versions s’occupent eux même des cas
        les plus simples, et laissent les cas difficiles aux
        humains. Généralement leur comportement est
        configurable.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;2.&nbsp;Astuces de base">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_astuces_de_base"></a>Chapitre&nbsp;2.&nbsp;Astuces de
            base</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_enregistrer_l_%C3%A9tat_courant">Enregistrer l'état
          courant</a></span></dt>

          <dt><span class="section"><a href=
          "#_ajouter_supprimer_renommer">Ajouter, supprimer,
          renommer</a></span></dt>

          <dt><span class="section"><a href=
          "#_annuler_reprendre_avanc%C3%A9">Annuler/Reprendre
          avancé</a></span></dt>

          <dt><span class="section"><a href=
          "#_reprise_revert">Reprise (revert)</a></span></dt>

          <dt><span class="section"><a href=
          "#_g%C3%A9n%C3%A9ration_du_journal_des_modifications_changelog">
          Génération du journal des modifications
          (changelog)</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%C3%A9l%C3%A9charger_des_fichiers">Télécharger des
          fichiers</a></span></dt>

          <dt><span class="section"><a href="#_le_dernier_cri">Le
          dernier cri</a></span></dt>

          <dt><span class="section"><a href=
          "#_publication_instantan%C3%A9e">Publication
          instantanée</a></span></dt>

          <dt><span class="section"><a href=
          "#_qu_8217_ai_je_fait">Qu’ai-je
          fait&nbsp;?</a></span></dt>

          <dt><span class="section"><a href=
          "#_exercice">Exercice</a></span></dt>
        </dl>
      </div>

      <p>Plutôt que de plonger dans l’océan des commandes Git,
      utilisez ces commandes élémentaires pour commencer en vous
      trempant les pieds. Malgré leur simplicité, chacune d’elles
      est utile. En effet, lors de mon premier mois d’utilisation
      de Git, je ne me suis jamais aventuré au-delà de ce qui est
      exposé dans ce chapitre.</p>

      <div class="section" title="Enregistrer l'état courant">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_enregistrer_l_%C3%A9tat_courant"></a>Enregistrer
              l'état courant</h2>
            </div>
          </div>
        </div>

        <p>Vous êtes sur le point d’effectuer une opération
        drastique&nbsp;? Avant de le faire, réalisez une capture de
        tous les fichiers du dossier courant&nbsp;:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Ma première sauvegarde"
</pre>

        <p>Si jamais votre opération tourne mal, vous pouvez
        retrouver votre version initiale, immaculée&nbsp;:</p>
        <pre class="literallayout">
$ git reset --hard
</pre>

        <p>Pour enregistrer un nouvel état&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a -m "Une autre sauvegarde"
</pre>
      </div>

      <div class="section" title="Ajouter, supprimer, renommer">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ajouter_supprimer_renommer"></a>Ajouter, supprimer,
              renommer</h2>
            </div>
          </div>
        </div>

        <p>Les commandes ci-dessus ne font que garder traces des
        fichiers qui étaient présents lorsque vous avez executé
        <span class="strong"><strong>git add</strong></span> pour
        la première fois. Si vous ajoutez de nouveaux fichiers ou
        sous-dossiers, il faut le signaler à Git&nbsp;:</p>
        <pre class="literallayout">
$ git add readme.txt Documentation
</pre>

        <p>De même, si vous voulez que Git oublie certains
        fichiers&nbsp;:</p>
        <pre class="literallayout">
$ git rm kludge.h obsolete.c
$ git rm -r incriminating/evidence/
</pre>

        <p>Git supprime les fichiers pour vous si vous ne l’avez
        pas encore fait.</p>

        <p>Renommer un fichier revient à supprimer l’ancien nom et
        ajouter le nouveau. Il y a également le raccourci
        <span class="strong"><strong>git mv</strong></span> qui a
        la même syntaxe que la commande mv. Par exemple&nbsp;:</p>
        <pre class="literallayout">
$ git mv bug.c feature.c
</pre>
      </div>

      <div class="section" title="Annuler/Reprendre avancé">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_annuler_reprendre_avanc%C3%A9"></a>Annuler/Reprendre
              avancé</h2>
            </div>
          </div>
        </div>

        <p>Parfois vous voulez seulement revenir en arrière et
        oublier les modifications effectuées depuis un certain
        temps parce qu’elles sont toutes fausses. Dans ce
        cas&nbsp;:</p>
        <pre class="literallayout">
$ git log
</pre>

        <p>vous montre une liste des commits récents, accompagnés
        de leur empreinte SHA1&nbsp;:</p>
        <pre class="screen">
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob &lt;bob@example.com&gt;
Date: Tue Mar 14 01:59:26 2000 -0800

    Remplacement de prinf() par write()

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice &lt;alice@example.com&gt;
Date:   Thu Jan 1 00:00:00 1970 +0000

    Commit initial
</pre>

        <p>Les premiers caractères de l’empreinte sont suffisants
        pour spécifier un commit&nbsp;; ou alors, copiez et collez
        l’empreinte en entier. Saisissez&nbsp;:</p>
        <pre class="literallayout">
$ git reset --hard 766f
</pre>

        <p>pour restaurer l'état correspondant au commit donné et
        supprimer de manière permanente tous les commits plus
        récents de l’enregistrement.</p>

        <p>Parfois vous ne voulez faire qu’un bref saut dans un
        état précédent. Dans ce cas, saisissez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout 82f5
</pre>

        <p>Ceci vous ramène en arrière dans le temps, tout en
        conservant les commits récents. Toutefois, comme pour le
        voyage temporel de la science-fiction, si vous faites des
        modifications suivies d’un commit, vous entrerez dans une
        réalité parallèle puisque vos actions sont différentes de
        ce qu’elles étaient la première fois.</p>

        <p>Cette réalité parallèle est appelée une <span class=
        "emphasis"><em>branche</em></span> (<span class=
        "emphasis"><em>branch</em></span>), et <a class="link"
        href="#branch">nous en dirons plus après</a>. Pour le
        moment rappelez-vous simplement que&nbsp;:</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>vous ramènera dans le présent. De plus, pour éviter que
        Git se plaigne, réalisez toujours un commit ou un reset de
        vos modifications avant de faire un checkout.</p>

        <p>Pour reprendre l’analogie du jeu vidéo&nbsp;:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git reset
            --hard</code></strong></span> : recharge une ancienne
            sauvegarde et supprime toutes les sauvegardes plus
            récentes.</li>

            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git
            checkout</code></strong></span> : recharge une ancienne
            partie, mais si vous jouez avec, l'état de la partie va
            différer des enregistrement suivants que vous aviez
            réalisés la première fois. Chaque nouvelle sauvegarde
            sera sur une branche séparée représentant la réalité
            parallèle dans laquelle vous êtes entré. <a class=
            "link" href="#branch">On s’en occupe plus
            loin</a>.</li>
          </ul>
        </div>

        <p>Vous pouvez choisir de ne restaurer que certains
        fichiers et sous-dossiers en les nommant à la suite de la
        commande&nbsp;:</p>
        <pre class="literallayout">
$ git checkout 82f5 un.fichier un-autre.fichier
</pre>

        <p>Faites attention car cette forme de <span class=
        "strong"><strong>checkout</strong></span> peut écraser vos
        fichiers sans avertissement. Pour éviter les accidents,
        faites un commit avant toute commande checkout, surtout
        quand vous débutez avec Git. En général, quand vous n'êtes
        pas sûr des conséquences d’une opération, et pas seulement
        des commandes Git, faites d’abord un <span class=
        "strong"><strong>git commit -a</strong></span>.</p>

        <p>Vous n’aimez pas copier et coller les empreintes&nbsp;?
        Alors utilisez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout :/"Ma première s"
</pre>

        <p>pour arriver sur le commit qui commence avec ce message.
        Vous pouvez aussi demander la cinquième sauvegarde en
        arrière&nbsp;:</p>
        <pre class="literallayout">
$ git checkout master~5
</pre>
      </div>

      <div class="section" title="Reprise (revert)">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_reprise_revert"></a>Reprise (revert)</h2>
            </div>
          </div>
        </div>

        <p>Dans une cour de justice, certains évènements peuvent
        être effacés du procès verbal. De même vous pouvez
        sélectionner des commits spécifiques à défaire&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a
$ git revert 1b6d
</pre>

        <p>défera le dernier commit ayant cette empreinte. La
        reprise est enregistrée comme un nouveau commit, ce que
        vous pourrez constater en lançant un <span class=
        "strong"><strong>git log</strong></span>.</p>
      </div>

      <div class="section" title=
      "Génération du journal des modifications (changelog)">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_g%C3%A9n%C3%A9ration_du_journal_des_modifications_changelog">
              </a>Génération du journal des modifications
              (changelog)</h2>
            </div>
          </div>
        </div>

        <p>Certains projets demandent un <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Changelog" target=
        "_top">changelog</a>. Créez-le en tapant&nbsp;:</p>
        <pre class="literallayout">
$ git log &gt; ChangeLog
</pre>
      </div>

      <div class="section" title="Télécharger des fichiers">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%C3%A9l%C3%A9charger_des_fichiers"></a>Télécharger
              des fichiers</h2>
            </div>
          </div>
        </div>

        <p>Faites une copie d’un projet géré par Git en
        saisissant&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://serveur/chemin/vers/les/fichiers
</pre>

        <p>Par exemple, pour récupérer les fichiers utilisés pour
        créer ce site&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>Nous aurons beaucoup à dire sur la commande <span class=
        "strong"><strong>clone</strong></span> d’ici peu.</p>
      </div>

      <div class="section" title="Le dernier cri">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_dernier_cri"></a>Le dernier cri</h2>
            </div>
          </div>
        </div>

        <p>Si vous avez déjà téléchargé une copie d’un projet en
        utilisant <span class="strong"><strong>git
        clone</strong></span>, vous pouvez la mettre à jour vers la
        dernière version avec&nbsp;:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Publication instantanée">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_publication_instantan%C3%A9e"></a>Publication
              instantanée</h2>
            </div>
          </div>
        </div>

        <p>Imaginez que vous avez écrit un script que vous voudriez
        partager avec d’autres. Vous pourriez leur dire de le
        télécharger de votre ordinateur, mais s’ils le font au
        moment où vous êtes en train d’améliorer le script ou d’y
        effectuer des modifications expérimentales, ils peuvent se
        retrouver dans la panade. Bien sûr, c’est pour cela qu’on a
        créé la publication de versions successives. Les
        développeurs peuvent travailler sur un projet fréquemment,
        mais ils ne rendent le code disponible quand lorsqu’ils le
        trouvent présentable.</p>

        <p>Pour faire ça avec Git, dans le dossier qui contient
        votre script&nbsp;:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Première publication"
</pre>

        <p>Ensuite vous pouvez dire à vos utilisateurs de
        lancer&nbsp;:</p>
        <pre class="literallayout">
$ git clone votre.ordinateur:/chemin/vers/le/script
</pre>

        <p>pour télécharger votre script. En considérant qu’ils ont
        accès à votre ordinateur via ssh. Sinon, lancez
        <span class="strong"><strong>git daemon</strong></span> et
        dites plutôt à vos utilisateurs de lancer&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://votre.ordinateur/chemin/vers/le/script
</pre>

        <p>À partir de maintenant, chaque fois que votre script est
        prêt à être publié, exécutez&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a -m "Nouvelle version"
</pre>

        <p>et vos utilisateurs peuvent mettre à jour leur version
        en allant dans leur dossier contenant votre script et en
        saisissant&nbsp;:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Vos utilisateurs ne se retrouveront jamais avec une
        version de votre script que vous ne vouliez pas leur
        montrer.</p>
      </div>

      <div class="section" title="Qu’ai-je fait&nbsp;?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qu_8217_ai_je_fait"></a>Qu’ai-je fait&nbsp;?</h2>
            </div>
          </div>
        </div>

        <p>Retrouvez les modifications faites depuis le dernier
        commit avec&nbsp;:</p>
        <pre class="literallayout">
$ git diff
</pre>

        <p>Ou depuis hier&nbsp;:</p>
        <pre class="literallayout">
$ git diff "@{yesterday}"
</pre>

        <p>Ou entre une version spécifique et la version deux
        commits en arrière&nbsp;:</p>
        <pre class="literallayout">
$ git diff 1b6d "master~2"
</pre>

        <p>Dans chacun de ces cas, la sortie est un <span class=
        "strong"><strong>patch</strong></span> (rustine) qui peut
        être appliqué en utilisant <span class="strong"><strong>git
        apply</strong></span>. Vous pouvez aussi essayer&nbsp;:</p>
        <pre class="literallayout">
$ git whatchanged --since="2 weeks ago"
</pre>

        <p>Souvent je parcours plutôt l’historique avec <a class=
        "ulink" href="http://sourceforge.net/projects/qgit" target=
        "_top">qgit</a>, pour sa pimpante interface photogénique,
        ou <a class="ulink" href="http://jonas.nitro.dk/tig/"
        target="_top">tig</a>, une interface en mode texte qui
        fonctionne même sur les connexions lentes. Autrement,
        installez un serveur web, lancez <span class=
        "strong"><strong>git instaweb</strong></span> et dégainez
        n’importe quel navigateur internet.</p>
      </div>

      <div class="section" title="Exercice">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_exercice"></a>Exercice</h2>
            </div>
          </div>
        </div>

        <p>Soit A, B, C, D quatre commits successifs où B est
        identique à A à l’exception de quelques fichiers qui ont
        été supprimés. Nous voudrions remettre les fichiers en D.
        Comment faire&nbsp;?</p>

        <p>Il y a au moins trois solutions. En considérant que nous
        sommes à D&nbsp;:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">La différence entre A et B sont
              les fichiers supprimés. Nous pouvons créer un patch
              représentant cette différence et
              l’appliquer&nbsp;:</p>
              <pre class="literallayout">
$ git diff B A | git apply
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Vu que nous avions enregistré les
              fichiers en A, nous pouvons les reprendre&nbsp;:</p>
              <pre class="literallayout">
$ git checkout A foo.c bar.h
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Nous pouvons aussi voir le chemin
              de A à B comme une modification à défaire&nbsp;:</p>
              <pre class="literallayout">
$ git revert B
</pre>
            </li>
          </ol>
        </div>

        <p>Quel est le meilleur choix&nbsp;? Celui que vous
        préférez. C’est facile d’obtenir ce que vous voulez avec
        Git, et souvent il y a plein de manières de le faire.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;3.&nbsp;Clonons gaiement">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_clonons_gaiement"></a>Chapitre&nbsp;3.&nbsp;Clonons
            gaiement</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_synchronisation_entre_machines">Synchronisation entre
          machines</a></span></dt>

          <dt><span class="section"><a href=
          "#_gestion_classique_des_sources">Gestion classique des
          sources</a></span></dt>

          <dt><span class="section"><a href=
          "#_d%C3%A9p%C3%B4ts_nus">Dépôts nus</a></span></dt>

          <dt><span class="section"><a href=
          "#_envoi_vs_rapatriement_push_vs_pull">Envoi vs
          rapatriement (push vs pull)</a></span></dt>

          <dt><span class="section"><a href=
          "#_forker_un_projet">Forker un projet</a></span></dt>

          <dt><span class="section"><a href=
          "#_syst%C3%A8me_ultime_de_sauvegarde">Système ultime de
          sauvegarde</a></span></dt>

          <dt><span class="section"><a href=
          "#_le_multi_t%C3%A2che_%C3%A0_la_vitesse_de_la_lumi%C3%A8re">
          Le multi-tâche à la vitesse de la lumière</a></span></dt>

          <dt><span class="section"><a href=
          "#_gu%C3%A9rilla_de_la_gestion_de_versions">Guérilla de
          la gestion de versions</a></span></dt>

          <dt><span class="section"><a href=
          "#_mercurial">Mercurial</a></span></dt>

          <dt><span class="section"><a href=
          "#_bazaar">Bazaar</a></span></dt>

          <dt><span class="section"><a href=
          "#_pourquoi_j_8217_utilise_git">Pourquoi j’utilise
          Git</a></span></dt>
        </dl>
      </div>

      <p>Avec les anciens systèmes de gestion de versions,
      l’opération standard pour obtenir des fichiers est le
      checkout. Vous obtenez un ensemble de fichiers correspondant
      à un état particulier précédemment enregistré.</p>

      <p>Avec Git et d’autres systèmes distribués de gestion de
      versions, le clonage est l’opération standard. Pour obtenir
      des fichiers, on crée un <span class=
      "emphasis"><em>clone</em></span> du dépôt entier. En d’autres
      termes, il s’agit de faire un <a class="ulink" href=
      "http://fr.wikipedia.org/wiki/Site_miroir" target=
      "_top">miroir</a> du serveur central. Tout ce qui peut se
      faire sur le dépôt central peut être fait sur le vôtre.</p>

      <div class="section" title="Synchronisation entre machines">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_synchronisation_entre_machines"></a>Synchronisation
              entre machines</h2>
            </div>
          </div>
        </div>

        <p>Je peux imaginer faire des archives <span class=
        "strong"><strong>tar</strong></span> ou utiliser
        <span class="strong"><strong>rsync</strong></span> pour des
        sauvegardes ou une synchronisation simple. Mais parfois
        j'édite sur mon portable, d’autres fois sur mon fixe, et
        les deux peuvent ne pas avoir communiqué entre temps.</p>

        <p>Initialisez un dépôt Git et faites un <span class=
        "strong"><strong>commit</strong></span> de vos fichiers
        depuis une machine. Ensuite sur l’autre&nbsp;:</p>
        <pre class="literallayout">
$ git clone autre.ordinateur:/chemin/vers/les/fichiers
</pre>

        <p>pour créer une deuxième copie de ces fichiers et du
        dépôt Git.</p>

        <p>À partir de ce moment,</p>
        <pre class="literallayout">
$ git commit -a
$ git pull autre.ordinateur:/chemin/vers/les/fichiers HEAD
</pre>

        <p>ira chercher l'état des fichiers sur l’autre ordinateur
        pour mettre à jour celui sur lequel vous travaillez. Si
        récemment vous avez fait des modifications d’un même
        fichier en conflit entre elles, Git vous le signalera et
        vous devrez répéter à nouveau le commit après avoir résolu
        ces conflits.</p>
      </div>

      <div class="section" title="Gestion classique des sources">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gestion_classique_des_sources"></a>Gestion
              classique des sources</h2>
            </div>
          </div>
        </div>

        <p>Initialisez le dépôt Git de vos fichiers&nbsp;:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Commit initial"
</pre>

        <p>Sur le serveur central, initialisez un <span class=
        "emphasis"><em>dépôt nu</em></span> (<span class=
        "strong"><strong>bare</strong></span> dans la terminologie
        Git) dans un dossier quelconque&nbsp;:</p>
        <pre class="literallayout">
$ mkdir proj.git
$ cd proj.git
$ git init --bare
$  # variante en une ligne : GIT_DIR=proj.git git init
</pre>

        <p>Si besoin, démarrez le démon (service)&nbsp;:</p>
        <pre class="literallayout">
$ git daemon --detach  # peut être tourne-t-il déjà
</pre>

        <p>Pour les services d’hébergement en ligne, suivez les
        instructions fournies pour mettre en place le dépôt Git
        initialement vide. En général il s’agit de remplir un
        formulaire sur une page web.</p>

        <p><span class="emphasis"><em>Poussez</em></span> votre
        projet vers le serveur central en utilisant&nbsp;:</p>
        <pre class="literallayout">
$ git push git://serveur.central/chemin/du/proj.git HEAD
</pre>

        <p>Pour obtenir les sources, un développeur
        saisit&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://serveur.central/chemin/du/proj.git
</pre>

        <p>Après avoir fait des modifications, le développeur les
        enregistre en local&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Pour se mettre à jour par rapport à la dernière
        version&nbsp;:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Tout conflit lors de la fusion doit être résolu puis
        validé&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Pour envoyer les modifications locales vers le dépôt
        central&nbsp;:</p>
        <pre class="literallayout">
$ git push
</pre>

        <p>Si le serveur principal a de nouvelles modifications
        dues à d’autres développeurs, l’envoi échoue et le
        développeur doit se mettre à jour de la dernière version,
        résoudre les éventuels conflits de fusion, puis essayer à
        nouveau.</p>
      </div>

      <div class="section" title="Dépôts nus">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_d%C3%A9p%C3%B4ts_nus"></a>Dépôts nus</h2>
            </div>
          </div>
        </div>

        <p>Un dépôt nu (<span class="strong"><strong>bare
        repository</strong></span>) est nommé ainsi car il n’a pas
        de dossier de travail : il ne contient que des fichiers qui
        sont normalement cachés dans le sous dossier <code class=
        "literal">.git</code>. En d’autres termes, il ne conserve
        que l’historique d’un projet et ne contient jamais le rendu
        d’une version donnée.</p>

        <p>Un dépôt nu joue un rôle similaire à celui du serveur
        principal dans un système de gestion de versions
        centralisé : le réceptacle de vos projets. Les développeurs
        clonent vos projets à partir de celui-ci et y poussent les
        dernières modifications officielles. En général il est
        placé sur un serveur qui ne fait quasiment que ce travail
        de distribution de l’information. Le développement s’opère
        sur les clones de sorte que le dépôt principal peut se
        passer d’un dossier de travail.</p>

        <p>Beaucoup des commandes de Git échouent sur un dépôt nu
        tant que la variable d’environnement <code class=
        "literal">GIT_DIR</code> n’est pas renseignée avec le
        chemin vers le dépôt ou que l’option <code class=
        "literal">--bare</code> n’est pas utilisée.</p>
      </div>

      <div class="section" title=
      "Envoi vs rapatriement (push vs pull)">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_envoi_vs_rapatriement_push_vs_pull"></a>Envoi vs
              rapatriement (push vs pull)</h2>
            </div>
          </div>
        </div>

        <p>Pourquoi a-t-on introduit la commande <code class=
        "literal">push</code> (<span class=
        "emphasis"><em>pousser</em></span> ou <span class=
        "emphasis"><em>envoyer</em></span>) au lieu de se contenter
        de la commande <code class="literal">pull</code>
        (<span class="emphasis"><em>tirer</em></span> ou
        <span class="emphasis"><em>rapatrier</em></span>) plus
        familière&nbsp;? Premièrement, la commande <code class=
        "literal">pull</code> échoue sur un dépôt nu&nbsp;: il faut
        y utiliser la commande <code class="literal">fetch</code>
        dont nous parlerons plus tard. Mais même si nous
        conservions un dépôt standard sur le serveur central, y
        rapatrier les modifications serait peu pratique. Nous
        devrions d’abord nous connecter au serveur et donner en
        argument à la commande <code class="literal">pull</code>
        l’adresse de la machine depuis laquelle nous souhaitons
        rapatrier des modifications. Des pare-feux peuvent
        éventuellement nous embêter, et comment faire si nous
        n’avons pas d’accès <code class="literal">shell</code> au
        serveur&nbsp;?</p>

        <p>Quoi qu’il en soit, ce cas mis à part, nous décourageons
        l’envoi (&nbsp;en comparaison du rapatriement&nbsp;) parce
        que cela peut entraîner des confusions lorsque la
        destination possède un dossier de travail.</p>

        <p>En résumé, pendant votre phase d’apprentissage de Git,
        n’utilisez l’envoi (&nbsp;push&nbsp;) que lorsque la
        destination est un dépôt nu&nbsp;; sinon rapatriez
        (&nbsp;pull&nbsp;).</p>
      </div>

      <div class="section" title="Forker un projet">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_forker_un_projet"></a>Forker un projet</h2>
            </div>
          </div>
        </div>

        <p>Vous en avez marre de la manière dont est géré un
        projet&nbsp;? Vous pensez pouvoir faire mieux&nbsp;? Dans
        ce cas, sur votre serveur&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://serveur.principal/chemin/vers/les/fichiers
</pre>

        <p>Ensuite, informez tout le monde du fork de ce projet sur
        votre serveur.</p>

        <p>Par la suite, vous pouvez fusionner les modifications
        venant du projet originel grâce à&nbsp;:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Système ultime de sauvegarde">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_syst%C3%A8me_ultime_de_sauvegarde"></a>Système
              ultime de sauvegarde</h2>
            </div>
          </div>
        </div>

        <p>Vous voulez des archives redondantes et géographiquement
        distribuées, permettant de faire face à un désastre&nbsp;?
        Si votre projet a beaucoup de développeurs, ne faites
        rien&nbsp;! Chaque clone de votre code est de fait une
        sauvegarde. Non seulement de l'état actuel, mais de
        l’historique complet. Grâce aux empreintes
        cryptographiques, si le clone de quelqu’un est corrompu, il
        sera repéré dès qu’il tentera de communiquer avec
        d’autres.</p>

        <p>Si votre projet n’est pas si populaire, trouvez autant
        de serveurs que possible afin d’héberger vos clones.</p>

        <p>Le vrai paranoïaque devrait toujours noter la dernière
        empreinte SHA1 de 20 octets du HEAD dans un endroit sûr. Ce
        doit être sûr, pas privé. Par exemple, la publier dans un
        quotidien marcherait bien, parce qu’il est difficile de
        réaliser une attaque modifiant l’ensemble des exemplaires
        d’un journal.</p>
      </div>

      <div class="section" title=
      "Le multi-tâche à la vitesse de la lumière">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_multi_t%C3%A2che_%C3%A0_la_vitesse_de_la_lumi%C3%A8re">
              </a>Le multi-tâche à la vitesse de la lumière</h2>
            </div>
          </div>
        </div>

        <p>Imaginons que vous souhaitiez travailler sur plusieurs
        fonctionnalités en parallèle. Dans ce cas validez
        (<code class="literal">commit</code>) votre projet et
        lancez&nbsp;:</p>
        <pre class="literallayout">
$ git clone . /un/nouveau/dossier
</pre>

        <p>Grâce aux <a class="ulink" href=
        "http://fr.wikipedia.org/wiki/Lien_mat%C3%A9riel" target=
        "_top">liens matériels</a>, les clones locaux sont créés
        plus rapidement et occupent moins de place que de simples
        copies.</p>

        <p>Vous pouvez maintenant travailler simultanément sur deux
        fonctionnalités indépendantes. Par exemple vous pouvez
        modifier l’un des clones pendant que l’autre est en cours
        de compilation. À tout moment vous pouvez valider
        (<code class="literal">commit</code>) vos modifications
        puis rapatrier (<code class="literal">pull</code>) les
        modifications depuis l’autre clone.</p>
        <pre class="literallayout">
$ git pull /mon/autre/clone HEAD
</pre>
      </div>

      <div class="section" title=
      "Guérilla de la gestion de versions">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gu%C3%A9rilla_de_la_gestion_de_versions"></a>Guérilla
              de la gestion de versions</h2>
            </div>
          </div>
        </div>

        <p>Alors que vous travaillez sur un projet qui utilise un
        autre système de gestion de versions, Git vous
        manque&nbsp;? Dans ce cas, initialisez un dépôt Git dans
        votre dossier de travail.</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Commit initial"
</pre>

        <p>puis clonez-le&nbsp;:</p>
        <pre class="literallayout">
$ git clone . /un/nouveau/dossier
</pre>

        <p>Allez ensuite dans le nouveau dossier et travaillez
        plutôt là, utilisant Git comme vous le voulez. De temps à
        autre, quand vous voulez vous synchroniser avec les autres,
        rendez-vous dans le dossier de départ, synchronisez-le en
        utilisant l’autre système de gestion de version, puis
        saisissez&nbsp;:</p>
        <pre class="literallayout">
$ git add .
$ git commit -m "Synchro avec les autres"
</pre>

        <p>Ensuite allez dans le nouveau dossier et
        lancez&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a -m "Description de mes modifications"
$ git pull
</pre>

        <p>La procédure pour partager vos modifications avec les
        autres dépend de l’autre système de gestion de versions. Le
        nouveau dossier contient les fichiers avec vos
        modifications. Lancez toute commande de l’autre système de
        gestion de versions nécessaire pour les envoyer au dépôt
        central.</p>

        <p>Subversion, qui est peut être le meilleur système de
        gestion de versions centralisé est utilisé par
        d’innombrables projets. La commande <span class=
        "strong"><strong>git svn</strong></span> automatise la
        procédure ci-dessus pour les dépôts Subversion, et peut
        aussi être utilisée pour exporter un projet Git vers un
        dépôt Subversion.</p>
      </div>

      <div class="section" title="Mercurial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mercurial"></a>Mercurial</h2>
            </div>
          </div>
        </div>

        <p>Mercurial est un système de gestion de versions
        similaire qui peut travailler quasiment sans heurt avec
        Git. Avec le plugin <code class="literal">hg-git</code> un
        utilisateur de Mercurial peut, sans rien perdre, envoyer
        (push) vers ou rapatrier (pull) depuis un dossier Git.</p>

        <p>Téléchargez le plugin <code class=
        "literal">hg-git</code> avec Git&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://github.com/schacon/hg-git.git
</pre>

        <p>ou Mercurial:</p>
        <pre class="literallayout">
$ hg clone http://bitbucket.org/durin42/hg-git/
</pre>

        <p>Malheureusement, il ne semble pas y avoir de plugin
        analogue pour Git. Pour cette raison, il semble préférable
        d’utiliser Git plutôt que Mercurial pour le dépôt
        principal. Avec un dépôt Mercurial, il faut généralement un
        volontaire qui maintienne un dépôt Git en parallèle alors
        que, grâce au plugin <code class="literal">hg-git</code>,
        un dépôt Git fait l’affaire même pour les utilisateurs de
        Mercurial.</p>

        <p>Bien que ce plugin puisse convertir un dépôt Mercurial
        en un dépôt Git en le poussant dans un dépôt vide, cette
        tâche est plus simple avec le script <code class=
        "literal">hg-fast-export-git</code>, disponible
        via&nbsp;:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/fast-export.git
</pre>

        <p>Pour faire une conversion, dans un nouveau
        dossier&nbsp;:</p>
        <pre class="literallayout">
$ git init
$ hg-fast-export.sh -r /depot/hg
</pre>

        <p>ceci après avoir ajouté le script à votre <code class=
        "literal">$PATH</code>.</p>
      </div>

      <div class="section" title="Bazaar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bazaar"></a>Bazaar</h2>
            </div>
          </div>
        </div>

        <p>Nous allons rapidement évoquer Bazaar parce que c’est le
        système de gestion de versions distribué libre le plus
        populaire après Git et Mercurial.</p>

        <p>Bazaar à l’avantage d’avoir plus de recul, étant donné
        qu’il est relativement jeune&nbsp;; ses concepteurs ont pu
        tirer les leçons du passé et éviter des petits écueils
        historiques. De plus ses développeurs ont le souci de la
        portabilité et de l’interopérabilité avec les autres
        systèmes de gestion de versions.</p>

        <p>Un plugin <code class="literal">bzr-git</code> permet
        aux utilisateurs de Bazaar de travailler avec les dépôts
        Git dans une certaine mesure, et permet de le faire de
        manière incrémentale, tandis que <code class=
        "literal">bzr-fast-export</code> est fait pour les
        conversions uniques.</p>
      </div>

      <div class="section" title="Pourquoi j’utilise Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_pourquoi_j_8217_utilise_git"></a>Pourquoi j’utilise
              Git</h2>
            </div>
          </div>
        </div>

        <p>Au départ j’ai choisi Git parce que j’ai entendu qu’il
        gérait l’inimaginablement ingérable source du noyaux Linux.
        Je n’ai jamais ressenti le besoin d’en changer. Git m’a
        rendu de fiers services et je ne me suis toujours pas
        heurté à ses limites. Comme j’utilise surtout Linux, les
        éventuels problèmes sur d’autres plateformes n’entrent pas
        en ligne de compte.</p>

        <p>De plus je préfère les programmes C et les scripts bash
        aux exécutables comme les scripts Pythons&nbsp;: il y a
        moins de dépendances et je suis accro aux temps d’exécution
        rapides.</p>

        <p>J’ai réfléchi à la manière d’améliorer Git, allant
        jusqu'à écrire mes propres outils de type Git, mais
        uniquement à des fins de recherche. Même si j’avais terminé
        ce projet j’aurais tout de même continué avec Git vu que
        les avantages sont trop peu significatifs pour justifier
        l’utilisation d’un système farfelu.</p>

        <p>Bien sur, vos besoins et envies diffèrent sûrement et
        vous pouvez très bien vous trouver mieux avec un autre
        système. Néanmoins vous ne pouvez pas faire une grosse
        erreur en choisissant Git.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;4.&nbsp;La sorcellerie des branches">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_la_sorcellerie_des_branches"></a>Chapitre&nbsp;4.&nbsp;La
            sorcellerie des branches</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_la_touche_du_chef">La touche du chef</a></span></dt>

          <dt><span class="section"><a href=
          "#_travail_temporaire">Travail temporaire</a></span></dt>

          <dt><span class="section"><a href=
          "#_corrections_rapides">Corrections
          rapides</a></span></dt>

          <dt><span class="section"><a href=
          "#_fusionner">Fusionner</a></span></dt>

          <dt><span class="section"><a href=
          "#_workflow_sans_interruption">Workflow sans
          interruption</a></span></dt>

          <dt><span class="section"><a href=
          "#_r%C3%A9organiser_le_foutoir">Réorganiser le
          foutoir</a></span></dt>

          <dt><span class="section"><a href=
          "#_gestion_des_branches">Gestion des
          branches</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_branches_temporaires">Les branches
          temporaires</a></span></dt>

          <dt><span class="section"><a href=
          "#_travailler_comme_il_vous_chante">Travailler comme il
          vous chante</a></span></dt>
        </dl>
      </div>

      <p>Des branchements et des fusions quasi-instantanés sont les
      fonctionnalités les plus puissantes qui font de Git un vrai
      tueur.</p>

      <p><span class=
      "strong"><strong>Problème</strong></span>&nbsp;: des facteurs
      externes amènent nécessairement à des changements de
      contexte. Un gros bug se manifeste sans avertissement dans la
      version déployée. La date limite pour une fonctionnalité
      particulière est avancée. Un développeur qui vous aidait pour
      une partie clé du projet n’est plus disponible. Bref, en tous
      cas, vous devez brusquement arrêter la tâche en cours pour
      vous focaliser sur une tâche tout autre.</p>

      <p>Interrompre votre réflexion peut être nuisible à votre
      productivité et le changement de contexte amène encore plus
      de perte. Avec un système de gestion de versions centralisé,
      il faudrait télécharger une nouvelle copie de travail depuis
      le serveur central. Un système de gestion de versions
      décentralisé est bien meilleur puisqu’il peut cloner
      localement la version voulue.</p>

      <p>Mais un clone implique encore la copie de tout le dossier
      de travail ainsi que de l’historique complet jusqu’au point
      voulu. Même si Git réduit ce coût grâce aux fichiers partagés
      et au liens matériels, les fichiers du projet doivent tout de
      même être entièrement recréés dans le nouveau dossier de
      travail.</p>

      <p><span class=
      "strong"><strong>Solution</strong></span>&nbsp;: dans ce
      genre de situations, Git offre un outil bien meilleur puisque
      plus rapide et moins consommateur d’espace disque&nbsp;: les
      branches.</p>

      <p>Grâce à un mot magique, les fichiers de votre dossier se
      transforment d’une version à une autre. Cette transformation
      peut être bien plus qu’un simple voyage dans l’historique.
      Vos fichiers peuvent se transformer de la dernière version
      stable vers une version expérimentale, vers la version
      courante de développement, vers la version d’un collègue,
      etc.</p>

      <div class="section" title="La touche du chef">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_la_touche_du_chef"></a>La touche du chef</h2>
            </div>
          </div>
        </div>

        <p>N’avez-vous jamais joué à l’un de ces jeux qui, à
        l’appui d’une touche particulière (la «touche du chef»),
        affiche instantanément une feuille de calcul&nbsp;? Ceci
        vous permet de cacher votre écran de jeu dès que le chef
        arrive.</p>

        <p>Dans un dossier vide&nbsp;:</p>
        <pre class="literallayout">
$ echo "Je suis plus intelligent que mon chef." &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Commit initial"
</pre>

        <p>Vous venez de créer un dépôt Git qui gère un fichier
        contenant un message. Maintenant tapez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout -b chef  # rien ne semble avoir changé
$ echo "Mon chef est plus intelligent que moi." &gt; myfile.txt
$ git commit -a -m "Un autre commit"
</pre>

        <p>Tout se présente comme si vous aviez réécrit votre
        fichier et intégrer (commit) ce changement. Mais ce n’est
        qu’une illusion. Tapez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout master  # bascule vers la version originale du fichier
</pre>

        <p>et ça y est&nbsp;! Le fichier texte est restauré. Et si
        le chef repasse pour regarder votre dossier,
        tapez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout chef  # bascule vers la version visible par le chef
</pre>

        <p>Vous pouvez basculer entre ces deux versions autant de
        fois que voulu, et intégrer (commit) vos changements à
        chacune d’elles indépendamment.</p>
      </div>

      <div class="section" title="Travail temporaire">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_travail_temporaire"></a>Travail temporaire</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a> Supposons que vous
        travailliez sur une fonctionnalité et que, pour une raison
        quelconque, vous ayez besoin de revenir trois versions en
        arrière afin d’ajouter temporairement quelques instructions
        d’affichage pour voir comment quelque chose fonctionne.
        Faites&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout HEAD~3
</pre>

        <p>Maintenant vous pouvez ajouter votre code temporaire là
        où vous le souhaitez. Vous pouvez même intégrer (commit)
        vos changements. Lorsque vous avez terminé,
        tapez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>pour retourner à votre travail d’origine. Notez que tous
        les changement non intégrés sont définitivement perdus
        (NdT&nbsp;: les changements intégrés via commit sont
        conservés quelques jours et sont accessibles en connaissant
        leur empreinte SHA1).</p>

        <p>Que faire si vous voulez nommer ces changements
        temporaires&nbsp;? Rien de plus simple&nbsp;:</p>
        <pre class="literallayout">
$ git checkout -b temporaire
</pre>

        <p>et faites un commit avant de rebasculer vers la branche
        master. Lorsque vous souhaitez revenir à vos changements
        temporaires, tapez simplement&nbsp;:</p>
        <pre class="literallayout">
$ git checkout temporaire
</pre>

        <p>Nous aborderons la commande <span class=
        "emphasis"><em>checkout</em></span> plus en détail lorsque
        nous parlerons du chargement d’anciens états. Mais nous
        pouvons tout de même en dire quelques mots&nbsp;: les
        fichiers sont bien amenés dans l'état demandé mais en
        quittant la branche master. À ce moment, tout commit
        poussera nos fichiers sur une route différente, qui pourra
        être nommée plus tard.</p>

        <p>En d’autres termes, après un checkout vers un état
        ancien, Git nous place automatiquement dans une nouvelle
        branche anonyme qui pourra être nommée et enregistrée grâce
        à <span class="strong"><strong>git checkout
        -b</strong></span>.</p>
      </div>

      <div class="section" title="Corrections rapides">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_corrections_rapides"></a>Corrections rapides</h2>
            </div>
          </div>
        </div>

        <p>Vous travaillez sur une tâche particulière et on vous
        demande de tout laisser tomber pour corriger un nouveau bug
        découvert dans la version `1b6d…`&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout -b correction 1b6d
</pre>

        <p>Puis quand vous avez corrigé le bug,
        saisissez&nbsp;:</p>
        <pre class="literallayout">
$ git commit -a -m "Bug corrigé"
$ git checkout master
</pre>

        <p>pour vous ramener à votre tâche originale. Vous pouvez
        même fusionner (<span class=
        "emphasis"><em>merge</em></span>) avec la correction de bug
        toute fraîche&nbsp;:</p>
        <pre class="literallayout">
$ git merge correction
</pre>
      </div>

      <div class="section" title="Fusionner">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_fusionner"></a>Fusionner</h2>
            </div>
          </div>
        </div>

        <p>Dans certains systèmes de gestion de versions, la
        création de branches est facile mais les fusionner est
        difficile. Avec Git, la fusion est si simple que vous n’y
        prêterez plus attention.</p>

        <p>En fait, nous avons déjà rencontré la fusion. La
        commande <span class="strong"><strong>pull</strong></span>
        ramène (<span class="emphasis"><em>fetch</em></span>) une
        série de versions puis les fusionne (<span class=
        "emphasis"><em>merge</em></span>) dans votre branche
        courante. Si vous n’avez effectué aucun changement local
        alors la fusion est un simple bon en avant (un <span class=
        "emphasis"><em>fast forward</em></span>), un cas dégénéré
        qui s’apparente au rapatriement de la dernière version dans
        un système de gestion de versions centralisé. Si vous avez
        effectué des changements locaux, Git les fusionnera
        automatiquement et préviendra s’il y a des conflits.</p>

        <p>Habituellement, une version à une seule <span class=
        "emphasis"><em>version parente</em></span>, qu’on appelle
        la version précédente. Une fusion de branches entre elles
        produit une version avec plusieurs parents. Ce qui pose la
        question suivante&nbsp;: à quelle version se réfère
        `HEAD~10`&nbsp;? Puisqu’une version peut avoir plusieurs
        parents, par quel parent remonterons-nous&nbsp;?</p>

        <p>Il s’avère que cette notation choisit toujours le
        premier parent. C’est souhaitable puisque la branche
        courante devient le premier parent lors d’une fusion. Nous
        nous intéressons plus fréquemment aux changements que nous
        avons faits dans la branche courante qu'à ceux fusionnés
        depuis d’autres branches.</p>

        <p>Vous pouvez choisir un parent spécifique grâce à
        l’accent circonflexe. Voici, par exemple, comment voir le
        log depuis le deuxième parent&nbsp;:</p>
        <pre class="literallayout">
$ git log HEAD^2
</pre>

        <p>Vous pouvez omettre le numéro pour le premier parent.
        Voici, par exemple, comment voir les différences avec le
        premier parent&nbsp;;</p>
        <pre class="literallayout">
$ git diff HEAD^
</pre>

        <p>Vous pouvez combiner cette notation avec les autres. Par
        exemple&nbsp;:</p>
        <pre class="literallayout">
$ git checkout 1b6d^^2~10 -b ancien
</pre>

        <p>démarre la nouvelle branche «ancien» dans l'état
        correspondant à 10 versions en arrière du deuxième parent
        du premier parent de la version 1b6d.</p>
      </div>

      <div class="section" title="Workflow sans interruption">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_workflow_sans_interruption"></a>Workflow sans
              interruption</h2>
            </div>
          </div>
        </div>

        <p>La plupart du temps dans un projet de réalisation
        matérielle, la seconde étape du plan ne peut commencer que
        lorsque la première étape est terminée. Une voiture en
        réparation reste bloquée au garage jusqu'à la livraison
        d’une pièce. Le montage d’un prototype est suspendu en
        attendant la fabrication d’une puce.</p>

        <p>Les projets logiciels peuvent être similaires. La
        deuxième partie d’une nouvelle fonctionnalité doit attendre
        que la première partie soit sortie et testée. Certains
        projets exigent une validation de votre code avant son
        acceptation, vous êtes donc obligé d’attendre que la
        première partie soit validée avant de commencer la
        seconde.</p>

        <p>Grâce aux branches et aux fusions faciles, vous pouvez
        contourner les règles et travailler sur la partie 2 avant
        que la partie 1 soit officiellement prête. Supposons que
        vous ayez terminé la version correspondant à la partie 1 et
        que vous l’ayez envoyée pour validation. Supposons aussi
        que vous soyez dans la branche <code class=
        "literal">master</code>. Alors, branchez-vous&nbsp;:</p>
        <pre class="literallayout">
$ git checkout -b part2
</pre>

        <p>Ensuite, travaillez sur la partie 2 et intégrez (via
        <code class="literal">commit</code>) vos changements autant
        que nécessaire. L’erreur étant humaine, vous voudrez
        parfois revenir en arrière pour effectuer des corrections
        dans la partie 1. Évidemment, si vous êtes chanceux ou très
        bon, vous pouvez sauter ce passage.</p>
        <pre class="literallayout">
$ git checkout master  # Retour à la partie 1
$ correction_des_bugs
$ git commit -a        # Intégration de la correction
$ git checkout part2   # Retour à la partie 2
$ git merge master     # Fusion de la correction.
</pre>

        <p>Finalement, la partie 1 est validée.</p>
        <pre class="literallayout">
$ git checkout master    # Retour à la partie 1
$ diffusion des fichiers # Diffusion au reste du monde !
$ git merge part2        # Fusion de la partie 2
$ git branch -d part2    # Suppression de la branche 'part2'.
</pre>

        <p>À cet instant vous êtes à nouveau dans la branche
        <code class="literal">master</code> avec la partie 2 dans
        votre dossier de travail.</p>

        <p>Il est facile d'étendre cette astuce à de nombreuses
        branches. Il est aussi facile de créer une branche
        rétroactivement&nbsp;: imaginons qu’après 7 commits, vous
        vous rendiez compte que vous auriez dû créer une branche.
        Tapez alors&nbsp;:</p>
        <pre class="literallayout">
$ git branch -m master part2  # Renommer la branche "master" en "part2".
$ git branch master HEAD~7    # Recréer une branche "master" 7 commits en arrière.
</pre>

        <p>La branche <code class="literal">master</code> contient
        alors uniquement la partie 1 et la branche <code class=
        "literal">part2</code> contient le reste&nbsp;; nous avons
        créé <code class="literal">master</code> sans basculer vers
        elle car nous souhaitons continuer à travailler sur
        <code class="literal">part2</code>. Ce n’est pas très
        courant. Jusqu'à présent nous avions toujours basculé vers
        une branche dès sa création, comme dans&nbsp;:</p>
        <pre class="literallayout">
$ git checkout HEAD~7 -b master  # Créer une branche et basculer vers elle.
</pre>
      </div>

      <div class="section" title="Réorganiser le foutoir">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_r%C3%A9organiser_le_foutoir"></a>Réorganiser le
              foutoir</h2>
            </div>
          </div>
        </div>

        <p>Peut-être aimez-vous travailler sur tous les aspects
        d’un projet dans la même branche. Vous souhaitez que votre
        travail en cours ne soit accessible qu'à vous-même et donc
        que les autres ne puissent voir vos versions que
        lorsqu’elles sont proprement organisées. Commencez par
        créer deux branches&nbsp;:</p>
        <pre class="literallayout">
$ git branch propre       # Créer une branche pour les versions propres
$ git checkout -b foutoir # Créer et basculer vers une branche pour le foutoir
</pre>

        <p>Ensuite, faites tout ce que vous voulez&nbsp;: corriger
        des bugs, ajouter des fonctionnalités, ajouter du code
        temporaire et faites-en des versions autant que voulu.
        Puis&nbsp;:</p>
        <pre class="literallayout">
$ git checkout propre
$ git cherry-pick foutoir^^
</pre>

        <p>applique les modifications de la version grand-mère de
        la version courante du «foutoir» à la branche «propre».
        Avec les cherry-picks appropriés vous pouvez construire une
        branche qui ne contient que le code permanent et où toutes
        les modifications qui marchent ensemble sont
        regroupées.</p>
      </div>

      <div class="section" title="Gestion des branches">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gestion_des_branches"></a>Gestion des branches</h2>
            </div>
          </div>
        </div>

        <p>Pour lister toutes les branches, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git branch
</pre>

        <p>Par défaut, vous commencez sur la branche nommée
        «master». Certains préconisent de laisser la branche
        «master» telle quelle et de créer de nouvelles branches
        pour vos propres modifications.</p>

        <p>Les options <span class=
        "strong"><strong>-d</strong></span> et <span class=
        "strong"><strong>-m</strong></span> vous permettent de
        supprimer et renommer les branches. Voir <span class=
        "strong"><strong>git help branch</strong></span>.</p>

        <p>La branche «master» est une convention utile. Les autres
        supposent que votre dépôt possède une telle branche et
        qu’elle contient la version officielle de votre projet.
        Bien qu’il soit possible de renommer ou d’effacer cette
        branche «master», il peut-être utile de respecter les
        traditions.</p>
      </div>

      <div class="section" title="Les branches temporaires">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_branches_temporaires"></a>Les branches
              temporaires</h2>
            </div>
          </div>
        </div>

        <p>Après un certain temps d’utilisation, vous vous
        apercevrez que vous créez fréquemment des branches
        éphémères toujours pour les mêmes raisons&nbsp;: elles vous
        servent juste à sauvegarder l'état courant, vous permettant
        ainsi de revenir momentanément à état précédent pour
        corriger un bug.</p>

        <p>C’est exactement comme si vous zappiez entre deux
        chaînes de télévision. Mais au lieu de presser deux
        boutons, il vous faut créer, basculer, fusionner et
        supprimer des branches temporaires. Par chance, Git propose
        un raccourci qui est aussi pratique que la télécommande de
        votre télévision&nbsp;:</p>
        <pre class="literallayout">
$ git stash
</pre>

        <p>Cela mémorise l'état courant dans un emplacement
        temporaire (un <span class=
        "emphasis"><em>stash</em></span>) et restaure l'état
        précédent. Votre dossier courant apparaît alors exactement
        comme il était avant que vous ne commenciez à faire des
        modifications et vous pouvez corriger des bugs, aller
        rechercher (pull) une modification de dépôt central ou
        toute autre chose. Lorsque vous souhaitez revenir à l'état
        mémorisé dans votre <span class=
        "emphasis"><em>stash</em></span>, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git stash apply  # Peut-être faudra-t-il résoudre quelques conflits.
</pre>

        <p>Vous pouvez avoir plusieurs <span class=
        "emphasis"><em>stash</em></span> et les manipuler de
        différents manières. Voir <span class="strong"><strong>git
        help stash</strong></span>. Comme vous l’aurez deviné, pour
        faire ces tours de magie, dans les coulisses Git gère des
        branches.</p>
      </div>

      <div class="section" title="Travailler comme il vous chante">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_travailler_comme_il_vous_chante"></a>Travailler
              comme il vous chante</h2>
            </div>
          </div>
        </div>

        <p>Vous vous demandez sans doute si l’usage des branches en
        vaut la peine. Après tout, des clones sont tout aussi
        rapides et vous pouvez basculer de l’un à l’autre par un
        simple <span class="strong"><strong>cd</strong></span> au
        lieu de commandes Git ésotériques.</p>

        <p>Considérez les navigateurs Web. Pourquoi proposer
        plusieurs onglets ainsi que plusieurs fenêtres&nbsp;? Parce
        proposer les deux permet de s’adapter à une large gamme
        d’utilisations. Certains préfèrent n’avoir qu’une seule
        fenêtre avec plein d’onglets. D’autres font tout le
        contraire&nbsp;: plein de fenêtres avec un seul onglet.
        D’autres encore mélangent un peu des deux.</p>

        <p>Les branches ressemblent à des onglets de votre dossier
        de travail et les clones ressemblent aux différents
        fenêtres de votre navigateur. Ces opérations sont toutes
        rapides et locales. Alors expérimentez pour trouver la
        combinaison qui vous convient. Git vous laisse travailler
        exactement comme vous le souhaitez.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;5.&nbsp;Les leçons de l’histoire">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_les_le%C3%A7ons_de_l_8217_histoire"></a>Chapitre&nbsp;5.&nbsp;Les
            leçons de l’histoire</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_je_me_corrige_8230">Je me corrige…</a></span></dt>

          <dt><span class="section"><a href="#_8230_et_bien_plus">…
          et bien plus</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_changements_locaux_en_dernier">Les changements
          locaux en dernier</a></span></dt>

          <dt><span class="section"><a href=
          "#_r%C3%A9%C3%A9criture_de_l_8217_histoire">Réécriture de
          l’histoire</a></span></dt>

          <dt><span class="section"><a href=
          "#_faire_l_8217_histoire">Faire
          l’histoire</a></span></dt>

          <dt><span class="section"><a href=
          "#_qu_8217_est_ce_qui_a_tout_cass%C3%A9">Qu’est-ce qui a
          tout cassé&nbsp;?</a></span></dt>

          <dt><span class="section"><a href=
          "#_qui_a_tout_cass%C3%A9">Qui a tout
          cassé&nbsp;?</a></span></dt>

          <dt><span class="section"><a href=
          "#_exp%C3%A9rience_personnelle">Expérience
          personnelle</a></span></dt>
        </dl>
      </div>

      <p>L’une des conséquences de la nature distribuée de Git est
      qu’il est facile de modifier l’historique. Mais si vous
      réécrivez le passé, faites attention&nbsp;: ne modifiez que
      la partie de l’historique que vous êtes le seul à posséder.
      Sinon, comme des nations qui se battent éternellement pour
      savoir qui a commis telle ou telle atrocité, si quelqu’un
      d’autre possède un clone dont l’historique diffère du vôtre,
      vous aurez des difficultés à vous réconcilier lorsque vous
      interagirez.</p>

      <p>Certains développeurs insistent très fortement pour que
      l’historique soit considérer comme immuable. D’autres pensent
      au contraire que les historiques doivent être rendus
      présentables avant d'être présentés publiquement. Git
      s’accommode des deux points de vue. Comme les clones, les
      branches et les fusions, la réécriture de l’historique est
      juste un pouvoir supplémentaire que vous donne Git. C’est à
      vous de l’utiliser à bon escient.</p>

      <div class="section" title="Je me corrige…">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_je_me_corrige_8230"></a>Je me corrige…</h2>
            </div>
          </div>
        </div>

        <p>Que faire si vous avez fait un commit mais que vous
        souhaitez y attacher un message différent&nbsp;? Pour
        modifier le dernier message, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>Vous apercevez-vous que vous avez oublié un
        fichier&nbsp;? Faites <span class="strong"><strong>git
        add</strong></span> pour l’ajouter puis exécutez le
        commande ci-dessus.</p>

        <p>Voulez-vous ajouter quelques modifications
        supplémentaires au dernier commit&nbsp;? Faites ces
        modifications puis exécutez&nbsp;:</p>
        <pre class="literallayout">
$ git commit --amend -a
</pre>
      </div>

      <div class="section" title="… et bien plus">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_8230_et_bien_plus"></a>… et bien plus</h2>
            </div>
          </div>
        </div>

        <p>Supposons que le problème précédent est dix fois pire.
        Après une longue séance, vous avez effectué une série de
        commits. Mais vous n'êtes pas satisfait de la manière dont
        ils sont organisés et certains des messages associés
        doivent être revus. Tapez alors&nbsp;:</p>
        <pre class="literallayout">
$ git rebase -i HEAD~10
</pre>

        <p>et les dix derniers commits apparaissent dans votre
        $EDITOR favori. Voici un petit extrait&nbsp;:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Ensuite&nbsp;:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">Supprimez un commit en supprimant
            sa ligne.</li>

            <li class="listitem">Réordonnez des commits en
            réordonnant leurs lignes.</li>

            <li class="listitem">
              <p class="simpara">Remplacez <code class=
              "literal">pick</code> par&nbsp;:</p>

              <div class="itemizedlist">
                <ul class="itemizedlist" type="circle">
                  <li class="listitem"><code class=
                  "literal">edit</code> pour marquer ce commit pour
                  amendement.</li>

                  <li class="listitem"><code class=
                  "literal">reword</code> pour modifier le message
                  associé.</li>

                  <li class="listitem"><code class=
                  "literal">squash</code> pour fusionner ce commit
                  avec le précédent.</li>

                  <li class="listitem"><code class=
                  "literal">fixup</code> pour fusionner ce commit
                  avec le précédent en supprimant le message
                  associé.</li>
                </ul>
              </div>
            </li>
          </ul>
        </div>

        <p>Sauvegardez et quittez. Si vous avez marqué un commit
        pour amendement alors tapez&nbsp;:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>Sinon, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git rebase --continue
</pre>

        <p>Donc faites des commits très tôt et faites-en
        souvent&nbsp;: vous pourrez tout ranger plus tard grâce à
        <span class="emphasis"><em>rebase</em></span>.</p>
      </div>

      <div class="section" title=
      "Les changements locaux en dernier">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_changements_locaux_en_dernier"></a>Les
              changements locaux en dernier</h2>
            </div>
          </div>
        </div>

        <p>Vous travaillez sur un projet actif. Vous faites
        quelques commits locaux puis vous vous resynchronisez avec
        le dépôt officiel grâce à une fusion (merge). Ce cycle se
        répète jusqu’au moment où vous êtes prêt à pousser vos
        contributions vers le dépôt central.</p>

        <p>Mais à cet instant l’historique de votre clone Git local
        est un fouillis infâme mélangeant les modifications
        officielles et les vôtres. Vous préféreriez que toutes vos
        modifications soient contiguës et se situent après toutes
        les modifications officielles.</p>

        <p>C’est un boulot pour <span class="strong"><strong>git
        rebase</strong></span> comme décrit ci-dessus. Dans la
        plupart des cas, vous pouvez utilisez l’option <span class=
        "strong"><strong>--onto</strong></span> et éviter les
        interactions.</p>

        <p>Lisez <span class="strong"><strong>git help
        rebase</strong></span> pour des exemples détaillés sur
        cette merveilleuse commande. Vous pouvez scinder des
        commits. Vous pouvez même réarranger des branches de
        l’arbre.</p>
      </div>

      <div class="section" title="Réécriture de l’histoire">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_r%C3%A9%C3%A9criture_de_l_8217_histoire"></a>Réécriture
              de l’histoire</h2>
            </div>
          </div>
        </div>

        <p>De temps en temps, vous avez besoin de faire des
        modifications équivalentes à la suppression d’une personne
        d’une photo officielle, la gommant ainsi de l’histoire
        d’une manière quasi Stalinienne. Supposons que vous ayez
        publié un projet mais en y intégrant un fichier que vous
        auriez dû conserver secret. Par exemple, vous avez
        accidentellement ajouté un fichier texte contenant votre
        numéro de carte de crédit. Supprimer ce fichier n’est pas
        suffisant puisqu’il pourra encore être retrouvé via
        d’anciennes versions du projet. Vous devez supprimer ce
        fichier dans toutes les versions&nbsp;:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'rm top/secret/fichier' HEAD
</pre>

        <p>La documentation <span class="strong"><strong>git help
        filter-branch</strong></span> explique cette exemple et
        donne une méthode plus rapide. De manière générale,
        <span class="strong"><strong>filter-branch</strong></span>
        vous permet de modifier des pans entiers de votre
        historique grâce à une seule commande.</p>

        <p>Après cela, le dossier <code class=
        "literal">.git/refs/original</code> contiendra l'état de
        votre dépôt avant l’opération. Vérifiez que la commande
        filter-branch a bien fait ce que vous souhaitiez puis
        effacer ce dossier si vous voulez appliquer d’autres
        commandes filter-branch.</p>

        <p>Finalement, remplacez tous les clones de votre projet
        par votre version révisée si vous voulez pouvoir interagir
        avec eux plus tard.</p>
      </div>

      <div class="section" title="Faire l’histoire">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_faire_l_8217_histoire"></a>Faire l’histoire</h2>
            </div>
          </div>
        </div>

        <p><a name="makinghistory" id="makinghistory"></a>
        Voulez-vous faire migrer un projet vers Git&nbsp;? S’il est
        géré par l’un des systèmes bien connus alors il y a de
        grandes chances que quelqu’un ait déjà écrit un script afin
        d’importer l’ensemble de l’historique dans Git.</p>

        <p>Sinon, regarder du côté de <span class=
        "strong"><strong>git fast-import</strong></span> qui lit un
        fichier texte dans un format spécifique pour créer un
        historique Git à partir de rien. Typiquement un script
        utilisant cette commande est un script jetable qui ne
        servira qu’une seule fois pour migrer le projet d’un seul
        coup.</p>

        <p>À titre d’exemple, collez le texte suivant dans un
        fichier temporaire (<code class=
        "literal">/tmp/historique</code>)&nbsp;:</p>
        <pre class="screen">
commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Commit initial
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Remplacement de printf() par write().
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Puis créez un dépôt Git à partir de ce fichier
        temporaire en tapant&nbsp;:</p>
        <pre class="literallayout">
$ mkdir projet; cd projet; git init
$ git fast-import --date-format=rfc2822 &lt; /tmp/historique
</pre>

        <p>Vous pouvez extraire la dernière version de ce projet
        avec&nbsp;:</p>
        <pre class="literallayout">
$ git checkout master .
</pre>

        <p>La commande <span class="strong"><strong>git
        fast-export</strong></span> peut convertir n’importe quel
        dépôt Git en un fichier au format <span class=
        "strong"><strong>git fast-import</strong></span> ce qui
        vous permet de l'étudier pour écrire des scripts
        d’exportation mais vous permet aussi de transporter un
        dépôt dans un format lisible. Ces commandes permettent
        aussi d’envoyer un dépôt via un canal qui n’accepte que du
        texte pur.</p>
      </div>

      <div class="section" title=
      "Qu’est-ce qui a tout cassé&nbsp;?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qu_8217_est_ce_qui_a_tout_cass%C3%A9"></a>Qu’est-ce
              qui a tout cassé&nbsp;?</h2>
            </div>
          </div>
        </div>

        <p>Vous venez tout juste de découvrir un bug dans une
        fonctionnalité de votre programme et pourtant vous êtes sûr
        qu’elle fonctionnait encore parfaitement il y a quelques
        mois. Zut&nbsp;! D’où provient ce bug&nbsp;? Si seulement
        vous aviez testé cette fonctionnalité pendant vos
        développements.</p>

        <p>Mais il est trop tard. En revanche, en supposant que
        vous avez fait des commits suffisamment souvent, Git peut
        cerner le problème.</p>
        <pre class="literallayout">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d
</pre>

        <p>Git extrait un état à mi-chemin entre ces deux versions
        (HEAD et 1b6d). Testez la fonctionnalité et si le bug se
        manifeste&nbsp;:</p>
        <pre class="literallayout">
$ git bisect bad
</pre>

        <p>Si elle ne se manifeste pas, remplacer "bad" (mauvais)
        par "good" (bon). Git vous transporte à nouveau dans un
        état à mi-chemin entre la bonne et la mauvaise version, en
        réduisant ainsi les possibilités. Après quelques
        itérations, cette recherche dichotomique vous amènera au
        commit où le bug est survenu. Une fois vos investigations
        terminées, retourner à votre état original en
        tapant&nbsp;:</p>
        <pre class="literallayout">
$ git bisect reset
</pre>

        <p>Au lieu de tester chaque état à la main, automatisez la
        recherche en tapant&nbsp;:</p>
        <pre class="literallayout">
$ git bisect run mon_script
</pre>

        <p>Git utilise la valeur de retour du script fourni pour
        décider si un état est bon ou mauvais&nbsp;: mon_script
        doit retourner 0 si l'état courant est ok, 125 si cet état
        doit être sauté et n’importe quelle valeur entre 1 et 127
        si l'état est mauvais. Une valeur négative abandonne la
        commande bisect.</p>

        <p>Vous pouvez faire bien plus&nbsp;: la page d’aide
        explique comment visualiser les bisects, comment examiner
        ou rejouer le log d’un bisect et comment éliminer des
        changements que vous savez sans conséquence afin
        d’accélérer la recherche.</p>
      </div>

      <div class="section" title="Qui a tout cassé&nbsp;?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_a_tout_cass%C3%A9"></a>Qui a tout
              cassé&nbsp;?</h2>
            </div>
          </div>
        </div>

        <p>Comme de nombreux systèmes de gestion de versions, Git a
        sa commande blame&nbsp;:</p>
        <pre class="literallayout">
$ git blame bug.c
</pre>

        <p>Cette commande annote chaque ligne du fichier afin de
        montrer par qui et quand elle a été modifiée la dernière
        fois. À l’inverse de la plupart des autres systèmes, cette
        commande marche hors-ligne et ne lit que le disque
        local.</p>
      </div>

      <div class="section" title="Expérience personnelle">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_exp%C3%A9rience_personnelle"></a>Expérience
              personnelle</h2>
            </div>
          </div>
        </div>

        <p>Avec un système de gestion de versions centralisé, la
        modification de l’historique est une opération difficile et
        faisable uniquement par les administrateurs. Créer un
        clone, créer une branche ou en fusionner plusieurs sont des
        opérations impossibles à réaliser sans communication
        réseau. Il en est de même pour certains opérations basiques
        telles que parcourir l’historique ou intégrer une
        modification. Avec certains systèmes, des communications
        réseaux sont même nécessaires juste pour voir ses propres
        modifications ou pour ouvrir un fichier avec le droit de
        modification.</p>

        <p>Ces systèmes centralisés empêchent le travail hors-ligne
        et nécessitent une infrastructure réseau d’autant plus
        lourde que le nombre de développeurs augmentent. Plus
        important encore, certaines opérations deviennent si lentes
        que les utilisateurs les évitent à moins qu’elles soient
        absolument indispensables. Dans les cas extrêmes cela
        devient vrai même pour les commandes les plus basiques.
        Lorsque les utilisateurs doivent effectuer des opérations
        lentes, la productivité souffre des interruptions
        répétées.</p>

        <p>J’ai moi-même vécu ce phénomène. Git a été le premier
        système de gestion de versions que j’ai utilisé. Je me suis
        vite accoutumé à lui, tenant la plupart de ses
        fonctionnalités pour acquises. Je pensais que les autres
        systèmes étaient similaires&nbsp;: le choix d’un système de
        gestion de versions ne devait pas être bien différent du
        choix d’un éditeur de texte ou d’un navigateur web.</p>

        <p>J’ai été très surpris lorsque, plus tard, il m’a fallu
        utilisé un système centralisé. Une liaison internet
        épisodique importe peu avec Git mais rend le développement
        quasi impossible lorsque le système exige qu’elle soit
        aussi fiable que les accès au disque local. De plus, je me
        restreignais afin d'éviter certaines commandes trop
        longues, ce qui m’empêchait de suivre ma méthode de travail
        habituelle.</p>

        <p>Lorsqu’il me fallait utiliser ces commandes lentes, cela
        interrompait mes réflexions et avait des effets pervers. En
        attendant la fin des communications avec le serveur, je me
        lançais dans autre chose pour passer le temps comme lire
        mes mails ou écrire de la documentation. Lorsque je
        revenais à mon travail initial, la commande s'était
        terminée depuis longtemps et je perdais du temps à
        retrouver le fil de mes pensées. Les être humains ne sont
        pas bons pour changer de contexte.</p>

        <p>Il y a aussi un effet intéressant du type
        «&nbsp;tragédie des biens communs&nbsp;»&nbsp;: afin
        d’anticiper la congestion du réseau, certains vont
        consommer plus de bandes passantes que nécessaire pour
        effectuer des opérations visant à réduire leurs attentes
        futures. Ces efforts combinés vont encore augmenter la
        congestion, incitant ces personnes à consommer encore plus
        de bande passante pour éviter ces délais toujours plus
        longs.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;6.&nbsp;Git multijoueur">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_git_multijoueur"></a>Chapitre&nbsp;6.&nbsp;Git
            multijoueur</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href="#_qui_suis_je">Qui
          suis-je&nbsp;?</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_via_ssh_et_http">Git via SSH et
          HTTP</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_via_n_8217_importe_quoi">Git via n’importe
          quoi</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_patches_la_monnaie_d_%C3%A9change_globale">Les
          patches&nbsp;: la monnaie d'échange
          globale</a></span></dt>

          <dt><span class="section"><a href=
          "#_le_num%C3%A9ro_de_votre_correspondant_a_chang%C3%A9">Le
          numéro de votre correspondant a changé</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_branches_distantes">Les branches
          distantes</a></span></dt>

          <dt><span class="section"><a href=
          "#_d%C3%A9p%C3%B4ts_distants_multiples">Dépôts distants
          multiples</a></span></dt>

          <dt><span class="section"><a href=
          "#_mes_pr%C3%A9f%C3%A9rences">Mes
          préférences</a></span></dt>
        </dl>
      </div>

      <p>Au départ, j’utilisais Git pour un projet privé où j'étais
      le seul développeur. Parmi toutes les commandes liées à la
      nature distribuée de Git, je n’avais besoin que de
      <span class="strong"><strong>pull</strong></span> et
      <span class="strong"><strong>clone</strong></span> afin de
      disposer de mon projet en différents lieux.</p>

      <p>Plus tard, j’ai voulu publier mon code via Git et inclure
      des modifications de plusieurs contributeurs. J’ai dû
      apprendre à gérer des projets avec de nombreux développeurs à
      travers le monde. Heureusement c’est l’un des points forts de
      Git et peut-être même sa <span class="emphasis"><em>raison
      d'être</em></span> (en français dans le texte).</p>

      <div class="section" title="Qui suis-je&nbsp;?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_suis_je"></a>Qui suis-je&nbsp;?</h2>
            </div>
          </div>
        </div>

        <p>À chaque commit sont associés le nom et le mail de
        l’auteur, ceux qui sont montrés par <span class=
        "strong"><strong>git log</strong></span>. Par défaut, Git
        utilise les valeurs fournies par le système pour remplir
        ces champs. Pour les configurer explicitement,
        tapez&nbsp;:</p>
        <pre class="literallayout">
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</pre>

        <p>Supprimer l’option <code class="literal">--global</code>
        pour que ces valeurs soient locales au dépôt courant.</p>
      </div>

      <div class="section" title="Git via SSH et HTTP">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_via_ssh_et_http"></a>Git via SSH et HTTP</h2>
            </div>
          </div>
        </div>

        <p>Supposez que vous ayez un accès SSH à un serveur Web sur
        lequel Git n’est pas installé. Bien que ce soit moins
        efficace que le protocole natif, Git sait communiquer par
        dessus HTTP.</p>

        <p>Télécharger, compiler et installer Git sur votre compte
        et créer un dépôt dans votre dossier web&nbsp;:</p>
        <pre class="literallayout">
$ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample hooks/post-update
</pre>

        <p>Avec les vieilles versions de Git, la commande de copie
        échoue et vous devez faire&nbsp;:</p>
        <pre class="literallayout">
$ chmod a+x hooks/post-update
</pre>

        <p>Maintenant vous pouvez transmettre vos modifications via
        SSH depuis n’importe lequel de vos clones&nbsp;:</p>
        <pre class="literallayout">
$ git push web.server:/path/to/proj.git master
</pre>

        <p>et n’importe qui peut récupérer votre projet grâce
        à&nbsp;:</p>
        <pre class="literallayout">
$ git clone http://web.server/proj.git
</pre>
      </div>

      <div class="section" title="Git via n’importe quoi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_via_n_8217_importe_quoi"></a>Git via n’importe
              quoi</h2>
            </div>
          </div>
        </div>

        <p>Besoin de synchroniser des dépôts sans passer par un
        serveur ni même une connexion réseau&nbsp;? Besoin
        d’improviser dans l’urgence&nbsp;? Nous avons déjà vu que
        <a class="link" href="#makinghistory"><span class=
        "strong"><strong>git fast-export</strong></span> et
        <span class="strong"><strong>git
        fast-import</strong></span> savent convertir et recréer un
        dépôt via un simple fichier</a>. Nous pourrions utiliser
        des fichiers de ce type pour assurer le transport entre des
        dépôts Git via n’importe quel canal. Mais un outil plus
        puissant existe&nbsp;: <span class="strong"><strong>git
        bundle</strong></span>.</p>

        <p>L'émetteur crée un 'bundle'&nbsp;:</p>
        <pre class="literallayout">
$ git bundle create monbundle HEAD
</pre>

        <p>puis il transmet ce bundle, <code class=
        "literal">monbundle</code>, à l’autre partie par n’importe
        quel moyen&nbsp;: email, clé USB, impression puis
        reconnaissance de caractères, lecture des bits au
        téléphone, signaux de fumée, etc. Le récepteur retrouve les
        mises à jour du bundle en tapant&nbsp;:</p>
        <pre class="literallayout">
$ git pull monbundle
</pre>

        <p>Le récepteur peut même faire cela dans un dépôt
        entièrement vide. Malgré sa petite taille <code class=
        "literal">monbundle</code> contient l’ensemble du dépôt Git
        d’origine.</p>

        <p>Pour des projets plus gros, on peut réduire le
        gaspillage en incluant dans le bundle uniquement les
        changements manquants dans l’autre dépôt. En supposant par
        exemple que le commit «1b6d…» est le commit le plus récent
        partagé par les deux dépôts, on peut faire&nbsp;:</p>
        <pre class="literallayout">
$ git bundle create monbundle HEAD ^1b6d
</pre>

        <p>Si on fait cela souvent, il se peut qu’on ne sache plus
        quel est le dernier commit partagé. La page d’aide suggère
        d’utiliser des tags pour résoudre ce problème. En pratique,
        juste après l’envoi d’un bundle, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git tag -f dernierbundle HEAD
</pre>

        <p>et pour créer un nouveau bundle faites&nbsp;:</p>
        <pre class="literallayout">
$ git bundle create nouveaubundle HEAD ^dernierbundle
</pre>
      </div>

      <div class="section" title=
      "Les patches&nbsp;: la monnaie d'échange globale">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_patches_la_monnaie_d_%C3%A9change_globale"></a>Les
              patches&nbsp;: la monnaie d'échange globale</h2>
            </div>
          </div>
        </div>

        <p>Les patches sont des représentations textuelles de vos
        modifications qui peuvent être facilement compris par les
        ordinateurs comme par les humains. C’est ce qui leur donne
        leur charme. Vous pouvez envoyer un patch par mail à un
        développeur sans savoir quel système de gestion de versions
        il utilise. À partir du moment où on peut lire les mails
        que vous envoyez, on peut voir vos modifications. De votre
        côté, vous n’avez besoin que d’un compte mail&nbsp;: aucune
        nécessité de mettre en œuvre un dépôt Git en ligne.</p>

        <p>Souvenez-vous du premier chapitre. La
        commande&nbsp;:</p>
        <pre class="literallayout">
$ git diff 1b6d &gt; mon.patch
</pre>

        <p>produit un patch qui peut être collé dans un mail. Dans
        un dépôt Git, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git apply &lt; mon.patch
</pre>

        <p>pour appliquer le patch.</p>

        <p>D’une manière plus formelle, lorsque le nom des auteurs
        et peut-être leur signature doit apparaître, générer tous
        les patches depuis un certain point en tapant&nbsp;:</p>
        <pre class="literallayout">
$ git format-patch 1b6d
</pre>

        <p>Les fichiers résultants peuvent être fournis à
        <span class="strong"><strong>git send-email</strong></span>
        ou envoyez à la main. Vous pouvez aussi spécifier un
        intervalle entre deux commits&nbsp;:</p>
        <pre class="literallayout">
$ git format-patch 1b6d..HEAD^^
</pre>

        <p>Du côté du destinataire, enregistrez un mail dans un
        fichier puis tapez&nbsp;:</p>
        <pre class="literallayout">
$ git am &lt; mail.txt
</pre>

        <p>Ça appliquera le patch reçu mais créera aussi un commit
        en y incluant toutes les informations telles que le nom des
        auteurs.</p>

        <p>Si vous utilisez un client de messagerie dans un
        navigateur, il vous faudra sans doute appuyer sur un bouton
        afin de voir le mail dans son format brut avant de
        l’enregistrer dans un fichier.</p>

        <p>Il y a de légères différences dans le cas des clients de
        messagerie se basant sur le format mbox, mais si vous
        utilisez l’un d’entre eux, vous êtes sans aucun doute
        capable de vous en débrouiller facilement sans lire des
        tutoriels !</p>

        <p>(NdT&nbsp;: si votre dépôt contient des fichiers
        binaires, n’oubliez-pas d’ajouter l’option <code class=
        "literal">--binary</code> aux commandes de création de
        patches ci-dessus.)</p>
      </div>

      <div class="section" title=
      "Le numéro de votre correspondant a changé">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_num%C3%A9ro_de_votre_correspondant_a_chang%C3%A9">
              </a>Le numéro de votre correspondant a changé</h2>
            </div>
          </div>
        </div>

        <p>Après la création d’un clone d’un dépôt, l’utilisation
        de <span class="strong"><strong>git push</strong></span> ou
        de <span class="strong"><strong>git pull</strong></span> se
        référera automatiquement à l’URL du dépôt d’origine.
        Comment Git fait-il&nbsp;? Le secret réside dans des
        options de configuration ajoutées dans le clone. Jetons-y
        un œil&nbsp;:</p>
        <pre class="literallayout">
$ git config --list
</pre>

        <p>L’option <code class="literal">remote.origin.url</code>
        détermine l’URL de la source&nbsp;; «origin» est un alias
        donné au dépôt d’origine. Comme dans le cas de la branche
        principale qui se nomme «master» par convention, on peut
        changer ou supprimer cet alias mais il n’y a habituellement
        aucune raison de le faire.</p>

        <p>Si le dépôt original change, vous pouvez modifier son
        URL via&nbsp;:</p>
        <pre class="literallayout">
$ git config remote.origin.url git://nouvel.url/proj.git
</pre>

        <p>L’option <code class=
        "literal">branch.master.merge</code> spécifie le nom de la
        branche distante utilisée par défaut par la commande
        <span class="strong"><strong>git pull</strong></span>. Lors
        du clonage initial, le nom choisi est celui de la branche
        courant du dépôt d’origine. Même si le HEAD du dépôt
        d’origine est déplacé vers une autre branche, la commande
        pull continuera à suivre fidêlement la branche
        initiale.</p>

        <p>Cette option ne s’applique qu’au dépôt ayant servi au
        clonage initial, celui enregistré dans l’option
        <code class="literal">branch.master.remote</code>. Si nous
        effectuons un pull depuis un autre dépôt, nous devrons
        indiquer explicitement la branche voulue&nbsp;:</p>
        <pre class="literallayout">
$ git pull git://example.com/other.git master
</pre>

        <p>Les détails ci-dessus expliquent pourquoi nos appels à
        push et pull dans nos précédents exemples n’avaient pas
        besoin d’arguments.</p>
      </div>

      <div class="section" title="Les branches distantes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_branches_distantes"></a>Les branches
              distantes</h2>
            </div>
          </div>
        </div>

        <p>Lorsque nous clonons un dépôt, nous clonons aussi toutes
        ses branches. Vous ne les avez sans doute pas remarquées
        car Git les cache&nbsp;: vous devez explicitement demander
        à les voir. Cela empêche les branches du dépôt distant
        d’interférer avec vos propres branches et cela rend aussi
        Git plus simple pour les débutants.</p>

        <p>Listons les branches distantes&nbsp;:</p>
        <pre class="literallayout">
$ git branch -r
</pre>

        <p>Vous devriez voir quelque chose comme&nbsp;:</p>
        <pre class="literallayout">
origin/HEAD
origin/master
origin/experimental
</pre>

        <p>Ces noms sont ceux des branches et du HEAD du dépôt
        distant et ils peuvent être utilisés dans les commandes Git
        normales. Supposez par exemple que vous avez réalisé de
        nombreux commits et que vous vouliez voir la différence
        avec la dernière version ramenée par fetch. Vous pourriez
        rechercher dans le log pour retrouver l’empreinte SHA1
        appropriée mais il est beaucoup plus simple de
        tapez&nbsp;:</p>
        <pre class="literallayout">
$ git diff origin/HEAD
</pre>

        <p>Vous pouvez aussi voir où en est rendu la branche
        ‘`experimental’'&nbsp;:</p>
        <pre class="literallayout">
$ git log origin/experimental
</pre>
      </div>

      <div class="section" title="Dépôts distants multiples">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_d%C3%A9p%C3%B4ts_distants_multiples"></a>Dépôts
              distants multiples</h2>
            </div>
          </div>
        </div>

        <p>Supposez que deux autres développeurs travaillent sur
        notre projet et que nous souhaitons garder un œil sur les
        deux. Nous pouvons suivre plus d’un dépôt à la fois grâce
        à&nbsp;:</p>
        <pre class="literallayout">
$ git remote add un_autre git://example.com/un_depot.git
$ git pull un_autre une_branche
</pre>

        <p>Maintenant nous avons fusionné avec une branche d’un
        second dépôt et nous avons accès facilement à toutes les
        branches de tous les dépôts&nbsp;:</p>
        <pre class="literallayout">
$ git diff origin/experimental^ un_autre/une_branche~5
</pre>

        <p>Mais comment faire si nous souhaitons juste comparer
        leurs modifications sans affecter notre travail&nbsp;? En
        d’autres termes, nous voulons examiner leurs branches sans
        que leurs modifications envahissent notre dossier de
        travail. À la place d’un pull, faisons&nbsp;:</p>
        <pre class="literallayout">
$ git fetch          # Rapatrier depuis le dépôt d'origin, par défaut
$ git fetch un_autre # Rapatrier depuis le dépôt d'un_autre
</pre>

        <p>Cela ne rapatrie (fetch) que les historiques. Bien que
        notre dossier de travail reste inchangé, nous pouvons faire
        référence à n’importe quelle branche de n’importe quel
        dépôt dans nos commandes Git puisque nous en possédons
        maintenant une copie locale.</p>

        <p>Rappelez-vous qu’en coulisse, un <span class=
        "strong"><strong>pull</strong></span> est simplement un
        <span class="strong"><strong>fetch</strong></span> suivi
        d’un <span class="strong"><strong>merge</strong></span>.
        Habituellement nous faisons appel à <span class=
        "strong"><strong>pull</strong></span> car nous voulons
        fusionner (merge) les dernières modifications distantes
        après les avoir rapatriées (fetch). La situation ci-dessus
        est une exception notable.</p>

        <p>Voir <span class="strong"><strong>get help
        remote</strong></span> pour savoir comment supprimer des
        dépôts distants, ignorer certaines branches et bien plus
        encore.</p>
      </div>

      <div class="section" title="Mes préférences">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mes_pr%C3%A9f%C3%A9rences"></a>Mes préférences</h2>
            </div>
          </div>
        </div>

        <p>Pour mes projets, j’aime que mes contributeurs se
        confectionnent un dépôt depuis lequel je peux effectuer des
        pull. Certains services d’hébergement Git vous permettent
        de créer votre propre dépôt clone d’un projet en cliquant
        simplement sur un bouton.</p>

        <p>Après avoir rapatrié (fetch) un arbre de modifications,
        j’utilise les commandes Git pour parcourir et examiner ces
        modifications qui, idéalement, sont bien organisées et bien
        décrites. Je fusionne mes propres modifications et effectue
        parfois quelques modifications supplémentaires. Une fois
        satisfait, je les envoie (push) vers le dépôt
        principal.</p>

        <p>Bien que recevant rarement des contributions, je pense
        que mon approche est parfaitement adaptable à grande
        échelle. Voir <a class="ulink" href=
        "http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html"
        target="_top">ce billet par Linus Torvalds</a>.</p>

        <p>Rester dans le monde Git est un peu plus pratique que de
        passer par des fichiers de patch puisque cela m'évite
        d’avoir à les convertir en commits Git. De plus, Git gère
        les détails tels qu’enregistrer le nom de l’auteur, son
        adresse mail ainsi que la date et l’heure et il demande à
        l’auteur de décrire ses propres modifications.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;7.&nbsp;La maîtrise de Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_la_ma%C3%AEtrise_de_git"></a>Chapitre&nbsp;7.&nbsp;La
            maîtrise de Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_publication_de_sources">Publication de
          sources</a></span></dt>

          <dt><span class="section"><a href=
          "#_g%C3%A9rer_le_changement">Gérer le
          changement</a></span></dt>

          <dt><span class="section"><a href=
          "#_mon_commit_est_trop_gros">Mon commit est trop
          gros&nbsp;!</a></span></dt>

          <dt><span class="section"><a href=
          "#_l_8217_index_l_8217_aire_d_8217_assemblage">L’index&nbsp;:
          l’aire d’assemblage</a></span></dt>

          <dt><span class="section"><a href=
          "#_ne_perdez_pas_la_t%C3%AAte">Ne perdez pas la
          tête</a></span></dt>

          <dt><span class="section"><a href=
          "#_chasseur_de_t%C3%AAte">Chasseur de
          tête</a></span></dt>

          <dt><span class="section"><a href=
          "#_construire_au_dessus_de_git">Construire au-dessus de
          Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_audacieuses_acrobaties">Audacieuses
          acrobaties</a></span></dt>

          <dt><span class="section"><a href=
          "#_se_pr%C3%A9munir_des_commits_erron%C3%A9s">Se prémunir
          des commits erronés</a></span></dt>
        </dl>
      </div>

      <p>À ce stade, vous devez être capable de parcourir les pages
      de <span class="strong"><strong>git help</strong></span> et
      comprendre presque tout (en supposant que vous lisez
      l’anglais). En revanche, retrouver la commande exacte qui
      résoudra un problème précis peut être fastidieux. Je peux
      sans doute vous aider à gagner un peu de temps&nbsp;: vous
      trouverez ci-dessous quelques-unes des recettes dont j’ai
      déjà eu besoin.</p>

      <div class="section" title="Publication de sources">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_publication_de_sources"></a>Publication de
              sources</h2>
            </div>
          </div>
        </div>

        <p>Dans mes projets, Git gère exactement tous les fichiers
        que je veux placer dans une archive afin de la publier.
        Pour créer une telle archive, j’utilise&nbsp;:</p>
        <pre class="literallayout">
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" title="Gérer le changement">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_g%C3%A9rer_le_changement"></a>Gérer le
              changement</h2>
            </div>
          </div>
        </div>

        <p>Indiquer à Git quels fichiers ont été ajoutés, supprimés
        ou renommés est parfois pénible pour certains projets. À la
        place, vous pouvez faire&nbsp;:</p>
        <pre class="literallayout">
$ git add .
$ git add -u
</pre>

        <p>Git cherchera les fichiers du dossier courant et gérera
        tous les détails tout seul. En remplacement de la deuxième
        commande <span class="emphasis"><em>add</em></span>, vous
        pouvez utiliser <code class="literal">git commit -a</code>
        pour créer un nouveau commit directement. Lisez
        <span class="strong"><strong>git help
        ignore</strong></span> pour savoir comment spécifier les
        fichiers qui doivent être ignorés.</p>

        <p>Vous pouvez effectuer tout cela en une seule passe grâce
        à&nbsp;:</p>
        <pre class="literallayout">
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>Les options <span class=
        "strong"><strong>-z</strong></span> et <span class=
        "strong"><strong>-0</strong></span> empêchent les effets
        secondaires imprévus dûs au noms de fichiers contenant des
        caractères étranges. Comme cette commande ajoutent aussi
        les fichiers habituellement ignorés, vous voudrez sûrement
        utiliser les options <code class="literal">-x</code> ou
        <code class="literal">-X</code>.</p>
      </div>

      <div class="section" title="Mon commit est trop gros&nbsp;!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mon_commit_est_trop_gros"></a>Mon commit est trop
              gros&nbsp;!</h2>
            </div>
          </div>
        </div>

        <p>Avez-vous négligé depuis longtemps de faire un
        commit&nbsp;? Avez-vous codé furieusement et tout oublié de
        la gestion de versions jusqu'à présent&nbsp;? Faites-vous
        plein de petits changements sans rapport entre eux parce
        que c’est votre manière de travailler&nbsp;?</p>

        <p>Pas de soucis. Faites&nbsp;:</p>
        <pre class="literallayout">
$ git add -p
</pre>

        <p>Pour chacune des modifications que vous avez faites, Git
        vous montrera le bout de code qui a changé et vous
        demandera si elle doit faire partie du prochain commit.
        Répondez par "y" (oui) ou par "n" (non). Vous avez aussi
        d’autres options comme celle vous permettant de reporter
        votre décision&nbsp;; tapez "?" pour en savoir plus.</p>

        <p>Une fois satisfait, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git commit
</pre>

        <p>pour faire un commit incluant exactement les
        modifications qui vous avez sélectionnées (les
        modifications indexées). Soyez certain de ne pas utiliser
        l’option <span class="strong"><strong>-a</strong></span>
        sinon Git fera un commit incluant toutes vos
        modifications.</p>

        <p>Que faire si vous avez modifié de nombreux fichiers en
        de nombreux endroits&nbsp;? Vérifier chaque modification
        individuellement devient alors rapidement frustrant et
        abrutissant. Dans ce cas, utilisez la commande <span class=
        "strong"><strong>git add -i</strong></span> dont
        l’interface est moins facile mais beaucoup plus souple. En
        quelques touches vous pouvez ajouter ou retirer de votre
        index (voir ci-dessous) plusieurs fichiers d’un seul coup
        mais aussi valider ou non chacune des modifications
        individuellement pour certains fichiers. Vous pouvez aussi
        utiliser en remplacement la commande <span class=
        "strong"><strong>git commit --interactive</strong></span>
        qui effectuera un commit automatiquement quand vous aurez
        terminé.</p>
      </div>

      <div class="section" title=
      "L’index&nbsp;: l’aire d’assemblage">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_index_l_8217_aire_d_8217_assemblage"></a>L’index&nbsp;:
              l’aire d’assemblage</h2>
            </div>
          </div>
        </div>

        <p>Jusqu’ici nous avons réussi à éviter de parler du fameux
        <span class="emphasis"><em>index</em></span> de Git mais
        nous devons maintenant le présenter pour mieux comprendre
        ce qui précède. L’index est une aire d’assemblage
        temporaire. Git ne transfert que très rarement de données
        depuis votre dossier de travail directement vers votre
        historique. En fait, Git copie d’abord ces données dans
        l’index puis il copie toutes ces données depuis l’index
        vers leur destination finale.</p>

        <p>Un <span class="strong"><strong>commit
        -a</strong></span>, par exemple, est en fait un processus
        en deux temps. La première étape consiste à construire dans
        l’index un instantané de l'état actuel de tous les fichiers
        suivis par Git. La seconde étape enregistre cet instantané
        de manière permanente dans l’historique. Effectuer un
        commit sans l’option <span class=
        "strong"><strong>-a</strong></span> réalise uniquement
        cette deuxième étape et cela n’a de sens qu’après avoir
        effectué des commandes qui change l’index, telle que
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Habituellement nous pouvons ignorer l’index et faire
        comme si nous échangions directement avec l’historique.
        Dans certaines occasions, nous voulons un contrôle fin et
        nous gérons donc l’index. Nous plaçons dans l’index un
        instantané de certaines modifications (mais pas toutes) et
        enregistrons de manière permanente cet instantané
        soigneusement construit.</p>
      </div>

      <div class="section" title="Ne perdez pas la tête">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ne_perdez_pas_la_t%C3%AAte"></a>Ne perdez pas la
              tête</h2>
            </div>
          </div>
        </div>

        <p>Le tag HEAD est comme un curseur qui pointe
        habituellement vers le tout dernier commit et qui avance à
        chaque commit. Certaines commandes Git vous permettent de
        le déplacer. Par exemple&nbsp;:</p>
        <pre class="literallayout">
$ git reset HEAD~3
</pre>

        <p>déplacera HEAD trois commits en arrière. À partir de là,
        toutes les commandes Git agiront comme si vous n’aviez
        jamais fait ces trois commits, même si vos fichier restent
        dans leur état présent. Voir les pages d’aide pour quelques
        usages intéressants.</p>

        <p>Mais comment faire pour revenir vers le futur&nbsp;? Les
        commits passés ne savent rien du futur.</p>

        <p>Si vous connaissez l’empreinte SHA1 du HEAD original,
        faites alors&nbsp;:</p>
        <pre class="literallayout">
$ git reset 1b6d
</pre>

        <p>Mais que faire si vous ne l’avez pas regardé&nbsp;? Pas
        de panique&nbsp;: pour des commandes comme celle-ci, Git
        enregistre la valeur originale de HEAD dans un tag nommé
        ORIG_HEAD et vous pouvez revenir sain et sauf
        via&nbsp;:</p>
        <pre class="literallayout">
$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" title="Chasseur de tête">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_chasseur_de_t%C3%AAte"></a>Chasseur de tête</h2>
            </div>
          </div>
        </div>

        <p>Peut-être que ORIG_HEAD ne vous suffit pas. Peut-être
        venez-vous de vous apercevoir que vous avez fait une
        monumentale erreur et que vous devez revenir à une ancienne
        version d’une branche oubliée depuis longtemps.</p>

        <p>Par défaut, Git conserve un commit au moins deux semaine
        même si vous avez demandé à Git de détruire la branche qui
        le contient. La difficulté consiste à retrouver l’empreinte
        appropriée. Vous pouvez toujours explorer les différentes
        valeurs d’empreinte trouvées dans <code class=
        "literal">.git/objects</code> et retrouver celle que vous
        cherchez par essais et erreurs. Mais il existe un moyen
        plus simple.</p>

        <p>Git enregistre l’empreinte de chaque commit qu’il traite
        dans <code class="literal">.git/logs</code>. La
        sous-dossier <code class="literal">refs</code> contient
        l’historique de toute l’activité de chaque branche alors
        que le fichier <code class="literal">HEAD</code> montre
        chaque valeur d’empreinte que HEAD a pu prendre. Ce dernier
        peut donc servir à retrouver les commits d’une branche qui
        a été accidentellement élaguée.</p>

        <p>La commande reflog propose une interface sympa vers ces
        fichiers de log. Essayez:</p>
        <pre class="literallayout">
$ git reflog
</pre>

        <p>Au lieu de copier/coller une empreinte listée par
        reflog, essayez&nbsp;:</p>
        <pre class="literallayout">
$ git checkout "@{10 minutes ago}"
</pre>

        <p>Ou basculez vers le cinquième commit précédemment visité
        via&nbsp;:</p>
        <pre class="literallayout">
$ git checkout "@{5}"
</pre>

        <p>Voir la section «Specifying Revisions» de <span class=
        "strong"><strong>git help rev-parse</strong></span> pour en
        savoir plus.</p>

        <p>Vous pouvez configurer une plus longue période de
        rétention pour les commits condamnés. Par
        exemple&nbsp;:</p>
        <pre class="literallayout">
$ git config gc.pruneexpire "30 days"
</pre>

        <p>signifie qu’un commit effacé ne le sera véritablement
        qu’après 30 jours et lorsque $git gc* tournera.</p>

        <p>Vous pouvez aussi désactiver le déclenchement
        automatique de <span class="strong"><strong>git
        gc</strong></span>&nbsp;:</p>
        <pre class="literallayout">
$ git config gc.auto 0
</pre>

        <p>auquel cas les commits ne seront véritablement effacés
        que lorsque vous lancerez <span class="strong"><strong>git
        gc</strong></span> manuellement.</p>
      </div>

      <div class="section" title="Construire au-dessus de Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_construire_au_dessus_de_git"></a>Construire
              au-dessus de Git</h2>
            </div>
          </div>
        </div>

        <p>À la manière UNIX, la conception de Git permet son
        utilisation comme un composant de bas niveau d’autres
        programmes tels que des interfaces graphiques ou web, des
        interfaces en ligne de commandes alternatives, des outils
        de gestion de patch, des outils d’importation et de
        conversion, etc. En fait, certaines commandes Git sont de
        simples scripts s’appuyant sur les commandes de base, comme
        des nains sur des épaules de géants. Avec un peu de
        bricolage, vous pouvez adapter Git à vos préférences.</p>

        <p>Une astuce facile consiste à créer des alias Git pour
        raccourcir les commandes que vous utilisez le plus
        fréquemment&nbsp;:</p>
        <pre class="literallayout">
$ git config --global alias.co checkout
$ git config --global --get-regexp alias  # affiche les alias connus
alias.co checkout
$ git co foo                              # identique à 'git checkout foo'
</pre>

        <p>Une autre astuce consiste à intégrer le nom de la
        branche courant dans votre prompt ou dans le titre de la
        fenêtre. L’invocation de&nbsp;:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD
</pre>

        <p>montre le nom complet de la branche courante. En
        pratique, vous souhaiterez probablement enlever
        "refs/heads/" et ignorer les erreurs&nbsp;:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>Le sous-dossier <code class="literal">contrib</code> de
        Git est une mine d’outils construits au-dessus de Git. Un
        jour, certains d’entre eux pourraient être promus au rang
        de commandes officielles. Dans Debian et Ubuntu, ce dossier
        est <code class=
        "literal">/usr/share/doc/git-core/contrib</code>.</p>

        <p>L’un des plus populaires de ces scripts est <code class=
        "literal">workdir/git-new-workdir</code>. Grâce à des liens
        symboliques intelligents, ce script crée un nouveau dépôt
        dont l’historique est partagé avec le dépôt original.</p>
        <pre class="literallayout">
$ git-new-workdir un/existant/depot nouveau/repertoire
</pre>

        <p>Le nouveau dossier et ses fichiers peuvent être vus
        comme un clone, sauf que l’historique est partagé et que
        les deux arbres des versions restent automatiquement
        synchrones. Nul besoin de merge, push ou pull.</p>
      </div>

      <div class="section" title="Audacieuses acrobaties">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_audacieuses_acrobaties"></a>Audacieuses
              acrobaties</h2>
            </div>
          </div>
        </div>

        <p>À ce jour, Git fait tout son possible pour que
        l’utilisateur ne puisse pas effacer accidentellement des
        données. Mais si vous savez ce que vous faites, vous pouvez
        passer outre les garde-fous des principales commandes.</p>

        <p><span class=
        "strong"><strong>Checkout</strong></span>&nbsp;: des
        modifications non intégrées (via commit) peuvent causer
        l'échec d’un checkout. Pour détruire vos modifications et
        réussir quoi qu’il arrive un checkout d’un commit donné,
        utilisez l’option d’obligation&nbsp;:</p>
        <pre class="literallayout">
$ git checkout -f HEAD^
</pre>

        <p>Inversement, si vous spécifiez des chemins particuliers
        pour un checkout alors il n’y a pas de garde-fous. Le
        contenu des chemins est silencieusement réécrit. Faites
        attention lorsque vous utilisez un checkout de cette
        manière.</p>

        <p><span class=
        "strong"><strong>Reset</strong></span>&nbsp;: un reset
        échoue aussi en présence de modifications non intégrées.
        Pour passer outre, faites&nbsp;:</p>
        <pre class="literallayout">
$ git reset --hard 1b6d
</pre>

        <p><span class=
        "strong"><strong>Branch</strong></span>&nbsp;: la
        suppression de branches échoue si cela implique la perte de
        certains commits. Par forcer la suppression,
        tapez&nbsp;:</p>
        <pre class="literallayout">
$ git branch -D branche_morte  # à la place de -d
</pre>

        <p>De manière similaire, une tentative visant à renommer
        une branche existante vers le nom d’une autre branche
        échoue si cela amène la perte de commits. Pour forcer le
        changement de nom, tapez&nbsp;:</p>
        <pre class="literallayout">
$ git branch -M source target  # à la place de -m
</pre>

        <p>Contrairement à checkout et reset, ces deux dernières
        commandes n’effectuent pas la suppression des informations
        immédiatement. Les commits destinés à disparaître sont
        encore disponibles dans le sous-dossier .git et peuvent
        encore être retrouvés grâce aux empreintes appropriées tel
        que retrouvées dans <code class="literal">.git/logs</code>
        (voir "Chasseur de tête" ci-dessus). Par défaut, ils sont
        conservés au moins deux semaines.</p>

        <p><span class=
        "strong"><strong>Clean</strong></span>&nbsp;: certaines
        commandes Git refusent de s’exécuter pour ne pas écraser
        des fichiers non suivis. Si vous êtes certain que tous ces
        fichiers et dossiers peuvent être sacrifiés alors
        effacez-les sans pitié via&nbsp;:</p>
        <pre class="literallayout">
$ git clean -f -d
</pre>

        <p>Ensuite, la commande trop prudente fonctionnera !</p>
      </div>

      <div class="section" title="Se prémunir des commits erronés">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_se_pr%C3%A9munir_des_commits_erron%C3%A9s"></a>Se
              prémunir des commits erronés</h2>
            </div>
          </div>
        </div>

        <p>Des erreurs stupides encombrent mes dépôts. Les plus
        effrayantes sont dues à des fichiers manquants car oubliés
        lors des <span class="strong"><strong>git
        add</strong></span>. D’autres erreurs moins graves
        concernent les espaces blancs inutiles ou les conflits de
        fusion non résolus&nbsp;: bien qu’inoffensives, j’aimerais
        qu’elles n’apparaissent pas dans les versions
        publiques.</p>

        <p>Si seulement je m’en étais prémuni en utilisant un
        <span class="emphasis"><em>hook</em></span> (un crochet)
        pour m’alerter de ces problèmes&nbsp;:</p>
        <pre class="literallayout">
$ cd .git/hooks
$ cp pre-commit.sample pre-commit  # Vieilles versions de Git : chmod +x pre-commit
</pre>

        <p>Maintenant Git empêchera un commit s’il détecte des
        espace inutiles ou s’il reste des conflits de fusion non
        résolus.</p>

        <p>Pour gérer ce guide, j’ai aussi ajouté les lignes
        ci-dessous au début de mon hook <span class=
        "strong"><strong>pre-commit</strong></span> pour me
        prémunir de mes inattentions&nbsp;:</p>
        <pre class="literallayout">
if git ls-files -o | grep '\.txt$'; then
  echo FAIL! Untracked .txt files.
  exit 1
fi
</pre>

        <p>Plusieurs opération de Git acceptent les hooks&nbsp;;
        voir <span class="strong"><strong>git help
        hooks</strong></span>. Nous avons déjà utilisé le hook
        <span class="strong"><strong>post-update</strong></span>
        lorsque nous avons parlé de Git au-dessus de HTTP. Celui-ci
        se déclenche à chaque mouvement de HEAD. Le script
        d’exemple post-update met à jour les fichiers Git
        nécessaires à une communication au-dessus de transports
        agnostiques tels que HTTP.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;8.&nbsp;Les secrets révélés">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_les_secrets_r%C3%A9v%C3%A9l%C3%A9s"></a>Chapitre&nbsp;8.&nbsp;Les
            secrets révélés</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_l_8217_invisibilit%C3%A9">L’invisibilité</a></span></dt>

          <dt><span class="section"><a href=
          "#_l_8217_int%C3%A9grit%C3%A9">L’intégrité</a></span></dt>

          <dt><span class="section"><a href=
          "#_l_8217_intelligence">L’intelligence</a></span></dt>

          <dt><span class="section"><a href=
          "#_l_8217_indexation">L’indexation</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_origines_de_git">Les origines de
          Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_la_base_d_8217_objets">La base
          d’objets</a></span></dt>

          <dt><span class="section"><a href="#_les_blobs">Les
          blobs</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_arbres_literal_trees_literal">Les arbres
          (<code class="literal">trees</code>)</a></span></dt>

          <dt><span class="section"><a href="#_les_commits">Les
          commits</a></span></dt>

          <dt><span class="section"><a href=
          "#_indiscernable_de_la_magie">Indiscernable de la
          magie</a></span></dt>
        </dl>
      </div>

      <p>Nous allons jeter un œil sous le capot pour comprendre
      comment Git réalise ses miracles. Je passerai sous silence la
      plupart des détails. Pour des explications plus détaillées,
      référez-vous au <a class="ulink" href=
      "http://www.kernel.org/pub/software/scm/git/docs/user-manual.html"
      target="_top">manuel utilisateur</a>.</p>

      <div class="section" title="L’invisibilité">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_invisibilit%C3%A9"></a>L’invisibilité</h2>
            </div>
          </div>
        </div>

        <p>Comment fait Git pour être si discret&nbsp;? Mis à part
        lorsque vous faites des commits et des fusions, vous pouvez
        travailler comme si la gestion de versions n’existait pas.
        Et c’est lorsque vous en avez besoin que vous êtes content
        de voir que Git veillait sur vous tout le temps.</p>

        <p>D’autres systèmes de gestion de versions vous mettent
        constamment aux prises avec de la paperasserie et de la
        bureaucratie. Les fichiers sont en lecture seule jusqu'à
        l’obtention depuis un serveur central du droit d'édition de
        tel ou tel fichier. Les commandes les plus basiques voient
        leurs performances s'écrouler au fur et à mesure que le
        nombre d’utilisateurs augmente. Le travail s’arrête dès
        lors que le réseau ou le serveur central est en panne.</p>

        <p>À l’inverse, Git conserve tout l’historique de votre
        projet dans le sous-dossier <code class=
        "literal">.git</code> de votre dossier de travail. C’est
        votre propre copie de l’historique et vous pouvez donc
        rester déconnecté tant que vous ne voulez pas communiquer
        avec les autres. Vous conservez un contrôle total sur le
        sort de vos fichiers puisque Git peut aisément les recréer
        à tout moment à partir de l’un des états enregistrés dans
        <code class="literal">.git</code>.</p>
      </div>

      <div class="section" title="L’intégrité">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_int%C3%A9grit%C3%A9"></a>L’intégrité</h2>
            </div>
          </div>
        </div>

        <p>La plupart des gens associent la cryptographie à la
        conservation du secret des informations mais l’un de ses
        buts tout aussi important est de conserver l’intégrité de
        ces informations. Un usage approprié des fonctions de
        hachage cryptographiques (celles qui calculent l’empreinte
        d’un document) permet d’empêcher la corruption accidentelle
        ou malicieuse des données.</p>

        <p>Une empreinte SHA1 peut être vue comme un nombre de 160
        bits identifiant de manière unique n’importe quelle suite
        d’octets que vous rencontrerez dans votre vie. On peut même
        aller plus loin&nbsp;: c’est vrai pour toutes les suites
        d’octets que les humains utiliseront sur plusieurs
        générations.</p>

        <p>Comme une empreinte SHA1 est elle-même une suite
        d’octets, nous pouvons calculer l’empreinte d’une suite de
        caractères contenant d’autres empreintes. Cette simple
        observation est étonnamment utile (cherchez par exemple
        <span class="emphasis"><em>hash chain</em></span>). Nous
        verrons plus tard comment Git utilise cela pour garantir
        efficacement l’intégrité des données.</p>

        <p>En bref, Git conserve vos données dans le sous-dossier
        <code class="literal">.git/objects</code> mais à la place
        des noms de fichiers normaux, vous n’y trouverez que des
        ID. En utilisant ces ID comme noms de fichiers et grâce à
        quelques astucieux fichiers de verrouillage et
        d’horodatage, Git transforme un simple système de fichiers
        en une base de données efficace et robuste.</p>
      </div>

      <div class="section" title="L’intelligence">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_intelligence"></a>L’intelligence</h2>
            </div>
          </div>
        </div>

        <p>Comment fait Git pour savoir que vous avez renommé un
        fichier même si vous ne lui avez pas dit
        explicitement&nbsp;? Bien sûr, vous pouvez utiliser
        <span class="strong"><strong>git mv</strong></span> mais
        c’est exactement la même chose que de faire <span class=
        "strong"><strong>git rm</strong></span> suivi par
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git a des heuristiques pour débusquer les changements de
        noms et les copies entre les versions successives. En fait,
        il peut même détecter les bouts de code qui ont été
        déplacés ou copiés d’un fichier à un autre ! Bien que ne
        couvrant pas tous les cas, cela marche déjà très bien et
        cette fonctionnalité est encore en cours d’amélioration. Si
        cela échoue pour vous, essayez les options activant des
        méthodes de détection de copie plus coûteuses et envisager
        de faire une mise à jour.</p>
      </div>

      <div class="section" title="L’indexation">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_indexation"></a>L’indexation</h2>
            </div>
          </div>
        </div>

        <p>Pour chaque fichier suivi, Git mémorise des
        informations, telles que sa taille et ses dates de création
        et de dernières modifications, dans un fichier appelé
        <span class="emphasis"><em>index</em></span>. Pour
        déterminer si un fichier a changé, Git compare son état
        courant avec ce qu’il a mémorisé dans l’index. Si cela
        correspond alors Git n’a pas besoin de relire le
        fichier.</p>

        <p>Puisque les appels à <span class=
        "emphasis"><em>stat</em></span> sont considérablement plus
        rapides que la lecture des fichiers, si vous n’avez modifié
        que quelques fichiers, Git peut déterminer son état en très
        peu de temps.</p>

        <p>Nous avons dit plus tôt que l’index était une aire
        d’assemblage. Comment se peut-il qu’un simple fichier
        contant quelques informations sur les fichiers soit une
        aire d’assemblage&nbsp;? Parce que la commande add ajoute
        les fichiers à la base de données de Git et met à jour
        l’index avec leurs informations alors que la commande
        commit, sans option, crée une nouvelle version basée
        uniquement sur cet index et les fichiers déjà inclus dans
        la base de données.</p>
      </div>

      <div class="section" title="Les origines de Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_origines_de_git"></a>Les origines de Git</h2>
            </div>
          </div>
        </div>

        <p>Ce <a class="ulink" href=
        "http://lkml.org/lkml/2005/4/6/121" target="_top">message
        de la Mailing List du noyau Linux</a> décrit l’enchaînement
        des évènements ayant mené à Git. L’ensemble de l’enfilade
        est un site archéologique fascinant pour les historiens de
        Git.</p>
      </div>

      <div class="section" title="La base d’objets">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_la_base_d_8217_objets"></a>La base d’objets</h2>
            </div>
          </div>
        </div>

        <p>Chacune des versions de vos données est conservée dans
        la base d’objets (<span class="emphasis"><em>object
        database</em></span>) qui réside dans le sous-dossier
        <code class="literal">.git/objects</code>&nbsp;; le reste
        du contenu du dossier <code class="literal">.git</code>
        représente moins de données&nbsp;: l’index, le nom des
        branches, les tags, les options de configuration, les logs,
        l’emplacement actuel de HEAD, et ainsi de suite. La base
        d’objets est simple mais élégante et constitue la source de
        la puissance de Git.</p>

        <p>Chaque fichier dans <code class=
        "literal">.git/objects</code> est un objet. Il y a trois
        sortes d’objets qui nous concerne&nbsp;: les <code class=
        "literal">blobs</code>, les arbres (<code class=
        "literal">trees</code>) et les <code class=
        "literal">commits</code>.</p>
      </div>

      <div class="section" title="Les blobs">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_blobs"></a>Les blobs</h2>
            </div>
          </div>
        </div>

        <p>Tout d’abord, faisons un peu de magie. Choisissez un nom
        de fichier… n’importe quel nom de fichier&nbsp;! Puis dans
        un dossier vide, faites (en remplaçant <code class=
        "literal">VOTRE_NOM_DE_FICHIER</code> par le nom que vous
        avez choisi)&nbsp;:</p>
        <pre class="literallayout">
$ echo joli &gt; VOTRE_NOM_DE_FICHIER
$ git init
$ git add .
$ find .git/objects -type f
</pre>

        <p>Vous verrez <code class=
        "literal">.git/objects/06/80f15d4cb13a09f600a25b84eae36506167970</code>.</p>

        <p>Comment puis-je le savoir sans connaître le nom de
        fichier que vous avez choisi&nbsp;? Tout simplement parce
        que l’empreinte SHA1 de&nbsp;:</p>
        <pre class="literallayout">
"blob" SP "5" NUL "joli" LF
</pre>

        <p>est 0680f15d4cb13a09f600a25b84eae36506167970. Où SP est
        un espace, NUL est l’octet de valeur nulle et LF est un
        passage à la ligne. Vous pouvez vérifier cela en
        tapant&nbsp;:</p>
        <pre class="literallayout">
$ printf "blob 5\000joli\n" | sha1sum
</pre>

        <p>Git utilise un classement par contenu&nbsp;: les
        fichiers ne sont pas stockés selon leur nom mais selon
        l’empreinte des données qu’ils contiennent, dans un fichier
        que nous appelons un objet <span class=
        "emphasis"><em>blob</em></span>. Nous pouvons considérer
        l’empreinte comme un ID unique du contenu d’un fichier.
        Donc nous pouvons retrouver un fichier par son contenu. La
        chaîne initiale <code class="literal">blob 5</code> est
        simplement un entête indiquant le type de l’objet et sa
        longueur en octets&nbsp;; cela simplifie le classement
        interne.</p>

        <p>Je peux donc aisément prédire ce que vous voyez. Le nom
        du fichier ne compte pas&nbsp;: pour construire l’objet
        blob, seules comptent les données stockées dans le
        fichier.</p>

        <p>Peut-être vous demandez-vous ce qui se produit pour des
        fichiers ayant le même contenu. Essayez en créant des
        copies de votre premier fichier, avec des noms quelconques.
        Le contenu de <code class="literal">.git/objects</code>
        reste le même quel que soit le nombre de copies que vous
        avez ajoutées. Git ne stocke le contenu qu’une seule
        fois.</p>

        <p>À propos, les fichiers dans <code class=
        "literal">.git/objects</code> sont compressés par zlib et,
        par conséquent, vous ne pouvez pas en consulter le contenu
        directement. Passez-les au travers du filtre <a class=
        "ulink" href="http://www.zlib.net/zpipe.c" target=
        "_top">zpipe -d</a> ou tapez&nbsp;:</p>
        <pre class="literallayout">
$ git cat-file -p 0680f15d4cb13a09f600a25b84eae36506167970
</pre>

        <p>qui affiche proprement l’objet choisi.</p>
      </div>

      <div class="section" title="Les arbres (trees)">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_arbres_literal_trees_literal"></a>Les arbres
              (<code class="literal">trees</code>)</h2>
            </div>
          </div>
        </div>

        <p>Mais que deviennent les noms des fichiers&nbsp;? Ils
        doivent bien être stockés quelque part à un moment. Git se
        préoccupe des noms de fichiers lors d’un commit&nbsp;:</p>
        <pre class="literallayout">
$ git commit  # Tapez un message
$ find .git/objects -type f
</pre>

        <p>Vous devriez voir maintenant trois objets. Mais là, je
        ne peux plus prédire le nom des deux nouveaux fichiers
        puisqu’ils dépendent en partie du nom de fichier que vous
        avez choisi. Nous continuerons en supposant que vous avez
        choisi «rose». Si ce n’est pas le cas, vous pouvez réécrire
        l’histoire pour que ce soit le cas&nbsp;:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'mv VOTRE_NOM_DE_FICHIER rose'
$ find .git/objects -type f
</pre>

        <p>Le fichier <code class=
        "literal">.git/objects/9a/6a950c3b14eb1a3fb540a2749514a1cb81e206</code>
        devrait maintenant apparaître puisque c’est l’empreinte
        SHA1 du contenu suivant&nbsp;:</p>
        <pre class="literallayout">
"tree" SP "32" NUL "100644 rose" NUL 0x9a6a950c3b14eb1a3fb540a2749514a1cb81e206
</pre>

        <p>Vérifiez que ce contenu est le bon en tapant&nbsp;:</p>
        <pre class="literallayout">
$ echo 9a6a950c3b14eb1a3fb540a2749514a1cb81e206 | git cat-file --batch
</pre>

        <p>Avec zpipe, il est plus simple de vérifier
        l’empreinte&nbsp;:</p>
        <pre class="literallayout">
$ zpipe -d &lt; .git/objects/9a/6a950c3b14eb1a3fb540a2749514a1cb81e206 | sha1sum
</pre>

        <p>La vérification de l’empreinte est plus difficile via
        cat-file puisque cette commande n’affiche pas que le
        contenu brut du fichier après décompression.</p>

        <p>Cette fichier est un objet arbre (<span class=
        "emphasis"><em>tree</em></span>)&nbsp;: une liste de tuples
        constitués d’un type, d’un nom de fichier et d’une
        empreinte. Dans notre exemple, le type est 100644 qui
        indique que <code class="literal">rose</code> est un
        fichier normal et l’empreinte est celle de l’objet de type
        blob contenant le contenu de <code class=
        "literal">rose</code>. Les autres types possibles pour un
        fichier sont exécutable, lien symbolique ou dossier. Dans
        ce dernier cas, l’empreinte représente un autre objet de
        type arbre.</p>

        <p>Si vous faites appel à la commande filter-branch, vous
        verrez apparaître de vieux objets dont vous n’avez pas
        besoin. Même s’ils disparaîtront automatiquement une fois
        expirée la période de rétention, nous allons les effacer
        dès maintenant pour rendre notre petit exemple plus facile
        à suivre&nbsp;:</p>
        <pre class="literallayout">
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
</pre>

        <p>Sur de vrais projets, vous devriez éviter de telles
        commandes puisqu’elles détruisent les sauvegardes. Si vous
        voulez un dossier propre, il est conseillé de faire un tout
        nouveau clone. Faites aussi attention si vous manipulez
        directement le contenu de <code class=
        "literal">.git</code>&nbsp;: que se passera-t-il si une
        commande Git s’effectue au même moment ou si le courant est
        soudainement coupé&nbsp;?</p>

        <p>De manière générale, les refs devraient toujours être
        effacées via <span class="strong"><strong>git update-ref
        -d</strong></span> même si on considère comme sans risque
        la suppression manuelle de <code class=
        "literal">refs/original</code>.</p>
      </div>

      <div class="section" title="Les commits">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_commits"></a>Les commits</h2>
            </div>
          </div>
        </div>

        <p>Nous avons expliqué 2 des 3 types d’objets. Le troisième
        est l’objet <span class="emphasis"><em>commit</em></span>.
        Son contenu dépend du message de commit ainsi que de la
        date et l’heure auxquelles il a été créé. Pour que vous
        obteniez la même chose qu’ici, nous devons bidouiller un
        peu&nbsp;:</p>
        <pre class="literallayout">
$ git commit --amend -m Shakespeare  # Changement de message de commit
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # Trucage de la date, l'heure et l'auteur.
$ find .git/objects -type f
</pre>

        <p>Le fichier <code class=
        "literal">.git/objects/ae/9d1241b2b6eea90529149a065f6bc444365c2a</code>
        devrait maintenant exister puisque c’est l’empreinte SHA1
        du contenu suivant&nbsp;:</p>
        <pre class="literallayout">
"commit 158" NUL
"tree 9a6a950c3b14eb1a3fb540a2749514a1cb81e206" LF
"author Alice &lt;alice@example.com&gt; 1234567890 -0800" LF
"committer Bob &lt;bob@example.com&gt; 1234567890 -0800" LF
LF
"Shakespeare" LF
</pre>

        <p>Comme précédemment, vous pouvez utiliser zpipe ou
        cat-file pour vérifier par vous-même.</p>

        <p>C’est le premier commit, ce qui explique pourquoi il n’y
        a pas de commit parent. Mais les commits suivants
        contiendront toujours au moins une ligne identifiant un
        commit parent.</p>
      </div>

      <div class="section" title="Indiscernable de la magie">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_indiscernable_de_la_magie"></a>Indiscernable de la
              magie</h2>
            </div>
          </div>
        </div>

        <p>Les secrets de Git semblent trop simples. On imagine
        qu’il suffit de mélanger quelques scripts shell et d’y
        ajouter une pincée de code C pour mitonner un tel système
        en quelques heures&nbsp;: un assemblage d’opérations
        basiques sur les fichiers et de calcul d’empreintes SHA1
        garni de quelques fichiers verrou et d’appels à fsync pour
        la robustesse. En fait, nous venons précisément de décrire
        les premières versions de Git. Malgré tout, mis à part
        quelques techniques astucieuses de compression pour gagner
        de la place et d’indexation pour gagner du temps, nous
        savons maintenant comment Git transforme adroitement un
        système de fichiers en une base de données parfaitement
        adaptée à de la gestion de versions.</p>

        <p>Par exemple, si un fichier quelconque de la base
        d’objets vient à être corrompu par une erreur disque alors
        son empreinte ne correspond plus et nous sommes alertés du
        problème. En calculant l’empreinte des empreintes d’autres
        objets, nous maintenons l’intégrité à tous les niveaux. Les
        commits sont atomiques puisque ils ne peuvent jamais
        mémoriser des modifications partiellement stockées&nbsp;:
        nous ne pouvons calculer l’empreinte d’un commit et le
        stocker dans la base d’objets qu’après y avoir déjà stocké
        tous les arbres, blobs et parents relatifs à ce commit. La
        base d’objets est immunisée contre les interruptions
        inattendues telles que les coupures de courant.</p>

        <p>Nous faisons même échouer les tentatives d’attaque les
        plus sournoises. Supposez que quelqu’un tente de modifier
        discrètement le contenu d’un fichier dans l’une des
        anciennes versions du projet. Pour rendre cohérent le
        contenu de la base d’objets, il lui faut changer
        l’empreinte de l’objet blob correspondant puisque elle doit
        maintenant représenter une chaîne d’octets différente. Cela
        signifie qu’il doit aussi changer l’empreinte de tous les
        arbres référençant ce blob et donc changer l’empreinte de
        tous les commits impliquant ces arbres ainsi que de tous
        les descendants de ces commits. Cela implique que
        l’empreinte du HEAD officiel diffère de celle du HEAD d’un
        dépôt corrompu. En remontant la suite d’empreintes erronées
        nous pouvons localiser avec précision le fichier corrompu
        ainsi que le premier commit où il l’a été.</p>

        <p>En résumé, tant que nous sommes sûrs des 20 octets
        représentant le dernier commit, il est impossible d’altérer
        un dépôt Git.</p>

        <p>Qu’en est-il des fameuses fonctionnalités de Git&nbsp;?
        Des branchements&nbsp;? Des fusions&nbsp;? Des tags&nbsp;?
        De simples détails. La tête courante est conservée dans le
        fichier <code class="literal">.git/HEAD</code> qui contient
        l’empreinte d’un objet commit. Cette empreinte sera tenue à
        jour durant un commit ainsi que durant de nombreuses autres
        commandes. Les branches fonctionnent de manière
        similaire&nbsp;: ce sont des fichiers dans <code class=
        "literal">.git/refs/heads</code>. Et les tags aussi&nbsp;:
        ils sont dans <code class="literal">.git/refs/tags</code>
        mais ils sont mis à jour par un ensemble différent de
        commandes.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;9.&nbsp;Appendix A: Les lacunes de Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_appendix_a_les_lacunes_de_git"></a>Chapitre&nbsp;9.&nbsp;Appendix
            A: Les lacunes de Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table des matières</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_les_faiblesses_de_sha1">Les faiblesses de
          SHA1</a></span></dt>

          <dt><span class="section"><a href=
          "#_microsoft_windows">Microsoft Windows</a></span></dt>

          <dt><span class="section"><a href=
          "#_des_fichiers_sans_relation">Des fichiers sans
          relation</a></span></dt>

          <dt><span class="section"><a href=
          "#_qui_modifie_quoi">Qui modifie
          quoi&nbsp;?</a></span></dt>

          <dt><span class="section"><a href=
          "#_l_8217_historique_d_8217_un_fichier">L’historique d’un
          fichier</a></span></dt>

          <dt><span class="section"><a href="#_le_clone_initial">Le
          clone initial</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_projets_versatiles">Les projets
          versatiles</a></span></dt>

          <dt><span class="section"><a href=
          "#_compteur_global">Compteur global</a></span></dt>

          <dt><span class="section"><a href=
          "#_les_dossiers_vides">Les dossiers vides</a></span></dt>

          <dt><span class="section"><a href=
          "#_le_premier_commit">Le premier commit</a></span></dt>

          <dt><span class="section"><a href=
          "#_bizarreries_de_l_8217_interface">Bizarreries de
          l’interface</a></span></dt>
        </dl>
      </div>

      <p>Git présente quelques problèmes que j’ai soigneusement
      cachés. Certains peuvent être résolus par des scripts et des
      hooks, d’autres nécessitent une réorganisation ou une
      redéfinition du projet et pour les quelques rares ennuis
      restants, il vous suffit d’attendre. Ou mieux encore, de
      donner un coup de main.</p>

      <div class="section" title="Les faiblesses de SHA1">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_faiblesses_de_sha1"></a>Les faiblesses de
              SHA1</h2>
            </div>
          </div>
        </div>

        <p>Avec le temps, les spécialistes de cryptographie
        découvrent de plus en plus de faiblesses de SHA1. À ce
        jour, la découverte de collisions d’empreintes semble à la
        portée d’organisations bien dotée. Et d’ici quelques
        années, peut-être que même un simple PC aura assez de
        puissance de calcul pour corrompre de manière indétectable
        un dépôt Git.</p>

        <p>Heureusement Git aura migrer vers une fonction de calcul
        d’empreintes de meilleure qualité avant que de futures
        recherches détruisent SHA1.</p>
      </div>

      <div class="section" title="Microsoft Windows">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_microsoft_windows"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Git sur Microsoft Windows peut être jugé
        encombrant&nbsp;:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://cygwin.com/" target="_top">Cygwin</a> est un
            environnement de type Linux dans Windows proposant
            <a class="ulink" href="http://cygwin.com/packages/git/"
            target="_top">un portage de Git</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://code.google.com/p/msysgit/" target="_top">Git
            on MSys</a> est un autre choix nécessitant beaucoup
            moins de place. Néanmoins quelques commandes doivent
            encore être améliorées.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Des fichiers sans relation">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_des_fichiers_sans_relation"></a>Des fichiers sans
              relation</h2>
            </div>
          </div>
        </div>

        <p>Si votre projet est très gros et contient de nombreux
        fichiers sans relation entre eux et changeant constamment,
        Git peut être plus défavorisé que d’autres systèmes puisque
        les fichiers pris séparément ne sont pas pistés. Git piste
        les changement de l’ensemble du projet, ce qui est
        habituellement bénéfique.</p>

        <p>Une solution consiste à découper votre projet en
        plusieurs parties, chacune réunissant des fichiers en
        relation entre eux. Utilisez <span class=
        "strong"><strong>git submodule</strong></span> si vous
        souhaitez conserver tout cela dans un seul dossier.</p>
      </div>

      <div class="section" title="Qui modifie quoi&nbsp;?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_modifie_quoi"></a>Qui modifie quoi&nbsp;?</h2>
            </div>
          </div>
        </div>

        <p>Certains systèmes de gestion de versions vous oblige à
        marquer explicitement un fichier avant de pouvoir le
        modifier. Bien que particulièrement ennuyeux puisque
        pouvant impliquer une communication avec un serveur
        central, cela présente deux avantages&nbsp;:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">Les diffs sont plus rapides
            puisque seuls les fichiers marqués doivent être
            examinés.</li>

            <li class="listitem">Quelqu’un peut savoir qui
            travaille sur un fichier en demandant au serveur
            central qui l’a marqué pour modification.</li>
          </ol>
        </div>

        <p>Avec quelques scripts appropriés, vous pouvez obtenir la
        même chose avec Git. Cela nécessite la coopération du
        développeur qui doit exécuter un script particulier avant
        toute modification d’un fichier.</p>
      </div>

      <div class="section" title="L’historique d’un fichier">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l_8217_historique_d_8217_un_fichier"></a>L’historique
              d’un fichier</h2>
            </div>
          </div>
        </div>

        <p>Puisque Git enregistre les modifications de manière
        globale au projet, la reconstruction de l’historique d’un
        seul fichier demande plus de travail qu’avec un système de
        gestion de versions qui traque les fichiers
        individuellement.</p>

        <p>Ce surplus est généralement négligeable et en vaut la
        peine puisque cela permet aux autres opérations d'être
        incroyablement efficaces. Par exemple, <code class=
        "literal">git checkout</code> est plus rapide que
        <code class="literal">cp -a</code> et un delta de versions
        globale au projet se compresse mieux qu’une collection de
        delta fichier par fichier.</p>
      </div>

      <div class="section" title="Le clone initial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_clone_initial"></a>Le clone initial</h2>
            </div>
          </div>
        </div>

        <p>La création d’un clone est plus coûteuse que
        l’extraction de code des autres systèmes quand il y a un
        historique conséquent.</p>

        <p>Ce coût initial s’avère payant dans le temps puisque la
        plupart des opérations futures s’effectueront rapidement et
        hors-ligne. En revanche, dans certains situations, il est
        préférable de créer un clone superficiel grâce à l’option
        <code class="literal">--depth</code> (qui limite la
        profondeur de l’historique). C’est plus rapide mais le
        clone ainsi créé offre des fonctionnalités réduites.</p>
      </div>

      <div class="section" title="Les projets versatiles">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_projets_versatiles"></a>Les projets
              versatiles</h2>
            </div>
          </div>
        </div>

        <p>Git a été conçu pour être rapide au regard de la taille
        des changements. Les humains font de petits changement de
        version en version. Une correction de bug en une ligne ici,
        une nouvelle fonctionnalité là, un commentaire amendé
        ailleurs… Mais si vous fichiers changent radicalement à
        chaque révision alors, à chaque commit, votre historique
        grossit d’un poids équivalent à celui de votre projet.</p>

        <p>Il n’y a rien que puisse faire un système de gestion de
        versions pour éviter cela, mais les utilisateurs de Git en
        souffrent plus puisque chaque clone contient habituellement
        l’historique complet.</p>

        <p>Il faut rechercher les raisons de ces changements
        radicaux. Peut-être faut-il changer les formats des
        fichiers. Des modifications mineures ne devraient modifier
        que très peu de chose dans très peu de fichiers.</p>

        <p>Peut-être une base données ou une solution d’archivage
        est-elle plus adaptée solution qu’un système de gestion de
        versions. À titre d’exemple, un système de gestion de
        versions n’est certainement pas bien taillé pour gérer des
        photos prises périodiquement par une webcam.</p>

        <p>Si les fichiers doivent absolument se transformer
        constamment et s’il faut absolument les gérer par version,
        une possibilité peut être une utilisation centralisée d’un
        dépôt Git. Chacun ne crée qu’un clone superficiel ne
        contenant qu’un historique récent voire inexistant du
        projet. Évidemment de nombreux outils Git ne seront plus
        utilisables et les corrections devront être fournies sous
        forme de patches. C’est sans doute acceptable sans en
        savoir plus sur les raisons réelles de la conservation de
        l’historique de nombreux fichiers instables.</p>

        <p>Un autre exemple serait un projet dépendant d’un
        firmware qui prend la forme d’un énorme fichier binaire.
        L’historique de ce firmware n’intéresse pas les utilisateur
        et les mises à jour se compressent difficilement et donc
        les révisions de ce firmware vont faire grossir inutilement
        le dépôt.</p>

        <p>Dans ce cas, le code source devrait être stocké dans le
        dépôt Git et les fichiers binaires conservés séparément.
        Pour rendre la vie meilleure, on peut distribuer un script
        qui utilisera un clone Git pour le code et rsync ou un
        clone Git superficiel pour le firmware.</p>
      </div>

      <div class="section" title="Compteur global">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_compteur_global"></a>Compteur global</h2>
            </div>
          </div>
        </div>

        <p>Certains systèmes de gestion de versions centralisés
        gère un entier positif qui augmente à chaque commit
        accepté. Git fait référence à un changement par son
        empreinte ce qui est mieux pour de nombreuses raisons.</p>

        <p>Mais certains aiment voir ce compteur. Par chance, il
        est très facile d'écrire un script qui se déclenchera à
        chaque mise à jour du dépôt Git central et incrémentera un
        compteur, peut-être dans un tag, qu’il associera à
        l’empreinte du dernier commit.</p>

        <p>Chaque clone peut gérer un tel compteur mais c’est
        probablement sans intérêt puisque seul le compteur du dépôt
        central compte.</p>
      </div>

      <div class="section" title="Les dossiers vides">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_les_dossiers_vides"></a>Les dossiers vides</h2>
            </div>
          </div>
        </div>

        <p>Les sous-dossiers vides ne peuvent pas être suivis.
        Placez-y des fichiers sans intérêt pour remédier à ce
        problème.</p>

        <p>Cette limitation n’est pas une fatalité due à la
        conception de Git mais un choix de l’implémentation
        actuelle. Avec un peu de chance, si de nombreux
        utilisateurs le demandent, cette fonctionnalité pourrait
        être ajoutée.</p>
      </div>

      <div class="section" title="Le premier commit">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_le_premier_commit"></a>Le premier commit</h2>
            </div>
          </div>
        </div>

        <p>Un informaticien typique compte à partir de 0 plutôt que
        de 1. Malheureusement, concernant les commits, Git n’adhère
        pas à cette convention. Plusieurs commandes ne fonctionnent
        pas avant le tout premier commit. De plus, certains cas
        limites doivent être gérés spécifiquement&nbsp;: par
        exemple, un rebasage vers une branche avec un commit
        initial différent.</p>

        <p>Git bénéficierait à définir le commit zéro&nbsp;: dès la
        création d’un dépôt, HEAD serait défini comme la chaîne
        contenant 20 octets nuls. Ce commit spécial représenterait
        un arbre vide, sans parent, qui serait présent dans tous
        les dépôts Git.</p>

        <p>Ainsi l’appel à git log, par exemple, pourrait indiquer
        à l’utilisateur qu’aucun commit n’a été fait au lieu de se
        terminer par une erreur fatale. Il en serait de même pour
        les autres outils.</p>

        <p>Le commit initial serait un descendant implicite de ce
        commit zéro.</p>

        <p>Mais ce n’est pas le cas et donc certains problèmes
        peuvent se poser. Si plusieurs branches avec des commits
        initiaux différents sont fusionnées alors le rebasage du
        résultat requiert de nombreuses interventions
        manuelles.</p>
      </div>

      <div class="section" title="Bizarreries de l’interface">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bizarreries_de_l_8217_interface"></a>Bizarreries de
              l’interface</h2>
            </div>
          </div>
        </div>

        <p>Étant donné deux commits A et B, le sens des expressions
        "A..B" et "A…B" diffère selon que la commande attend deux
        extrémités ou un intervalle. Voir <span class=
        "strong"><strong>git help diff</strong></span> et
        <span class="strong"><strong>git help
        rev-parse</strong></span>.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chapitre&nbsp;10.&nbsp;Appendix B: Traduire ce guide">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_appendix_b_traduire_ce_guide"></a>Chapitre&nbsp;10.&nbsp;Appendix
            B: Traduire ce guide</h2>
          </div>
        </div>
      </div>

      <p>Faites un clone du source puis créer un répertoire
      correspondant au <a class="ulink" href=
      "http://www.iana.org/assignments/language-subtag-registry"
      target="_top">code IETF de la langue souhaitée</a>&nbsp;:
      voir <a class="ulink" href=
      "http://www.w3.org/International/articles/language-tags/Overview.en.php"
      target="_top">l’article du W3C concernant
      l’internationalisation</a>. Par exemple pour l’anglais c’est
      "en", pour le japonais c’est "ja" et pour le chinois
      traditionnel c’est "zh-Hant". Dans ce nouveau répertoire,
      traduisez chacun des fichiers <code class=
      "literal">txt</code> du répertoire "en" original.</p>

      <p>Par exemple, pour créer ce guide en <a class="ulink" href=
      "http://fr.wikipedia.org/wiki/Klingon%20(langue)" target=
      "_top">Klingon</a>, vous devriez faire&nbsp;:</p>
      <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh  # "tlh" et le code IETF de la langue Klingon.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Traduire le fichier.
</pre>

      <p>et ainsi de suite pour tous les fichiers. Vous pouvez
      relire votre travail incrémentalement&nbsp;:</p>
      <pre class="literallayout">
$ make LANG=tlh
$ firefox book.html
</pre>

      <p>Faites souvent des commits pour vos modifications puis
      faites-le moi savoir dès que c’est prêt. GitHub.com propose
      une interface qui facilite les choses&nbsp;: faites un fork
      du projet "gitmagic", poussez-y vos modifications et
      demandez-moi de les fusionner.</p>

      <p>J’aime avoir des traductions qui suivent le schéma
      ci-dessus car mes scripts peuvent alors produire les versions
      HTML et PDF. Et puis c’est pratique de conserver toutes les
      traductions dans le dépôt officiel. Mais que cela ne vous
      empêche pas de faire ce qui vous convient le mieux&nbsp;: par
      exemple, les traducteurs chinois préfèrent utiliser Google
      Docs. Je suis content tant que votre travail permet à
      d’autres de profiter de mon travail.</p>
    </div>
  </div>
</body>
</html>
