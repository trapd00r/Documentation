Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Fri, 5 Feb 1999 10:10:19 +0100 (MET)
Message-Id: <199902050910.KAA19564@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: one more completion variable
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5266


If you have multiple global matching specifications for completion
(like `-M 'm:{a-z}={A-Z}' 'r:|[.,_-]=* r:|=*'), and trying the first
one doesn't produce any matches, the completion code tries again with
the second one. This means that the new style completion widgets will
be called a second time. To be able to test this in the completion
shell functions, we need information about which global matcher is
currently being used, especially in functions like pfiles() which do
the matching themselves.

The patch adds a variable MATCHER (special like the others) that
contains the number of the global matcher being used. I used the
number since this is easy to test (the patch also adds a condition
code [[ -matcher 1 ]], but this is just for completeness'
sake). Giving the matcher definition string to the completion widget
would be possible but since I don't think anyone wants to write a
parser for such strings in shell code this would be pretty useless.

It also changes the new-completion-examples-file to show the use, so
if you use it and don't like the matcher mentioned in the comment you
might wish to modify the code.

Bye
 Sven

diff -u os/Zle/comp1.c Src/Zle/comp1.c
--- os/Zle/comp1.c	Thu Feb  4 19:56:49 1999
+++ Src/Zle/comp1.c	Thu Feb  4 20:15:31 1999
@@ -95,7 +95,8 @@
 
 /**/
 long compcurrent,
-     compnmatches;
+     compnmatches,
+     compmatcher;
 
 /**/
 char *compcontext,
diff -u os/Zle/compctl.c Src/Zle/compctl.c
--- os/Zle/compctl.c	Thu Feb  4 19:56:49 1999
+++ Src/Zle/compctl.c	Thu Feb  4 20:16:46 1999
@@ -1815,6 +1815,7 @@
     { "SUFFIX", PM_SCALAR, VAR(compsuffix) },
     { "IPREFIX", PM_SCALAR, VAR(compiprefix) },
     { "NMATCHES", PM_INTEGER, VAR(compnmatches) },
+    { "MATCHER", PM_INTEGER, VAR(compmatcher) },
     { NULL, 0, NULL }
 };
 
@@ -2117,6 +2118,15 @@
     return 0;
 }
 
+/**/
+static int
+cond_matcher(char **a, int id)
+{
+    if (comp_check())
+	return compmatcher == cond_val(a, 0);
+    return 0;
+}
+
 static struct builtin bintab[] = {
     BUILTIN("compctl", 0, bin_compctl, 0, -1, 0, NULL, NULL),
     BUILTIN("complist", 0, bin_complist, 1, -1, 0, NULL, NULL),
@@ -2140,6 +2150,7 @@
     CONDDEF("after", 0, cond_range, 1, 1, 0),
     CONDDEF("mafter", 0, cond_range, 1, 1, 1),
     CONDDEF("nmatches", 0, cond_nmatches, 1, 1, 0),
+    CONDDEF("matcher", 0, cond_matcher, 1, 1, 0),
 };
 
 static struct funcwrap wrapper[] = {
diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Thu Feb  4 20:08:12 1999
+++ Src/Zle/zle_tricky.c	Thu Feb  4 20:18:12 1999
@@ -3457,6 +3457,7 @@
     if (validlist)
 	return !nmatches;
 
+    compmatcher = 1;
     for (;;) {
 	if (m) {
 	    ms.next = NULL;
@@ -3511,6 +3512,7 @@
 	    break;
 
 	errflag = 0;
+	compmatcher++;
     }
     return 1;
 }
--- om/new-completion-examples	Thu Feb  4 15:55:15 1999
+++ Misc/new-completion-examples	Thu Feb  4 21:49:37 1999
@@ -188,7 +188,8 @@
 # This is intended as a replacement for `complist -f', `complist -/', and
 # `complist -g ...' (but don't use it with other options).
 # This function behaves as if you have a matcher definition like:
-#   compctl -M 'r:|[-.,_/]=* r:|=* m:{a-z}={A-Z} m:-=_ m:.=,'
+#   compctl -M 'r:|[-.,_/]=* r:|=* m:{a-z}={A-Z} m:-=_ m:.=,' \
+#              'm:{a-z}={A-Z} l:|=* r:|=*'
 # so you may want to modify this.
 
 pfiles() {
@@ -256,7 +257,12 @@
     str="${str#*/}"
   done
 
-  ostr="$str:gs/,/*,/:gs/_/*_/:gs./.*/.:gs/-/*[-_]/:gs/./*[.,]/:gs-*[.,]*[.,]*/-../-:gs.**.*."
+  if [[ -matcher 1 ]] then
+    ostr="$str:gs/,/*,/:gs/_/*_/:gs./.*/.:gs/-/*[-_]/:gs/./*[.,]/:gs-*[.,]*[.,]*/-../-:gs.**.*."
+  else
+    ostr="${str%/*}/*${str##*/}*"
+    ostr="$ostr:gs./.*/.:gs.**.*."
+  fi
 
   for ppre in "$ppres[@]"; do
     str="$ostr"

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

