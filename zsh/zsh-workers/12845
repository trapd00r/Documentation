From zsh-workers-return-12845-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Sep 19 15:24:34 2000
Return-Path: <zsh-workers-return-12845-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13154 invoked from network); 19 Sep 2000 15:24:33 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 19 Sep 2000 15:24:33 -0000
Received: (qmail 14868 invoked by alias); 19 Sep 2000 15:24:03 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12845
Received: (qmail 14861 invoked from network); 19 Sep 2000 15:24:02 -0000
Date: Tue, 19 Sep 2000 11:23:45 -0400
From: Clint Adams <schizo@debian.org>
To: Bart Schaefer <schaefer@candle.brasslantern.com>
Cc: zsh-workers@sunsite.auc.dk
Subject: PATCH: files module - PATH_MAX
Message-ID: <20000919112345.A21076@dman.com>
References: <20000917235109.A6793@dman.com> <20000918000915.B6793@dman.com> <1000918063956.ZM24783@candle.brasslantern.com> <20000918132142.B11367@dman.com> <1000919031819.ZM30176@candle.brasslantern.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
User-Agent: Mutt/1.1.2i
In-Reply-To: <1000919031819.ZM30176@candle.brasslantern.com>; from schaefer@candle.brasslantern.com on Tue, Sep 19, 2000 at 03:18:19AM +0000

> Looks good.

This should take care of the last direct dependency on PATH_MAX by the
files module.

Index: Src/Modules/files.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/files.c,v
retrieving revision 1.8
diff -u -r1.8 files.c
--- Src/Modules/files.c	2000/09/18 17:29:07	1.8
+++ Src/Modules/files.c	2000/09/19 15:08:50
@@ -255,14 +255,15 @@
 domove(char *nam, MoveFunc move, char *p, char *q, int flags)
 {
     struct stat st;
-    char *qbuf;
-    char pbuf[PATH_MAX + 1];
-    strcpy(pbuf, unmeta(p));
+    char *pbuf, *qbuf;
+
+    pbuf = ztrdup(unmeta(p));
     qbuf = unmeta(q);
     if(flags & MV_NODIRS) {
 	errno = EISDIR;
 	if(lstat(pbuf, &st) || S_ISDIR(st.st_mode)) {
 	    zwarnnam(nam, "%s: %e", p, errno);
+	    zsfree(pbuf);
 	    return 1;
 	}
     }
@@ -270,6 +271,7 @@
 	int doit = flags & MV_FORCE;
 	if(S_ISDIR(st.st_mode)) {
 	    zwarnnam(nam, "%s: cannot overwrite directory", q, 0);
+	    zsfree(pbuf);
 	    return 1;
 	} else if(flags & MV_INTER) {
 	    nicezputs(nam, stderr);
@@ -277,8 +279,10 @@
 	    nicezputs(q, stderr);
 	    fputs("'? ", stderr);
 	    fflush(stderr);
-	    if(!ask())
+	    if(!ask()) {
+		zsfree(pbuf);
 		return 0;
+	    }
 	    doit = 1;
 	} else if((flags & MV_ASKNW) &&
 		!S_ISLNK(st.st_mode) &&
@@ -289,8 +293,10 @@
 	    fprintf(stderr, "', overriding mode %04o? ",
 		mode_to_octal(st.st_mode));
 	    fflush(stderr);
-	    if(!ask())
+	    if(!ask()) {
+		zsfree(pbuf);
 		return 0;
+	    }
 	    doit = 1;
 	}
 	if(doit && !(flags & MV_ATOMIC))
@@ -298,8 +304,10 @@
     }
     if(move(pbuf, qbuf)) {
 	zwarnnam(nam, "%s: %e", p, errno);
+	zsfree(pbuf);
 	return 1;
     }
+    zsfree(pbuf);
     return 0;
 }
 

