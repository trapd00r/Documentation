From zsh-workers-return-10978-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Apr 27 13:50:50 2000
Return-Path: <zsh-workers-return-10978-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16778 invoked from network); 27 Apr 2000 13:50:43 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Apr 2000 13:50:43 -0000
Received: (qmail 16041 invoked by alias); 27 Apr 2000 13:50:25 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10978
Received: (qmail 16014 invoked from network); 27 Apr 2000 13:50:22 -0000
Date: Thu, 27 Apr 2000 15:27:22 +0200 (MET DST)
Message-Id: <200004271327.PAA19344@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Thu, 27 Apr 2000 10:53:44 +0200
	(MET DST)
Subject: Re: PATCH: Re: Lots of flickering in menu-selection, and a send-break problem


I wrote:

> Bart Schaefer wrote:
> 
> ...
> 
> > You get similar flickering if you abort out of a scrolling menu-selection
> > with C-u (kill-whole-line).  I don't see the flicker when not scrolling.
> 
> Ick. No patch for this yet. Menu-selection redisplays the (part of
> the) list again without the mark when it's finished. That's a good
> thing, I think. But then kill-whole-line comes and clears the list
> again (same happens with all the other widgets that clear the list).
> 
> I think adding a ZLE_* flag that says that the widget clears the
> screen and testing the flag in menu-selection to avoid re-displaying
> the list is the best solution. A problem might be the functions that
> clear the list only in some cases...

Or we just make sure that the screen isn't cleared before that last
list-display done by menu-selection, just as we do while
menu-selection is active.

Yes, I know, not a really nice solution, but it's such a sweet little
patch: the first hunk of the patch below, the rest is for the changed
cursor-wrap-around suggested by Bart, which seemed even more sensible
after thinking about it. The only irritating effect is that moving
left when at the top-left match wraps you around to the bottom-right
match. Is that how pine works?

Bye
 Sven

Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.10
diff -u -r1.10 complist.c
--- Src/Zle/complist.c	2000/04/27 08:55:07	1.10
+++ Src/Zle/complist.c	2000/04/27 13:22:45
@@ -1458,7 +1458,7 @@
 	amatches = oamatches;
 	return 1;
     }
-    if (inselect)
+    if (inselect || mlbeg >= 0)
 	clearflag = 0;
 
     mscroll = 0;
@@ -1571,7 +1571,7 @@
     Thingy cmd;
     Menustack u = NULL;
     int i = 0, acc = 0, wishcol = 0, setwish = 0, oe = onlyexpl, wasnext = 0;
-    int space, lbeg = 0, step = 1;
+    int space, lbeg = 0, step = 1, wrap;
     char *s;
 
     if (fdat || (dummy && (!(s = getsparam("MENUSELECT")) ||
@@ -1809,10 +1809,15 @@
 		   cmd == Th(z_downlineorhistory) ||
 		   cmd == Th(z_downlineorsearch) ||
 		   cmd == Th(z_vidownlineorhistory)) {
+	    wrap = 0;
+
+	down:
+
 	    do {
 		if (mline == mlines - 1) {
 		    p -= mline * mcols;
 		    mline = 0;
+		    wrap |= 1;
 		} else {
 		    mline++;
 		    p += mcols;
@@ -1820,14 +1825,22 @@
 		if (adjust_mcol(wishcol, &p, NULL))
 		    continue;
 	    } while (!*p);
+
+	    if (wrap == 1)
+		goto right;
 	} else if (cmd == Th(z_uphistory) ||
 		   cmd == Th(z_uplineorhistory) ||
 		   cmd == Th(z_uplineorsearch) ||
 		   cmd == Th(z_viuplineorhistory)) {
+	    wrap = 0;
+
+	up:
+
 	    do {
 		if (!mline) {
 		    mline = mlines - 1;
 		    p += mline * mcols;
+		    wrap |= 1;
 		} else {
 		    mline--;
 		    p -= mcols;
@@ -1835,6 +1848,9 @@
 		if (adjust_mcol(wishcol, &p, NULL))
 		    continue;
 	    } while (!*p);
+
+	    if (wrap == 1)
+		goto left;
 	} else if (cmd == Th(z_emacsforwardword) ||
 		   cmd == Th(z_viforwardword) ||
 		   cmd == Th(z_viforwardwordend) ||
@@ -1893,7 +1909,9 @@
 	} else if (cmd == Th(z_beginningofhistory)) {
 	    int ll;
 	    Cmatch **lp;
+
 	top:
+
 	    ll = mline;
 	    lp = p;
 	    while (mline) {
@@ -1911,7 +1929,9 @@
 	} else if (cmd == Th(z_endofhistory)) {
 	    int ll;
 	    Cmatch **lp;
+
 	bottom:
+
 	    ll = mline;
 	    lp = p;
 	    while (mline < mlines - 1) {
@@ -1927,33 +1947,55 @@
 	    mline = ll;
 	    p = lp;
 	} else if (cmd == Th(z_forwardchar) || cmd == Th(z_viforwardchar)) {
-	    int omcol = mcol;
-	    Cmatch *op = *p;
+	    int omcol;
+	    Cmatch *op;
+
+	    wrap = 0;
+
+	right:
 
+	    omcol = mcol;
+	    op = *p;
+
 	    do {
 		if (mcol == mcols - 1) {
 		    p -= mcol;
 		    mcol = 0;
+		    wrap |= 2;
 		} else {
 		    mcol++;
 		    p++;
 		}
 	    } while (!*p || (mcol != omcol && *p == op));
 	    wishcol = mcol;
+
+	    if (wrap == 2)
+		goto down;
 	} else if (cmd == Th(z_backwardchar) || cmd == Th(z_vibackwardchar)) {
-	    int omcol = mcol;
-	    Cmatch *op = *p;
+	    int omcol;
+	    Cmatch *op;
 
+	    wrap = 0;
+
+	left:
+
+	    omcol = mcol;
+	    op = *p;
+
 	    do {
 		if (!mcol) {
 		    mcol = mcols - 1;
 		    p += mcol;
+		    wrap |= 2;
 		} else {
 		    mcol--;
 		    p--;
 		}
 	    } while (!*p || (mcol != omcol && *p == op));
 	    wishcol = mcol;
+
+	    if (wrap == 2)
+		goto up;
 	} else if (cmd == Th(z_beginningofbufferorhistory) ||
 		   cmd == Th(z_beginningofline) ||
 		   cmd == Th(z_beginningoflinehist) ||

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

