From zsh-workers-return-7264-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Jul 23 12:36:15 1999
Return-Path: <zsh-workers-return-7264-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14815 invoked from network); 23 Jul 1999 12:36:13 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Jul 1999 12:36:13 -0000
Received: (qmail 139 invoked by alias); 23 Jul 1999 12:36:05 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7264
Received: (qmail 132 invoked from network); 23 Jul 1999 12:36:04 -0000
Message-Id: <9907231205.AA30710@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: 3.1.6-test-2: Completion/Commands don't override bindings
Date: Fri, 23 Jul 1999 14:05:06 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

This patch makes compdef -k use the -n option, which prevents a key being
bound if it is something other than undefined-key.  I've used it in the
widgets in Completion/Commands, so that people loading the completion
system don't get their own bindings randomly overridden.

I could have avoided forking for the test with some temporary files.  I've
always wanted a non-forking version of $(...) (actually, it might be quite
straightforward if you can think up some syntax, only not right now).  The
dumped file doesn't need this, since the bindkey command is never written.

--- Completion/Commands/_correct_filename.new	Fri Jul 23 13:35:45 1999
+++ Completion/Commands/_correct_filename	Fri Jul 23 13:35:55 1999
@@ -1,4 +1,4 @@
-#compdef -k complete-word \C-xC
+#compdef -kn complete-word \C-xC
 
 # Function to correct a filename.  Can be used as a completion widget,
 # or as a function in its own right, in which case it will print the
--- Completion/Commands/_correct_word.new	Fri Jul 23 13:35:46 1999
+++ Completion/Commands/_correct_word	Fri Jul 23 13:36:01 1999
@@ -1,4 +1,4 @@
-#compdef -k complete-word \C-xc
+#compdef -kn complete-word \C-xc
 
 # Simple completion front-end implementing spelling correction.
 # The maximum number of errors is set quite high, and
--- Completion/Commands/_expand_word.new	Fri Jul 23 13:35:46 1999
+++ Completion/Commands/_expand_word	Fri Jul 23 13:36:05 1999
@@ -1,4 +1,4 @@
-#compdef -k complete-word \C-xe
+#compdef -kn complete-word \C-xe
 
 # Simple completion front-end implementing expansion.
 #
--- Completion/Commands/_history_complete_word.new	Fri Jul 23 13:35:46 1999
+++ Completion/Commands/_history_complete_word	Fri Jul 23 13:36:13 1999
@@ -1,2 +1,2 @@
-#compdef -k complete-word \e/
+#compdef -kn complete-word \e/
 compgen -Q -H 0 ''
--- Completion/Commands/_most_recent_file.new	Fri Jul 23 13:35:46 1999
+++ Completion/Commands/_most_recent_file	Fri Jul 23 13:36:18 1999
@@ -1,4 +1,4 @@
-#compdef -k complete-word \C-xm
+#compdef -kn complete-word \C-xm
 
 # Complete the most recent file matching the pattern on the line so
 # far: globbing is active, i.e. *.txt will be expanded to the most recent
--- Completion/Commands/_read_comp.new	Fri Jul 23 13:35:46 1999
+++ Completion/Commands/_read_comp	Fri Jul 23 13:36:26 1999
@@ -1,4 +1,4 @@
-#compdef -k complete-word \C-x\C-r
+#compdef -kn complete-word \C-x\C-r
 
 # This allows an on-the-fly choice of completions.  On typing the key
 # sequence given above, you will be prompted for a string of arguments.  If
--- Completion/Core/compinit.new	Fri Jul  9 14:11:57 1999
+++ Completion/Core/compinit	Fri Jul 23 13:54:41 1999
@@ -114,7 +114,8 @@
 # whose name is given as the first argument be autoloaded. When defining
 # a function for command names the `-n' option may be given and keeps
 # the definitions from overriding any previous definitions for the
-# commands.
+# commands; with `-k', the `-n' option prevents compdef from rebinding
+# a key sequence which is already bound.
 # For deleting definitions, the `-d' option must be given. Without the
 # `-p' option, this deletes definitions for functions for the commands
 # whose names are given as arguments. If combined with the `-p' option
@@ -202,6 +203,10 @@
 
       # And bind the keys...
       for i; do
+        if [[ -n $new ]]; then
+	   bindkey "$i" | read -A opt
+	   [[ $opt[-1] = undefined-key ]] || continue
+	fi
         bindkey "$i" "$func"
       done
       ;;
@@ -354,7 +359,7 @@
       shift _i_line
       case $_i_tag in
       (\#compdef)
-	if [[ $_i_line[1] = -[pk] ]]; then
+	if [[ $_i_line[1] = -[pk](n|) ]]; then
 	  compdef ${_i_line[1]}a "${_i_file:t}" "${(@)_i_line[2,-1]}"
 	else
 	  compdef -na "${_i_file:t}" "${_i_line[@]}"
--- Doc/Zsh/compsys.yo.new	Thu Jul 22 14:39:11 1999
+++ Doc/Zsh/compsys.yo	Fri Jul 23 13:41:43 1999
@@ -151,7 +151,9 @@
 tt(complist) module is loaded (see
 ifzman(zmanref(zshmodules))\
 ifnzman(noderef(The complist Module))\
-), the tt(menu-select) widget can be used, too.
+), the tt(menu-select) widget can be used, too.  If the option tt(-n) is
+also given, the bindings will not be used if the key is already bound (that
+is, is bound to something other than tt(undefined-key)).
 
 The widget is then bound to all the var(key-sequences) given, if any: when
 one of the var(key-sequences) is typed, the function in the file will
@@ -203,7 +205,9 @@
 tt(complete-word), tt(delete-char-or-list), tt(expand-or-complete),
 tt(expand-or-complete-prefix), tt(list-choices), tt(menu-complete),
 tt(menu-expand-or-complete), and tt(reverse-menu-complete), as well as
-tt(menu-select) if the tt(complist) module is loaded.
+tt(menu-select) if the tt(complist) module is loaded.  The option tt(-n)
+prevents the key being bound if it is already to bound to something other
+than tt(undefined-key).
 
 In each of the forms supporting it the tt(-a) option makes the
 var(function) autoloadable (exactly equivalent to

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

