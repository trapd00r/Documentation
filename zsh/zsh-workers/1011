From A.Main@dcs.warwick.ac.uk Thu May  9 01:46:18 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3) with ESMTP id BAA05720 for <mason@werple.mira.net.au>; Thu, 9 May 1996 01:46:16 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id LAA07243; Wed, 8 May 1996 11:31:31 -0400 (EDT)
Resent-Date: Wed, 8 May 1996 11:31:31 -0400 (EDT)
From: Zefram <A.Main@dcs.warwick.ac.uk>
Message-Id: <3623.199605081530@cray.dcs.warwick.ac.uk>
Subject: Redirection bugs, and fixes
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Wed, 8 May 1996 16:30:11 +0100 (BST)
X-Patch: 90
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]7473.22
X-US-Congress: Moronic fuckers
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"rmwhb3.0.5n1.IvBan"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/1011
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 5646
Status: O

-----BEGIN PGP SIGNED MESSAGE-----

There are a few remaining bugs in redirection, particularly in closing
already redirected fds.  The patch below fixes all the problems I know
about in this area.  The patch to utils.c below fixes a little problem
with movefd(), that it would always move its argument, even if it was
already >=10.

The incantation to demonstrate one of the bugs fixed here is:

% echo foo >file >&-
% echo bar
% cat file >/dev/tty
bar
% 

I've posted most of this code before, but it hasn't got into the
baseline yet.  Some of the code is new -- a slightly improved version
of the old patch.  This patch is against 2.6-beta17.

On other issues (does anyone read these rambling commentaries I post?),
as I now have some free time again, and the baseline is now up to date
with my multitudinous ZLE patches, I plan to work seriously on making
ZLE 8-bit clean.  If anyone else has done a significant amount of work
in this area, please let me know.

And one more thing: I noticed that Src/.indent.pro disappeared between
beta16 and beta17.  I don't think it was in any of the hzoli releases.
I don't use indent myself, but this seems a rather silly change.  Zoltan,
was there some reason for removing this?

 -zefram

      Index: Src/exec.c
      *** Src/exec.c:1.1.1.8	Tue May  7 23:24:16 1996
      --- Src/exec.c	Tue May  7 23:55:44 1996
      ***************
      *** 909,944 ****
        void
        closemn(struct multio **mfds, int fd)
        {
      !     if (mfds[fd]) {
      ! 	if (mfds[fd]->ct > 1) {
      ! 	    struct multio *mn = mfds[fd];
      ! 	    char buf[TCBUFSIZE];
      ! 	    int len, i;
      ! 
      ! 	    if (zfork()) {
      ! 		for (i = 0; i < mn->ct; i++)
      ! 		    zclose(mn->fds[i]);
      ! 		zclose(mn->pipe);
      ! 		return;
      ! 	    }
        
      ! 	    /* pid == 0 */
      ! 	    closeallelse(mn);
      ! 	    if (mn->rflag) {
      ! 		/* tee process */
      ! 		while ((len = read(mn->pipe, buf, TCBUFSIZE)) > 0)
      ! 		    for (i = 0; i < mn->ct; i++)
      ! 			write(mn->fds[i], buf, len);
      ! 	    } else {
      ! 		/* cat process */
      ! 		for (i = 0; i < mn->ct; i++)
      ! 		    while ((len = read(mn->fds[i], buf, TCBUFSIZE)) > 0)
      ! 			write(mn->pipe, buf, len);
      ! 	    }
      ! 	    _exit(0);
      ! 	}
      ! 	mfds[fd] = NULL;
            }
        }
        
        /* close all the mnodes (failure) */
      --- 909,944 ----
        void
        closemn(struct multio **mfds, int fd)
        {
      !     struct multio *mn = mfds[fd];
      !     char buf[TCBUFSIZE];
      !     int len, i;
        
      !     if (!mfds[fd] || mfds[fd]->ct < 2)
      ! 	return;
      ! 
      !     if (zfork()) {
      ! 	for (i = 0; i < mn->ct; i++)
      ! 	    zclose(mn->fds[i]);
      ! 	zclose(mn->pipe);
      ! 	mn->ct = 1;
      ! 	mn->fds[0] = fd;
      ! 	return;
      !     }
      ! 
      !     /* pid == 0 */
      !     closeallelse(mn);
      !     if (mn->rflag) {
      ! 	/* tee process */
      ! 	while ((len = read(mn->pipe, buf, TCBUFSIZE)) > 0)
      ! 	    for (i = 0; i < mn->ct; i++)
      ! 		write(mn->fds[i], buf, len);
      !     } else {
      ! 	/* cat process */
      ! 	for (i = 0; i < mn->ct; i++)
      ! 	    while ((len = read(mn->fds[i], buf, TCBUFSIZE)) > 0)
      ! 		write(mn->pipe, buf, len);
            }
      +     _exit(0);
        }
        
        /* close all the mnodes (failure) */
      ***************
      *** 1428,1434 ****
        		    init_io();
        		break;
        	    case CLOSE:
      ! 		if (!forked && fn->fd1 < 10)
        		    save[fn->fd1] = movefd(fn->fd1);
        		closemn(mfds, fn->fd1);
        		zclose(fn->fd1);
      --- 1428,1434 ----
        		    init_io();
        		break;
        	    case CLOSE:
      ! 		if (!forked && fn->fd1 < 10 && save[fn->fd1] == -1)
        		    save[fn->fd1] = movefd(fn->fd1);
        		closemn(mfds, fn->fd1);
        		zclose(fn->fd1);
      ***************
      *** 1437,1443 ****
        	    case MERGEOUT:
        		if (fn->fd2 == FD_COPROC)
        		    fn->fd2 = (fn->type == MERGEOUT) ? coprocout : coprocin;
      ! 		closemn(mfds, fn->fd1);
        		fil = dup(fn->fd2);
        		if (fil == -1) {
        		    char fdstr[4];
      --- 1437,1444 ----
        	    case MERGEOUT:
        		if (fn->fd2 == FD_COPROC)
        		    fn->fd2 = (fn->type == MERGEOUT) ? coprocout : coprocin;
      ! 		else if(fn->fd2 < 10)
      ! 		    closemn(mfds, fn->fd2);
        		fil = dup(fn->fd2);
        		if (fil == -1) {
        		    char fdstr[4];
      Index: Src/utils.c
      *** Src/utils.c:1.1.1.7	Tue May  7 23:24:36 1996
      --- Src/utils.c	Tue May  7 23:55:46 1996
      ***************
      *** 859,871 ****
        {
            int fe;
        
      !     if (fd == -1)
        	return fd;
        #ifdef F_DUPFD
            fe = fcntl(fd, F_DUPFD, 10);
        #else
      !     if ((fe = dup(fd)) < 10)
      ! 	fe = movefd(fe);
        #endif
            close(fd);
            fdtable[fd] = 0;
      --- 859,870 ----
        {
            int fe;
        
      !     if (fd == -1 || fd >= 10)
        	return fd;
        #ifdef F_DUPFD
            fe = fcntl(fd, F_DUPFD, 10);
        #else
      !     fe = movefd(dup(fd));
        #endif
            close(fd);
            fdtable[fd] = 0;

-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBMY/tEnD/+HJTpU/hAQEqoQP/SL1+I0gCqrbAXGier3eD4lnLqMtfoFVj
TIWW75o/CIvBWzJwZnPrD78oBM+AmKjL015CwTnQy6G8FnAE/er/amNqmwHWR2u/
s6+9z0/D6xppoBbmQrkQldLzH4AcENCuFcqoMlXnehMDsUhHV/yRXMBjGRQwEsfL
fab64op3XtQ=
=441j
-----END PGP SIGNATURE-----


