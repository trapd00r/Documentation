From zsh-workers-request@math.gatech.edu Thu Jan 21 10:45:11 1999
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19994 invoked from network); 21 Jan 1999 10:45:11 -0000
Received: from ns2.primenet.com.au (HELO primenet.com.au) (7795@203.24.36.3)
  by ns1.primenet.com.au with SMTP; 21 Jan 1999 10:45:11 -0000
Received: (qmail 6960 invoked from network); 21 Jan 1999 10:44:56 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns2.primenet.com.au with SMTP; 21 Jan 1999 10:44:56 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id FAA24427;
	Thu, 21 Jan 1999 05:37:40 -0500 (EST)
Resent-Date: Thu, 21 Jan 1999 05:37:40 -0500 (EST)
Date: Thu, 21 Jan 1999 11:36:34 +0100 (MET)
Message-Id: <199901211036.LAA18556@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
In-reply-to: "Bart Schaefer"'s message of Wed, 6 Jan 1999 23:36:32 -0800
Subject: Re: experimental new style completion
Resent-Message-ID: <"Yb7gt2.0.cz5.qDmfs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4941
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Bart Schaefer wrote:

> May I suggest that there's no reason to abbreviate names of this sort.
> 
>  `command' (not `cmd')      we are completing in command position
>  `argument' (not `arg')     we are completing in argument position
>  `redirect' (not `redir')   ... after a redirection operator
>  `math'                     ... in a math environment
>  `subscript' (not `subscr') ... in a subscript
>  `value'                    ... in the value of an variable assignment
>  `condition'                ... inside `[[...]]'
> 

The patch below does this.

> Also ... I may be mistaken, but isn't it possible to be in both the command
> position and after a redirection operator (e.g. readnullcmd) or in both a
> math context and inside a subscript?  Is a single context identifier enough?

This is not changed by the patch. The intended usage is to call a
provided shell function or alias that generates the matches for
`included' context types (see the use of `compalso' in the example
file). Anyway after thinking more about this I see a real use for this 
only with `math' and `subscript' and probaly using the `math' stuff in 
some cases in conditions. `command' and `redirection' are mutually
exclusive as far as I can see.

Bye
 Sven

*** Src/Zle/zle_tricky.c.old	Thu Jan 21 10:47:03 1999
--- Src/Zle/zle_tricky.c	Thu Jan 21 11:03:02 1999
***************
*** 3241,3249 ****
  		zsfree(compcommand);
  		compcommand = "";
  		if (lincmd)
! 		    compcontext = (insubscr ? "subscr" : "cmd");
  		else if (linredir)
! 		    compcontext = "redir";
  		else
  		    switch (inwhat) {
  		    case IN_ENV:
--- 3241,3249 ----
  		zsfree(compcommand);
  		compcommand = "";
  		if (lincmd)
! 		    compcontext = (insubscr ? "subscript" : "command");
  		else if (linredir)
! 		    compcontext = "redirect";
  		else
  		    switch (inwhat) {
  		    case IN_ENV:
***************
*** 3253,3270 ****
  			break;
  		    case IN_MATH:
  			if (insubscr) {
! 			    compcontext = "subscr";
  			    compcommand = varname ? varname : "";
  			} else
  			    compcontext = "math";
  			usea = 0;
  			break;
  		    case IN_COND:
! 			compcontext = "cond";
  			break;
  		    default:
  			if (cmdstr) {
! 			    compcontext = "arg";
  			    compcommand = cmdstr;
  			} else {
  			    compcontext = "value";
--- 3253,3270 ----
  			break;
  		    case IN_MATH:
  			if (insubscr) {
! 			    compcontext = "subscript";
  			    compcommand = varname ? varname : "";
  			} else
  			    compcontext = "math";
  			usea = 0;
  			break;
  		    case IN_COND:
! 			compcontext = "condition";
  			break;
  		    default:
  			if (cmdstr) {
! 			    compcontext = "argument";
  			    compcommand = cmdstr;
  			} else {
  			    compcontext = "value";
*** Src/example.old	Thu Jan 21 10:47:18 1999
--- Src/example	Thu Jan 21 11:25:50 1999
***************
*** 42,47 ****
--- 42,53 ----
  
  alias compsub='do-complete "$@" || return 1'
  
+ # This searches $1 in the array for normal completions and calls the result.
+ 
+ compalso() {
+   1="$comps[$1]"
+   [[ -z "$1" ]] || call-complete "$@"
+ }
  
  # This generates matches. The first argument is something we got from one
  # of the associative arrays above. This is expected to be either the name
***************
*** 81,87 ****
    # For arguments we use the `do-complete' function below called via the
    # convenience alias `compsub'.
  
!   if [[ $CONTEXT == arg || $CONTEXT == cmd ]] then
      compsub
    else
      # Let's see if we have a special completion definition for the other
--- 87,93 ----
    # For arguments we use the `do-complete' function below called via the
    # convenience alias `compsub'.
  
!   if [[ $CONTEXT == argument || $CONTEXT == command ]] then
      compsub
    else
      # Let's see if we have a special completion definition for the other
***************
*** 90,100 ****
      comp=''
  
      case $CONTEXT in
!     redir)  comp="$comps[--redir--]";;
      math)   comp="$comps[--math--]";;
!     subscr) comp="$comps[--subscr--]";;
      value)  comp="$comps[--value--]";;
!     cond)   comp="$comps[--cond--]";;
      esac
  
      # If not, we use default completion, if any.
--- 96,106 ----
      comp=''
  
      case $CONTEXT in
!     redirect)  comp="$comps[--redir--]";;
      math)   comp="$comps[--math--]";;
!     subscript) comp="$comps[--subscr--]";;
      value)  comp="$comps[--value--]";;
!     condition)   comp="$comps[--cond--]";;
      esac
  
      # If not, we use default completion, if any.
***************
*** 114,120 ****
    # two strings we have search in the completion definition arrays (e.g.
    # a path and the last path name component).
  
!   if [[ $CONTEXT == cmd ]] then
      comp="$comps[--command--]"
      [[ -z "$comp" ]] || call-complete "$comp" "$@" || return 1
      return 0
--- 120,126 ----
    # two strings we have search in the completion definition arrays (e.g.
    # a path and the last path name component).
  
!   if [[ $CONTEXT == command ]] then
      comp="$comps[--command--]"
      [[ -z "$comp" ]] || call-complete "$comp" "$@" || return 1
      return 0
***************
*** 162,170 ****
    shift
    (( CURRENT-- ))
    if [[ CURRENT -eq 0 ]] then
!     CONTEXT=cmd
    else
!     CONTEXT=arg
    fi
    compsub
  }
--- 168,176 ----
    shift
    (( CURRENT-- ))
    if [[ CURRENT -eq 0 ]] then
!     CONTEXT=command
    else
!     CONTEXT=argument
    fi
    compsub
  }
***************
*** 178,185 ****
  __command=( -c )
  
  defcomp --math-- __math
- defcomp --subscr-- __math
  __math=( -v )
  
  # A simple pattern completion, just as an example.
  
--- 184,196 ----
  __command=( -c )
  
  defcomp --math-- __math
  __math=( -v )
+ 
+ defcomp --subscr-- __subscr
+ __subscr() {
+   compalso --math-- "$@"
+   # ...probably other stuff
+ }
  
  # A simple pattern completion, just as an example.
  

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

