From zsh-workers-return-16819-mason-zsh=primenet.com.au@sunsite.dk Wed Mar 13 09:26:24 2002
Return-Path: <zsh-workers-return-16819-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19175 invoked from network); 13 Mar 2002 09:26:22 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 13 Mar 2002 09:26:22 -0000
Received: (qmail 17175 invoked by alias); 13 Mar 2002 09:26:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16819
Received: (qmail 17164 invoked from network); 13 Mar 2002 09:26:16 -0000
From: Sven Wischnowsky <wischnow@berkom.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-ID: <15503.6928.151944.873784@wischnow.berkom.de>
Date: Wed, 13 Mar 2002 10:25:36 +0100
To: zsh-workers@sunsite.dk
Subject: Re: Redirection completion
In-Reply-To: <20020312131651.GA28986@logica.com>
References: <15496.46201.219885.149096@wischnow.berkom.de>
	<22196.1015596405@csr.com>
	<15496.50795.888698.447601@wischnow.berkom.de>
	<15500.28153.769884.199234@wischnow.berkom.de>
	<20020312131651.GA28986@logica.com>
X-Mailer: VM 6.95 under 21.5 (patch 3) "asparagus" XEmacs Lucid


Ok, below is the next version, I'm going to commit it this time.

It uses the comma-separated sub-contexts discussed. For values it is
`-value-,<name>,<cmd>', so I've not put the parameter type in it, as
suggested by Oliver. For redirection it is `-redirect-,<op>,<cmd>'.

_value and _redirect try multiple strings of this form to allow easier
definition of defaults.  This is done by replacing parts with the
string `-default-' in the hope that this is more consistent and to be
able to distinguish this case from the case that the command name part
can't be set because there isn't a command name on the line. (Hope
this is ok, Bart?)

For example, completion after `foo=<TAB>' makes _value try:

  1) -value-,foo,
  2) -value-,foo,-default-
  3) -value-,-default-,-default-

in this order. For association-values this is also re-dispatched with
`-value-,foo-key,' (this was also done by previous patches but not so
cleanly).

Order of lookup and of the parts and use of `-default-' can be changed
if noone likes it (except me). This order is partly the result of using
brace extension in the calls to _dispatch. But it's important, affects
also redirection and the two orders are connected, I think, by the
question which of the two parts is the more important one. I.e.:
should `-redirect-,-default-,echo' or `-redirect-,>,-default-' take
precedence?

And another question where the default-handling is important is: when
should post-patterns (-P) be tried? Currently this is done only if we
would otherwise use the function defined for the least specific
context (the one with all parts being `-default-').

In the sub-context used for looking up styles it always uses the most
specific version.


Oliver Kiddle wrote:

> ...
> 
> I've tried yesterdays patch and things don't seem to be quite working
> yet - I'm just getting file completion. I also had limited success with
> pattern completions for values and the old -T system. I've put one at
> the end. If you fix it, please commit it yourself. I perhaps just
> needed those new -p and -N changes which I was going to suggest.

Can't say anything about this without more information. Have you
remembered to remove the dump-file?

> I also got _gzip to handle GZIP which I'll post once you've got this
> latest change done and I've fixed it not to use -T. The compset -q and
> faking $words[0] made me wonder that it wouldn't be a good idea to have
> an option to compset to fake $words[0] as well. I think we do it in
> quite a few other places.

A few, yes. But I don't think that we really need support from builtins
for every little peace of shell code ;-)

> ...
> 
> My worry was that if, for example in _gzip we wanted to handle all the
> redirections we will need something like:
> 
> #compdef gzip gunzip gzcat -redirect->-gzip -redirect-<-gzip
> -redirect-2>-gzip -redirect-<-gunzip -redirect->-gunzip
> -redirect-2>gunzip -redirect-<-gzcat -redirect->-gzcat
> -redirect-2>-gzcat -value-GZIP
> 
> so we either now use pattern completions a lot or allow
> compdef {,-redirect-{<,>,2>}}-{gzip,gzcat,gunzip}
> 
> or have I misunderstood something somewhere?

Aha. Ugh. No. See above, `-redirect-,-default-,gzip' etc. are enough.
Not that short either, I admit, but allowing braces there isn't *that*
simple (well, it isn't that hard either, a bit of `eval' with an array
and some quoting magic, but...).

> ..
> 
> I've failed to spot the connection with default completions. Can you
> summarise the issues perhaps?

I wished I could. It's currently more of a feeling than anything else.
I may well be on a completely wrong track, I'll try to think some more.

> On other points: a comma seems best as the separator though I'm not
> particularly fussed. Quoting is probably the best solution to commands
> with the separator in their name. Using a hyphen may be confusing
> because it might cause problems if the trailing - of -redirect- can be
> the separator as well as part of the context name.

Btw. currently none of the functions tries to do anything about
quoting any characters. And with the fixed format it probably isn't
that much of a problem, I think, especially if we keep the order of
the parts, because a comma can't appear in neither the redirection
operator nor the parameter name.

> ...
> 
> It is also arguable that for normal completion, we should start with
> something like -command-.

Yes, that thought crossed my mind, too. I quickly looked the other way.

> > > with the cursor positioned ON the `>', what context(s) get tried when I
> > > press TAB?  I might expect it to complete file descriptor numbers ...
> > > and in that case, I'd want to complete only the numbers of *valid* file
> > > descriptors, but those aren't available to shell functions (yet).
> > 
> > Yes that would be nice.
> > 
> > Currently you should get argument completion (but strangely, trying
> > `echo ><TAB>' shows that `-command-' is tried, only after `echo foo ><TBA>'
> > do we get argument completion -- I'll have to have a look).
> 
> There are a few places where the division into contexts is not as ideal
> as would be nice. Hence not being able to complete glob qualifiers,
> parameter expansion flags etc as we do for subscript flags.

About that <tab> ON the redirection operator: that was a small bug in
the C-code. It didn't insert the `x' for the empty word completion
thingy.

For what Oliver wrote: one could say that's really a problem of the
C-code not knowing any better what to report. One could also say that
somewhere near the beginning of the completion system we could look at
$BUFFER to find out if we are in a special context.

> #compdef -T values -P LC_* LANG

I've turned this into the _locales function in the patch.


Bart Schaefer wrote:

> If we do stick with hyphens, what does the context look like in the case
> of completion after:
> 
> zsh% - 2>

(See above for the quoting issue.) The problem here is of course, that
`- foo <TAB>' should report `echo' as the command but currently
doesn't. I've got some weird ideas about functions being declared to
take precedence over the normal context handling (and that may be
connected with the globbing-flag completion Oliver mentioned), but
nothing to talk about yet.


Bye
  Sven

Index: Completion/compdump
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/compdump,v
retrieving revision 1.3
diff -u -r1.3 compdump
--- Completion/compdump	4 Mar 2002 08:53:42 -0000	1.3
+++ Completion/compdump	13 Mar 2002 09:20:36 -0000
@@ -35,43 +35,34 @@
 
 print "#files: $#_d_files" > $_d_file
 
-# First dump the arrays _comps, _servicecomps and _patcomps.  The quoting
+# Dump the arrays _comps, _services and _patcomps.  The quoting
 # hieroglyphics ensure that a single quote inside a variable is itself
 # correctly quoted.
 
-for _d_name in $_comp_assocs; do
-
-  print "\n\ntypeset -gA _$_d_name _service$_d_name _pat$_d_name _postpat$_d_name"
-
-  _d_tmp="_${_d_name}"
-  print "\n_${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
-
-  _d_tmp="_service${_d_name}"
-  print "\n_service${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_comps=(" >> $_d_file
+for _d_f in ${(ok)_comps}; do
+  print -r - "${(q)_d_f}" "${(q)_comps[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
-  _d_tmp="_pat${_d_name}"
-  print "\n_pat${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_services=(" >> $_d_file
+for _d_f in ${(ok)_services}; do
+  print -r - "${(q)_d_f}" "${(q)_services[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
-  _d_tmp="_postpat${_d_name}"
-  print "\n_postpat${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_patcomps=(" >> $_d_file
+for _d_f in ${(ok)_patcomps}; do
+  print -r - "${(q)_d_f}" "${(q)_patcomps[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
+_d_tmp="_postpatcomps"
+print "\n_postpatcomps=(" >> $_d_file
+for _d_f in ${(ok)_postpatcomps}; do
+  print -r - "${(q)_d_f}" "${(q)_postpatcomps[$_d_f]}"
 done >> $_d_file
+print ")" >> $_d_file
 
 print "\n_compautos=(" >> $_d_file
 for _d_f in "${(ok@)_compautos}"; do
Index: Completion/compinit
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/compinit,v
retrieving revision 1.7
diff -u -r1.7 compinit
--- Completion/compinit	4 Mar 2002 08:53:42 -0000	1.7
+++ Completion/compinit	13 Mar 2002 09:20:36 -0000
@@ -102,21 +102,10 @@
   esac
 done
 
-# The name suffixes for the associative arrays containing the functions
-# to call.
-
-typeset -gUa _comp_assocs
-
-_comp_assocs=(comps)
-
 # The associative arrays containing the definitions for the commands and
 # services.
-# Definitions for patterns will be stored in the associations `_pat*'
-# and `_postpat*'.
-# The assocs for the other function types are created automatically by
-# compdef.
 
-typeset -gA _comps _servicecomps _patcomps _postpatcomps
+typeset -gA _comps _services _patcomps _postpatcomps
 
 # `_compautos' contains the names and options for autoloaded functions
 # that get options.
@@ -191,9 +180,6 @@
 # The option `-P' is like `-p', but the function will be called after
 # trying to find a function defined for the command on the line if no
 # such function could be found.
-# In each of these cases the argument list may also contain `-T assoc'
-# options to specify the associactive arrays to which the following
-# definitions should be added.
 # With the `-k' option a function for a special completion keys is 
 # defined and immediately bound to those keys. Here, the extra arguments
 # are the name of one of the builtin completion widgets and any number
@@ -209,8 +195,7 @@
 # whose names are given as arguments. If combined with the `-p' option
 # it deletes the definitions for the patterns given as argument.
 # The `-d' option may not be combined with the `-k' option, i.e.
-# definitions for key function can not be removed. But one `-T assoc'
-# option may follow the `-d' to say which definitions should be removed.
+# definitions for key function can not be removed.
 #
 # Examples:
 #
@@ -232,7 +217,7 @@
 #   delete the definitions for the command names `bar' and `baz'
 
 compdef() {
-  local opt autol type func delete new i ret=0 cmd svc assoc=comps
+  local opt autol type func delete new i ret=0 cmd svc
 
   # Get the options.
 
@@ -277,38 +262,26 @@
 
     if [[ "$1" = *\=* ]]; then
       while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          if [[ "$1" = *\=* ]]; then
-	    cmd="${1%%\=*}"
-	    svc="${1#*\=}"
-            func="$_comps[${(e):-\${(k)_service${assoc}[(R)$svc]:-$svc}}]"
-            [[ -n ${(e):-\$_service${assoc}[$svc]} ]] &&
-                svc=${(e):-\$_service${assoc}[$svc]}
-	    [[ -z "$func" ]] &&
-	        func="${${(e):-\$_pat${assoc}[(K)$svc][1]}:-${(e):-\$_postpat${assoc}[(K)$svc][1]}}"
-            if [[ -n "$func" ]]; then
-	      eval "_${assoc}"'[$cmd]="$func"'
-	      eval "_service${assoc}"'[$cmd]="$svc"'
-	    else
-	      echo "$0: unknown command or service: $svc"
-	      ret=1
-	    fi
+        if [[ "$1" = *\=* ]]; then
+	  cmd="${1%%\=*}"
+	  svc="${1#*\=}"
+          func="$_comps[${_services[(R)$svc]:-$svc}]"
+          [[ -n ${_services[$svc]} ]] &&
+              svc=${_services[$svc]}
+	  [[ -z "$func" ]] &&
+	      func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}"
+          if [[ -n "$func" ]]; then
+	    _comps[$cmd]="$func"
+	    _services[$cmd]="$svc"
 	  else
-	    echo "$0: invalid argument: $1"
+	    echo "$0: unknown command or service: $svc"
 	    ret=1
 	  fi
-          shift
-        fi
+	else
+	  echo "$0: invalid argument: $1"
+	  ret=1
+	fi
+        shift
       done
 
       return ret
@@ -322,42 +295,6 @@
     shift
 
     case "$type" in
-    pattern)
-      while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          eval "_pat${assoc}"'[$1]="$func"'
-          shift
-        fi
-      done
-      ;;
-    postpattern)
-      while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          eval "_postpat${assoc}"'[$1]="$func"'
-          shift
-        fi
-      done
-      ;;
     widgetkey)
       while [[ -n $1 ]]; do
 	if [[ $# -lt 3 ]]; then
@@ -406,54 +343,48 @@
       # For commands store the function name in the
       # associative array, command names as keys.
       while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
+        if [[ "$1" = -N ]]; then
+          type=normal
+        elif [[ "$1" = -p ]]; then
+          type=pattern
+        elif [[ "$1" = -P ]]; then
+          type=postpattern
         else
-          if [[ "$1" = *\=* ]]; then
-	    cmd="${1%%\=*}"
-	    svc=yes
-          else
-	    cmd="$1"
-	    svc=
-          fi
-          if [[ -z "$new" || -z "${(e):-\$_${assoc}[$1]}" ]]; then
-            eval "_${assoc}"'[$cmd]="$func"'
-	    [[ -n "$svc" ]] && eval "_service${assoc}"'[$cmd]="${1#*\=}"'
-	  fi
-          shift
+          case "$type" in
+          pattern)
+            _patcomps[$1]="$func"
+            ;;
+          postpattern)
+            _postpatcomps[$1]="$func"
+            ;;
+          *)
+            if [[ "$1" = *\=* ]]; then
+	      cmd="${1%%\=*}"
+	      svc=yes
+            else
+	      cmd="$1"
+	      svc=
+            fi
+            if [[ -z "$new" || -z "${_comps[$1]}" ]]; then
+              _comps[$cmd]="$func"
+	      [[ -n "$svc" ]] && _services[$cmd]="${1#*\=}"
+	    fi
+            ;;
+          esac
         fi
+        shift
       done
       ;;
     esac
   else
     # Handle the `-d' option, deleting.
 
-    if [[ $1 = -T ]]; then
-      shift
-      if (( ! $# )); then
-        echo "$0: missing type"
-        return 1
-      fi
-      _comp_assocs=( "$_comp_assocs[@]" "$1" )
-      typeset -gA _$1 _service$1 _pat$1 _postpat$1
-      assoc="$1"
-      shift
-    fi
-
     case "$type" in
     pattern)
-      unset "_pat${assoc}[$^@]"
+      unset "_patcomps[$^@]"
       ;;
     postpattern)
-      unset "_postpat${assoc}[$^@]"
+      unset "_postpatcomps[$^@]"
       ;;
     key)
       # Oops, cannot do that yet.
@@ -462,7 +393,7 @@
       return 1
       ;;
     *)
-      unset "_${assoc}[$^@]"
+      unset "_comps[$^@]"
     esac
   fi
 }
Index: Completion/Base/Completer/_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Completer/_complete,v
retrieving revision 1.4
diff -u -r1.4 _complete
--- Completion/Base/Completer/_complete	4 Mar 2002 08:53:42 -0000	1.4
+++ Completion/Base/Completer/_complete	13 Mar 2002 09:20:36 -0000
@@ -95,7 +95,7 @@
 
 comp="$_comps[-first-]"
 if [[ -n "$comp" ]]; then
-  service="${_servicecomps[-first-]:--first-}"
+  service="${_services[-first-]:--first-}"
   ccarray[3]=-first-
   eval "$comp" && ret=0
   if [[ "$_compskip" = all ]]; then
@@ -124,7 +124,7 @@
   ccarray[3]="$cname"
 
   comp="$_comps[$cname]"
-  service="${_servicecomps[$cname]:-$cname}"
+  service="${_services[$cname]:-$cname}"
 
   # If not, we use default completion, if any.
 
@@ -134,7 +134,7 @@
       return 1
     fi
     comp="$_comps[-default-]"
-    service="${_servicecomps[-default-]:--default-}"
+    service="${_services[-default-]:--default-}"
   fi
   [[ -n "$comp" ]] && eval "$comp" && ret=0
 fi
Index: Completion/Base/Core/_dispatch
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Core/_dispatch,v
retrieving revision 1.1
diff -u -r1.1 _dispatch
--- Completion/Base/Core/_dispatch	4 Mar 2002 08:53:43 -0000	1.1
+++ Completion/Base/Core/_dispatch	13 Mar 2002 09:20:36 -0000
@@ -1,31 +1,17 @@
 #autoload
 
 local comp pat val name i ret=1 _compskip="$_compskip"
-local curcontext="$curcontext" service str comptype noskip def
-local __comps __patcomps __postpatcomps __services
+local curcontext="$curcontext" service str noskip
 
 # If we get the option `-s', we don't reset `_compskip'.
 
-while [[ "$1" = -[sd] ]]; do
-  if [[ "$1" = -s ]]; then
-    noskip=yes
-  else
-    def=yes
-  fi
-  shift
-done
+if [[ "$1" = -s ]]; then
+  noskip=yes
+fi
 
 [[ -z "$noskip" ]] && _compskip=
 
-comptype=$1
-
-__comps=_$1
-
-(( ${(P)+__comps} )) || return 1
-
-__patcomps=_pat$1
-__postpatcomps=_postpat$1
-__services=_service$1
+curcontext="${curcontext%:*:*}:${1}:"
 
 shift
 
@@ -35,9 +21,9 @@
 
   for str in "$@"; do
     [[ -n "$str" ]] || continue
-    service="${${(e):-\$${__services}[\$str]}:-$str}"
-    for i in "${(@e):-\$${__patcomps}[(K)\$str]}"; do
-      "$i" && ret=0
+    service="${_services[$str]:-$str}"
+    for i in "${(@)_patcomps[(K)$str]}"; do
+      eval "$i" && ret=0
       if [[ "$_compskip" = *patterns* ]]; then
         break
       elif [[ "$_compskip" = all ]]; then
@@ -54,30 +40,27 @@
 for str in "$@"; do
   [[ -n "$str" ]] || continue
   name="$str"
-  comp="${(e):-\$${__comps}[\$str]}"
-  service="${${(e):-\$${__services}[\$str]}:-$str}"
+  comp="${_comps[$str]}"
+  service="${_services[$str]:-$str}"
 
   [[ -z "$comp" ]] || break
 done
 
 # And generate the matches, probably using default completion.
 
-if [[ -n "$comp" ]]; then
+if [[ -n "$comp" && "$name" != "${argv[-1]}" ]]; then
   _compskip=patterns
   eval "$comp" && ret=0
   [[ "$_compskip" = (all|*patterns*) ]] && return ret
-elif [[ "$_compskip" != *default* ]]; then
-  name=-default-
-  comp="${(e):-\$${__comps}[-default-]}"
 fi
 
 if [[ "$_compskip" != (all|*patterns*) ]]; then
   for str; do
     [[ -n "$str" ]] || continue
-    service="${${(e):-\$${__services}[\$str]}:-$str}"
-    for i in "${(@e):-\$${__postpatcomps}[(K)\$str]}"; do
+    service="${_services[$str]:-$str}"
+    for i in "${(@)_postpatcomps[(K)$str]}"; do
       _compskip=default
-      "$i" && ret=0
+      eval "$i" && ret=0
       if [[ "$_compskip" = *patterns* ]]; then
         break
       elif [[ "$_compskip" = all ]]; then
@@ -88,9 +71,9 @@
   done
 fi
 
-[[ "$name" = -default- && -n "$comp" &&
+[[ "$name" = "${argv[-1]}" && -n "$comp" &&
    "$_compskip" != (all|*default*) ]] &&
-  service="${${(e):-\$${__services}[-default-]}:--default-}" &&
+  service="${_services[$name]:-$name}" &&
    eval "$comp" && ret=0
 
 _compskip=''
Index: Completion/Base/Core/_normal
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Core/_normal,v
retrieving revision 1.3
diff -u -r1.3 _normal
--- Completion/Base/Core/_normal	4 Mar 2002 08:53:43 -0000	1.3
+++ Completion/Base/Core/_normal	13 Mar 2002 09:20:36 -0000
@@ -1,6 +1,6 @@
 #compdef -command-line-
 
-local _comp_command1 _comp_command2 skip
+local _comp_command1 _comp_command2 _comp_command skip
 
 if [[ "$1" = -s ]]; then
   skip=(-s)
@@ -22,4 +22,5 @@
 
 _set_command
 
-_dispatch -d "$skip[@]" comps "$_comp_command1" "$_comp_command2"
+_dispatch "$skip[@]" "$_comp_command" \
+          "$_comp_command1" "$_comp_command2" -default-
Index: Completion/Base/Utility/_set_command
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_set_command,v
retrieving revision 1.1
diff -u -r1.1 _set_command
--- Completion/Base/Utility/_set_command	4 Mar 2002 08:53:43 -0000	1.1
+++ Completion/Base/Utility/_set_command	13 Mar 2002 09:20:36 -0000
@@ -1,7 +1,7 @@
 #autoload
 
-# This sets the parameters _comp_command1 and _comp_command2 in the
-# calling function.
+# This sets the parameters _comp_command1, _comp_command2 and _comp_command
+# in the calling function.
 
 local command
 
@@ -11,21 +11,21 @@
 
 if (( $+builtins[$command] + $+functions[$command] )); then
   _comp_command1="$command"
-  curcontext="${curcontext%:*:*}:${_comp_command1}:"
+  _comp_command="$_comp_command1"
 elif [[ "$command[1]" = '=' ]]; then
   eval _comp_command2\=$command
   _comp_command1="$command[2,-1]"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
+  _comp_command="$_comp_command2"
 elif [[ "$command" = ..#/* ]]; then
   _comp_command1="${PWD}/$command"
   _comp_command2="${command:t}"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
+  _comp_command="$_comp_command2"
 elif [[ "$command" = */* ]]; then
   _comp_command1="$command"
   _comp_command2="${command:t}"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
+  _comp_command="$_comp_command2"
 else
   _comp_command1="$command"
   _comp_command2="$commands[$command]"
-  curcontext="${curcontext%:*:*}:${_comp_command1}:"
+  _comp_command="$_comp_command1"
 fi
Index: Completion/Unix/Command/_gcc
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Command/_gcc,v
retrieving revision 1.4
diff -u -r1.4 _gcc
--- Completion/Unix/Command/_gcc	6 Mar 2002 14:22:41 -0000	1.4
+++ Completion/Unix/Command/_gcc	13 Mar 2002 09:20:37 -0000
@@ -1,13 +1,13 @@
-#compdef gcc g++ -T values LDFLAGS CFLAGS CPPFLAGS
+#compdef gcc g++ -value-,LDFLAGS,-default- -value-,CFLAGS,-default- -value-,CPPFLAGS,-default-
 
 local curcontext="$curcontext" state line ret=1 expl args args2
 typeset -A opt_args
 
-if [[ "$comptype" = values ]]; then
+if [[ "$service" = -value-* ]]; then
   compset -q
   words=( fake "$words[@]" )
   (( CURRENT++ ))
-  if [[ "$service" = LDFLAGS ]]; then
+  if [[ "$service" = *LDFLAGS ]]; then
     args2=( '-R:runtime path:->rundir' )
   else
     args2=()
Index: Completion/Unix/Command/_make
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Command/_make,v
retrieving revision 1.1
diff -u -r1.1 _make
--- Completion/Unix/Command/_make	2 Apr 2001 11:56:47 -0000	1.1
+++ Completion/Unix/Command/_make	13 Mar 2002 09:20:37 -0000
@@ -45,6 +45,7 @@
     fi
     _wanted targets expl 'make target' compadd -a tmp && return 0
   fi
+  compstate[parameter]="${PREFIX%%\=*}"
   compset -P 1 '*='
-  _files
+  _value "$@"
 fi
Index: Completion/Unix/Command/_su
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Command/_su,v
retrieving revision 1.3
diff -u -r1.3 _su
--- Completion/Unix/Command/_su	4 Mar 2002 08:53:43 -0000	1.3
+++ Completion/Unix/Command/_su	13 Mar 2002 09:20:37 -0000
@@ -17,4 +17,4 @@
 shell="${${(M@)${(@f)$(</etc/passwd)}:#$usr*}##*:}"
 compset -n $base
 
-_dispatch comps $shell $shell:t -default-
+_dispatch $shell:t $shell $shell:t -default-
Index: Completion/Unix/Type/_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_files,v
retrieving revision 1.6
diff -u -r1.6 _files
--- Completion/Unix/Type/_files	4 Mar 2002 08:53:43 -0000	1.6
+++ Completion/Unix/Type/_files	13 Mar 2002 09:20:37 -0000
@@ -1,4 +1,4 @@
-#compdef -T redirs -default-
+#compdef -redirect-,-default-,-default-
 
 local opts tmp glob pat pats expl tag i def descr end ign ret=1 match tried
 local type sdef
Index: Completion/Unix/Type/_locales
===================================================================
RCS file: Completion/Unix/Type/_locales
diff -N Completion/Unix/Type/_locales
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ Completion/Unix/Type/_locales	13 Mar 2002 09:20:37 -0000
@@ -0,0 +1,11 @@
+#compdef -value-,LANG,-default- -P -value-,LC_*,-default-
+
+local locales
+
+if (( $+commands[locale] )); then
+  locales=( $(_call_program locales locale -a) )
+else
+  locales=( /usr/lib/locale/*(:t) )
+fi
+
+_wanted locales expl locale compadd "$@" -a locales
Index: Completion/Unix/Type/_printers
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_printers,v
retrieving revision 1.3
diff -u -r1.3 _printers
--- Completion/Unix/Type/_printers	4 Mar 2002 08:53:43 -0000	1.3
+++ Completion/Unix/Type/_printers	13 Mar 2002 09:20:37 -0000
@@ -1,4 +1,4 @@
-#compdef -T values PRINTER LPDEST
+#compdef -value-,PRINTER,-default- -value-,LPDEST,-default-
 
 local expl ret=1 list disp sep
 
Index: Completion/Unix/Type/_terminals
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_terminals,v
retrieving revision 1.2
diff -u -r1.2 _terminals
--- Completion/Unix/Type/_terminals	4 Mar 2002 08:53:43 -0000	1.2
+++ Completion/Unix/Type/_terminals	13 Mar 2002 09:20:37 -0000
@@ -1,4 +1,4 @@
-#compdef infocmp -T values TERM
+#compdef infocmp -value-,TERM,-default-
 
 local desc expl
 
Index: Completion/Unix/Type/_time_zone
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_time_zone,v
retrieving revision 1.4
diff -u -r1.4 _time_zone
--- Completion/Unix/Type/_time_zone	4 Mar 2002 08:53:43 -0000	1.4
+++ Completion/Unix/Type/_time_zone	13 Mar 2002 09:20:37 -0000
@@ -1,4 +1,4 @@
-#compdef -T values TZ
+#compdef -value-,TZ,-default-
 
 local expl
 
Index: Completion/X/Type/_x_display
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Type/_x_display,v
retrieving revision 1.2
diff -u -r1.2 _x_display
--- Completion/X/Type/_x_display	4 Mar 2002 08:53:43 -0000	1.2
+++ Completion/X/Type/_x_display	13 Mar 2002 09:20:37 -0000
@@ -1,3 +1,3 @@
-#compdef -T values DISPLAY
+#compdef -value-,DISPLAY,-default-
 
 _tags displays && _hosts -S ':0 ' -r :
Index: Completion/Zsh/Command/_compdef
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Command/_compdef,v
retrieving revision 1.2
diff -u -r1.2 _compdef
--- Completion/Zsh/Command/_compdef	4 Mar 2002 08:53:43 -0000	1.2
+++ Completion/Zsh/Command/_compdef	13 Mar 2002 09:20:37 -0000
@@ -1,24 +1,37 @@
 #compdef compdef
 
-local state line expl list disp curcontext="$curcontext"
+local state line expl list disp curcontext="$curcontext" pat normal ret=1
+local args1 args2
 typeset -A opt_args
 
-_arguments -C -s -A "-*" -S \
-  '(-d)-a[make function autoloadable]' \
-  '(-d -p -P)-n[leave existing definitions intact]' \
-  "*-T[select type of completion function]:completion function type:($_comp_assocs)" \
+args2=()
+if (( ! ${words[2,-1][(I)[^-]*]} || ${words[(I)-[kK]]} )); then
+  args1=(
+    -A '-*'
+    '(-d)-a[make function autoloadable]'
+    '(-d)-n[leave existing definitions intact]'
+  )
+  args2=(
+     - d
+      '(-a -n)-d[delete]:*:completed command:->ccom'
+     - k
+      '-k[define widget and key binding]:completion function:->cfun:style:->style:*:key'
+     - K
+      '-K[define multiple widgets based on function]:*::: :->multi'
+  )
+else
+  args1=(
+    '-N[completion for named command]'
+  )
+fi
+
+_arguments -C -s -S \
+  "$args1[@]" \
+  '-p[completion for command matching pattern]' \
+  '-P[completion for command matching pattern]' \
   ':completion function:->cfun' \
-  '*:commands: _command_names' \
- - d \
-  '(-a -n)-d[delete]:*:completed command:->ccom' \
- - p \
-  '(-n)-p[completion for command matching pattern]:completion function:->cfun:pattern' \
- - P \
-  '(-n)-P[as -p for commands without own completion]:completion function:->cfun:pattern' \
- - k \
-  '-k[define widget and key binding]:completion function:->cfun:style:->style:*:key' \
- - K \
-  '-K[define multiple widgets based on function]:*::: :->multi' && return 0
+  '*:commands:->com' \
+  "$args2[@]" && return 0
 
 if [[ $state = multi ]]; then
   case $(( CURRENT % 3 )) in
@@ -30,6 +43,15 @@
 fi
 
 case $state in
+  com)
+    pat="${words[(I)-[pP]]}"
+    normal="${words[(I)-N]}"
+    if (( pat && pat > normal )); then
+      _message -e patterns 'pattern'
+    else
+      _command_names
+    fi
+  ;;
   ccom)
     _wanted commands expl 'completed command' compadd -k _comps
   ;;
Index: Completion/Zsh/Context/_in_vared
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Context/_in_vared,v
retrieving revision 1.2
diff -u -r1.2 _in_vared
--- Completion/Zsh/Context/_in_vared	4 Mar 2002 08:53:43 -0000	1.2
+++ Completion/Zsh/Context/_in_vared	13 Mar 2002 09:20:37 -0000
@@ -32,4 +32,4 @@
 
 compstate[insert]="${compstate[insert]//tab /}"
 
-_dispatch comps "$also"
+_dispatch "$also" "$also"
Index: Completion/Zsh/Context/_redirect
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Context/_redirect,v
retrieving revision 1.2
diff -u -r1.2 _redirect
--- Completion/Zsh/Context/_redirect	4 Mar 2002 08:53:43 -0000	1.2
+++ Completion/Zsh/Context/_redirect	13 Mar 2002 09:20:37 -0000
@@ -1,17 +1,16 @@
 #compdef -redirect-
 
-# This searches for `<command-name>:<redir-op>' and `<redir-op>', where
-# `<redir-op>' is something like `<' or `2>'.
-
-local strs _comp_command1 _comp_command2
+local strs _comp_command1 _comp_command2 _comp_command
 
 _set_command
 
-strs=( "$compstate[redirect]" )
+strs=( -default- )
 
 if [[ -n "$_comp_command1" ]]; then
-  strs=( "${_comp_command1}:$strs[-1]" "$strs[@]" )
-  [[ -n "$_comp_command2" ]] && strs=( "${_comp_command2}:$strs[1]" "$strs[@]" )
+  strs=( "${_comp_command1}" "$strs[@]" )
+  [[ -n "$_comp_command2" ]] &&
+      strs=( "${_comp_command2}" "$strs[@]" )
 fi
 
-_dispatch -d redirs "$strs[@]"
+_dispatch -redirect-,${compstate[redirect]},${_comp_command} \
+          -redirect-,{${compstate[redirect]},-default-},${^strs}
Index: Completion/Zsh/Context/_subscript
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Context/_subscript,v
retrieving revision 1.9
diff -u -r1.9 _subscript
--- Completion/Zsh/Context/_subscript	4 Mar 2002 08:53:43 -0000	1.9
+++ Completion/Zsh/Context/_subscript	13 Mar 2002 09:20:37 -0000
@@ -113,5 +113,5 @@
 
   return 1
 else
-  _dispatch comps -math-
+  _dispatch -math- -math-
 fi
Index: Completion/Zsh/Context/_value
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Context/_value,v
retrieving revision 1.5
diff -u -r1.5 _value
--- Completion/Zsh/Context/_value	4 Mar 2002 08:53:43 -0000	1.5
+++ Completion/Zsh/Context/_value	13 Mar 2002 09:20:37 -0000
@@ -1,4 +1,4 @@
-#compdef -value- -array-value- -T values -default-
+#compdef -value- -array-value- -value-,-default-,-default-
 
 # You can customize completion for different parameters by writing
 # functions with the tag-line `#compdef -T value <name>'.
@@ -6,30 +6,20 @@
 # and `<param-name>'. If the line contains a command (as in `make foo=<TAB>')
 # the string `<command>:<param-name>:<param-type>' is also searched for.
 
-if [[ "$service" != -default- ]]; then
-  local strs type
+if [[ "$service" != -value-,* ]]; then
+  local strs ctx=
 
-  type="${(Pt)compstate[parameter]}"
-
-  if [[ -z "$type" ]]; then
-    if [[ "$compstate[parameter]" = *-* ]]; then
-      type=association-value
-    elif [[ "$compstate[context]" = value ]]; then
-      type=scalar
-    else
-      type=array
-    fi
-  fi
-
-  strs=( "${compstate[parameter]}:$type" "$compstate[parameter]" )
+  strs=( -default- )
 
   if [[ "$compstate[context]" != *value && -n "$_comp_command1" ]]; then
-    strs=( "${_comp_command1}:$^strs[@]" "$strs[@]" )
+    ctx="${_comp_command}"
+    strs=( "${_comp_command1}" "$strs[@]" )
     [[ -n "$_comp_command2" ]] &&
-        strs=( "${_comp_command2}:${(@)^strs[-2,-1]}" "$strs[@]" )
+        strs=( "${_comp_command2}" "$strs[@]" )
   fi
 
-  _dispatch -d values "$strs[@]"
+  _dispatch -value-,${compstate[parameter]},$ctx \
+            -value-,{${compstate[parameter]},-default-},${^strs}
 else
   if [[ "$compstate[parameter]" != *-* &&
         "$compstate[context]" = *value &&
@@ -39,7 +29,9 @@
           compadd -k "$compstate[parameter]"
     else
       compstate[parameter]="${compstate[parameter]}-${words[CURRENT-1]}"
-      _value "$@"
+
+      _dispatch -value-,${compstate[parameter]}, \
+                -value-,{${compstate[parameter]},-default-},-default-
     fi
   else
     local pats
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.147
diff -u -r1.147 compsys.yo
--- Doc/Zsh/compsys.yo	4 Mar 2002 08:53:43 -0000	1.147
+++ Doc/Zsh/compsys.yo	13 Mar 2002 09:20:37 -0000
@@ -159,7 +159,8 @@
 The tags are:
 
 startitem()
-item(tt(#compdef) var(names...))(
+item(tt(#compdef) var(names...) [ tt(-[pP]) var(patterns...) [ tt(-N)
+var(names...) ] ])(
 The file will be made autoloadable and the function defined 
 in it will be called when completing var(names), each of which is
 either the name of a command whose arguments are to be completed or one of
@@ -174,33 +175,18 @@
 to the string `tt(service)'.  The function can then use that parameter 
 to decide what to complete.
 
-Finally, the list of var(names) may contain tt(-T) options, each
-followed by a type name.  These type names describe in which set of
-completion function definitions the function is to be stored.  The
-default without a tt(-T) option is `tt(comps)', saying that the
-function is a normal completion function.  Other type names currently
-understood by the completion system are tt(redirs) and tt(values).
-The first is used to define specialised completion functions for
-use after redirection operators for certain commands and the latter is
-used to define functions used when completing values of parameters.
-For example, to define the function that should be used when
-completing after `tt(foo=<TAB>)' one would use the tag line:
-
-example(#compdef -T values foo)
-
-When the function is called, the parameter tt($comptype) will be set
-to the type name, making it easy to distinguish what should be
-completed.
-)
-item(tt(#compdef -p) var(patterns...))(
-The file will be made autoloadable and the function defined in it will be
-called when completing for a command whose name matches the given
-var(pattern) (a standard globbing pattern).  As in the first case, the
-list of var(patterns) may contain tt(-T) options.
-)
-item(tt(#compdef -P) var(patterns...))(
-Like the previous one, but the function will be called only if no
-completion function for the command on the line could be found.
+If the list of var(names) contains a tt(-p) or tt(-P) option, the
+following words are taken to be patterns.  When completing for a
+command or context whose name matches one of the patterns, the
+function will be called.  In the case of tt(-P), this will only be
+done if no other completion function for the command or context could
+be found (i.e. this can be used to define default completion for
+commands or contexts matching one of the patterns which don't have a
+completion function specifically defined for them).
+
+If the list contains the tt(-N) option, the following words are used
+as in the normal case again.  Another tt(-p) or tt(-P) option can be
+usedto toggle back to defining patterns again. 
 )
 item(tt(#compdef -k) var(style key-sequences...))(
 This can be used to bind special completion functions to the
@@ -272,10 +258,8 @@
 findex(compdef)
 cindex(completion system, adding definitions)
 startitem()
-xitem(tt(compdef) [ tt(-an) ] var(function names) [ tt(-T) var(type) ] ...))
-xitem(tt(compdef -d) [ tt(-T) var(type) ] var(names...))
-xitem(tt(compdef -p) [ tt(-a) ] var(function patterns) [ tt(-T) var(type) ] ...)
-xitem(tt(compdef -P) [ tt(-a) ] var(function patterns) [ tt(-T) var(type) ] ...)
+xitem(tt(compdef) [ tt(-an) ] var(function names...) [ tt(-[pP]) var(patterns...) ])
+xitem(tt(compdef -d) var(names...))
 xitem(tt(compdef -k) [ tt(-an) ] var(function style key-sequences...))
 item(tt(compdef -K) [ tt(-an) ] var(function name style key-sequences ...))(
 The first form tells the completion system to call the given
@@ -297,27 +281,25 @@
 
 example(compdef '_files -g "*.h"' foo)
 
-The tt(-T) options in the list of var(names) define for which type of
-completions the function is to be used, i.e. in which set of
-completion functions definitions it should be added.  Currently used
-tt(type)s are tt(comps) (the default, for normal completion functions
-for command completion), tt(values) for completion of parameter values
-in assignments and tt(redirs) for completion after redirection
-operators.
-
 If the
 tt(-n) option is given, any existing completion behaviour for particular
 contexts or commands will not be altered.  These definitions can be deleted
 by giving the tt(-d) option as in the second form.
 
-The form with tt(-p) is similar to the first, but var(function) will be
-called for all commands whose name matches the var(pattern); this is like
-the tt(#compdef -p) function tag.
-
-The form with tt(-P) is like the third, but the var(function) will be
-called only if no function for the command itself was found or if one
-was found and it set the tt(_compskip) parameter to a value em(not)
-containing the substring tt(patterns).
+In both of the first two cases forms and as for the tt(#compdef) tag
+described above, the var(names) may also contain tt(-p), tt(-P) and
+tt(-N) options.  The first two make the following arguments be used as
+patterns and the var(function) will be called for all commands and
+contexts matching one of the patterns.  Wtih tt(-P) this will only
+happen if no specific function is defined for the command or context.
+The tt(-N) option toggles back to using the var(names) as described
+above.
+
+Inside functions defined for patterns, the parameter tt($_compskip)
+may be used.  If it is set to a value containing the substring
+`tt(patterns)' none of the pattern-functions will be called.  If it is
+set to a value containing the substring `tt(all)', no other function
+will be called.
 
 The form with tt(-k) defines a widget with the same name as the var(function)
 which will be called for each of the var(key-sequences); this is like the
@@ -2566,6 +2548,56 @@
 (e.g. completion for the `tt(-tilde-)' context is done by the function 
 named `tt(_tilde)').
 
+The functions for some contexts re-dispatch by calling the function
+tt(_dispatch) to offer more specific context information.  This is
+done by appending the parts of extra information to the name of the
+context, separated by commas.  Currently, only the function
+completing redirection arguments (tt(_redirect)) and the function
+completing values in parameter assignments (tt(_value)) use this
+feature.  The former uses contexts of the form
+`tt(-redirect-,)var(op)tt(,)var(command)', where var(op) is the
+redirection operator and var(command) is the name of the command on
+the line.  If there isn't a command yet, the var(command) field will
+be empty.  The function completing values uses contexts of the form
+`tt(-value-,)var(name)tt(,)var(command)', where var(name) is the name
+of the parameter (or `var(name)tt(-)var(key)' when completing a
+value of an associative array in an assignment like
+`tt(assoc=LPAR()key <TAB>)').  The var(command) part is the name of
+the command from the line again in completions like `tt(make
+CFLAGS=<TAB>)' and is empty for normal assignments.
+
+To simplify defining functions for multiple cases, the functions
+tt(_redirect) and tt(_value) will make tt(_dispatch) try these context
+names more than once with each of the parts once set to the string
+tt(-default-).  For example, when completing after `tt(foo=<TAB>)',
+tt(_value) will try the names `tt(-value-,foo,)' (note the empty
+var(command) part), `tt(-value-,foo,-default-)' and
+`tt(-value-,-default-,-default-)'.  Also note the order in which the
+contexts are tried.
+
+As an example:
+
+example(compdef '_files -g "*.log"' '-redirect-,2>,-default-')
+
+could be used to complete files matching `tt(*.log)' when completing
+after `tt(2> <TAB>)'.
+
+And:
+
+example(compdef _foo -value-,-default-,-default-)
+
+says that the function tt(_foo) is to be called to provide completion
+for the values of parameters for which no special function has been
+defined.
+
+In any case the most specific context name will be used inside the
+context string used for looking up styles.  For example:
+
+example(zstyle ':completion:*:*:-redirect-,2>,*:*' file-patterns '*.log')
+
+is another way to make completion after `tt(2> <TAB>)' complete files
+matching `tt(*.log)'.
+
 Before trying to find a function for a specific context, tt(_complete) 
 checks if the parameter `tt(compcontext)' is set.  If it is set to an
 array, the elements are taken to be the possible matches which will be
@@ -3657,17 +3689,16 @@
 passed down to the builtins which implement the internals of completion.
 )
 findex(_dispatch)
-item(tt(_dispatch) [ tt(-d) ] var(type strings ...))(
-This function looks up the function defined for the first var(string)
-in the set of definitions named var(type) (these are those definitions
-defined with `tt(-T )var(type)').  If one is found, it is called to
-generate completions.  Otherwise the definition for the second
-var(string) is looked up and so on.  If none is found and the tt(-d)
-option is given, the definition for the special name tt(-default-) is
-used.
-
-This function is the one responsible for setting the parameters
-tt($service) and tt($comptype).
+item(tt(_dispatch) var(context strings ...))(
+This looks up the functions defined for the var(strings) one after
+another until it finds one that is defined. That function is then
+called to generate the matches.  Normally, the last var(string) is the
+one used to look up the default completion.
+
+This function is the one responsible for setting the parameter
+tt($service) (to the var(strings) as they are tried) and for setting
+the var(context/command) field of the tt($curcontext) parameter (to
+the var(context) given as the first argument).
 )
 findex(_files)
 item(tt(_files))(
Index: Src/Zle/zle_tricky.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_tricky.c,v
retrieving revision 1.34
diff -u -r1.34 zle_tricky.c
--- Src/Zle/zle_tricky.c	7 Mar 2002 08:38:44 -0000	1.34
+++ Src/Zle/zle_tricky.c	13 Mar 2002 09:20:37 -0000
@@ -856,6 +856,7 @@
 	(iblank(line[cs]) && (!cs || line[cs-1] != '\\')) ||
 	line[cs] == ')' || line[cs] == '`' || line[cs] == '}' ||
 	line[cs] == ';' || line[cs] == '|' || line[cs] == '&' ||
+	line[cs] == '>' || line[cs] == '<' ||
 	(instring && (line[cs] == '"' || line[cs] == '\'')) ||
 	(addspace = (comppref && !iblank(line[cs])))) {
 	*ptmp = (char *)line;

-- 
Sven Wischnowsky                          wischnow@berkom.de

