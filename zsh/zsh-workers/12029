From zsh-workers-return-12029-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 22 08:40:23 2000
Return-Path: <zsh-workers-return-12029-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1274 invoked from network); 22 Jun 2000 08:40:20 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 22 Jun 2000 08:40:20 -0000
Received: (qmail 1133 invoked by alias); 22 Jun 2000 08:34:26 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12029
Received: (qmail 1113 invoked from network); 22 Jun 2000 08:34:20 -0000
Date: Thu, 22 Jun 2000 10:33:53 +0200 (MET DST)
Message-Id: <200006220833.KAA02868@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Wed, 21 Jun 2000 14:52:50 +0000
Subject: Re: PATCH: Re: history completion oddity


Bart Schaefer wrote:

> On Jun 21, 10:03am, Sven Wischnowsky wrote:
> }
> } Bart wrote:
> } > Incidentally, I just had an exchange with A. Spiegl in which he noted that
> } > history completion is unacceptably slow because he has HISTSIZE=15000.
> } 
> } Hmhm. I wasn't happy when I used those temporal arrays. I was thinking 
> } about allowing `compadd -a "foo[2,-1]"', it seems that I forgot to
> } ask.
> 
> That sounds like as good an idea as any.

Good. This patch does that, using, like vared, fetchvalue() which
means that one can even do `compadd -k 'parameters[(R)*export*]' and
things like that.


Andy Spiegl wrote:

> Sven Wischnowsky wrote:
> 
> ...
> 
> > I.e. maybe we could add a style to _history* to complete only the last 
> > N words/lines. Probably a bit like that example code in _first,
> > i.e. try the last N words/lines, if that doesn't yield matches, try
> > the last 2N words/lines, and so on.
> That sounds like a _very_ good idea!

The patch also adds the `range' styles used by _history{,_c_w} which
can be set to a number to say to complete only the last N words and it 
may be set to `max:slice' to complete at most the last `max' words,
trying first the last `slice' words, then the `slice' words before
those, etc.

There must be a better name than `range', but we've had more than 37
degrees Celsius here for several days now and my brain is fried.


Other things the patch does (I wanted to put some of them into a
separate patch and then forgot to diff, sorry):

- the list-color handling should be cleaner now (no changes, only the
  internal handling, it now uses a uniquified array)
- a bit of cleanup in _h_c_w ($curcontex)
- a (very small) builtin `compgroups' in computil.c to make the
  group-order style faster
- slightly better memory behaviour for `compadd -[ak]', the results of 
  those now use the normal heap instead of the one used for completion
  (and the normal heap will be freed/popped from time to time)
- and example for `zstyle -e' in the compsys doc; anyone know of other 
  good examples? something with $PREFIX, for example?
- changes to some completion functions to use `foo[...]' with -[ak]


Bye
 Sven

Index: Completion/Builtins/_arrays
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_arrays,v
retrieving revision 1.1.1.8
diff -u -r1.1.1.8 _arrays
--- Completion/Builtins/_arrays	2000/03/23 04:19:27	1.1.1.8
+++ Completion/Builtins/_arrays	2000/06/22 08:29:20
@@ -2,4 +2,4 @@
 
 local expl
 
-_wanted arrays expl array compadd - "${(@k)parameters[(R)*array*]}"
+_wanted arrays expl array compadd -k "parameters[(R)*array*~*local*]"
Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.15
diff -u -r1.15 _zstyle
--- Completion/Builtins/_zstyle	2000/06/19 09:55:31	1.15
+++ Completion/Builtins/_zstyle	2000/06/22 08:29:20
@@ -136,7 +136,7 @@
         ctop=cz
       fi
       _wanted styles expl style \
-         compadd -M 'r:|-=* r:|=*' - ${(k)styles[(R)[^:]#[$ctop][^:]#:*]}
+         compadd -M 'r:|-=* r:|=*' -k "styles[(R)[^:]#[$ctop][^:]#:*]"
       ;;
       
     style-arg)
Index: Completion/Commands/_bash_completions
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Commands/_bash_completions,v
retrieving revision 1.3
diff -u -r1.3 _bash_completions
--- Completion/Commands/_bash_completions	2000/05/31 09:38:26	1.3
+++ Completion/Commands/_bash_completions	2000/06/22 08:29:20
@@ -33,8 +33,8 @@
 case $key in
   '!') _main_complete _command_names
        ;;
-  '$') _main_complete - _wanted parameters expl 'exported parameters' \
-                            compadd - "${(@k)parameters[(R)*export*]}"
+  '$') _main_complete - parameters _wanted parameters expl 'exported parameters' \
+                                       compadd -k 'parameters[(R)*export*]'
        ;;
   '@') _main_complete _hosts
        ;;
Index: Completion/Commands/_history_complete_word
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Commands/_history_complete_word,v
retrieving revision 1.5
diff -u -r1.5 _history_complete_word
--- Completion/Commands/_history_complete_word	2000/06/21 08:05:28	1.5
+++ Completion/Commands/_history_complete_word	2000/06/22 08:29:20
@@ -7,21 +7,27 @@
 #
 # Available styles:
 #
-#   :history-words:list -- display lists of available matches
-#   :history-words:stop -- prevent looping at beginning and end of matches
-#                          during menu-completion
-#   :history-words:sort -- sort matches lexically (default is to sort by age)
-#   :history-words:remove-all-dups --
-#                          remove /all/ duplicate matches rather than just
-#                          consecutives
-#
+#   list --  display lists of available matches
+#   stop --  prevent looping at beginning and end of matches during
+#            menu-completion
+#   sort --  sort matches lexically (default is to sort by age)
+#   remove-all-dups --
+#            remove /all/ duplicate matches rather than just consecutives
+#   range -- range of history words to complete
 
 _history_complete_word () {
   setopt localoptions nullglob rcexpandparam extendedglob
   unsetopt markdirs globsubst shwordsplit nounset ksharrays
 
-  local expl direction stop
+  local expl direction stop curcontext="$curcontext"
+  local max slice hmax=$#historywords
 
+  if [[ -z "$curcontext" ]]; then
+    curcontext=history-words:::
+  else
+    curcontext="history-words${curcontext#*:}"
+  fi
+
   if [[ $WIDGET = *newer ]]; then
     direction=newer
   else
@@ -32,6 +38,19 @@
 
   zstyle -t ":completion:${curcontext}:history-words" list || compstate[list]=''
 
+  if zstyle -s ":completion:${curcontext}:history-words" range max; then
+    if [[ $max = *:* ]]; then
+      slice=${max#*:}
+      max=${max%:*}
+    else
+      slice=$max
+    fi
+    [[ max -gt hmax ]] && max=$hmax
+  else
+    max=$hmax
+    slice=$max
+  fi
+
   if [[ -n "$compstate[old_list]" &&
         ( -n "$stop" || "$compstate[insert]" = menu ) ]] ; then
     # array of matches is newest -> oldest (reverse of history order)
@@ -66,11 +85,11 @@
     _history_complete_word_gen_matches
   fi
 
-  [[ -n "$compstate[nmatches]" ]]
+  (( $compstate[nmatches] ))
 }
 
 _history_complete_word_gen_matches () {
-  local opt h_words
+  local opt beg=2
 
   [[ -n "$_hist_stop" ]] && PREFIX="$_hist_old_prefix"
 
@@ -90,9 +109,11 @@
   SUFFIX="$SUFFIX$ISUFFIX"
   ISUFFIX=
 
-  h_words=( "${(@)historywords[2,-1]}" )
-  _wanted "$opt" history-words expl 'history word' \
-      compadd -Q -a h_words
+  while [[ $compstate[nmatches] -eq 0 && beg -lt max ]]; do
+    _main_complete - history _wanted "$opt" history-words expl 'history word' \
+                                 compadd -Q -a 'historywords[beg,beg+slice]'
+    (( beg+=slice ))
+  done
 
   zstyle -t ":completion:${curcontext}:history-words" list ||
       compstate[list]=
Index: Completion/Core/_history
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_history,v
retrieving revision 1.3
diff -u -r1.3 _history
--- Completion/Core/_history	2000/06/21 08:05:28	1.3
+++ Completion/Core/_history	2000/06/22 08:29:20
@@ -11,12 +11,12 @@
 #
 # Available styles:
 #
-#   :history-words:sort -- sort matches lexically (default is to sort by age)
-#   :history-words:remove-all-dups --
-#                          remove /all/ duplicate matches rather than just
-#                          consecutives
+#   sort --  sort matches lexically (default is to sort by age)
+#   remove-all-dups --
+#            remove /all/ duplicate matches rather than just consecutives
+#   range -- range of history words to complete
 
-local opt expl h_words
+local opt expl max slice hmax=$#historywords beg=2
 
 if zstyle -t ":completion:${curcontext}:" remove-all-dups; then
   opt=-
@@ -30,6 +30,19 @@
   opt="${opt}V"
 fi
 
+if zstyle -s ":completion:${curcontext}:" range max; then
+  if [[ $max = *:* ]]; then
+    slice=${max#*:}
+    max=${max%:*}
+  else
+    slice=$max
+  fi
+  [[ max -gt hmax ]] && max=$hmax
+else
+  max=$hmax
+  slice=$max
+fi
+
 PREFIX="$IPREFIX$PREFIX"
 IPREFIX=
 SUFFIX="$SUFFIX$ISUFFIX"
@@ -37,5 +50,11 @@
 
 # We skip the first element of historywords so the current word doesn't
 # interfere with the completion
-h_words=( "${(@)historywords[2,-1]}" )
-_wanted "$opt" history-words expl 'history word' compadd -Q -a h_words
+
+while [[ $compstate[nmatches] -eq 0 && beg -lt max ]]; do
+  _wanted "$opt" history-words expl 'history word' \
+      compadd -Q -a 'historywords[beg,beg+slice]'
+  (( beg+=slice ))
+done
+
+(( $compstate[namtches] ))
Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.29
diff -u -r1.29 _main_complete
--- Completion/Core/_main_complete	2000/06/18 14:16:25	1.29
+++ Completion/Core/_main_complete	2000/06/22 08:29:20
@@ -34,7 +34,7 @@
       _saved_insert="${compstate[insert]}" \
       _saved_colors="$ZLS_COLORS"
 
-typeset -U _lastdescr _comp_ignore
+typeset -U _lastdescr _comp_ignore _comp_colors
 
 [[ -z "$curcontext" ]] && curcontext=:::
 
@@ -263,7 +263,11 @@
    ( "$_comp_force_list" = ?*  && nm -ge _comp_force_list ) ]] &&
     compstate[list]="${compstate[list]//messages} force"
 
-[[ "$compstate[old_list]" = keep ]] && ZLS_COLORS="$_saved_colors"
+if [[ "$compstate[old_list]" = keep ]]; then
+  ZLS_COLORS="$_saved_colors"
+else
+  ZLS_COLORS="${(j.:.)_comp_colors}"
+fi
 
 # Now call the post-functions.
 
Index: Completion/Core/_parameters
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_parameters,v
retrieving revision 1.1.1.12
diff -u -r1.1.1.12 _parameters
--- Completion/Core/_parameters	2000/03/23 04:19:28	1.1.1.12
+++ Completion/Core/_parameters	2000/06/22 08:29:20
@@ -5,4 +5,4 @@
 
 local expl
 
-_wanted parameters expl parameter compadd "$@" - ${(k)parameters[(R)^*local*]}
+_wanted parameters expl parameter compadd "$@" -k 'parameters[(R)^*local*]'
Index: Completion/Core/_setup
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_setup,v
retrieving revision 1.5
diff -u -r1.5 _setup
--- Completion/Core/_setup	2000/06/19 08:47:44	1.5
+++ Completion/Core/_setup	2000/06/22 08:29:20
@@ -7,16 +7,10 @@
 if zstyle -a ":completion:${curcontext}:$1" list-colors val; then
   zmodload -i zsh/complist
   if [[ "$1" = default ]]; then
-    ZLS_COLORS="${(j.:.)${(@)val:gs/:/\\\:}}"
+    _comp_colors=( "$val[@]" )
   else
-    local simple grouped
-
-    simple=( "(${2})${(@)^val:#\(*\)*}" )
-    grouped=( "${(M@)val:#\(*\)*}" )
-    simple="${(j.:.)simple}:"
-    grouped="${(j.:.)grouped}:"
-    [[ "$ZLS_COLORS" != *${simple}*  ]] && ZLS_COLORS="${simple}$ZLS_COLORS"
-    [[ "$ZLS_COLORS" != *${grouped}* ]] && ZLS_COLORS="${grouped}$ZLS_COLORS"
+    _comp_colors=( "$_comp_colors[@]"
+                   "(${2})${(@)^val:#\(*\)*}" "${(M@)val:#\(*\)*}" )
   fi
 
 # Here is the problem mentioned in _main_complete.
Index: Completion/Core/_tags
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_tags,v
retrieving revision 1.5
diff -u -r1.5 _tags
--- Completion/Core/_tags	2000/04/25 09:48:09	1.5
+++ Completion/Core/_tags	2000/06/22 08:29:21
@@ -30,18 +30,8 @@
 
   [[ "$1" = -(|-) ]] && shift
 
-  if zstyle -a ":completion:${curcontext}:" group-order order; then
-    local name
-
-    for name in "$order[@]"; do
-      compadd -J "$name"
-      compadd -V "$name"
-      compadd -J "$name" -1
-      compadd -V "$name" -1
-      compadd -J "$name" -2
-      compadd -V "$name" -2
-    done
-  fi
+  zstyle -a ":completion:${curcontext}:" group-order order &&
+      compgroups "$order[@]"
 
   # Set and remember offered tags.
 
Index: Completion/Debian/_apt
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_apt,v
retrieving revision 1.7
diff -u -r1.7 _apt
--- Completion/Debian/_apt	2000/06/08 03:03:55	1.7
+++ Completion/Debian/_apt	2000/06/22 08:29:21
@@ -469,7 +469,7 @@
     -- \
     /$'shell\0'/ \
       \( \
-	/$'[^\0]#\0'/ ':parameters:shell variable to assign:compadd "$expl[@]" - "${(@k)parameters}"' \
+	/$'[^\0]#\0'/ ':parameters:shell variable to assign:_parameters' \
 	/$'[^\0]#\0'/ ':values:configuration key:compadd "$expl[@]" - ${${(f)"$(apt-config dump 2>&1)"}% *}' \
       \) \# \| \
     /$'dump\0'/ \| \
Index: Completion/X/_x_extension
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_extension,v
retrieving revision 1.4
diff -u -r1.4 _x_extension
--- Completion/X/_x_extension	2000/05/31 09:38:26	1.4
+++ Completion/X/_x_extension	2000/06/22 08:29:21
@@ -15,5 +15,5 @@
   [[ "$1" = - ]] && shift
 
   _wanted extensions expl 'X extensions' \
-      compadd "$@" -M 'm:{a-z}={A-Z} r:|-=* r:|=*' - _xe_cache
+      compadd "$@" -M 'm:{a-z}={A-Z} r:|-=* r:|=*' -a _xe_cache
 fi
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.72
diff -u -r1.72 compsys.yo
--- Doc/Zsh/compsys.yo	2000/06/20 07:16:27	1.72
+++ Doc/Zsh/compsys.yo	2000/06/22 08:29:22
@@ -386,6 +386,22 @@
 When looking up styles the completion system uses full context names,
 including the tag.
 
+To have more control over when certain values for styles are used one
+can use the special parameters available in completion widgets (see
+ifzman(see zmanref(zshcompwid))\
+ifnzman(noderef(Completion Widgets)))\
+) and the tt(-e) option to tt(zstyle) that makes the value be
+evaluated when looked up.  For example, to make the tt(completer)
+style have a different value when completion for the tt(cvs) command,
+one could use the tt(words) special array:
+
+example(zstyle -e ':completion:*' completer '
+    if [[ $words[1] = cvs ]]; then
+      reply=(_complete)
+    else
+      reply=(_complete _approximate)
+    fi')
+
 Styles determine such things as how the matches are generated; some of them
 correspond to shell options (for example, the use of menu completion), but
 styles provide more specific control.  They can have any number of strings as
@@ -1731,6 +1747,19 @@
 is any, and if it is different from the word on the line.
 )
 enditem()
+)
+kindex(range, completion style)
+item(tt(range))(
+This is used by the tt(_history) completer and the
+tt(_history_complete_word) bindable command to decide which words
+should be completed.  It may be set to a number, var(N), to say that
+only the last var(N) words from the history should be completed.  The
+value may also be of the form `var(max)tt(:)var(slice)'.  This means
+that first the last var(slice) words will be completed.  If that
+yields no matches, the var(slice) words before those will be tried and 
+so on, until either at least one match is generated or var(max) words
+have been tried.  The default is to complete all words from the
+history at once.
 )
 kindex(remove-all-dups, completion style)
 item(tt(remove-all-dups))(
Index: Doc/Zsh/compwid.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compwid.yo,v
retrieving revision 1.18
diff -u -r1.18 compwid.yo
--- Doc/Zsh/compwid.yo	2000/06/19 10:48:21	1.18
+++ Doc/Zsh/compwid.yo	2000/06/22 08:29:22
@@ -485,11 +485,14 @@
 )
 item(tt(-a))(
 With this flag the var(words) are taken as names of arrays and the
-possible matches are their values.
+possible matches are their values.  If only some elements of the
+arrays are needed, the var(words) may also contain subscripts, as in
+`tt(foo[2,-1])'.
 )
 item(tt(-k))(
 With this flag the var(words) are taken as names of associative arrays
-and the possible matches are their keys.
+and the possible matches are their keys.  As for tt(-a), the
+var(words) may also contain subscripts, as in `tt(foo[(R)*bar*])'.
 )
 item(tt(-d) var(array))(
 This adds per-match display strings. The var(array) should contain one 
Index: Src/zsh.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/zsh.h,v
retrieving revision 1.15
diff -u -r1.15 zsh.h
--- Src/zsh.h	2000/06/13 09:13:29	1.15
+++ Src/zsh.h	2000/06/22 08:29:22
@@ -1629,8 +1629,8 @@
 # define NEWHEAPS(h)    do { Heap _switch_oldheaps = h = new_heaps(); do
 # define OLDHEAPS       while (0); old_heaps(_switch_oldheaps); } while (0);
 
-# define SWITCHHEAPS(h)  do { Heap _switch_oldheaps = switch_heaps(h); do
-# define SWITCHBACKHEAPS while (0); switch_heaps(_switch_oldheaps); } while (0);
+# define SWITCHHEAPS(o, h)  do { o = switch_heaps(h); do
+# define SWITCHBACKHEAPS(o) while (0); switch_heaps(o); } while (0);
 
 /****************/
 /* Debug macros */
Index: Src/Zle/compcore.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compcore.c,v
retrieving revision 1.32
diff -u -r1.32 compcore.c
--- Src/Zle/compcore.c	2000/06/19 09:32:31	1.32
+++ Src/Zle/compcore.c	2000/06/22 08:29:23
@@ -1553,14 +1553,17 @@
 }
 
 static char **
-get_user_keys(char *nam)
+get_data_arr(char *name, int keys)
 {
-    char **ret;
+    struct value vbuf;
+    Value v;
 
-    if ((ret = gethkparam(nam)))
-	return (incompfunc ? arrdup(ret) : ret);
+    if (!(v = fetchvalue(&vbuf, &name, 1,
+			 (keys ? SCANPM_WANTKEYS : SCANPM_WANTVALS) |
+			 SCANPM_MATCHMANY)))
+	return NULL;
 
-    return NULL;
+    return getarrvalue(v);
 }
 
 /* This is used by compadd to add a couple of matches. The arguments are
@@ -1586,9 +1589,10 @@
     Patprog cp = NULL, *pign = NULL;
     LinkList aparl = NULL, oparl = NULL, dparl = NULL;
     Brinfo bp, bpl = brbeg, obpl, bsl = brend, obsl;
+    Heap oldheap;
 
     if (!*argv) {
-	SWITCHHEAPS(compheap) {
+	SWITCHHEAPS(oldheap, compheap) {
 	    /* Select the group in which to store the matches. */
 	    gflags = (((dat->aflags & CAF_NOSORT ) ? CGF_NOSORT  : 0) |
 		      ((dat->aflags & CAF_UNIQALL) ? CGF_UNIQALL : 0) |
@@ -1602,7 +1606,7 @@
 	    }
 	    if (dat->mesg)
 		addmesg(dat->mesg);
-	} SWITCHBACKHEAPS;
+	} SWITCHBACKHEAPS(oldheap);
 
 	return 1;
     }
@@ -1638,7 +1642,7 @@
 
     /* Switch back to the heap that was used when the completion widget
      * was invoked. */
-    SWITCHHEAPS(compheap) {
+    SWITCHHEAPS(oldheap, compheap) {
 	if ((doadd = (!dat->apar && !dat->opar && !dat->dpar))) {
 	    if (dat->aflags & CAF_MATCH)
 		hasmatched = 1;
@@ -1887,17 +1891,22 @@
 	obpl = bpl;
 	obsl = bsl;
 	if (dat->aflags & CAF_ARRAYS) {
-	    arrays = argv;
-	    argv = NULL;
-	    while (*arrays && (!(argv = ((dat->aflags & CAF_KEYS) ?
-					 get_user_keys(*arrays) :
-					 get_user_var(*arrays))) || !*argv))
+	    Heap oldheap2;
+
+	    SWITCHHEAPS(oldheap2, oldheap) {
+		arrays = argv;
+		argv = NULL;
+		while (*arrays &&
+		       (!(argv = get_data_arr(*arrays,
+					      (dat->aflags & CAF_KEYS))) ||
+			!*argv))
+		    arrays++;
 		arrays++;
-	    arrays++;
-	    if (!argv) {
-		ms = NULL;
-		argv = &ms;
-	    }
+		if (!argv) {
+		    ms = NULL;
+		    argv = &ms;
+		}
+	    } SWITCHBACKHEAPS(oldheap2);
 	}
 	if (dat->ppre)
 	    ppl = strlen(dat->ppre);
@@ -1994,17 +2003,22 @@
 		free_cline(lc);
 	    }
 	    if ((dat->aflags & CAF_ARRAYS) && !argv[1]) {
-		argv = NULL;
-		while (*arrays && (!(argv = ((dat->aflags & CAF_KEYS) ?
-					     get_user_keys(*arrays) :
-					     get_user_var(*arrays))) || !*argv))
+		Heap oldheap2;
+
+		SWITCHHEAPS(oldheap2, oldheap) {
+		    argv = NULL;
+		    while (*arrays &&
+			   (!(argv = get_data_arr(*arrays,
+						  (dat->aflags & CAF_KEYS))) ||
+			    !*argv))
+			arrays++;
 		    arrays++;
-		arrays++;
-		if (!argv) {
-		    ms = NULL;
-		    argv = &ms;
-		}
-		argv--;
+		    if (!argv) {
+			ms = NULL;
+			argv = &ms;
+		    }
+		    argv--;
+		} SWITCHBACKHEAPS(oldheap2);
 	    }
 	}
 	if (dat->apar)
@@ -2015,7 +2029,7 @@
 	    set_list_array(dat->dpar, dparl);
 	if (dat->exp)
 	    addexpl();
-    } SWITCHBACKHEAPS;
+    } SWITCHBACKHEAPS(oldheap);
 
     /* We switched back to the current heap, now restore the stack of
      * matchers. */
Index: Src/Zle/compctl.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compctl.c,v
retrieving revision 1.6
diff -u -r1.6 compctl.c
--- Src/Zle/compctl.c	2000/06/07 11:21:42	1.6
+++ Src/Zle/compctl.c	2000/06/22 08:29:24
@@ -2268,13 +2268,14 @@
 static int
 makecomplistctl(int flags)
 {
+    Heap oldheap;
     int ret;
 
     if (cdepth == MAX_CDEPTH)
 	return 0;
 
     cdepth++;
-    SWITCHHEAPS(compheap) {
+    SWITCHHEAPS(oldheap, compheap) {
 	int ooffs = offs, lip, lp;
 	char *str = comp_str(&lip, &lp, 0), *t;
 	char *os = cmdstr, **ow = clwords, **p, **q, qc;
@@ -2333,7 +2334,7 @@
 	clwords = ow;
 	clwnum = on;
 	clwpos = op;
-    } SWITCHBACKHEAPS;
+    } SWITCHBACKHEAPS(oldheap);
     cdepth--;
 
     return ret;
Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.28
diff -u -r1.28 complist.c
--- Src/Zle/complist.c	2000/06/19 14:51:06	1.28
+++ Src/Zle/complist.c	2000/06/22 08:29:24
@@ -1750,8 +1750,6 @@
 	}
 	setwish = wasnext = 0;
 
-    getk:
-
 	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
 	    zbeep();
 	    break;
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.33
diff -u -r1.33 computil.c
--- Src/Zle/computil.c	2000/06/19 13:09:07	1.33
+++ Src/Zle/computil.c	2000/06/22 08:29:25
@@ -3200,7 +3200,7 @@
 		    }
 	}
 	if (*add) {
-	    char *ret = "", buf[259], *oadd = add;
+	    char *ret = "", buf[259];
 
 	    for (mp = ms; *add; add++, mp++) {
 		if (!(m = *mp)) {
@@ -3661,6 +3661,32 @@
     return 1;
 }
 
+static int
+bin_compgroups(char *nam, char **args, char *ops, int func)
+{
+    Heap oldheap;
+    char *n;
+
+    SWITCHHEAPS(oldheap, compheap) {
+	while ((n = *args++)) {
+	    endcmgroup(NULL);
+	    begcmgroup(n, 0);
+	    endcmgroup(NULL);
+	    begcmgroup(n, CGF_NOSORT);
+	    endcmgroup(NULL);
+	    begcmgroup(n, CGF_UNIQALL);
+	    endcmgroup(NULL);
+	    begcmgroup(n, CGF_NOSORT|CGF_UNIQCON);
+	    endcmgroup(NULL);
+	    begcmgroup(n, CGF_UNIQALL);
+	    endcmgroup(NULL);
+	    begcmgroup(n, CGF_NOSORT|CGF_UNIQCON);
+	}
+    } SWITCHBACKHEAPS(oldheap);
+
+    return 0;
+}
+
 static struct builtin bintab[] = {
     BUILTIN("compdescribe", 0, bin_compdescribe, 3, -1, 0, NULL, NULL),
     BUILTIN("comparguments", 0, bin_comparguments, 1, -1, 0, NULL, NULL),
@@ -3670,6 +3696,7 @@
     BUILTIN("comptry", 0, bin_comptry, 0, -1, 0, NULL, NULL),
     BUILTIN("compfmt", 0, bin_compfmt, 2, -1, 0, NULL, NULL),
     BUILTIN("compfiles", 0, bin_compfiles, 1, -1, 0, NULL, NULL),
+    BUILTIN("compgroups", 0, bin_compgroups, 1, -1, 0, NULL, NULL),
 };
 
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

