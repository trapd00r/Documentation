From zsh-workers-return-16184-mason-zsh=primenet.com.au@sunsite.dk Fri Oct 26 23:30:53 2001
Return-Path: <zsh-workers-return-16184-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 639 invoked from network); 26 Oct 2001 23:30:53 -0000
Received: from ns2.primenet.com.au (HELO primenet.com.au) (?9aOe+OxJArjfmS2QIAYATirn+L3jECwQ?@203.24.36.3)
  by ns1.primenet.com.au with SMTP; 26 Oct 2001 23:30:53 -0000
Received: (qmail 6904 invoked from network); 26 Oct 2001 23:30:52 -0000
Received: from sunsite.dk (130.225.247.90)
  by proxy.melb.primenet.com.au with SMTP; 26 Oct 2001 23:30:52 -0000
Received: (qmail 21379 invoked by alias); 26 Oct 2001 23:30:46 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16184
Received: (qmail 21364 invoked from network); 26 Oct 2001 23:30:45 -0000
Date: Fri, 26 Oct 2001 16:29:40 -0700 (PDT)
From: Wayne Davison <wayned@users.sourceforge.net>
X-Sender: wayne@life.blorf.net
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: zsh-workers@sunsite.dk
Subject: Re: .zsh_history bugreport
In-Reply-To: <011026155103.ZM10856@candle.brasslantern.com>
Message-ID: <Pine.LNX.4.21.0110261616050.7802-100000@life.blorf.net>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

On Fri, 26 Oct 2001, Bart Schaefer wrote:
> So if fgets() returns nonzero but buf didn't get any longer, start ==
> l and (start >= l) is true and so we return -1.

The problem occurs when the buf DOES get longer, even just 1 character
longer.  In this case, the '\0' byte was not at the start of the line,
so we double the readline buffer, and recurse (even though we're nowhere
near the limit of our readline buffer).  As long as the '\0' byte is not
immidiately followed by a newline byte, we continue to read.

My original patch was wrong in that it did not handle the case where
the '\0' was at the very start of the first read, so I've fixed that.

I also noticed that the existing code had a problem in the rare case
where we read a partial string (w/o a newline) because of an EOF: the
code would eliminate the last character of the string, even though it
was not a newline.

Finally, I optimized the logic a tiny bit, and since "l" (ell) looks so
much like a "1" (one), I changed that variable name to be "len".  Here's
my new patch.

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: Src/hist.c
--- Src/hist.c	2001/10/15 18:42:52	1.35
+++ Src/hist.c	2001/10/26 23:27:28
@@ -1766,31 +1766,34 @@
 
 static int histfile_linect;
 
-static int readhistline(int start, char **bufp, int *bufsiz, FILE *in)
+static int
+readhistline(int start, char **bufp, int *bufsiz, FILE *in)
 {
     char *buf = *bufp;
     if (fgets(buf + start, *bufsiz - start, in)) {
-	int l = strlen(buf);
-
-	if (start >= l)
+	int len = start + strlen(buf + start);
+	if (len == start)
 	    return -1;
-
-	if (l) {
-	    if (buf[l - 1] != '\n' && !feof(in)) {
+	if (buf[len - 1] != '\n') {
+	    if (!feof(in)) {
+		if (len < (*bufsiz) - 1)
+		    return -1;
 		*bufp = zrealloc(buf, 2 * (*bufsiz));
 		*bufsiz = 2 * (*bufsiz);
-		return readhistline(l, bufp, bufsiz, in);
+		return readhistline(len, bufp, bufsiz, in);
 	    }
-	    buf[l - 1] = '\0';
-	    if (l > 1 && buf[l - 2] == '\\') {
-		buf[--l - 1] = '\n';
+	}
+	else {
+	    buf[len - 1] = '\0';
+	    if (len > 1 && buf[len - 2] == '\\') {
+		buf[--len - 1] = '\n';
 		if (!feof(in))
-		    return readhistline(l, bufp, bufsiz, in);
+		    return readhistline(len, bufp, bufsiz, in);
 	    }
 	}
-	return l;
-    } else
-	return 0;
+	return len;
+    }
+    return 0;
 }
 
 /**/
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

