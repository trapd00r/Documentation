From zsh-workers-return-5626-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 03 15:11:12 1999
Return-Path: <zsh-workers-return-5626-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11957 invoked from network); 3 Mar 1999 15:11:10 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 3 Mar 1999 15:11:10 -0000
Received: (qmail 28744 invoked by alias); 3 Mar 1999 15:10:52 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5626
Received: (qmail 28736 invoked from network); 3 Mar 1999 15:10:49 -0000
Message-Id: <9903031454.AA22503@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: Weird bug with approximate completion
Date: Wed, 03 Mar 1999 15:54:58 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>

I'm getting a weird bug with approximate completion:  the shell exits with
an out-of-memory error.  One command that did this (there were more) was
% echo ~/bin/comp/set<TAB>
where the real file is ~/bin/comp/_setopt.

It looks like zhalloc() is being called with one argument and getting
another much larger one.  It could be specific to AIX 3.2, and related to
the fact that my stack backtrace is now 97 frames deep (but another time it
was `only' 88).  No fewer then 12 of those (10 in the other case) are
runshfunc(), because of the effect of wrappers.  The limits are all large,
e.g. stacksize is 32MB.  Maybe it would be nice to flatten out the
hierarchy for calls to shell functions a bit.

But it's strange it only happens when correcting, so I can't be sure it
isn't a shell problem.  I couldn't get it to happen as such on HPUX or
IRIX, but I did see something weird with correction on IRIX, lots of 255
characters appeared (which isn't even German).  So maybe there is some
corruption coming from the shell.  Looks rather subtle though.  In that
case it may be useful to know that the call to zhalloc() that goes wrong is
always from

		p = (char *)ncalloc(lpl + lsl + 3);

in make complistflags() around line 6192.  The arguments lpl and lsl
themselves seem to be sensible, so it's nothing simple.  One clue might be
that I don't use pattern matching much apart from correction, and this is
in a (ispattern & 1) section (fairly innocuous looking, however, and
ordinary glob completion doesn't seem to do this).

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

