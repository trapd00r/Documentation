From zsh-workers-return-14257-mason-zsh=primenet.com.au@sunsite.dk Tue May 08 12:22:25 2001
Return-Path: <zsh-workers-return-14257-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16262 invoked from network); 8 May 2001 12:22:18 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 May 2001 12:22:18 -0000
Received: (qmail 8463 invoked by alias); 8 May 2001 12:22:07 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14257
Received: (qmail 8441 invoked from network); 8 May 2001 12:22:06 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Tue, 8 May 2001 14:21:54 +0200 (MET DST)
Message-Id: <200105081221.OAA03854@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: Using _values with ->state transitions?
In-Reply-To: <1010507150830.ZM27726@candle.brasslantern.com>

Bart Schaefer wrote:

> ...
> 
> OK, that does work for me.  However, it sometimes ignores the -s option.
> To wit:
> 
> schaefer[505] _tv() {
> function> _values -s ':' test 'a:arg:->foo' b c
> function> if [[ -n $state ]]; then compadd $state; fi
> function> }
> schaefer[506] compdef _tv :
> schaefer[507] : a<TAB>
> schaefer[507] : a=<TAB>
> schaefer[508] : a=foo 
>                       ^cursor here -- why did that space get added?
> 		      I expected `a=foo:'.

Er, how should _values do that?  At the time the `foo' is added as a
match _values isn't running anymore.  We could make _values store the
`-qS$sep' in some array that has to be declared by the calling function,
but then that function has to use it and probably could equally well do
it directly.  Should we add that or just document what the function
handling the `->state' would have to do?

(But it was broken for the (...)-forms of actions, too.  Ahem.)

> It would also be nice if there were a way to specify that something other
> than an `=' comes between the value and its argument.

The patch below does that.  One can now use `_value -S : ...' to say
that values are separated from their arguments by colons, for example.

> } > The zsh/computil documentation needs some improvement.
> } 
> } I always think of computil as something too deeply hidden for ca. 99
> } percent of all users and programmers.
> 
> Well, then, it's the doc for _values that needs improvement.  The SPECS
> for _values are no longer the same as those for _arguments (at best, they
> now are a subset).

Hm, yes, the `= ...' prefix is not supported.  Anything else we need to
add?

Bye
  Sven

Index: Completion/Base/Utility/_values
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_values,v
retrieving revision 1.1
diff -u -r1.1 _values
--- Completion/Base/Utility/_values	2001/04/02 11:12:08	1.1
+++ Completion/Base/Utility/_values	2001/05/08 12:15:21
@@ -13,9 +13,12 @@
 
 if compvalues -i "$@"; then
 
-  local noargs args opts descr action expl sep subc
+  local noargs args opts descr action expl sep argsep subc test='*'
   local oldcontext="$curcontext"
 
+  compvalues -S argsep
+  compvalues -s sep && [[ -n "$sep" ]] && test="[^${(q)sep}]#"
+
   if ! compvalues -D descr action; then
 
     _tags values || return 1
@@ -24,17 +27,17 @@
 
     compvalues -V noargs args opts
 
-    if [[ "$PREFIX" = *\=* ]]; then
+    if [[ "$PREFIX" = *${argsep}${~test} ]]; then
       local name
 
-      name="${PREFIX%%\=*}"
+      name="${PREFIX%%${argsep}*}"
       if compvalues -L "$name" descr action; then
-        IPREFIX="${IPREFIX}${name}="
-        PREFIX="${PREFIX#*\=}"
+        IPREFIX="${IPREFIX}${name}${argsep}"
+        PREFIX="${PREFIX#*${argsep}}"
       else
         local prefix suffix
 
-	prefix="${PREFIX#*\=}"
+	prefix="${PREFIX#*${argsep}}"
 	suffix="$SUFFIX"
 	PREFIX="$name"
 	SUFFIX=''
@@ -45,7 +48,7 @@
 
         PREFIX="$prefix"
 	SUFFIX="$suffix"
-        IPREFIX="${IPREFIX}${args[1]%%:*}="
+        IPREFIX="${IPREFIX}${args[1]%%:*}${argsep}"
 	compvalues -L "${args[1]%%:*}" descr action subc
 	curcontext="${oldcontext%:*}:$subc"
       fi
@@ -59,8 +62,8 @@
 
       _describe "$descr" \
         noargs "$sep[@]" -M 'r:|[_-]=* r:|=*' -- \
-        args -S= -M 'r:|[_-]=* r:|=*' -- \
-        opts -qS= -M 'r:|[_-]=* r:|=*'
+        args -S "${argsep}" -M 'r:|[_-]=* r:|=*' -- \
+        opts -qS "${argsep}" -M 'r:|[_-]=* r:|=*'
 
       curcontext="$oldcontext"
 
@@ -82,7 +85,7 @@
   # we have only one possible value left.
 
   [[ ${#snames}+${#names}+${#onames} -ne 1 ]] && compvalues -s sep &&
-      expl=( "-qS$sep" "$expl[@]" )
+      expl=( "-qS$sep" "$expl[@]" ) sep=( "-qS$sep" )
 
   if [[ "$action" = -\>* ]]; then
     compvalues -v val_args
@@ -113,7 +116,7 @@
 
       eval ws\=\( "${action[3,-3]}" \)
 
-      _describe "$descr" ws -M 'r:|[_-]=* r:|=*' "$subopts[@]"
+      _describe "$descr" ws -M 'r:|[_-]=* r:|=*' "$subopts[@]" "$sep[@]"
 
     elif [[ "$action" = \(*\) ]]; then
 
@@ -121,7 +124,7 @@
 
       eval ws\=\( "${action[2,-2]}" \)
 
-      _all_labels arguments expl "$descr" compadd "$subopts[@]" -a - ws
+      _all_labels arguments expl "$descr" compadd "$subopts[@]" "$sep[@]" -a - ws
     elif [[ "$action" = \{*\} ]]; then
 
       # A string in braces is evaluated.
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.122
diff -u -r1.122 compsys.yo
--- Doc/Zsh/compsys.yo	2001/05/08 08:47:00	1.122
+++ Doc/Zsh/compsys.yo	2001/05/08 12:15:25
@@ -3949,8 +3949,14 @@
 All other arguments describe the possible values and their
 arguments in the same format used for the description of options by
 the tt(_arguments) function (see above).  The only differences are that
-no minus or plus sign is required at the beginning and that
-values can have only one argument.
+no minus or plus sign is required at the beginning, that
+values can have only one argument and that those forms of actions
+beginning with an equal sign are not supported.
+
+The character separating a value from its argument can be set using the
+option tt(-S) (like tt(-s), followed by the character to use as the
+separator in the next argument).  If this option is not used, the equal
+sign will be used as the separator.
 
 Example:
 
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.53
diff -u -r1.53 computil.c
--- Src/Zle/computil.c	2001/05/06 22:37:51	1.53
+++ Src/Zle/computil.c	2001/05/08 12:15:26
@@ -2029,6 +2029,7 @@
     char *descr;		/* global description */
     int hassep;			/* multiple values allowed */
     char sep;			/* separator character */
+    char argsep;                /* argument separator */
     Cvdef next;			/* next in cache */
     Cvval vals;			/* value definitions */
     char **defs;		/* original strings */
@@ -2090,16 +2091,21 @@
     Cvdef ret;
     Cvval val, *valp;
     Caarg arg;
-    char **oargs = args, sep = '\0', *name, *descr, *p, *q, **xor, c;
+    char **oargs = args, sep = '\0', asep = '=', *name, *descr, *p, *q, **xor, c;
     int xnum, multi, vtype, hassep = 0;
 
-    if (args[0][0] == '-' && args[0][1] == 's' && !args[0][2]) {
+    while (args[0][0] == '-' && (args[0][1] == 's' || args[0][1] == 'S') &&
+           !args[0][2]) {
 	if (args[1][0] && args[1][1]) {
 	    zwarnnam(nam, "invalid separator: %s", args[1], 0);
 	    return NULL;
 	}
-	hassep = 1;
-	sep = args[1][0];
+        if (args[0][1] == 's') {
+            hassep = 1;
+            sep = args[1][0];
+        } else
+            asep = args[1][0];
+
 	args += 2;
     }
     if (!args[0] || !args[1]) {
@@ -2112,6 +2118,7 @@
     ret->descr = ztrdup(descr);
     ret->hassep = hassep;
     ret->sep = sep;
+    ret->argsep = asep;
     ret->next = NULL;
     ret->vals = NULL;
     ret->defs = zarrdup(oargs);
@@ -2330,7 +2337,7 @@
 	    for (str = compprefix, end = strchr(str, d->sep); end;) {
 		*end = '\0';
 
-		if ((heq = !!(eq = strchr(str, '='))))
+		if ((heq = !!(eq = strchr(str, d->argsep))))
 		    *eq++ = '\0';
 		else
 		    eq = "";
@@ -2342,7 +2349,7 @@
 		    cv_inactive(d, ptr->xor);
 		}
 		if (heq)
-		    eq[-1] = '=';
+		    eq[-1] = d->argsep;
 
 		*end = d->sep;
 		str = end + 1;
@@ -2357,7 +2364,7 @@
 		    if ((end = strchr(str, d->sep)))
 			*end = '\0';
 
-		    if ((heq = !!(eq = strchr(str, '='))))
+		    if ((heq = !!(eq = strchr(str, d->argsep))))
 			*eq++ = '\0';
 		    else
 			eq = "";
@@ -2369,7 +2376,7 @@
 			cv_inactive(d, ptr->xor);
 		    }
 		    if (heq)
-			eq[-1] = '=';
+			eq[-1] = d->argsep;
 		    if (end)
 			*end++ = d->sep;
 		}
@@ -2408,16 +2415,16 @@
     compprefix = str;
     compsuffix = ztrdup("");
 
-    if ((eq = strchr(str, '='))) {
+    if ((eq = strchr(str, d->argsep))) {
 	*eq++ = '\0';
 
 	if ((ptr = cv_get_val(d, str)) && ptr->type != CVV_NOARG) {
-	    eq[-1] = '=';
+	    eq[-1] = d->argsep;
 	    ignore_prefix(eq - str);
 	    state.def = ptr->arg;
 	    state.val = ptr;
 	} else
-	    eq[-1] = '=';
+	    eq[-1] = d->argsep;
     }
     memcpy(&cv_laststate, &state, sizeof(state));
 }
@@ -2445,6 +2452,7 @@
     case 'C': min = 1; max =  1; break;
     case 'V': min = 3; max =  3; break;
     case 's': min = 1; max =  1; break;
+    case 'S': min = 1; max =  1; break;
     case 'd': min = 1; max =  1; break;
     case 'L': min = 3; max =  4; break;
     case 'v': min = 1; max =  1; break;
@@ -2546,6 +2554,15 @@
 	    return 0;
 	}
 	return 1;
+    case 'S':
+	{
+	    char tmp[2];
+
+	    tmp[0] = cv_laststate.d->argsep;
+	    tmp[1] = '\0';
+	    setsparam(args[1], ztrdup(tmp));
+	}
+	return 0;
     case 'd':
 	setsparam(args[1], ztrdup(cv_laststate.d->descr));
 	return 0;

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

