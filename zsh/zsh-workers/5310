Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Message-ID: <19990208064924.18981.qmail@hotmail.com>
X-Originating-IP: [209.157.52.3]
From: "Matt Armstrong" <mattarmst@hotmail.com>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH zsh-3.1.5-pws-7: cygwin make fixes
Date: Sun, 07 Feb 1999 22:49:22 PST
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="----=_NextPart_000_4050cdcc_7b834069$6fb35eff"
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5310

------=_NextPart_000_4050cdcc_7b834069$6fb35eff
Content-Type: text/plain

There are two problems with the make system in zsh-3.1.5-pws-7 (and 
surely previous versions) when running under cygwin.

1) The makefiles assume they are creating "zsh" and not "zsh.exe."  Not 
a problem unless you do a "make install" under cygwin.

2) The Src/signames.awk gets confused by cygwin's sys/signals.h since it 
defines signal names for multiple platforms (many of which #define all 
the signal names to 1).

I fixed #1 by adding AC_EXEEXT to configure.in and using the 
corresponding $(EXEEXT) variable where needed in the other makefiles.  
WARNING: I imagine you need a fairly recent autoconf to get the 
AC_EXEEXT (I tested with version 2.13).  You can get it at 
http://sourceware.cygnus.com/autoconf/.

I fixed #2 by re-doing the way signames.c is created.  Instead of a AWK 
script that gets run on a signal.h file, a C program is compiled and 
run.  This gets it right even if the signal.h file is hard to parse.

My fix for #1 may be controversial because it may break for people who 
need to keep using an older autoconf.  Is upgrading a problem?

My fix for #2, I think, is a good thing.  ;-)  I'd do the same thing for 
the RLIMIT stuff if cygwin had RLIMIT stuff.

The patch for both is attached (they intertwine).

Please let me know if sending patches as MIME attachments is an 
inconvenience (though, pasting a patch file into this little hotmail 
edit window may ruin it).

The patch file is generated with cvs rdiff.  If you apply it with 
'patch', do it as "patch -p1 -E < zsh-patch.txt" in the root of your zsh 
tree.  "-p1" (p-one, not "el") will strip off the leading "zsh" path 
component that cvs rdiff likes to add.  "-E" will delete 
Src/signames.awk instead of leaving it as a zero length file.

REMEMBER: Src/mksignames.c is a new file, Src/signames.awk gets deleted.

Testing: You might check that "kill -l" prints the same thing before and 
after this patch.

______________________________________________________
Get Your Private, Free Email at http://www.hotmail.com
------=_NextPart_000_4050cdcc_7b834069$6fb35eff
Content-Type: text/plain; name="zsh-patch.txt"
Content-Transfer-Encoding: 8bit
Content-Disposition: attachment; filename="zsh-patch.txt"

Index: zsh/configure.in
diff -c zsh/configure.in:1.1.1.3 zsh/configure.in:1.3
*** zsh/configure.in:1.1.1.3	Sat Jan 30 10:14:56 1999
--- zsh/configure.in	Tue Feb 02 23:11:27 1999
***************
*** 287,292 ****
--- 287,294 ----
  fi
  AC_SUBST(U)
  
+ AC_EXEEXT                   dnl Determine the executable suffix.
+ 
  AC_FUNC_ALLOCA              dnl Check how to get `alloca'.
  
  dnl If the compiler supports union initialisation
***************
*** 661,684 ****
  fi
  AC_DEFINE_UNQUOTED($signals_style)
  AC_MSG_RESULT($signals_style)
- 
- dnl Where is <signal.h> located?  Needed as input for signals.awk
- AC_CACHE_CHECK(where signal.h is located, zsh_cv_path_signal_h,
- [for SIGNAL_H in /usr/include/bsd/sys/signal.h  dnl Next
-                  /usr/include/asm/signum.h      dnl alpha-Linux
-                  /usr/include/asm/signal.h      dnl Linux 1.3.0 and above
-                  /usr/include/linux/signal.h    dnl Linux up to 1.2.11
-                  /usr/include/sys/signal.h      dnl Almost everybody else
-                  /dev/null;                     dnl Just in case we fall through
- do
-   test -f $SIGNAL_H && \
-   grep '#[ 	]*define[ 	][ 	]*SIG[0-9A-Z]*[ 	]*[0-9][0-9]*' $SIGNAL_H > /dev/null && \
-   break
- done
- zsh_cv_path_signal_h=$SIGNAL_H
- ])
- SIGNAL_H=$zsh_cv_path_signal_h
- AC_SUBST(SIGNAL_H)dnl
  
  dnl -----------------------------------------------------
  dnl Look for the file containing the RLIMIT_* definitions
--- 663,668 ----
Index: zsh/Config/defs.mk
diff -c zsh/Config/defs.mk:1.1.1.2 zsh/Config/defs.mk:1.2
*** zsh/Config/defs.mk:1.1.1.2	Sat Jan 23 20:48:28 1999
--- zsh/Config/defs.mk	Tue Feb 02 23:11:27 1999
***************
*** 58,63 ****
--- 58,64 ----
  DLLD            = @DLLD@
  EXPOPT          = @EXPOPT@
  IMPOPT          = @IMPOPT@
+ EXEEXT          = @EXEEXT@
  
  # utilities
  AWK             = @AWK@
Index: zsh/Src/.cvsignore
diff -c zsh/Src/.cvsignore:1.1.1.1 zsh/Src/.cvsignore:1.2
*** zsh/Src/.cvsignore:1.1.1.1	Sat Jan 23 18:10:11 1999
--- zsh/Src/.cvsignore	Sat Jan 30 14:06:22 1999
***************
*** 23,25 ****
--- 23,26 ----
  zshxmods.h
  bltinmods.list
  tags TAGS
+ mksignames mksignames.exe
\ No newline at end of file
Index: zsh/Src/Makefile.in
diff -c zsh/Src/Makefile.in:1.1.1.2 zsh/Src/Makefile.in:1.3
*** zsh/Src/Makefile.in:1.1.1.2	Sat Jan 23 20:48:38 1999
--- zsh/Src/Makefile.in	Tue Feb 02 23:17:23 1999
***************
*** 41,47 ****
  
  all: bin modules
  
! bin: zsh
  
  modules: headers
  
--- 41,47 ----
  
  all: bin modules
  
! bin: zsh$(EXEEXT)
  
  modules: headers
  
***************
*** 63,69 ****
  LDRUNPATH = LD_RUN_PATH=$(libdir)/zsh
  NDRUNPATH =
  
! zsh: $(@L@IBZSH) $(@L@STMP) $(MAIN_OBJS)
  	rm -f $@
  	$(@L@DRUNPATH) $(LINK) $(MAIN_OBJS) $(@L@LIST) $(ZSH_@E@XPORT) $(@L@IBZSH) $(LIBS)
  
--- 63,69 ----
  LDRUNPATH = LD_RUN_PATH=$(libdir)/zsh
  NDRUNPATH =
  
! zsh$(EXEEXT): $(@L@IBZSH) $(@L@STMP) $(MAIN_OBJS)
  	rm -f $@
  	$(@L@DRUNPATH) $(LINK) $(MAIN_OBJS) $(@L@LIST) $(ZSH_@E@XPORT) $(@L@IBZSH) $(LIBS)
  
***************
*** 147,162 ****
  uninstall.bin: uninstall.bin-here
  
  # install binary, creating install directory if necessary
! install.bin-here: zsh install.bin-@L@
  	$(sdir_top)/mkinstalldirs $(bindir)
! 	$(INSTALL_PROGRAM) $(STRIPFLAGS) zsh $(bindir)/zsh-$(VERSION)
! 	if test -f $(bindir)/zsh; then \
! 	    rm -f $(bindir)/zsh.old; \
! 	    ln $(bindir)/zsh $(bindir)/zsh.old; \
  	else :; fi
! 	rm -f $(bindir)/zsh.new
! 	ln $(bindir)/zsh-$(VERSION) $(bindir)/zsh.new
! 	mv $(bindir)/zsh.new $(bindir)/zsh
  
  install.bin-N:
  install.bin-L: $(LIBZSH)
--- 147,162 ----
  uninstall.bin: uninstall.bin-here
  
  # install binary, creating install directory if necessary
! install.bin-here: zsh$(EXEEXT) install.bin-@L@
  	$(sdir_top)/mkinstalldirs $(bindir)
! 	$(INSTALL_PROGRAM) $(STRIPFLAGS) zsh$(EXEEXT) $(bindir)/zsh-$(VERSION)$(EXEEXT)
! 	if test -f $(bindir)/zsh$(EXEEXT); then \
! 	    rm -f $(bindir)/zsh.old$(EXEEXT); \
! 	    ln $(bindir)/zsh$(EXEEXT) $(bindir)/zsh.old$(EXEEXT); \
  	else :; fi
! 	rm -f $(bindir)/zsh.new$(EXEEXT)
! 	ln $(bindir)/zsh-$(VERSION)$(EXEEXT) $(bindir)/zsh.new$(EXEEXT)
! 	mv $(bindir)/zsh.new$(EXEEXT) $(bindir)/zsh$(EXEEXT)
  
  install.bin-N:
  install.bin-L: $(LIBZSH)
***************
*** 165,171 ****
  
  # uninstall binary
  uninstall.bin-here: uninstall.bin-@L@
! 	rm -f $(bindir)/zsh-$(VERSION) $(bindir)/zsh
  
  uninstall.bin-N:
  uninstall.bin-L:
--- 165,171 ----
  
  # uninstall binary
  uninstall.bin-here: uninstall.bin-@L@
! 	rm -f $(bindir)/zsh-$(VERSION)$(EXEEXT) $(bindir)/zsh$(EXEEXT)
  
  uninstall.bin-N:
  uninstall.bin-L:
***************
*** 179,185 ****
  	rm -f stamp-modobjs stamp-modobjs.tmp
  
  clean-here:
! 	rm -f modules.index.tmp modules.stamp zsh ansi2knr.o ansi2knr
  	rm -f libzsh-*.$(DL_EXT)
  
  distclean-here:
--- 179,185 ----
  	rm -f stamp-modobjs stamp-modobjs.tmp
  
  clean-here:
! 	rm -f modules.index.tmp modules.stamp zsh$(EXEEXT) ansi2knr.o ansi2knr
  	rm -f libzsh-*.$(DL_EXT)
  
  distclean-here:
Index: zsh/Src/mksignames.c
diff -c nul zsh/Src/mksignames.c:1.2
*** nul	Sun Feb 07 22:08:50 1999
--- zsh/Src/mksignames.c	Sun Jan 31 21:57:56 1999
***************
*** 0 ****
--- 1,320 ----
+ /*
+  * mksignames.c - create signames.c
+  *
+  * This file is part of zsh, the Z shell.
+  *
+  * Copyright (c) 1999 Matt Armstrong
+  * All rights reserved
+  *
+  * Permission is hereby granted, without written agreement and without
+  * license or royalty fees, to use, copy, modify, and distribute this
+  * software and to distribute modified versions of this software for
+  * any purpose, provided that the above copyright notice and the
+  * following two paragraphs appear in all copies of this software.
+  *
+  * In no event shall Matt Armstrong or the Zsh Development Group be
+  * liable to any party for direct, indirect, special, incidental, or
+  * consequential damages arising out of the use of this software and
+  * its documentation, even if Matt Armstrong and the Zsh Development
+  * Group have been advised of the possibility of such damage.
+  *
+  * Matt Armstrong and the Zsh Development Group specifically disclaim
+  * any warranties, including, but not limited to, the implied
+  * warranties of merchantability and fitness for a particular purpose.
+  * The software provided hereunder is on an "as is" basis, and Matt
+  * Armstrong and the Zsh Development Group have no obligation to
+  * provide maintenance, support, updates, enhancements, or
+  * modifications.
+  *
+  */
+ 
+ /*
+  * This code replaces the previous signames.awk that tried to deduce
+  * the number and kind of signals available on the system by examining
+  * the header files.  The idea is that the C version will get the
+  * answer right more often.  
+  */
+ #include <stdio.h>
+ #include <signal.h>
+ 
+ #ifdef NSIG
+ #define MAX_SIGNAL NSIG
+ #else
+ #define MAX_SIGNAL 60
+ #endif
+ 
+ #define MAX(x,y) ((x)>(y)?(x):(y))
+ 
+ char *sigmsg[MAX_SIGNAL];
+ char *sigs[MAX_SIGNAL];
+ int max_signal;
+ #ifdef USE_SUSPENDED
+ int suspended = 1;
+ #else
+ int suspended = 0;
+ #endif
+ 
+ /* For each signal in the system, describe it in the sigmsg[] and sigs[]
+    arrays.  Bump max_signal to the largest possible signal value. */
+ void
+ init(void)
+ {
+     int i, missing;
+ 
+     sigs[0] = "EXIT";
+     sigmsg[0] = "done";
+ 
+ #ifdef SIGALRM
+     sigs[SIGALRM] = "ALRM";
+     sigmsg[SIGALRM] = "alarm";
+     max_signal = MAX(max_signal, SIGALRM);
+ #endif
+ #ifdef SIGBUS
+     sigs[SIGBUS] = "BUS";
+     sigmsg[SIGBUS] = "bus error";
+     max_signal = MAX(max_signal, SIGBUS);
+ #endif
+ #ifdef SIGCHLD
+     sigs[SIGCHLD] = "CHLD";
+     sigmsg[SIGCHLD] = "death of child";
+     max_signal = MAX(max_signal, SIGCHLD);
+ #endif
+ #ifdef SIGCLD
+     sigs[SIGCLD] = "CLD";
+     sigmsg[SIGCLD] = "death of child";
+     max_signal = MAX(max_signal, SIGCLD);
+ #endif
+ #ifdef SIGCONT
+     sigs[SIGCONT] = "CONT";
+     sigmsg[SIGCONT] = "continued";
+     max_signal = MAX(max_signal, SIGCONT);
+ #endif
+ #ifdef SIGEMT
+     sigs[SIGEMT] = "EMT";
+     sigmsg[SIGEMT] = "EMT instruction";
+     max_signal = MAX(max_signal, SIGEMT);
+ #endif
+ #ifdef SIGFPE
+     sigs[SIGFPE] = "FPE";
+     sigmsg[SIGFPE] = "floating point exception";
+     max_signal = MAX(max_signal, SIGFPE);
+ #endif
+ #ifdef SIGHUP
+     sigs[SIGHUP] = "HUP";
+     sigmsg[SIGHUP] = "hangup";
+     max_signal = MAX(max_signal, SIGHUP);
+ #endif
+ #ifdef SIGILL
+     sigs[SIGILL] = "ILL";
+     sigmsg[SIGILL] = "illegal hardware instruction";
+     max_signal = MAX(max_signal, SIGILL);
+ #endif
+ #ifdef SIGINFO
+     sigs[SIGINFO] = "INFO";
+     sigmsg[SIGINFO] = "status request from keyboard";
+     max_signal = MAX(max_signal, SIGINFO);
+ #endif
+ #ifdef SIGINT
+     sigs[SIGINT] = "INT";
+     sigmsg[SIGINT] = "interrupt";
+     max_signal = MAX(max_signal, SIGINT);
+ #endif
+ #ifdef SIGIO
+     sigs[SIGIO] = "IO";
+     sigmsg[SIGIO] = "i/o ready";
+     max_signal = MAX(max_signal, SIGIO);
+ #endif
+ #ifdef SIGIOT
+     sigs[SIGIOT] = "IOT";
+     sigmsg[SIGIOT] = "IOT instruction";
+     max_signal = MAX(max_signal, SIGIOT);
+ #endif
+ #ifdef SIGABRT
+     sigs[SIGABRT] = "ABRT";
+     sigmsg[SIGABRT] = "abort";
+     max_signal = MAX(max_signal, SIGABRT);
+ #endif
+ #ifdef SIGKILL
+     sigs[SIGKILL] = "KILL";
+     sigmsg[SIGKILL] = "killed";
+     max_signal = MAX(max_signal, SIGKILL);
+ #endif
+ #ifdef SIGLOST
+     sigs[SIGLOST] = "LOST";
+     sigmsg[SIGLOST] = "resource lost";
+     max_signal = MAX(max_signal, SIGLOST);
+ #endif
+ #ifdef SIGPIPE
+     sigs[SIGPIPE] = "PIPE";
+     sigmsg[SIGPIPE] = "broken pipe";
+     max_signal = MAX(max_signal, SIGPIPE);
+ #endif
+ #ifdef SIGPOLL
+     sigs[SIGPOLL] = "POLL";
+     sigmsg[SIGPOLL] = "pollable event occurred";
+     max_signal = MAX(max_signal, SIGPOLL);
+ #endif
+ #ifdef SIGPROF
+     sigs[SIGPROF] = "PROF";
+     sigmsg[SIGPROF] = "profile signal";
+     max_signal = MAX(max_signal, SIGPROF);
+ #endif
+ #ifdef SIGPWR
+     sigs[SIGPWR] = "PWR";
+     sigmsg[SIGPWR] = "power fail";
+     max_signal = MAX(max_signal, SIGPWR);
+ #endif
+ #ifdef SIGQUIT
+     sigs[SIGQUIT] = "QUIT";
+     sigmsg[SIGQUIT] = "quit";
+     max_signal = MAX(max_signal, SIGQUIT);
+ #endif
+ #ifdef SIGSEGV
+     sigs[SIGSEGV] = "SEGV";
+     sigmsg[SIGSEGV] = "segmentation fault";
+     max_signal = MAX(max_signal, SIGSEGV);
+ #endif
+ #ifdef SIGSYS
+     sigs[SIGSYS] = "SYS";
+     sigmsg[SIGSYS] = "invalid system call";
+     max_signal = MAX(max_signal, SIGSYS);
+ #endif
+ #ifdef SIGTERM
+     sigs[SIGTERM] = "TERM";
+     sigmsg[SIGTERM] = "terminated";
+     max_signal = MAX(max_signal, SIGTERM);
+ #endif
+ #ifdef SIGTRAP
+     sigs[SIGTRAP] = "TRAP";
+     sigmsg[SIGTRAP] = "trace trap";
+     max_signal = MAX(max_signal, SIGTRAP);
+ #endif
+ #ifdef SIGURG
+     sigs[SIGURG] = "URG";
+     sigmsg[SIGURG] = "urgent condition";
+     max_signal = MAX(max_signal, SIGURG);
+ #endif
+ #ifdef SIGUSR1
+     sigs[SIGUSR1] = "USR1";
+     sigmsg[SIGUSR1] = "user-defined signal 1";
+     max_signal = MAX(max_signal, SIGUSR1);
+ #endif
+ #ifdef SIGUSR2
+     sigs[SIGUSR2] = "USR2";
+     sigmsg[SIGUSR2] = "user-defined signal 2";
+     max_signal = MAX(max_signal, SIGUSR2);
+ #endif
+ #ifdef SIGVTALRM
+     sigs[SIGVTALRM] = "VTALRM";
+     sigmsg[SIGVTALRM] = "virtual time alarm";
+     max_signal = MAX(max_signal, SIGVTALRM);
+ #endif
+ #ifdef SIGWINCH
+     sigs[SIGWINCH] = "WINCH";
+     sigmsg[SIGWINCH] = "window size changed";
+     max_signal = MAX(max_signal, SIGWINCH);
+ #endif
+ #ifdef SIGXCPU
+     sigs[SIGXCPU] = "XCPU";
+     sigmsg[SIGXCPU] = "cpu limit exceeded";
+     max_signal = MAX(max_signal, SIGXCPU);
+ #endif
+ #ifdef SIGXFSZ
+     sigs[SIGXFSZ] = "XFSZ";
+     sigmsg[SIGXFSZ] = "file size limit exceeded";
+     max_signal = MAX(max_signal, SIGXFSZ);
+ #endif
+ #ifdef SIGSTOP
+     sigs[SIGSTOP] = "STOP";
+     sigmsg[SIGSTOP] = suspended ? "suspended (signal)" : "stopped (signal)";
+     max_signal = MAX(max_signal, SIGSTOP);
+ #endif
+ #ifdef SIGTSTP
+     sigs[SIGTSTP] = "TSTP";
+     sigmsg[SIGTSTP] = "";
+     max_signal = MAX(max_signal, SIGTSTP);
+ #endif
+ #ifdef SIGTTIN
+     sigs[SIGTTIN] = "TTIN";
+     sigmsg[SIGTTIN] = " (tty input)";
+     max_signal = MAX(max_signal, SIGTTIN);
+ #endif
+ #ifdef SIGTTOU
+     sigs[SIGTTOU] = "TTOU";
+     sigmsg[SIGTTOU] = " (tty output)";
+     max_signal = MAX(max_signal, SIGTTOU);
+ #endif
+ 
+     /* Now make sure we have them all.  NSIG is a POSIX thing, I
+        think. */
+ #ifdef NSIG
+     if (max_signal != NSIG - 1) {
+ 	printf("Found %d signals, while signal.h's NSIG #define is %d.\n",
+ 	       max_signal, NSIG);
+ 	printf("Modify mksignames.c to include the missing signal(s).\n");
+ 	exit(1);
+     }
+ #endif
+ }
+ 
+ /* Print signames.c to stdout */
+ void
+ printit(void)
+ {
+     int i;
+ 
+     printf("/** signames.c                                 **/\n");
+     printf("/** architecture-customized signames.c for zsh **/\n");
+     printf("\n");
+     printf("#define SIGCOUNT\t%d\n", max_signal);
+     printf("\n");
+     printf("#include \"zsh.mdh\"\n");
+     printf("\n");
+ 
+     printf("/**/\n");
+     printf("char *sigmsg[SIGCOUNT+2] = {\n");
+     for (i = 0; i <= max_signal; i++) {
+ 	if (!sigmsg[i]) {
+ 	    printf("\t\"\",\n");
+ 	} else {
+ 	    if (i == SIGSTOP 
+ 		|| i == SIGTSTP
+ 		|| i == SIGTTIN
+ 		|| i == SIGTTOU) {
+ 		printf("# ifdef USE_SUSPENDED\n\t\"suspended%s\",\n",
+ 		       sigmsg[i]);
+ 		printf("# else\n\t\"stopped%s\",\n# endif\n",
+ 		       sigmsg[i]);
+ 	    } else {
+ 		printf("\t\"%s\",\n", sigmsg[i]);
+ 	    }
+ 	}
+     }
+     puts("\tNULL");
+     puts("};");
+     puts("");
+ 
+     printf("/**/\n");
+     printf("char *sigs[SIGCOUNT+4] = {\n");
+     for (i = 0; i <= max_signal; i++) {
+ 	if (sigs[i] == "") {
+ 	    printf("\t\"%d\",\n", i);
+ 	} else {
+ 	    printf("\t\"%s\",\n", sigs[i]);
+ 	}
+     }
+     printf("\t\"ZERR\",\n");
+     printf("\t\"DEBUG\",\n");
+     puts("\tNULL");
+     puts("};");
+ }
+ 
+ int
+ main()
+ {
+     init();
+     printit();
+     exit(0);
+ }
+ 
+ 
Index: zsh/Src/signames.awk
diff -c zsh/Src/signames.awk:1.1.1.1 zsh/Src/signames.awk:removed
*** zsh/Src/signames.awk:1.1.1.1	Sat Jan 23 18:10:11 1999
--- zsh/Src/signames.awk	Sun Feb 07 22:08:50 1999
***************
*** 1,98 ****
- #
- # {g,n}awk script to generate signames.c
- #
- # NB: On SunOS 4.1.3 - user-functions don't work properly, also \" problems
- # Without 0 + hacks some nawks compare numbers as strings
- #
- /^[\t ]*#[\t ]*define[\t _]*SIG[A-Z][A-Z0-9]*[\t ]*[1-9][0-9]*/ { 
-     sigindex = index($0, "SIG")
-     sigtail = substr($0, sigindex, 80)
-     split(sigtail, tmp)
-     signam = substr(tmp[1], 4, 20)
-     signum = tmp[2]
-     if (sig[signum] == "") {
- 	sig[signum] = signam
- 	if (0 + max < 0 + signum && signum < 60)
- 	    max = signum
- 	if (signam == "ABRT")   { msg[signum] = "abort" }
- 	if (signam == "ALRM")   { msg[signum] = "alarm" }
- 	if (signam == "BUS")    { msg[signum] = "bus error" }
- 	if (signam == "CHLD")   { msg[signum] = "death of child" }
- 	if (signam == "CLD")    { msg[signum] = "death of child" }
- 	if (signam == "CONT")   { msg[signum] = "continued" }
- 	if (signam == "EMT")    { msg[signum] = "EMT instruction" }
- 	if (signam == "FPE")    { msg[signum] = "floating point exception" }
- 	if (signam == "HUP")    { msg[signum] = "hangup" }
- 	if (signam == "ILL")    { msg[signum] = "illegal hardware instruction" }
- 	if (signam == "INFO")   { msg[signum] = "status request from keyboard" }
- 	if (signam == "INT")    { msg[signum] = "interrupt" }
- 	if (signam == "IO")     { msg[signum] = "i/o ready" }
- 	if (signam == "IOT")    { msg[signum] = "IOT instruction" }
- 	if (signam == "KILL")   { msg[signum] = "killed" }
- 	if (signam == "LOST")	{ msg[signum] = "resource lost" }
- 	if (signam == "PIPE")   { msg[signum] = "broken pipe" }
- 	if (signam == "POLL")	{ msg[signum] = "pollable event occurred" }
- 	if (signam == "PROF")   { msg[signum] = "profile signal" }
- 	if (signam == "PWR")    { msg[signum] = "power fail" }
- 	if (signam == "QUIT")   { msg[signum] = "quit" }
- 	if (signam == "SEGV")   { msg[signum] = "segmentation fault" }
- 	if (signam == "SYS")    { msg[signum] = "invalid system call" }
- 	if (signam == "TERM")   { msg[signum] = "terminated" }
- 	if (signam == "TRAP")   { msg[signum] = "trace trap" }
- 	if (signam == "URG")	{ msg[signum] = "urgent condition" }
- 	if (signam == "USR1")   { msg[signum] = "user-defined signal 1" }
- 	if (signam == "USR2")   { msg[signum] = "user-defined signal 2" }
- 	if (signam == "VTALRM") { msg[signum] = "virtual time alarm" }
- 	if (signam == "WINCH")  { msg[signum] = "window size changed" }
- 	if (signam == "XCPU")   { msg[signum] = "cpu limit exceeded" }
- 	if (signam == "XFSZ")   { msg[signum] = "file size limit exceeded" }
-     }
- }
- 
- END {
-     ps = "%s"
-     ifdstr = sprintf("# ifdef USE_SUSPENDED\n\t%csuspended%s%c,\n%s else\n\t%cstopped%s%c,\n# endif\n", 34, ps, 34, "#", 34, ps, 34)
- 
-     printf "/** signames.c                                 **/\n"
-     printf "/** architecture-customized signames.c for zsh **/\n"
-     printf "\n"
-     printf "#define SIGCOUNT\t%d\n", max
-     printf "\n"
-     printf "#include %czsh.mdh%c\n", 34, 34
-     printf "\n"
-     printf "/**/\n"
-     printf "char *sigmsg[SIGCOUNT+2] = {\n"
-     printf "\t%c%s%c,\n", 34, "done", 34
- 
-     for (i = 1; i <= 0 + max; i++)
- 	if (msg[i] == "") {
- 	    if (sig[i] == "")
- 		printf("\t%c%c,\n", 34, 34)
- 	    else if (sig[i] == "STOP")
- 		printf ifdstr, " (signal)", " (signal)"
- 	    else if (sig[i] == "TSTP")
- 		printf ifdstr, "", ""
- 	    else if (sig[i] == "TTIN")
- 		printf ifdstr, " (tty input)", " (tty input)"
- 	    else if (sig[i] == "TTOU")
- 		printf ifdstr, " (tty output)", " (tty output)"
- 	    else
- 		printf("\t%cSIG%s%c,\n", 34, sig[i], 34)
- 	} else
- 	    printf("\t%c%s%c,\n", 34, msg[i], 34)
-     print "\tNULL"
-     print "};"
-     print ""
-     print "/**/"
-     printf "char *sigs[SIGCOUNT+4] = {\n"
-     printf("\t%cEXIT%c,\n", 34, 34)
-     for (i = 1; i <= 0 + max; i++)
- 	if (sig[i] == "")
- 	    printf("\t%c%d%c,\n", 34, i, 34)
- 	else
- 	    printf("\t%c%s%c,\n", 34, sig[i], 34)
-     printf("\t%cZERR%c,\n", 34, 34)
-     printf("\t%cDEBUG%c,\n", 34, 34)
-     print "\tNULL"
-     print "};"
- }
--- 0 ----
Index: zsh/Src/zsh.mdd
diff -c zsh/Src/zsh.mdd:1.1.1.2 zsh/Src/zsh.mdd:1.4
*** zsh/Src/zsh.mdd:1.1.1.2	Sat Jan 23 20:48:42 1999
--- zsh/Src/zsh.mdd	Sun Feb 07 22:08:28 1999
***************
*** 12,20 ****
  prototypes.h hashtable.h ztype.h"
  
  :<<\Make
! signames.c: signames.awk ../config.h @SIGNAL_H@
! 	$(AWK) -f $(sdir)/signames.awk @SIGNAL_H@ > $@
  
  sigcount.h: signames.c
  	grep 'define.*SIGCOUNT' signames.c > $@
  
--- 12,27 ----
  prototypes.h hashtable.h ztype.h"
  
  :<<\Make
! mksignames.o: mksignames.c
! 	$(CC) -c $(CPPFLAGS) $(CFLAGS) $(sdir)/mksignames.c
  
+ mksignames$(EXEEXT): mksignames.o
+ 	$(CC) $(LDFLAGS) $(EXELDFLAGS) -o $@ ansi2knr.o
+ 
+ signames.c: ../config.h mksignames.c
+ 	$(CC) $(sdir)/mksignames.c -o mksignames$(EXEEXT)
+ 	./mksignames$(EXEEXT) > $@
+ 
  sigcount.h: signames.c
  	grep 'define.*SIGCOUNT' signames.c > $@
  
***************
*** 60,66 ****
  
  clean-here: clean.zsh
  clean.zsh:
! 	rm -f sigcount.h signames.c bltinmods.list version.h zshpaths.h zshxmods.h
  
  # This is not properly part of this module, but it is built as if it were.
  main.o: main.c zsh.mdh main.pro
--- 67,73 ----
  
  clean-here: clean.zsh
  clean.zsh:
! 	rm -f sigcount.h signames.c bltinmods.list version.h zshpaths.h zshxmods.h mksignames.o mksignames$(EXEEXT)
  
  # This is not properly part of this module, but it is built as if it were.
  main.o: main.c zsh.mdh main.pro

------=_NextPart_000_4050cdcc_7b834069$6fb35eff--


