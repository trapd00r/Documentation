From zsh-workers-request@math.gatech.edu Mon Oct 26 23:10:25 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2471 invoked from network); 26 Oct 1998 23:10:24 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 26 Oct 1998 23:10:24 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id RAA22828;
	Mon, 26 Oct 1998 17:55:59 -0500 (EST)
Resent-Date: Mon, 26 Oct 1998 17:55:59 -0500 (EST)
From: Phil Pennock <phil@athenaeum.demon.co.uk>
Message-Id: <199810262303.XAA00552@athenaeum.demon.co.uk>
Subject: Docs fix
To: zsh-workers@math.gatech.edu
Date: Mon, 26 Oct 1998 23:03:47 +0000 (GMT)
X-Disclaimer-1: Any views expressed in this message, where not explicitly
X-Disclaimer-2: attributed otherwise, are mine and mine alone.  Such views
X-Disclaimer-3: do not necessarily coincide with those of any organisation
X-Disclaimer-4: or company with which I am or have been affiliated.
X-Personality: INTJ
X-Phase-of-Moon: The Moon is Waxing Crescent (33% of Full)
X-Mailer: ELM [version 2.4ME+ PL37 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"zOfv81.0.da5._tFDs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4450
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Quick docs fix; fairly trivial.

The first one is just some stuff for the FAQ about $* vs "$@"

The second one is a couple of fixes for grammar.yo -- a typo and a
semantic flaw.

They're both small, so in just one mail.  I think you can just stick two
diffs together the way I have ...

-Phil
-----------------------------< cut here >-------------------------------
*** Etc/FAQ.yo.old	Wed Apr 29 00:50:21 1998
--- Etc/FAQ.yo	Thu Oct 15 23:25:21 1998
***************
*** 687,698 ****
    )
    can be replaced by the zsh function,
    verb(
!     cd() { builtin cd $*; echo $PWD; }
    )
    (the `builtin' tells zsh to use its own `cd', avoiding an infinite loop)
    or, perhaps better,
    verb(
!     cd() { builtin cd $*; print -D $PWD; }
    )
    (which converts your home directory to a tt(~)).  In fact, this problem is
    better solved by defining the special function chpwd() (see the manual).
--- 687,698 ----
    )
    can be replaced by the zsh function,
    verb(
!     cd() { builtin cd "$@"; echo $PWD; }
    )
    (the `builtin' tells zsh to use its own `cd', avoiding an infinite loop)
    or, perhaps better,
    verb(
!     cd() { builtin cd "$@"; print -D $PWD; }
    )
    (which converts your home directory to a tt(~)).  In fact, this problem is
    better solved by defining the special function chpwd() (see the manual).
***************
*** 704,719 ****
    SETCOUNTER(XXenumcounter)(0)
    enumerate(
    myeit() If the csh alias references "parameters" (tt(\!:1), tt(\!*) etc.),
!      then in zsh you need a function (referencing tt($1), tt($*) etc.).
       Otherwise, you can use a zsh alias.
  
    myeit() If you use a zsh function, you need to refer _at_least_ to
!      tt($*) in the body (inside the tt({ })).  Parameters don't magically
       appear inside the tt({ }) the way they get appended to an alias.
  
    myeit() If the csh alias references its own name (tt(alias rm "rm -i")),
       then in a zsh function you need the "command" keyword
!      (function tt(rm() { command rm -i $* })), but in a zsh alias
       you don't (tt(alias rm="rm -i")).
  
    myeit() If you have aliases that refer to each other (tt(alias ls "ls -C";
--- 704,719 ----
    SETCOUNTER(XXenumcounter)(0)
    enumerate(
    myeit() If the csh alias references "parameters" (tt(\!:1), tt(\!*) etc.),
!      then in zsh you need a function (referencing tt($1), tt($*) or tt("$@") etc.).
       Otherwise, you can use a zsh alias.
  
    myeit() If you use a zsh function, you need to refer _at_least_ to
!      tt($*) or tt("$@") in the body (inside the tt({ })).  Parameters don't magically
       appear inside the tt({ }) the way they get appended to an alias.
  
    myeit() If the csh alias references its own name (tt(alias rm "rm -i")),
       then in a zsh function you need the "command" keyword
!      (function tt(rm() { command rm -i "$@" })), but in a zsh alias
       you don't (tt(alias rm="rm -i")).
  
    myeit() If you have aliases that refer to each other (tt(alias ls "ls -C";
***************
*** 766,772 ****
    There is one other serious problem with aliases: consider
    verb(
      alias l='/bin/ls -F'
!     l() { /bin/ls -la $* | more }
    )
    mytt(l) in the function definition is in command position and is expanded
    as an alias, defining mytt(/bin/ls) and mytt(-F) as functions which call
--- 766,772 ----
    There is one other serious problem with aliases: consider
    verb(
      alias l='/bin/ls -F'
!     l() { /bin/ls -la "$@" | more }
    )
    mytt(l) in the function definition is in command position and is expanded
    as an alias, defining mytt(/bin/ls) and mytt(-F) as functions which call
*** Doc/Zsh/grammar.yo.old	Thu Oct 15 23:28:26 1998
--- Doc/Zsh/grammar.yo	Thu Oct 15 23:35:11 1998
***************
*** 117,123 ****
  cindex(for loops)
  cindex(loops, for)
  item(tt(for) var(name) [ tt(in) var(word) ... var(term) ] tt(do) var(list) tt(done))(
! where var(term) is one ore more newline or tt(;).
  Expand the list of var(word)s, and set the parameter
  var(name) to each of them in turn, executing
  var(list) each time.  If the tt(in) var(word) is omitted,
--- 117,123 ----
  cindex(for loops)
  cindex(loops, for)
  item(tt(for) var(name) [ tt(in) var(word) ... var(term) ] tt(do) var(list) tt(done))(
! where var(term) is one or more newline or tt(;).
  Expand the list of var(word)s, and set the parameter
  var(name) to each of them in turn, executing
  var(list) each time.  If the tt(in) var(word) is omitted,
***************
*** 211,217 ****
  cindex(testing conditional expression)
  item(tt([[) var(exp) tt(]]))(
  Evaluates the conditional expression var(exp)
! and return a zero exit status if it is true.
  See noderef(Conditional Expressions)
  for a description of var(exp).
  )
--- 211,217 ----
  cindex(testing conditional expression)
  item(tt([[) var(exp) tt(]]))(
  Evaluates the conditional expression var(exp)
! and return a zero exit status iff it is true.
  See noderef(Conditional Expressions)
  for a description of var(exp).
  )

