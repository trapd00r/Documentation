From zsh-workers-return-10276-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 27 11:44:03 2000
Return-Path: <zsh-workers-return-10276-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3233 invoked from network); 27 Mar 2000 11:44:01 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Mar 2000 11:44:01 -0000
Received: (qmail 9753 invoked by alias); 27 Mar 2000 11:43:50 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10276
Received: (qmail 9745 invoked from network); 27 Mar 2000 11:43:50 -0000
Date: Mon, 27 Mar 2000 13:43:49 +0200 (MET DST)
Message-Id: <200003271143.NAA05644@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Sat, 25 Mar 2000 20:39:22 +0000
Subject: Re: endianness of wordcode


Bart Schaefer wrote:

> ...
> 
> } I think the zcompile documentation, and maybe other places where wordcode
> } is mentioned, could be friendlier [...]
> 
> Yes.

Thanks, Bart.

> We'd also discussed changing -r/-m to -R/-M and changing -M to -m, but this
> patch doesn't do that yet.

I haven't done that yet either, because I fear I have to do some more
with this yet.

> Sven, please check the accuracy of my edits to func.yo. 

They are correct. At least that's how it should work and seems to work 
for me.

Now...

> In particular
> I'm not sure how to explain what happens if you do
> 
> 	zcompile -c foo foo bar frob ding
> 	fpath=($PWD)
> 	autoload foo
> 	foo

I don't understand what you mean here. If foo is already defined, the
autoload won't change that and you just get that executed. If foo is
unfunction'ed before the autoload, it loads foo.zwc and executes foo
just as expected. At least for me. What am I missing?

> And I'm even more confused by
> 
> 	zcompile -c foo -k foo bar frob ding
> 	fpath=($PWD)
> 	autoload foo
> 	foo
> 
> which first executes "foo" successfully and then prints
> 
> 	foo:3: foo: function not defined by file
> 
> leaving "foo" as an undefined (but marked autoloaded) function.

Here at least `foo' was already defined, right. This is a problem I
hadn't thought about. If we save it to be loaded ksh-style, the init
code originally surrounding the function definition (if there was any) 
is, of course, already deleted. So, the best attempt we could do is to 
put the body of the function in a `foo() { body }' and save that (I
mean, zcompile would do that, the definition of foo in the current
shell wouldn't be changed).

But this is a bit ugly, too. Maybe the user just wasn't aware of this
effect and would have preferred a warning. So maybe we should just do
that. Note also, that for ksh-style autoloaded function that aren't
loaded yet, the whole contents of the definition file is put into the
wordcode file (i.e. one gets different results depending on whether
the function is already loaded or not).

Or maybe we should first try to find the original file defining the
function, if we find one, write that into the wordcode file (but if
foo had been changed in the meanwhile, the changes would be lost, hm), 
if not, do the `foo() { body }' trick.

Hrm. Dunno. I seem to prefer the solution that just prints an error
message and doesn't even try to create the wordcode file in such a
case.

Help, please.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

