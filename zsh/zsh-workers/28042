From zsh-workers-return-28042-mason-zsh=primenet.com.au@zsh.org Wed Jun 16 21:46:56 2010
Return-Path: <zsh-workers-return-28042-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6548 invoked by alias); 16 Jun 2010 21:46:56 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28042
Received: (qmail 26571 invoked from network); 16 Jun 2010 21:46:39 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at ntlworld.com designates 81.103.221.48 as permitted sender)
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: zsh-workers@zsh.org (Zsh hackers list)
Subject: PATCH: transpose-lines widget
X-Mailer: MH-E 8.2; nmh 1.3; GNU Emacs 23.1.1
Date: Wed, 16 Jun 2010 22:46:24 +0100
Message-ID: <14662.1276724784@pws-pc>
X-Cloudmark-Analysis: v=1.1 cv=1ggfb5FlKZQUfF3vzm9UBYZ2uTfLsbs/8dSljwg5+mE= c=1 sm=0 a=mI6YO6ZdSLUA:10 a=DogomfpGjd0A:10 a=NLZqzBF-AAAA:8 a=I1zSlEQCMrXXvbC3i-8A:9 a=upS2pgTi-B-Fj6j3x_-v8BqiA2QA:4 a=_dQi-Dcv4p4A:10 a=AXGAEMDZimYYMCBa:21 a=KnW_STjQO5cWWBjm:21 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117

Seemed to be missing.

Useful inside

  IFS=$'\n' vared path

and similar.  ^x^t is the natural binding.

Index: Doc/Zsh/contrib.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/contrib.yo,v
retrieving revision 1.116
diff -p -u -r1.116 contrib.yo
--- Doc/Zsh/contrib.yo	23 May 2010 19:54:03 -0000	1.116
+++ Doc/Zsh/contrib.yo	16 Jun 2010 21:42:48 -0000
@@ -2073,6 +2073,23 @@ a true value, the search continues upwar
 tt(auto-previous) is unset or false (the default), the widget must be
 invoked repeatedly in order to search earlier history lines.
 )
+tindex(transpose-lines)
+item(tt(transpose-lines))(
+Only useful with a multi-line editing buffer; the lines here are
+lines within the current on-screen buffer, not history lines.
+The effect is similar to the function of the same name in Emacs.
+
+Transpose the current line with the previous line and move the cursor
+to the start of the next line.  Repeating this (which can be done by
+providing a positive numeric prefix argument) has the effect of moving
+the line above the cursor down by a number of lines.
+
+With a negative numeric prefix argument, requires two lines above the
+cursor.  These two lines are transposed and the cursor moved to the
+start of the previous line.  Using a numeric prefix less than -1
+has the effect of moving the line above the cursor up by minus that
+number of lines.
+)
 tindex(which-command)
 item(tt(which-command))(
 This function is a drop-in replacement for the builtin widget
Index: Functions/Zle/.distfiles
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/.distfiles,v
retrieving revision 1.23
diff -p -u -r1.23 .distfiles
--- Functions/Zle/.distfiles	15 Dec 2006 11:44:29 -0000	1.23
+++ Functions/Zle/.distfiles	16 Jun 2010 21:42:48 -0000
@@ -1,28 +1,45 @@
 DISTFILES_SRC='
 .distfiles
-backward-kill-word-match       backward-word-match
-capitalize-word-match          copy-earlier-word
-cycle-completion-positions     define-composed-chars
-delete-whole-word-match        down-case-word-match
-down-line-or-beginning-search  edit-command-line
-forward-word-match             history-beginning-search-menu
-history-pattern-search         history-search-end
-incarg                         incremental-complete-word
-insert-composed-char           insert-files
-insert-unicode-char            keeper
-keymap+widget                  kill-word-match
+backward-kill-word-match
+backward-word-match
+capitalize-word-match
+copy-earlier-word
+cycle-completion-positions
+define-composed-chars
+delete-whole-word-match
+down-case-word-match
+down-line-or-beginning-search
+edit-command-line
+forward-word-match
+history-beginning-search-menu
+history-pattern-search
+history-search-end
+incarg
+incremental-complete-word
+insert-composed-char
+insert-files
+insert-unicode-char
+keeper
+keymap+widget
+kill-word-match
 match-word-context
 match-words-by-style
 modify-current-argument
 narrow-to-region
-narrow-to-region-invisible     predict-on
-quote-and-complete-word        read-from-minibuffer
-replace-string                 select-word-style
+narrow-to-region-invisible
+predict-on
+quote-and-complete-word
+read-from-minibuffer
+replace-string
 replace-string-again
+select-word-style
 smart-insert-last-word
 split-shell-arguments
+transpose-lines
 transpose-words-match
-up-case-word-match             up-line-or-beginning-search
-url-quote-magic                which-command
+up-case-word-match
+up-line-or-beginning-search
+url-quote-magic
+which-command
 zed-set-file-name
 '
Index: Functions/Zle/transpose-lines
===================================================================
RCS file: Functions/Zle/transpose-lines
diff -N Functions/Zle/transpose-lines
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ Functions/Zle/transpose-lines	16 Jun 2010 21:42:48 -0000
@@ -0,0 +1,43 @@
+# Transpose lines.  This is like in emacs: with a positive argument
+# (default 1) the current line and the previous line are swapped and the
+# cursor goes down one line; with a negative argument the previous two
+# lines are swapped and the cursor goes up one line.
+
+emulate -L zsh
+setopt extendedglob # xtrace
+
+local -a match mbegin mend
+integer count=${NUMERIC:-1}
+local init prev lline final rrline
+
+if (( ${NUMERIC:-1} < 0 )); then
+  while (( count++ )); do
+    [[ $LBUFFER != (#b)(|*$'\n')([^$'\n']#$'\n')([^$'\n']#$'\n')([^$'\n']#) ]] && return 1
+    
+    LBUFFER=$match[1]$match[3]
+    RBUFFER=$match[2]$match[4]$RBUFFER
+  done
+else
+  while (( count-- )); do
+    [[ $LBUFFER != (#b)(*)$'\n'([^$'\n']#) ]] && return 1
+
+    prev=$match[1]
+    lline=$match[2]
+
+    if [[ $prev = (#b)(*$'\n')([^$'\n']#) ]]; then
+      init=$match[1]
+      prev=$match[2]
+    fi
+
+    if [[ $RBUFFER = (#b)([^$'\n']#)$'\n'(*) ]]; then
+      rline=$match[1]
+      final=$match[2]
+      prev+=$'\n'
+    else
+      rline=$RBUFFER
+    fi
+
+    LBUFFER=$init$lline$rline$'\n'$prev
+    RBUFFER=$final
+  done
+fi


-- 
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

