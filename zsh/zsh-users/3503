From zsh-users-return-3503-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Nov 02 08:11:32 2000
Return-Path: <zsh-users-return-3503-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27624 invoked from network); 2 Nov 2000 08:11:27 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 2 Nov 2000 08:11:27 -0000
Received: (qmail 8687 invoked by alias); 2 Nov 2000 08:11:03 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 3503
Received: (qmail 8680 invoked from network); 2 Nov 2000 08:11:02 -0000
Date: Thu, 2 Nov 2000 09:11:00 +0100 (MET)
Message-Id: <200011020811.JAA08401@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-users@sunsite.auc.dk
In-reply-to: Deborah Ariel Pickett's message of Thu, 2 Nov 2000 15:42:30 +1100
	(EST)
Subject: PATCH: Re: 3.1.<7->: zsh/parameter and jobs


[Apologies for sending a patch to the users list...]

Deborah Ariel Pickett wrote:

> ...
> 
> Unfortunately, one of the things that I now miss from doing it the new
> way is that zsh cannot tell me which jobs are the current and previous
> job.  My old get-the-output-of-the-jobs-builtin could do that.  All it
> would take to get the new system doing it is a read-only export of the
> curjob and prevjob variables in the shell's source code.  (I
> briefly looked at the zsh source code for making modules, and quickly
> decided that I wasn't up to the task.)
> 
> Any thoughts about this?

Only one: to add it. Dunno why I didn't think about it.

Bye
 Sven

Index: Doc/Zsh/mod_parameter.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_parameter.yo,v
retrieving revision 1.4
diff -u -r1.4 mod_parameter.yo
--- Doc/Zsh/mod_parameter.yo	2000/08/16 09:25:40	1.4
+++ Doc/Zsh/mod_parameter.yo	2000/11/02 08:09:00
@@ -127,12 +127,13 @@
 This associative array gives information about the states of the jobs
 currently known. The keys are the job numbers and the values are
 strings of the form
-`var(job-state):var(pid)tt(=)var(state)tt(...)'. The var(job-state)
-gives the state the whole job is currently in, one of `tt(running)',
-`tt(suspended)', or `tt(done)'. This is followed by one
-`var(pid)tt(=)var(state)' for every process in the job. The var(pid)s
-are, of course, the process IDs and the var(state) describes the state 
-of that process.
+`var(job-state):var(mark):var(pid)tt(=)var(state)tt(...)'. The
+var(job-state) gives the state the whole job is currently in, one of
+`tt(running)', `tt(suspended)', or `tt(done)'. The var(mark) is
+`tt(+)' for the current job, `tt(-)' for the previous job and empty
+otherwise. This is followed by one `var(pid)tt(=)var(state)' for every
+process in the job. The var(pid)s are, of course, the process IDs and
+the var(state) describes the state of that process.
 )
 vindex(nameddirs)
 item(tt(nameddirs))(
Index: Src/jobs.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/jobs.c,v
retrieving revision 1.5
diff -u -r1.5 jobs.c
--- Src/jobs.c	2000/09/22 22:28:06	1.5
+++ Src/jobs.c	2000/11/02 08:09:00
@@ -43,12 +43,12 @@
 /* the current job (+) */
  
 /**/
-int curjob;
+mod_export int curjob;
  
 /* the previous job (-) */
  
 /**/
-int prevjob;
+mod_export int prevjob;
  
 /* the job table */
  
Index: Src/Modules/parameter.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/parameter.c,v
retrieving revision 1.18
diff -u -r1.18 parameter.c
--- Src/Modules/parameter.c	2000/10/30 08:19:44	1.18
+++ Src/Modules/parameter.c	2000/11/02 08:09:01
@@ -1222,14 +1222,21 @@
 pmjobstate(int job)
 {
     Process pn;
-    char buf[256], buf2[128], *ret, *state;
+    char buf[256], buf2[128], *ret, *state, *cp;
 
+    if (job == curjob)
+	cp = ":+";
+    else if (job == prevjob)
+	cp = ":-";
+    else
+	cp = ":";
+
     if (jobtab[job].stat & STAT_DONE)
-	ret = dupstring("done");
+	ret = dyncat("done", cp);
     else if (jobtab[job].stat & STAT_STOPPED)
-	ret = dupstring("suspended");
+	ret = dyncat("suspended", cp);
     else
-	ret = dupstring("running");
+	ret = dyncat("running", cp);
 
     for (pn = jobtab[job].procs; pn; pn = pn->next) {
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

