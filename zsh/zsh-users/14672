From zsh-users-return-14672-mason-zsh=primenet.com.au@zsh.org Sun Dec 20 18:18:07 2009
Return-Path: <zsh-users-return-14672-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16582 invoked by alias); 20 Dec 2009 18:18:07 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14672
Received: (qmail 22059 invoked from network); 20 Dec 2009 18:18:05 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <091220101728.ZM1980@torch.brasslantern.com>
Date: Sun, 20 Dec 2009 10:17:27 -0800
In-reply-to: <2d460de70912200133t4e1dcc72l3737395b46b0753e@mail.gmail.com>
Comments: In reply to Richard Hartmann <richih.mailinglist@gmail.com>
 "Graceful hiding of $RPROMPT" (Dec 20, 10:33am)
References: <2d460de70912200133t4e1dcc72l3737395b46b0753e@mail.gmail.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Graceful hiding of $RPROMPT
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Dec 20, 10:33am, Richard Hartmann wrote:
}
} I am looking for a way to fall back gracefully, i.e. remove more and
} more of $RPROMPT when needed instead of the all or nothing mechanism
} which is in place, now.

This may not be impossible to do in shell code, but I think it's going
to be prohibitively difficult.

Look at Functions/Prompts/prompt_bart_setup.  From "prompt -h bart":

    The "upper right prompt" looks like:
	date time
    The fourth color is used for the date, and the first again for the
    time.  As with RPS1, first the date and then the time disappear as
    the upper left prompt grows too wide.

The prompt_bart_precmd function is where the computation of widths is
handled in order to set up the upper right prompt.  The complication
you're faced with is computing the width of left prompt plus the width
of the first line of input (which might be in $BUFFER or might be in
$PREBUFFER) *and* doing so every time the contents of $BUFFER change.

There's no single place to intercept buffer changes, so you'll have to
at least override the self-insert widget and probably any other widget
that might insert or delete (e.g., the entire completion suite).  Or
set an extremely short TMOUT and have the shell effectively busy-wait
on TRAPARLM to watch for changes, but I can't recommend that.

Another possibility is to embed the right prompt in PS1 rather than
using RPS1 at all.  The same width computations in prompt_bart_precmd
would apply; you would use save/restore cursor position escapes in PS1
and wrap output of the right prompt in %{...%} so that the line editor
can't "see" that a right prompt exists at all.

In this scenario you simply type over the right prompt as the input
extends far enough, which might not be visually appealing.

A final possibility is to do something like this:

zle-line-init() { POSTDISPLAY="${(%%):-  %D  %@}"; zle -R }
zle -N zle-line-init

This puts a prompt-like string at the end of the buffer and scrolls
it away to the right as you type.  A drawback here is that you can't
embed any terminal control sequences in POSTDISPLAY, zsh converts them
all to literal characters before output.

So to really get what you want, it'll require hacking the C code in
Src/Zle/zle_refresh.c, function zrefresh.  Look for references to
"rpmpt" e.g. the variable "put_rpmpt".  A nice touch would be if the
%(l...) mechansim was intelligent about being used in RPS1 and counted
the ZLE buffer as part of "at least N characters have already been
printed".

-- 

