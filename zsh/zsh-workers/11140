From zsh-workers-return-11140-mason-zsh=primenet.com.au@sunsite.auc.dk Thu May 04 07:42:46 2000
Return-Path: <zsh-workers-return-11140-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1186 invoked from network); 4 May 2000 07:42:45 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 4 May 2000 07:42:45 -0000
Received: (qmail 112 invoked by alias); 4 May 2000 07:42:31 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11140
Received: (qmail 92 invoked from network); 4 May 2000 07:42:30 -0000
Date: Thu, 4 May 2000 09:42:25 +0200 (MET DST)
Message-Id: <200005040742.JAA18193@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Wed, 3 May 2000 19:12:52 +0400
Subject: PATCH: RE: Command completion


Andrej Borsenkow wrote:

> > Ok, it would also be cool, somehow, if we could hide matches for one
> > type when they are overridden by another type. But this would
> > definitely require C-code support and I have no idea how to
> > do that in
> > a generic way.
> 
> I may be wrong, but we have strict preference order, don't we? So, if
> both $functions[nslookup] and $commands[nslookup] exist, we need not
> offer the latter?

I'm not exactly sure what you mean here.

1) To do this right, we would have to find out for every external
   command if there is a shell function with the same name. If there
   is, the external command is not listed.
   And the same for builtins, of course.
2) The order in which the code tries to generate matches can be
   controlled by the user. So, when adding external commands we would
   have to check *if* the user requested shell functions, too, and if
   he did, do 1).
3) Partly this could certainly be done by making the completion code
   look in other groups (different groups, that's, of course, the
   point) for equal matches. This may be slow and we would have to
   make sure that the matches are tried in the right order in all
   completion functions.

> And, as I said, I have the impression that in
> > completely ambiguous cases I would like to see the list (no, I can't
> > really explain why).
> >
> 
> Hmm ...
> 
> bor@itsrm2% whence -av nslookup
> nslookup is a shell function
> nslookup is /usr/sbin/nslookup

Eh? I've no idea what you want to say here.

What I wanted to say is probably that the fact that the same match
appears in more than one group may be interesting information in some
cases (`Why is it doing *this*? It never did that before!' <TAB> `Oh,
there is both a shell function and a external command, better use
=foo.')

Something like that.


Anyway, the patch makes the list not be shown if all matches look the
same. Then it adds the `force-list' style to give more control over
when the list is shown. It can be set to `always', the list will
always be shown, even if there is only one match (which is immediately 
accepted). It may also be set to a number and in this case the list is 
shown if there are at least that many matches, even if ther all look
alike.

So, to get the previous behaviour, one could set

  zstyle ':completion:*' force-list 2

But even then is the match accepted (i.e. you get that space at the
end).


Ok?


Bye
 Sven

Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.7
diff -u -r1.7 _zstyle
--- Completion/Builtins/_zstyle	2000/04/18 07:36:56	1.7
+++ Completion/Builtins/_zstyle	2000/05/04 07:39:52
@@ -25,6 +25,7 @@
   expand		 c:
   file-patterns		 c:filepat
   file-sort              c:fsort
+  force-list             c
   format		 c:
   glob			 c:
   group-name		 c:
Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.11
diff -u -r1.11 _main_complete
--- Completion/Core/_main_complete	2000/04/27 08:21:10	1.11
+++ Completion/Core/_main_complete	2000/05/04 07:39:52
@@ -200,6 +200,13 @@
   fi
 fi
 
+if zstyle -s ":completion:${curcontext}:" force-list tmp &&
+   [[ "$compstate[list]" = *list* && 
+      ( "$tmp" = always ||
+        ( "$tmp" = [0-9]## && nm -ge tmp ) ) ]]; then
+  compstate[list]="$compstate[list] force"
+fi
+
 # Now call the post-functions.
 
 funcs=( "$comppostfuncs[@]" )
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.32
diff -u -r1.32 compsys.yo
--- Doc/Zsh/compsys.yo	2000/05/03 14:44:01	1.32
+++ Doc/Zsh/compsys.yo	2000/05/04 07:39:53
@@ -1033,6 +1033,18 @@
 sorted alphabetically by name. If the value contains the string
 `tt(reverse)', sorting is done in decreasing order.
 )
+kindex(force-list, completion style)
+item(tt(force-list))(
+If the completion code would show a list of completions at all, this
+style controls whether the list is shown even in cases when it would
+normally not do that. For example, normally the list is only shown if
+there are at least to different matches. By setting this style to
+`tt(always)', the list will always even be shown, even if there is
+only a single match which is immediately accepted. The style may also
+be set to a number. In this case the list will be shown if there are
+at least that many matches, even if they would all insert the same
+string.
+)
 kindex(format, completion style)
 item(tt(format))(
 If this is set for the tt(descriptions) tag, its value is used as a
Index: Src/Zle/compcore.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compcore.c,v
retrieving revision 1.14
diff -u -r1.14 compcore.c
--- Src/Zle/compcore.c	2000/05/03 08:35:33	1.14
+++ Src/Zle/compcore.c	2000/05/04 07:39:53
@@ -152,6 +152,11 @@
 /**/
 mod_export int smatches;
 
+/* != 0 if more than one match and at least two different matches */
+
+/**/
+mod_export int diffmatches;
+
 /* The number of messages. */
 
 /**/
@@ -388,10 +393,10 @@
 	    invalidatelist();
     } else if (useline) {
 	/* We have matches. */
-	if (nmatches > 1) {
+	if (nmatches > 1 && diffmatches) {
 	    /* There is more than one match. */
 	    ret = do_ambiguous();
-	} else if (nmatches == 1) {
+	} else if (nmatches == 1 || !diffmatches) {
 	    /* Only one match. */
 	    Cmgroup m = amatches;
 
@@ -423,7 +428,8 @@
 	cs = origcs;
     }
     /* Print the explanation strings if needed. */
-    if (!showinglist && validlist && usemenu != 2 && nmatches != 1 &&
+    if (!showinglist && validlist && usemenu != 2 && 
+	(nmatches != 1 || diffmatches) &&
 	useline != 2 && (!oldlist || !listshown)) {
 	onlyexpl = 1;
 	showinglist = -2;
@@ -870,7 +876,7 @@
 
     if (compfunc) {
 	char *os = s;
-	int onm = nmatches, osi = movefd(0);
+	int onm = nmatches, odm = diffmatches, osi = movefd(0);
 
 	bmatchers = NULL;
 	mstack = NULL;
@@ -905,6 +911,7 @@
 
 	if (oldlist) {
 	    nmatches = onm;
+	    diffmatches = odm;
 	    validlist = 1;
 	    amatches = lastmatches;
 	    lmatches = lastlmatches;
@@ -2635,7 +2642,7 @@
 
     opm = pmatches;
     pmatches = lmatches = NULL;
-    nmatches = smatches = 0;
+    nmatches = smatches = diffmatches = 0;
 
     if (!ainfo->count) {
 	if (last)
@@ -2667,6 +2674,9 @@
 	    nmatches += g->mcount;
 	    smatches += g->lcount;
 
+	    if (g->mcount > 1)
+		diffmatches = 1;
+
 	    n = (Cmgroup) zcalloc(sizeof(struct cmgroup));
 
 	    if (g->perm) {
@@ -2721,17 +2731,28 @@
 
 	    nmatches += g->mcount;
 	    smatches += g->lcount;
+
+	    if (g->mcount > 1)
+		diffmatches = 1;
+
 	    g->num = gn++;
 	}
 	g->new = 0;
 	g = g->next;
     }
-    for (g = pmatches; g; g = g->next) {
+    for (g = pmatches, p = NULL; g; g = g->next) {
 	g->nbrbeg = nbrbeg;
 	g->nbrend = nbrend;
 	for (rn = 1, q = g->matches; *q; q++) {
 	    (*q)->rnum = rn++;
 	    (*q)->gnum = mn++;
+	}
+	if (!diffmatches && *g->matches) {
+	    if (p) {
+		if (!matcheq(*g->matches, *p))
+		    diffmatches = 1;
+	    } else
+		p = g->matches;
 	}
     }
     hasperm = 1;
Index: Src/Zle/compctl.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compctl.c,v
retrieving revision 1.3
diff -u -r1.3 compctl.c
--- Src/Zle/compctl.c	2000/04/13 08:09:13	1.3
+++ Src/Zle/compctl.c	2000/05/04 07:39:54
@@ -1762,7 +1762,7 @@
     struct cmlist ms;
     Cmlist m;
     char *os = s;
-    int onm = nmatches, osi = movefd(0);
+    int onm = nmatches, odm = diffmatches, osi = movefd(0);
     LinkNode n;
 
     /* We build a copy of the list of matchers to use to make sure that this
@@ -1843,6 +1843,7 @@
 
 	if (oldlist) {
 	    nmatches = onm;
+	    diffmatches = odm;
 	    validlist = 1;
 	    amatches = lastmatches;
 	    lmatches = lastlmatches;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

