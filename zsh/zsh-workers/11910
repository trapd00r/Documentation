From zsh-workers-return-11910-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 15 08:07:06 2000
Return-Path: <zsh-workers-return-11910-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18080 invoked from network); 15 Jun 2000 08:07:05 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Jun 2000 08:07:05 -0000
Received: (qmail 12036 invoked by alias); 15 Jun 2000 08:06:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11910
Received: (qmail 12025 invoked from network); 15 Jun 2000 08:06:50 -0000
Date: Thu, 15 Jun 2000 10:06:47 +0200 (MET DST)
Message-Id: <200006150806.KAA06014@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Clint Adams's message of Wed, 14 Jun 2000 09:53:20 -0400
Subject: PATCH: _arguments (was: Re: odd diff completion)


Clint Adams wrote:

> Under 3.1.9:
> 
> diff pars<TAB>
> completes to diff parse.c
> 
> Under yesterday's CVS:
> 
> diff pars<TAB>
> completes to diff parsB

Ahem. Sorry, under certain conditons ca_get_sopt() returned an option
even for non-option strings.


In another message:

> > The `-A -*' doesn't mean that it complete ignores all unknown strings
> > starting with a hyphen, it just means that it doesn't stop completing
> > options if it finds undescribed `-foo's.
> 
> > So, you still have to give it the `--{install,...}' to make it ignore
> > it. Or you use the `= ' trick together with the `::' trick, as in:
> > 
> >            '(-i)--install:*::Debian packages:= ->install' \
> 
> I'm confused.  If I omit the '--{install,...}', doesn't that make
> --install an undescribed -foo, and thus it shouldn't stop completing
> options?

I've now had a look and am of the opinion, that the behaviour is the
right thing. The install case uses multiple sets. For multiple sets,
_arguments has to detect undescribed options and it has to stop trying 
to complete a set if there is a string not covered by the descriptions 
for that set on the line (otherwise it couldn't make the sets be
mutually exclusive).

We could make the -A pattern be used there, the patch below contains
the code for that, #if'ed out with a marker comment above it. However,
that would defeat the purpose of multiple sets, i.e. the sets are then 
not mutually exclusive if we use a simple pattern like -*. One would
then need a pattern that exactly matches all possible options -- not
very user-friendly.

So the solution for the current state of _arguments, which I don't
want to change is to include the --install etc. in the second call to
_arguments, that makes everything work as you want. BUT, I'd be
willing to give some more help for this. The only things I could think 
of are:

- an option, say -I, which gives an array of options which are to be
  ignored but not completed
- or, probably more more user-friendly, yet another optspec syntax
  describing options which are to be ignored but not completed; for
  example, if we find a syntax that starts with a special string for
  that, one could use <not>${^_dpkg_actions} in the second call to
  _arguments to make it skip all options described in $_dpkg_options

I think I prefer the latter (or both). Anyone got an idea for an
acceptable syntax? Or other suggestions?

Bye
 Sven

Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.29
diff -u -r1.29 computil.c
--- Src/Zle/computil.c	2000/06/13 12:14:32	1.29
+++ Src/Zle/computil.c	2000/06/15 07:20:53
@@ -1083,7 +1083,7 @@
     LinkList l = NULL;
 
     *lp = NULL;
-    for (p = NULL; *line; line++)
+    for (p = NULL; *line; line++) {
 	if ((p = d->single[STOUC(*line)]) && p->active &&
 	    p->args && p->name[0] == pre) {
 	    if (p->type == CAO_NEXT) {
@@ -1100,8 +1100,10 @@
 		}
 		break;
 	    }
-	} else if (!p || (!p->active && p->name[0] != pre))
+	} else if (p && !p->active)
 	    return NULL;
+	p = NULL;
+    }
     if (p && end)
 	*end = line;
     return p;
@@ -1444,7 +1446,14 @@
 		state.opt = 0;
 	    else
 		state.curopt = NULL;
-	} else if (multi && (*line == '-' || *line == '+') && cur != compcurrent)
+	} else if (multi && (*line == '-' || *line == '+') && cur != compcurrent
+#if 0
+		   /**** Ouch. Using this will disable the mutual exclusion
+			 of different sets. Not using it will make the -A
+			 pattern be effectively ignored with multiple sets. */
+		   && (!napat || !pattry(napat, line))
+#endif
+		   )
 	    return 1;
 	else if (state.arg && (!napat || !pattry(napat, line))) {
 	    /* Otherwise it's a normal argument. */

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

