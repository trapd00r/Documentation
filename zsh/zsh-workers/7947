From zsh-workers-return-7947-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Sep 20 10:23:30 1999
Return-Path: <zsh-workers-return-7947-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3218 invoked from network); 20 Sep 1999 10:23:29 -0000
Received: from mail2.primenet.com.au (HELO primenet.com.au) (?2o9rrFqAuugY0xXUGj3B26KXWbjsp9xK?@203.24.36.6)
  by ns1.primenet.com.au with SMTP; 20 Sep 1999 10:23:29 -0000
Received: (qmail 2250 invoked from network); 20 Sep 1999 09:56:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by mail2.primenet.com.au with SMTP; 20 Sep 1999 09:56:47 -0000
Received: (qmail 29522 invoked by alias); 20 Sep 1999 09:56:21 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7947
Received: (qmail 29515 invoked from network); 20 Sep 1999 09:56:20 -0000
Date: Mon, 20 Sep 1999 11:56:14 +0200 (MET DST)
Message-Id: <199909200956.LAA05609@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 20 Jul 1999 17:39:25 +0000
Subject: PATCH: was: Re: Inserting all completions


Bart Schaefer wrote:

> [ about the possibility to insert all matches resulting from a
>   completion ]
>
> Maybe all-or-nothing is actually sufficient; what about simply:
> 
> 	compstate[insert]=expand
> 
> Which would act much like the _expand completer with only expand_glob.

This patch adds `all' (not `expand') as a possible value for
`compstate[insert]'. If after the widget has finished it has this
value, all completions are inserted.

The other stuff mentioned in Bart's message will have to wait until we 
have a way to get at the current matches (probably blended with
Peter's suggestion for re-invoking the widget and things like that).

Currently no completion function uses this. Maybe I'll change
`_expand' to allow this kind of `expansion', too.

This also made me notice a uglyness which also happens when using
menu-completion and accept-and-menu-completed in braces. If you have a 
match spec like `m:{a-z}={A-Z}' and to `z{<TAB>' in the Src directory, 
you get `Zle' as one possible match. But if you accept that and then
continue selecting other matches the character before the `{' has the
wrong case for at least one of the matches. Since the `all' value
basically uses the same code, it has the same problem. I have no idea
how to solve this. Any suggestions. (The obvious solution would be to
not use any matches that don't have the same prefix any more, but that 
might be hard to implement. I'll have to think some more about this.)

Bye
 Sven

diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Sun Sep 19 16:57:28 1999
+++ Src/Zle/zle_tricky.c	Sun Sep 19 17:32:15 1999
@@ -4735,6 +4735,48 @@
 	    inststr(origline);
 	    cs = origcs;
 	    showinglist = -2;
+	} else if (useline == 2 && nmatches > 1) {
+	    int first = 1, nm = nmatches;
+	    Cmatch *mc;
+
+	    menucmp = 1;
+	    menuacc = 0;
+
+	    for (minfo.group = amatches;
+		 minfo.group && !(minfo.group)->mcount;
+		 minfo.group = (minfo.group)->next);
+
+	    mc = (minfo.group)->matches;
+
+	    while (1) {
+		if (!first)
+		    acceptlast();
+		first = 0;
+
+		if (!--nm)
+		    menucmp = 0;
+
+		do_single(*mc);
+		minfo.cur = mc;
+
+		if (!*++(minfo.cur)) {
+		    do {
+			if (!(minfo.group = (minfo.group)->next))
+			    break;
+		    } while (!(minfo.group)->mcount);
+		    if (!minfo.group)
+			break;
+		    minfo.cur = minfo.group->matches;
+		}
+		mc = minfo.cur;
+	    }
+	    menucmp = 0;
+	    minfo.cur = NULL;
+
+	    if (compforcelist && *compforcelist && uselist)
+		showinglist = -2;
+	    else
+		invalidatelist();
 	} else if (useline) {
 	    /* We have matches. */
 	    if (nmatches > 1) {
@@ -4763,7 +4805,7 @@
 	}
 	/* Print the explanation strings if needed. */
 	if (!showinglist && validlist && usemenu != 2 && nmatches != 1 &&
-	    (!oldlist || !listshown)) {
+	    useline != 2 && (!oldlist || !listshown)) {
 	    Cmgroup g = amatches;
 	    Cexpl *e;
 	    int up = 0, tr = 1, nn = 0;
@@ -5074,6 +5116,8 @@
 	else if (!strcmp(compinsert, "auto") ||
 		 !strcmp(compinsert, "automenu"))
 	    useline = 1, usemenu = 2;
+	else if (!strcmp(compinsert, "all"))
+	    useline = 2, usemenu = 0;
 	else if (idigit(*compinsert)) {
 	    char *m;
 
diff -u od/Zsh/compwid.yo Doc/Zsh/compwid.yo
--- od/Zsh/compwid.yo	Sun Sep 19 12:18:54 1999
+++ Doc/Zsh/compwid.yo	Sun Sep 19 17:52:41 1999
@@ -259,6 +259,9 @@
 one more than the maximum selects the first. Unless the value of this
 key ends in a space, the match is inserted as in a menu-completion,
 i.e. without automatically appending a space.
+
+It may also be set to tt(all), which makes all matches generated be
+inserted into the line.
 )
 item(tt(to_end))(
 Specifies the occasions on which the cursor is moved to the end of a string

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

