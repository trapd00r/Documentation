From zsh-workers-request@euclid.skiles.gatech.edu Wed Jan 22 22:05:16 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 3451 invoked from network); 22 Jan 1997 22:05:12 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 22 Jan 1997 22:05:12 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id QAA18143; Wed, 22 Jan 1997 16:58:01 -0500 (EST)
Resent-Date: Wed, 22 Jan 1997 16:58:01 -0500 (EST)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199701222159.WAA02294@bolyai.cs.elte.hu>
Subject: Re: Order of field splitting in zsh
In-Reply-To: <Pine.SV4.3.95.970122183037.1005A-100000@itsrm1.mow.sni.de> from Andrej Borsenkow at "Jan 22, 97 06:58:34 pm"
To: borsenkow.msk@sni.de
Date: Wed, 22 Jan 1997 22:59:05 +0100 (MET)
Cc: zsh-workers@math.gatech.edu
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL27 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"5NNaz3.0.QR4.frevo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2816
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Andrej Borsenkow wrote:
> There is more simple case:
> 
> % ./sh (where sh -> /bin/zsh)
> % args $(echo 'a ')$(echo 'b')
>                 ^ note blank here (or any IFS white space)
> 1
> ab

That's a real bug.  Here is a fix.  That causes an other minor change:

% args () { for i; do print -r -- "/$i/"; done ; }
% args a${^=:- }b                                  
/ab/
/ab/
% args a${^=:- } 
/a/
/a/

Previously zsh expanded these to one word.

Zoltan


*** Src/utils.c	1997/01/20 01:04:43	3.1.1.22
--- Src/utils.c	1997/01/22 21:10:46
***************
*** 1429,1439 ****
  {
      char *t, **ret, **ptr;
  
!     skipwsep(&s);
!     ptr = ret = (char **) ncalloc(sizeof(*ret) * (wordcount(s, NULL, 0) + 1));
  
      if (*s && isep(*s == Meta ? s[1] ^ 32 : *s))
  	*ptr++ = dupstring(allownull ? "" : nulstring);
      while (*s) {
  	if (isep(*s == Meta ? s[1] ^ 32 : *s)) {
  	    if (*s == Meta)
--- 1429,1441 ----
  {
      char *t, **ret, **ptr;
  
!     ptr = ret = (char **) ncalloc(sizeof(*ret) * (wordcount(s, NULL, -!allownull) + 1));
  
+     skipwsep(&s);
      if (*s && isep(*s == Meta ? s[1] ^ 32 : *s))
  	*ptr++ = dupstring(allownull ? "" : nulstring);
+     else if (!allownull && t != s)
+ 	*ptr++ = dupstring("");
      while (*s) {
  	if (isep(*s == Meta ? s[1] ^ 32 : *s)) {
  	    if (*s == Meta)
***************
*** 1448,1455 ****
--- 1450,1460 ----
  	    ztrncpy(*ptr++, t, s - t);
  	} else
  	    *ptr++ = dupstring(nulstring);
+ 	t = s;
  	skipwsep(&s);
      }
+     if (!allownull && t != s)
+ 	*ptr++ = dupstring("");
      *ptr = NULL;
      return ret;
  }
***************
*** 1536,1560 ****
  	    if ((c && *(s + sl)) || mul)
  		r++;
      } else {
! 	char *t;
  
  	r = 0;
! 	if (!mul)
  	    skipwsep(&s);
! 	if (*s && isep(*s == Meta ? s[1] ^ 32 : *s))
  	    r++;
! 	for (t = s; *t; r++) {
! 	    if (isep(*t == Meta ? t[1] ^ 32 : *t)) {
! 		if (*t == Meta)
! 		    t++;
! 		t++;
! 		if (!mul)
! 		    skipwsep(&t);
  	    }
! 	    findsep(&t, NULL);
! 	    if (!mul)
! 		skipwsep(&t);
  	}
      }
      return r;
  }
--- 1541,1569 ----
  	    if ((c && *(s + sl)) || mul)
  		r++;
      } else {
! 	char *t = s;
  
  	r = 0;
! 	if (mul <= 0)
  	    skipwsep(&s);
! 	if ((*s && isep(*s == Meta ? s[1] ^ 32 : *s)) ||
! 	    (mul < 0 && t != s))
  	    r++;
! 	for (; *s; r++) {
! 	    if (isep(*s == Meta ? s[1] ^ 32 : *s)) {
! 		if (*s == Meta)
! 		    s++;
! 		s++;
! 		if (mul <= 0)
! 		    skipwsep(&s);
  	    }
! 	    findsep(&s, NULL);
! 	    t = s;
! 	    if (mul <= 0)
! 		skipwsep(&s);
  	}
+ 	if (mul < 0 && t != s)
+ 	    r++;
      }
      return r;
  }
*** Src/subst.c	1997/01/18 22:04:39	3.1.1.4
--- Src/subst.c	1997/01/22 21:45:16
***************
*** 1134,1139 ****
--- 1134,1140 ----
  	case Equals:
  	    if (vunset) {
  		char sav = *idend;
+ 		int l;
  
  		*idend = '\0';
  		val = dupstring(u);
***************
*** 1146,1161 ****
  		    char *arr[2], **t, **a, **p;
  		    if (spsep || spbreak) {
  			aval = sepsplit(val, spsep, 0);
! 			isarr = 1;
  			sep = spsep = NULL;
  			spbreak = 0;
  		    } else if (!isarr) {
  			arr[0] = val;
  			arr[1] = NULL;
! 			aval = arr;
  		    }
! 		    p = a = zcalloc(sizeof(char *) * (arrlen(aval) + 1));
! 		    for (t = aval; *t; untokenize(*t), *p++ = ztrdup(*t++));
  		    setaparam(idbeg, a);
  		} else {
  		    untokenize(val);
--- 1147,1174 ----
  		    char *arr[2], **t, **a, **p;
  		    if (spsep || spbreak) {
  			aval = sepsplit(val, spsep, 0);
! 			isarr = 2;
  			sep = spsep = NULL;
  			spbreak = 0;
+ 			l = arrlen(aval);
+ 			if (l && !*(aval[l-1]))
+ 			    l--;
+ 			if (l && !**aval)
+ 			    l--, t = aval + 1;
+ 			else
+ 			    t = aval;
  		    } else if (!isarr) {
  			arr[0] = val;
  			arr[1] = NULL;
! 			t = aval = arr;
! 			l = 1;
  		    }
! 		    p = a = zalloc(sizeof(char *) * (l + 1));
! 		    while (l--) {
! 			untokenize(*t);
! 			*p++ = ztrdup(*t++);
! 		    }
! 		    *p++ = NULL;
  		    setaparam(idbeg, a);
  		} else {
  		    untokenize(val);
***************
*** 1309,1315 ****
  	    else if (!aval[1])
  		val = aval[0];
  	    else
! 		isarr = 1;
  	}
      }
      if (casmod) {
--- 1322,1328 ----
  	    else if (!aval[1])
  		val = aval[0];
  	    else
! 		isarr = 2;
  	}
      }
      if (casmod) {
***************
*** 1403,1409 ****
  		for (tn = firstnode(tl); tn; incnode(tn)) {
  		    strcatsub(&y, ostr, aptr, x, xlen,
  			      (char *) getdata(tn), globsubst);
! 		    if (qt && !*y)
  			y = dupstring(nulstring);
  		    if (i == 1)
  			setdata(n, (void *) y);
--- 1416,1422 ----
  		for (tn = firstnode(tl); tn; incnode(tn)) {
  		    strcatsub(&y, ostr, aptr, x, xlen,
  			      (char *) getdata(tn), globsubst);
! 		    if (qt && !*y && isarr != 2)
  			y = dupstring(nulstring);
  		    if (i == 1)
  			setdata(n, (void *) y);
***************
*** 1420,1426 ****
  		return NULL;
  	    xlen = strlen(x);
  	    strcatsub(&y, ostr, aptr, x, xlen, NULL, globsubst);
! 	    if (qt && !*y)
  		y = dupstring(nulstring);
  	    setdata(n, (void *) y);
  
--- 1433,1439 ----
  		return NULL;
  	    xlen = strlen(x);
  	    strcatsub(&y, ostr, aptr, x, xlen, NULL, globsubst);
! 	    if (qt && !*y && isarr != 2)
  		y = dupstring(nulstring);
  	    setdata(n, (void *) y);
  
***************
*** 1433,1439 ****
  				  premul, postmul);
  		if (eval && parsestr(x))
  		    return NULL;
! 		if (qt && !*x)
  		    y = dupstring(nulstring);
  		else if (globsubst)
  		    tokenize(y = dupstring(x));
--- 1446,1452 ----
  				  premul, postmul);
  		if (eval && parsestr(x))
  		    return NULL;
! 		if (qt && !*x && isarr != 2)
  		    y = dupstring(nulstring);
  		else if (globsubst)
  		    tokenize(y = dupstring(x));
***************
*** 1450,1456 ****
  		return NULL;
  	    xlen = strlen(x);
  	    *str = strcatsub(&y, aptr, aptr, x, xlen, s, globsubst);
! 	    if (qt && !*y)
  		y = dupstring(nulstring);
  	    insertlinknode(l, n, (void *) y), incnode(n);
  	}
--- 1463,1469 ----
  		return NULL;
  	    xlen = strlen(x);
  	    *str = strcatsub(&y, aptr, aptr, x, xlen, s, globsubst);
! 	    if (qt && !*y && isarr != 2)
  		y = dupstring(nulstring);
  	    insertlinknode(l, n, (void *) y), incnode(n);
  	}
***************
*** 1469,1475 ****
  	    return NULL;
  	xlen = strlen(x);
  	*str = strcatsub(&y, ostr, aptr, x, xlen, s, globsubst);
! 	if (qt && !*y)
  	    y = dupstring(nulstring);
  	setdata(n, (void *) y);
      }
--- 1482,1488 ----
  	    return NULL;
  	xlen = strlen(x);
  	*str = strcatsub(&y, ostr, aptr, x, xlen, s, globsubst);
! 	if (qt && !*y && isarr != 2)
  	    y = dupstring(nulstring);
  	setdata(n, (void *) y);
      }

