From zsh-workers-return-5326-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Feb 08 17:57:31 1999
Return-Path: <zsh-workers-return-5326-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29742 invoked from network); 8 Feb 1999 17:57:29 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Feb 1999 17:57:29 -0000
Received: (qmail 18873 invoked by alias); 8 Feb 1999 17:56:57 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5326
Received: (qmail 18848 invoked from network); 8 Feb 1999 17:56:22 -0000
Message-Id: <9902081740.AA50108@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: zsh-3.1.5-pws-7: another go at signames
In-Reply-To: ""Bart Schaefer""'s message of "Mon, 08 Feb 1999 08:54:53 NFT."
             <990208085454.ZM13891@candle.brasslantern.com> 
Date: Mon, 08 Feb 1999 18:40:08 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>

"Bart Schaefer" wrote:
> Seems to me it should be possible to do this particular thing with just
> the preprocessor, rather than needing to compile and execute a program.
> use the awk script to generate a bunch of #defines for every possible
> signal in the header, feed that through "cc -E ...." and then awk or sed
> the output again to extract the stuff zsh needs.

This is a good idea.  There was another, more drastic problem with
what Matt had: it required you to know all the possible signals, since
you never got to see the names if you didn't know them already.
That's pretty hairy, given the stuff that gets shoved into OSes --- it
would have needed major additions just for AIX here.

This is pretty much Bart's idea above.  (It still needs the right
signal.h, but so does every other idea.)  signames1.awk does a first
pass through the signal header, extracting everything in sight, and
dumping lines like

XXNAMES XXSIGHUP SIGHUP

to sigtmp.c.  This gets preprocessed; it's up to cpp to turn the last
word, SIGHUP here, into a number, and these get dumped to sigtmp.out.
Then signames2.awk runs on that; it's an only slightly modified
version of signames.awk which matches only those lines where the
substitution of the signal number has taken place.  I managed to get
an identical signames.c to the one before.  Matt, does this fix your
problems?

You ought to be able to get it to work by running config.status in the
top directory, then removing Makemod and Makemod.in in Src and running
make there.

signames.awk and now signames2.awk seem deliberately to stop before
60.  Is this known to be right?  I have extra definitions for signals
60..63, separated from the rest.  I take it that means somebody's
thought about this.

The only problem I know of over and above the existing ones is that
now $(CPP) has to work, which zsh didn't need before.  But configure
should make a good job of finding that.  I can't think of a good
reason why anything more than `#include <signal.h>' should be
necessary in sigtmp.c.

Note this patch doesn't delete the old signames.awk, which nonetheless
becomes redundant.  I hope.

--- Config/defs.mk.sn2	Mon Feb  8 10:43:29 1999
+++ Config/defs.mk	Mon Feb  8 18:12:08 1999
@@ -44,6 +44,7 @@
 
 # compilation
 CC              = @CC@
+CPP             = @CPP@
 CPPFLAGS        = @CPPFLAGS@
 DEFS            = @DEFS@
 CFLAGS          = @CFLAGS@
--- Src/zsh.mdd.sn2	Mon Feb  8 10:44:28 1999
+++ Src/zsh.mdd	Mon Feb  8 18:14:39 1999
@@ -12,8 +12,11 @@
 prototypes.h hashtable.h ztype.h"
 
 :<<\Make
-signames.c: signames.awk ../config.h @SIGNAL_H@
-	$(AWK) -f $(sdir)/signames.awk @SIGNAL_H@ > $@
+signames.c: signames1.awk signames2.awk ../config.h @SIGNAL_H@
+	$(AWK) -f $(sdir)/signames1.awk @SIGNAL_H@ >sigtmp.c
+	$(CPP) sigtmp.c >sigtmp.out
+	$(AWK) -f $(sdir)/signames2.awk sigtmp.out > $@
+	rm -f sigtmp.c sigtmp.out
 
 sigcount.h: signames.c
 	grep 'define.*SIGCOUNT' signames.c > $@
--- /dev/null	Mon Feb  8 18:16:14 1999
+++ Src/signames1.awk	Mon Feb  8 18:07:02 1999
@@ -0,0 +1,9 @@
+BEGIN { printf "#include <signal.h>\n\n" }
+
+/^[\t ]*#[\t ]*define[\t _]*SIG[A-Z][A-Z0-9]*[\t ]*[1-9][0-9]*/ { 
+    sigindex = index($0, "SIG")
+    sigtail = substr($0, sigindex, 80)
+    split(sigtail, tmp)
+    signam = substr(tmp[1], 4, 20)
+    printf("XXNAMES XXSIG%s SIG%s\n", signam, signam)
+}
--- /dev/null	Mon Feb  8 18:16:14 1999
+++ Src/signames2.awk	Mon Feb  8 18:07:52 1999
@@ -0,0 +1,100 @@
+#
+# {g,n}awk script to generate signames.c
+# This version relies on the previous output of the preprocessor
+# on sigtmp.c, sigtmp.out, which is in turn generated by signames1.awk.
+#
+# NB: On SunOS 4.1.3 - user-functions don't work properly, also \" problems
+# Without 0 + hacks some nawks compare numbers as strings
+#
+/^XXNAMES XXSIG[A-Z][A-Z0-9]* [1-9][0-9]*/ {
+    sigindex = index($0, "SIG")
+    sigtail = substr($0, sigindex, 80)
+    split(sigtail, tmp)
+    signam = substr(tmp[1], 4, 20)
+    signum = tmp[2]
+    if (sig[signum] == "") {
+	sig[signum] = signam
+	if (0 + max < 0 + signum && signum < 60)
+	    max = signum
+	if (signam == "ABRT")   { msg[signum] = "abort" }
+	if (signam == "ALRM")   { msg[signum] = "alarm" }
+	if (signam == "BUS")    { msg[signum] = "bus error" }
+	if (signam == "CHLD")   { msg[signum] = "death of child" }
+	if (signam == "CLD")    { msg[signum] = "death of child" }
+	if (signam == "CONT")   { msg[signum] = "continued" }
+	if (signam == "EMT")    { msg[signum] = "EMT instruction" }
+	if (signam == "FPE")    { msg[signum] = "floating point exception" }
+	if (signam == "HUP")    { msg[signum] = "hangup" }
+	if (signam == "ILL")    { msg[signum] = "illegal hardware instruction" }
+	if (signam == "INFO")   { msg[signum] = "status request from keyboard" }
+	if (signam == "INT")    { msg[signum] = "interrupt" }
+	if (signam == "IO")     { msg[signum] = "i/o ready" }
+	if (signam == "IOT")    { msg[signum] = "IOT instruction" }
+	if (signam == "KILL")   { msg[signum] = "killed" }
+	if (signam == "LOST")	{ msg[signum] = "resource lost" }
+	if (signam == "PIPE")   { msg[signum] = "broken pipe" }
+	if (signam == "POLL")	{ msg[signum] = "pollable event occurred" }
+	if (signam == "PROF")   { msg[signum] = "profile signal" }
+	if (signam == "PWR")    { msg[signum] = "power fail" }
+	if (signam == "QUIT")   { msg[signum] = "quit" }
+	if (signam == "SEGV")   { msg[signum] = "segmentation fault" }
+	if (signam == "SYS")    { msg[signum] = "invalid system call" }
+	if (signam == "TERM")   { msg[signum] = "terminated" }
+	if (signam == "TRAP")   { msg[signum] = "trace trap" }
+	if (signam == "URG")	{ msg[signum] = "urgent condition" }
+	if (signam == "USR1")   { msg[signum] = "user-defined signal 1" }
+	if (signam == "USR2")   { msg[signum] = "user-defined signal 2" }
+	if (signam == "VTALRM") { msg[signum] = "virtual time alarm" }
+	if (signam == "WINCH")  { msg[signum] = "window size changed" }
+	if (signam == "XCPU")   { msg[signum] = "cpu limit exceeded" }
+	if (signam == "XFSZ")   { msg[signum] = "file size limit exceeded" }
+    }
+}
+
+END {
+    ps = "%s"
+    ifdstr = sprintf("# ifdef USE_SUSPENDED\n\t%csuspended%s%c,\n%s else\n\t%cstopped%s%c,\n# endif\n", 34, ps, 34, "#", 34, ps, 34)
+
+    printf "/** signames.c                                 **/\n"
+    printf "/** architecture-customized signames.c for zsh **/\n"
+    printf "\n"
+    printf "#define SIGCOUNT\t%d\n", max
+    printf "\n"
+    printf "#include %czsh.mdh%c\n", 34, 34
+    printf "\n"
+    printf "/**/\n"
+    printf "char *sigmsg[SIGCOUNT+2] = {\n"
+    printf "\t%c%s%c,\n", 34, "done", 34
+
+    for (i = 1; i <= 0 + max; i++)
+	if (msg[i] == "") {
+	    if (sig[i] == "")
+		printf("\t%c%c,\n", 34, 34)
+	    else if (sig[i] == "STOP")
+		printf ifdstr, " (signal)", " (signal)"
+	    else if (sig[i] == "TSTP")
+		printf ifdstr, "", ""
+	    else if (sig[i] == "TTIN")
+		printf ifdstr, " (tty input)", " (tty input)"
+	    else if (sig[i] == "TTOU")
+		printf ifdstr, " (tty output)", " (tty output)"
+	    else
+		printf("\t%cSIG%s%c,\n", 34, sig[i], 34)
+	} else
+	    printf("\t%c%s%c,\n", 34, msg[i], 34)
+    print "\tNULL"
+    print "};"
+    print ""
+    print "/**/"
+    printf "char *sigs[SIGCOUNT+4] = {\n"
+    printf("\t%cEXIT%c,\n", 34, 34)
+    for (i = 1; i <= 0 + max; i++)
+	if (sig[i] == "")
+	    printf("\t%c%d%c,\n", 34, i, 34)
+	else
+	    printf("\t%c%s%c,\n", 34, sig[i], 34)
+    printf("\t%cZERR%c,\n", 34, 34)
+    printf("\t%cDEBUG%c,\n", 34, 34)
+    print "\tNULL"
+    print "};"
+}

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

