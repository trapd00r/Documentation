From zsh-workers-return-17147-mason-zsh=primenet.com.au@sunsite.dk Tue May 14 07:59:58 2002
Return-Path: <zsh-workers-return-17147-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7568 invoked from network); 14 May 2002 07:59:57 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 14 May 2002 07:59:57 -0000
Received: (qmail 29778 invoked by alias); 14 May 2002 07:59:48 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 17147
Received: (qmail 29767 invoked from network); 14 May 2002 07:59:47 -0000
From: Sven Wischnowsky <wischnow@berkom.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-ID: <15584.50137.133265.722041@wischnow.berkom.de>
Date: Tue, 14 May 2002 09:59:21 +0200
To: zsh-workers@sunsite.dk
Subject: Re: aggregated options in completion lists
In-Reply-To: <1021212626.4179.3.camel@localhost.localdomain>
References: <1021212626.4179.3.camel@localhost.localdomain>
X-Mailer: VM 6.95 under 21.5 (patch 3) "asparagus" XEmacs Lucid


Borsenkow Andrej wrote:

> This looks strange. And of course all descriptions are cut off (I am
> sorry, actually every option is on a single line, it is just I do not
> know how to tell it Evolution). There probably should be some (settable)
> limit on column width.

Below is a patch. This is the simple implementation. One could thing
about how nice it were if the code could do:

   % foo <TAB>
   description
   --long-option1  --long-option2
   --long-option3                   -- description

I.e., to not repeat the description for every sub-set of matches it
creates. That, however is much harder to implement and, if uses often,
could probably be slightly irritating, I think.

Opinions?


Can anyone help me with a better name for that style? `max-match-length'
just doesn't sound right. `max-match-columns' might be better, but
sound (to me) as if the number of matches per line were meant, which
it isn't.

I'll commit it anyway.


Bye
  Sven

Index: Completion/Base/Utility/_describe
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_describe,v
retrieving revision 1.11
diff -u -r1.11 _describe
--- Completion/Base/Utility/_describe	6 May 2002 07:59:50 -0000	1.11
+++ Completion/Base/Utility/_describe	14 May 2002 07:57:50 -0000
@@ -2,7 +2,7 @@
 
 # This can be used to add options or values with descriptions as matches.
 
-local _opt _expl _tmpm _tmpd
+local _opt _expl _tmpm _tmpd _mlen
 local _type=values _descr _ret=1 _showd _nm _hide _args _grp _sep
 local csl="$compstate[list]" csl2
 local _oargv _argv _new _strs _mats _opts _i _try=0
@@ -25,6 +25,8 @@
 zstyle -T ":completion:${curcontext}:$_type" verbose && _showd=yes
 
 zstyle -s ":completion:${curcontext}:$_type" list-separator _sep || _sep=--
+zstyle -s ":completion:${curcontext}:$_type" max-match-length _mlen ||
+    _mlen=$((COLUMNS/2))
 
 _descr="$1"
 shift
@@ -97,9 +99,9 @@
     fi
 
     if [[ -n "$_showd" ]]; then
-      compdescribe -I "$_hide" "$_sep " _expl "$_grp[@]" "$@"
+      compdescribe -I "$_hide" "$_mlen" "$_sep " _expl "$_grp[@]" "$@"
     else
-      compdescribe -i "$_hide" "$@"
+      compdescribe -i "$_hide" "$_mlen" "$@"
     fi
 
     compstate[list]="$csl"
Index: Completion/Zsh/Command/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Zsh/Command/_zstyle,v
retrieving revision 1.9
diff -u -r1.9 _zstyle
--- Completion/Zsh/Command/_zstyle	16 Apr 2002 07:48:46 -0000	1.9
+++ Completion/Zsh/Command/_zstyle	14 May 2002 07:57:51 -0000
@@ -80,6 +80,7 @@
   matcher		 c:
   matcher-list		 c:
   max-errors		 c:
+  max-match-length       c:max-match-length
   menu			 c:boolauto
   muttrc                 c:_files
   numbers		 c:bool
@@ -380,6 +381,10 @@
 
     separator)
       _message -e separators 'separator string'
+      ;;
+
+    max-match-length)
+      _message -e numbers 'maximum display length for matches'
       ;;
 
     urgh) 
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.155
diff -u -r1.155 compsys.yo
--- Doc/Zsh/compsys.yo	14 May 2002 07:54:24 -0000	1.155
+++ Doc/Zsh/compsys.yo	14 May 2002 07:57:51 -0000
@@ -1766,6 +1766,20 @@
 
 The default value for this style is `tt(2 numeric)'.
 )
+kindex(max-match-length, completion style)
+item(tt(max-match-length))(
+This is used to define the maximum length to use for the matches when
+listing matches with descriptions. In such lists, matches with the
+same description will be grouped together, but that means that in
+cases where many matches have the same description, the matches take
+up most of the display width, leaving only little room for the
+descriptions. By setting this style one can specify whether one
+prefers to make more matches be grouped together or whether the shell
+should try keep more of the descriptions visible. 
+
+The value should give the maximum number of display columns to give to
+the matches, the default is half the screen width.
+)
 kindex(menu, completion style)
 item(tt(menu))(
 If this is set to true in a given context, using any of the tags defined
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.77
diff -u -r1.77 computil.c
--- Src/Zle/computil.c	17 Apr 2002 07:28:19 -0000	1.77
+++ Src/Zle/computil.c	14 May 2002 07:57:52 -0000
@@ -41,6 +41,7 @@
     int showd;			/* != 0 if descriptions should be shown */
     char *sep;			/* the separator string */
     int slen;			/* its length */
+    int maxmlen;                /* maximum length to allow for the matches */
     Cdset sets;			/* the sets of matches */
     int pre;                    /* longest prefix (before description) */
     int suf;                    /* longest suffix (description) */
@@ -129,22 +130,26 @@
                 continue;
 
             num = 1;
-            len = str1->len;
+            len = str1->len + cd_state.slen;
             strp = &(str1->other);
 
-            for (set2 = set1; set2; set2 = set2->next)
+            for (set2 = set1; set2; set2 = set2->next) {
                 for (str2 = (set2 == set1 ? str1->next : set2->strs);
                      str2; str2 = str2->next)
                     if (str2->desc && !strcmp(str1->desc, str2->desc)) {
+                        len += 2 + str2->len;
+                        if (len > cd_state.maxmlen)
+                            break;
                         str1->kind = 1;
                         str2->kind = 2;
                         num++;
-                        len += str2->len;
                         *strp = str2;
                         strp = &(str2->other);
                     }
+                if (str2)
+                    break;
+            }
             *strp = NULL;
-            len += num * 2 + cd_state.slen;
 
             if (len >= columns) {
                 cd_state.groups = 0;
@@ -393,12 +398,13 @@
 /* Initialisation. Store and calculate the string and matches and so on. */
 
 static int
-cd_init(char *nam, char *hide, char *sep, char **opts, char **args, int disp)
+cd_init(char *nam, char *hide, char *mlen, char *sep,
+        char **opts, char **args, int disp)
 {
     Cdset *setp, set;
     Cdstr *strp, str;
     char **ap, *tmp;
-    int grp = 0;
+    int grp = 0, itmp;
 
     if (cd_parsed) {
 	zsfree(cd_state.sep);
@@ -411,7 +417,12 @@
     cd_state.sets = NULL;
     cd_state.showd = disp;
     cd_state.maxg = cd_state.groups = cd_state.descs = 0;
-
+    cd_state.maxmlen = atoi(mlen);
+    itmp = columns - cd_state.slen - 4;
+    if (cd_state.maxmlen > itmp)
+        cd_state.maxmlen = itmp;
+    if (cd_state.maxmlen < 4)
+        cd_state.maxmlen = 4;
     if (*args && !strcmp(*args, "-g")) {
         args++;
         grp = 1;
@@ -537,7 +548,7 @@
                 /* We are building a columnised list with dummy matches
                  * but there are also matches without descriptions.
                  * Those end up in a different group, so make sure that
-                 * groupd doesn't have an explanation. */
+                 * group doesn't have an explanation. */
 
                 for (mp = dp = opts; *mp; mp++) {
                     if (dp[0][0] == '-' && dp[0][1] == 'X') {
@@ -679,25 +690,25 @@
     }
     switch (args[0][1]) {
     case 'i':
-        if (n < 2) {
+        if (n < 3) {
             zwarnnam(nam, "not enough arguments", NULL, 0);
 
             return 1;
         }
-	return cd_init(nam, args[1], "", NULL, args + 2, 0);
+	return cd_init(nam, args[1], args[2], "", NULL, args + 3, 0);
     case 'I':
-        if (n < 5) {
+        if (n < 6) {
             zwarnnam(nam, "not enough arguments", NULL, 0);
 
             return 1;
         } else {
             char **opts;
 
-            if (!(opts = getaparam(args[3]))) {
-		zwarnnam(nam, "unknown parameter: %s", args[2], 0);
+            if (!(opts = getaparam(args[4]))) {
+		zwarnnam(nam, "unknown parameter: %s", args[4], 0);
 		return 1;
             }
-            return cd_init(nam, args[1], args[2], opts, args + 4, 1);
+            return cd_init(nam, args[1], args[2], args[3], opts, args + 5, 1);
         }
     case 'g':
 	if (cd_parsed) {

-- 
Sven Wischnowsky                          wischnow@berkom.de

