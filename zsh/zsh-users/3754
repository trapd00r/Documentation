From zsh-users-return-3754-mason-zsh=primenet.com.au@sunsite.dk Wed Mar 28 09:01:00 2001
Return-Path: <zsh-users-return-3754-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20829 invoked from network); 28 Mar 2001 09:00:58 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 28 Mar 2001 09:00:58 -0000
Received: (qmail 26417 invoked by alias); 28 Mar 2001 09:00:45 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3754
Received: (qmail 26402 invoked from network); 28 Mar 2001 09:00:44 -0000
Date: Wed, 28 Mar 2001 11:00:44 +0200 (MET DST)
Message-Id: <200103280900.LAA06786@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-users@sunsite.dk
In-reply-to: Mario Lang's message of 28 Mar 2001 09:22:03 +0200
Subject: Re: Backticks and                       other tricks


Mario Lang wrote:

> Can anyone cast some light on the following questions
> regarding the code below:
> 1. Why does ${(P)...[...]} not work with subscripts of the
> array? (in fucntion argsargs).

`array', that's the point.  The ${(P)1} yields an array (a *normal*
array, not an associative array).  On normal arrays the subscripts of
`[ef1]' etc. are used as mathematical expressions and since there
aren't any variables with those names, mathematical evaluation gives
the value `0' (zero) as subscripts, so one always gets the first
element in the array.

Currently I don't see a solution other than just not using an
associative array at all, e.g. by prepending the `keys' to the
strings:

  # No need for backslashes here...

  filters=(
    ef1:"Resonant bandpass filter":"center frequency":Hz:"width":Hz
    ef3:"Resonant lowpass filter":"cutoff frequency":Hz:resonance::gain:
    ef4:"Resonant lowpass filter (3rd-order, 36dB)":"cutoff frequency":Hz:resonance:
    efa:"Allpass filter":"delay":samples:"feedback":percents
    efb:"Bandpass filter":"center frequency":Hz:"width":Hz
    efc:"Comb filter":"delay":samples:"radius":0-1
    efh:"Highpass filter":"cutoff frequency":Hz
    efi:"Inverse comb filter":"delay":samples:"radius":0-1
    efl:"Lowpass filter":"cutoff frequency":Hz
    efr:"Bandreject filter":"center frequency":Hz:"width":Hz
    efs:"Resonator (resonating bandpass filter)":"center frequency":Hz:"width":Hz\
  )

  argsargs () {
    for i in ${(P)1}; do
      print -- "*-${i%%:*}[${${i#*:}%%:*}]: :->${i%%:*}"
    done
  }

> 2. Why does the inclusion trick with backticks not
> work (`argsargs filters`). Actually _arguments complains
> about not being able to parse this option. 

The backticks make the words in the output of argsargs be split at
white spaces.  One solution would be to set IFS (deprecated) or use
the standard expression for splitting process outputs into lines:

  ${(f)"$(argsargs filters)"}

The quoting around the $(..) makes it return the complete output as
one (unaltered) string.  The (f) flag splits that at newlines into
array elements.


But anyway I would suggest not using process substitution if it can be 
avoided (always an extra process).  And since the options don't change 
it can be cached without any harm.  E.g.:

  if (( ! $+_ecasound_opts )); then
    local filters i

    filters=(
      ...
    )

    _ecasound_opts=()
    for i in $filters; do
      _ecasound_opts=($_ecasound_opts "*-${i%%:*}[${${i#*:}%%:*}]: :->${i%%:*}")
    done
  fi

  _arguments \
    $_ecasound_opts \
    ...                # other options



To -workers: that the ${(P)1} thing doesn't work is ugly, isn't it?

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

