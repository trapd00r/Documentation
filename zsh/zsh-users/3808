From zsh-users-return-3808-mason-zsh=primenet.com.au@sunsite.dk Fri Apr 06 17:11:13 2001
Return-Path: <zsh-users-return-3808-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14632 invoked from network); 6 Apr 2001 16:54:41 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 6 Apr 2001 16:54:41 -0000
Received: (qmail 1074 invoked by alias); 6 Apr 2001 16:54:30 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3808
Received: (qmail 1062 invoked from network); 6 Apr 2001 16:54:29 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010406165353.ZM12264@candle.brasslantern.com>
Date: Fri, 6 Apr 2001 16:53:53 +0000
In-Reply-To: <20010406151348.A27201@greux.loria.fr>
Comments: In reply to Vincent Lefevre <vincent@vinc17.org>
        "Parameter expansion: tr?" (Apr  6,  3:13pm)
References: <20010406151348.A27201@greux.loria.fr>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.dk, Vincent Lefevre <vincent@vinc17.org>
Subject: Re: Parameter expansion: tr?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Apr 6,  3:13pm, Vincent Lefevre wrote:
} Subject: Parameter expansion: tr?
}
} I've seen how one can do a string substitution in a parameter expansion,
} but how can I do a tr, e.g. to swap the "." and "/" characters?
} 
} Is there a simple way to do that, or do I need associative arrays?

The following requires 3.1.9 or later:

  function ztr {
    setopt extendedglob noshwordsplit
    local chunk=''
    while read -u0k 4096 chunk; do
	print -Rn ${chunk//(#b)([$1])/${2[${1[(I)$match]}]}}
	chunk=''
    done
    # "read -k" will exit nonzero on the last partial chunk, print it
    (( $#chunk )) && print -Rn ${chunk//(#b)([$1])/${2[${1[(I)$match]}]}}
  }

% ztr "abcde ." "NOPQR-/" <<EOF
The quick brown fox jumped over the lazy dog.
EOF
ThR-quiPk-Orown-fox-jumpRQ-ovRr-thR-lNzy-Qog/
% 

I think the "read -k" behavior on a partial chunk is a bug, but I seem to
recall some zsh-workers discussion to the effect that other shells also
behave that way.  I may be thinking of some other "read" behavior, though.

Using ${1[(I)$match]} emulates the real `tr aaa xyz` == `tr a z` behavior.
If you give the above function only one argument, it acts like "tr -d".
"tr -s" and "tr -c" left as exercises for the reader.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

