From zsh-workers-request@math.gatech.edu  Sun Oct  1 11:12:56 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.net.au (8.7/8.7) with SMTP id LAA18334 for <mason@werple.mira.net.au>; Sun, 1 Oct 1995 11:12:52 +1000 (EST)
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA02439
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Sat, 30 Sep 1995 20:55:59 -0400
Received: by math (5.x/SMI-SVR4)
	id AA08688; Sat, 30 Sep 1995 18:24:46 -0400
Resent-Date: Sat, 30 Sep 1995 23:26:58 +0100 (MET)
Old-Return-Path: <hzoli@cs.elte.hu>
From: hzoli@cs.elte.hu (Zoltan Hidvegi)
Message-Id: <9509302226.AA19188@turan.elte.hu>
Subject: $(($...)) bugfix for hzoli releases
To: zsh-workers@math.gatech.edu (zsh-workers)
Date: Sat, 30 Sep 1995 23:26:58 +0100 (MET)
X-Mailer: ELM [version 2.4 PL23]
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"XboTE1.0.c72.iESRm"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/412
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

As Mark Borges noticed my releases has a problem with substitutions inside
math substitutions.  E.g.

% echo $(($1))
zsh: bad math expression: unbalanced stack

Note that it only occures with $((...)) and not with $[...].  Here is the fix.
I also moved a sanity check inside an #ifdef DEBUG ... #endif, and wrote some
better comments.

Cheers,
   Zoltan

*** 1.16	1995/09/22 18:57:05
--- Src/subst.c	1995/09/30 21:44:56
***************
*** 125,152 ****
  	    else
  		endchar = *str, *str = '\0';
  
! 	    /* echo ${(e)~foo} discards some special characters without	*
! 	     * the untokenization below. A single untokenize is not	*
! 	     * enough because of the silly quoting rules within `...`.	*/
! 	    while (*++str && *str != endchar)
! 		if (itok(*str) && *str != Nularg &&
! 		    !(endchar != Outpar && *str == Bnull &&
! 		      (str[1] == '$' || str[1] == '\\' || str[1] == '`' ||
! 		       (qt && str[1] == '"'))))
! 		    *str = ztokens[*str - Pound];
! 	    if (!*str) {
! 		/* This shoud never happen */
! 		zerr("Oops. parse error in command substitution", NULL, 0);
! 		return NULL;
! 	    }
  	    *str++ = '\0';
! 	    if (endchar == Outpar && str2[1] == '(' &&
! 		str[-2] == ')') {
  		/* Math substitution of the form $((...)) */
  		str = arithsubst(str2 + 1, &str3, str);
  		setdata(node, (void *) str3);
  		continue;
  	    }
  	    if (!(pl = getoutput(str2 + 1, qt || ssub))) {
  		zerr("parse error in command substitution", NULL, 0);
  		return NULL;
--- 125,161 ----
  	    else
  		endchar = *str, *str = '\0';
  
! 	    while (*++str != endchar)
! #ifdef DEBUG
! 		if (!*str) {
! 		    /* This shoud never happen */
! 		    zerr("Oops. parse error in command substitution", NULL, 0);
! 		    return NULL;
! 		}
! #else
! 		;
! #endif
  	    *str++ = '\0';
! 	    if (endchar == Outpar && str2[1] == '(' && str[-2] == ')') {
  		/* Math substitution of the form $((...)) */
  		str = arithsubst(str2 + 1, &str3, str);
  		setdata(node, (void *) str3);
  		continue;
  	    }
+ 
+ 	    /* It is a command substitution, which will be parsed again   *
+ 	     * by the lexer, so we untokenize it first, but we cannot use *
+ 	     * untokenize() since in the case of `...` some Bnulls should *
+ 	     * be left unchanged.  Note that the lexer doesn't tokenize   *
+ 	     * the body of a command substitution so if there are some    *
+ 	     * tokens here they are from a ${(e)~...} substitution.       */
+ 	    for (str = str2; *++str; )
+ 		if (itok(*str) && *str != Nularg &&
+ 		    !(endchar != Outpar && *str == Bnull &&
+ 		      (str[1] == '$' || str[1] == '\\' || str[1] == '`' ||
+ 		       (qt && str[1] == '"'))))
+ 		    *str = ztokens[*str - Pound];
+ 	    str++;
  	    if (!(pl = getoutput(str2 + 1, qt || ssub))) {
  		zerr("parse error in command substitution", NULL, 0);
  		return NULL;

