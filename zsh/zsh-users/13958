From zsh-users-return-13958-mason-zsh=primenet.com.au@sunsite.dk Sat Mar 21 12:53:31 2009
Return-Path: <zsh-users-return-13958-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11164 invoked from network); 21 Mar 2009 12:53:18 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 21 Mar 2009 12:53:18 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 44275 invoked from network); 21 Mar 2009 12:53:08 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 21 Mar 2009 12:53:08 -0000
Received: (qmail 14306 invoked by alias); 21 Mar 2009 12:52:52 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 13958
Received: (qmail 14293 invoked from network); 21 Mar 2009 12:52:52 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 21 Mar 2009 12:52:52 -0000
Received: from sievert.tabularazor.org (sievert.tabularazor.org [78.47.31.242])
	by bifrost.dotsrc.org (Postfix) with ESMTP id B6A3382CF026
	for <zsh-users@sunsite.dk>; Sat, 21 Mar 2009 13:52:48 +0100 (CET)
Received: by sievert.tabularazor.org (Postfix, from userid 2350)
	id D0BCF11505B9; Sat, 21 Mar 2009 14:06:23 +0100 (CET)
Date: Sat, 21 Mar 2009 14:06:23 +0100
From: Daniel Friesel <derf@sievert.tabularazor.org>
To: zsh-users@sunsite.dk
Cc: freakguard@gmail.com
Subject: Re: wierd sshfs completion
Message-ID: <20090321130623.GA16004@sievert.tabularazor.org>
References: <200903211203.20315.freakguard@gmail.com> <20090321122841.GA15859@sievert.tabularazor.org> <200903211331.32428.freakguard@gmail.com>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="YiEDa0DAkWCtVeE4"
Content-Disposition: inline
In-Reply-To: <200903211331.32428.freakguard@gmail.com>
User-Agent: Mutt/1.5.16 (2007-06-09)
X-Virus-Scanned: ClamAV 0.92.1/9147/Sat Mar 21 08:15:16 2009 on bifrost
X-Virus-Status: Clean


--YiEDa0DAkWCtVeE4
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

On Sat, Mar 21, 2009 at 01:31:32PM +0100, Freak wrote:
> Works good. But after choosing a remote hostname <tab>:
> (space)<local dirs>
> 
> It should display remote dirs instead (like scp)

There you go ;)

But this is a really ugly solution, this _sshfs almost entirely consists
of snippets from _ssh.
One should think about either splitting up _ssh so that for example
_remote_files can be used by other scripts as well, or adding sshfs
completion to _ssh.

--YiEDa0DAkWCtVeE4
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename=_sshfs

#compdef sshfs
## Since _user_at_host was a little inflexible,
## I ripped the responsible parts from _ssh.
## In future, sshfs should be handled by _ssh as well
## Copyright goes to whoever wrote _ssh (if in doubt, the zsh dudes)

typeset expl lstate tmp

_remote_files () {
  # There should be coloring based on all the different ls -F classifiers.
  local expl rempat remfiles remdispf remdispd args suf ret=1

  if zstyle -T ":completion:${curcontext}:files" remote-access; then
    zparseopts -D -E -a args p: 1 2 4 6 F:
    if [[ -z $QIPREFIX ]]
    then rempat="${PREFIX%%[^./][^/]#}\*"
    else rempat="${(q)PREFIX%%[^./][^/]#}\*"
    fi
    remfiles=(${(M)${(f)"$(_call_program files ssh -o BatchMode=yes $args -a -x ${IPREFIX%:} ls -d1FL "$rempat" 2>/dev/null)"}%%[^/]#(|/)})
    compset -P '*/'
    compset -S '/*' || suf='remote file'

    remdispf=(${remfiles:#*/})
    remdispd=(${(M)remfiles:#*/})

    _tags files
    while _tags; do
      while _next_label files expl ${suf:-remote directory}; do
        [[ -n $suf ]] && compadd "$@" "$expl[@]" -d remdispf \
	    ${(q)remdispf%[*=@|]} && ret=0 
	compadd ${suf:+-S/} "$@" "$expl[@]" -d remdispd \
	    ${(q)remdispd%/} && ret=0
      done
      (( ret )) || return 0
    done
    return ret
  else
    _message -e remote-files 'remote file'
  fi
}

_arguments \
  '-V[version]' \
  '-p:tcp port:' \
  '-C[compression]' \
  '-o:options:_values -s , "sshfs or fuse or mount options" reconnect sshfs_sync no_readahead sshfs_debug cache=:cache\ setting:(yes no) cache_timeout=:seconds: cache_stat_timeout=:seconds: cache_dir_timeout=:seconds: cache_link_timeout=:seconds: ssh_command=:ssh\ command:_command_names directport=:port: SSHOPT=:ssh\ option: default_permissions allow_other allow_root kernel_cache large_read direct_io max_read=:size: hard_remove debug fs_name=:name: use_ino readdir_ino' \
  '-d[debug]' \
  '-f[foreground]' \
  '-s[disable multithreaded operation]' \
  '-r[mount read-only]' \
  '-h[help]' \
  ':remote directory:->userhost' \
  ':mountpoint:_files -/'

_ssh_users () {
	_combination -s '[:@]' my-accounts users-hosts users "$@"
}

_ssh_hosts () {
	local -a config_hosts
	local config
	integer ind

	# If users-hosts matches, we shouldn't complete anything else.
	if [[ "$IPREFIX" == *@ ]]; then
		_combination -s '[:@]' my-accounts users-hosts "users=${IPREFIX/@}" hosts "$@" && return
	else
		_combination -s '[:@]' my-accounts users-hosts \
		${opt_args[-l]:+"users=${opt_args[-l]:q}"} hosts "$@" && return
	fi
	if (( ind = ${words[(I)-F]} )); then
		config=${~words[ind+1]}
	else
		config="$HOME/.ssh/config"
	fi
	if [[ -r $config ]]; then
		local IFS=$'\t ' key hosts host
		while read key hosts; do
			if [[ "$key" == (#i)host ]]; then
				for host in ${(z)hosts}; do
					case $host in
						(*[*?]*) ;;
						(*) config_hosts+=("$host") ;;
					esac
				done
			fi
		done < "$config"
		if (( ${#config_hosts} )); then
			_wanted hosts expl 'remote host name' \
			compadd -M 'm:{a-zA-Z}={A-Za-z} r:|.=* r:|=*' "$@" $config_hosts
		fi
	fi
}

while [[ -n $state ]]; do
	lstate=$state
	state=''
	case $lstate in
		userhost)
			if compset -P '*:'; then
				_remote_files ${(kv)~opt_args[(I)-[FP1246]]/-P/-p} && ret=0
			elif compset -P '*@'; then
				_wanted hosts expl 'remote host name' _ssh_hosts -S ':'
			elif compset -S '@*'; then
				_wanted users expl 'login name' _ssh_users -S ''
			else
				if (( $+opt_args[-l] )); then
					tmp=()
				else
					tmp=( 'users:login name:_ssh_users -qS@' )
				fi
				 _alternative \
				'hosts:remote host name:_ssh_hosts -S :' \
				"$tmp[@]"
			fi
		;;
	esac
done

--YiEDa0DAkWCtVeE4--

