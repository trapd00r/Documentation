From zsh-workers-request@math.gatech.edu Fri Oct 23 10:05:03 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13798 invoked from network); 23 Oct 1998 10:04:58 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 23 Oct 1998 10:04:58 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id FAA18166;
	Fri, 23 Oct 1998 05:48:25 -0400 (EDT)
Resent-Date: Fri, 23 Oct 1998 05:48:25 -0400 (EDT)
Subject: Compiling ZSH-3.0.0 on QNX 4.23
From: Michal Gomulinski <s146028@ia.pw.edu.pl>
To: zsh-workers@math.gatech.edu
Date: 	Fri, 23 Oct 1998 11:50:48 +0200 (MET DST)
X-Mailer: ELM [version 2.4 PL24 ME6]
MIME-Version: 1.0
Content-Type: 	text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7BIT
Message-Id: <98Oct23.115056+0200met_dst.117392-12597+1@csd.ia.pw.edu.pl>
Resent-Message-ID: <"gIV6p2.0.nR4.f35Cs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4439
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Hi!

I've managed to compile zsh-3.0.0 on QNX box (Watcom C). The only changes
I had to make are related to different definition of DIR structure
and some things about inclusion of termio header files. 

The most serious thing was the existence of halloc in the system 
libraries (it means Huge alloc there). That is why I had to change
your halloc into something else everywhere in the sources.

Still one problem remains, that is when I had automatic correction
turned on and type say "mkae" zsh writes
something like this

Correct mkae to make ?[nya] n

Note that it doesn't wait for the answer but assumes the answer is no
and tries to execute 'mkae' immediately, which of course fails.

If you would like me to provide some of the system include files
or do some checks/debugging of zsh on QNX mail me at: 
M.Gomulinski@writeme.com

Yours
   Michal

-- 
Micha/l Gomuli/nski, zwany "Welniakiem"
e-mail: M.Gomulinski@elka.pw.edu.pl, M.Gomulinski@writeme.com
http://www.ia.pw.edu.pl/~s146028


diff -c -r zsh-3.0.0/Src/compat.c orig/zsh-3.0.0/Src/compat.c
*** zsh-3.0.0/Src/compat.c	Wed Oct 14 08:03:53 1998
--- orig/zsh-3.0.0/Src/compat.c	Sat Jul 27 22:24:36 1996
***************
*** 156,162 ****
  	readdir(dir);
  	readdir(dir);
  	while ((de = readdir(dir)))
! 	    if ((ino_t) de->d_stat.st_ino == ino) {
  		lstat(de->d_name, &sbuf);
  		if (sbuf.st_dev == dev)
  		    goto match;
--- 156,162 ----
  	readdir(dir);
  	readdir(dir);
  	while ((de = readdir(dir)))
! 	    if ((ino_t) de->d_ino == ino) {
  		lstat(de->d_name, &sbuf);
  		if (sbuf.st_dev == dev)
  		    goto match;
diff -c -r zsh-3.0.0/Src/mem.c orig/zsh-3.0.0/Src/mem.c
*** zsh-3.0.0/Src/mem.c	Wed Oct 14 07:48:20 1998
--- orig/zsh-3.0.0/Src/mem.c	Sun Aug  4 14:35:44 1996
***************
*** 39,45 ****
  	There are two ways to allocate memory in zsh.  The first way is
  	to call zalloc/zcalloc, which call malloc/calloc directly.  It
  	is legal to call realloc() or free() on memory allocated this way.
! 	The second way is to call myhalloc/hcalloc, which allocates memory
  	from one of the memory pools on the heap stack.  Such memory pools 
  	will automatically created when the heap allocation routines are
  	called.  To be sure that they are freed at appropriate times
--- 39,45 ----
  	There are two ways to allocate memory in zsh.  The first way is
  	to call zalloc/zcalloc, which call malloc/calloc directly.  It
  	is legal to call realloc() or free() on memory allocated this way.
! 	The second way is to call halloc/hcalloc, which allocates memory
  	from one of the memory pools on the heap stack.  Such memory pools 
  	will automatically created when the heap allocation routines are
  	called.  To be sure that they are freed at appropriate times
***************
*** 60,66 ****
  	it will all be freed when the pool is destroyed.  In fact,
  	attempting to free this memory may result in a core dump.
  	The pair of pointers ncalloc and alloc may point to either
! 	zalloc & zcalloc or myhalloc & hcalloc; permalloc() sets them to the
  	former, and heapalloc() sets them to the latter. This can be useful.
  	For example, the dupstruct() routine duplicates a syntax tree,
  	allocating the new memory for the tree using alloc().  If you want
--- 60,66 ----
  	it will all be freed when the pool is destroyed.  In fact,
  	attempting to free this memory may result in a core dump.
  	The pair of pointers ncalloc and alloc may point to either
! 	zalloc & zcalloc or halloc & hcalloc; permalloc() sets them to the
  	former, and heapalloc() sets them to the latter. This can be useful.
  	For example, the dupstruct() routine duplicates a syntax tree,
  	allocating the new memory for the tree using alloc().  If you want
***************
*** 103,109 ****
      int luh = useheap;
  
      alloc = hcalloc;
!     ncalloc = myhalloc;
      useheap = 1;
      return luh;
  }
--- 103,109 ----
      int luh = useheap;
  
      alloc = hcalloc;
!     ncalloc = halloc;
      useheap = 1;
      return luh;
  }
***************
*** 231,237 ****
  
  /**/
  void *
! myhalloc(size_t size)
  {
      Heap h, hp;
      char *ret;
--- 231,237 ----
  
  /**/
  void *
! halloc(size_t size)
  {
      Heap h, hp;
      char *ret;
***************
*** 300,306 ****
  {
      void *ptr;
  
!     ptr = myhalloc(size);
      memset(ptr, 0, size);
      return ptr;
  }
--- 300,306 ----
  {
      void *ptr;
  
!     ptr = halloc(size);
      memset(ptr, 0, size);
      return ptr;
  }
***************
*** 311,317 ****
  {
      char *ptr;
  
!     ptr = (char *)myhalloc(new);
      memcpy(ptr, p, old);
      return (void *) ptr;
  }
--- 311,317 ----
  {
      char *ptr;
  
!     ptr = (char *)halloc(new);
      memcpy(ptr, p, old);
      return (void *) ptr;
  }
diff -c -r zsh-3.0.0/Src/subst.c orig/zsh-3.0.0/Src/subst.c
*** zsh-3.0.0/Src/subst.c	Wed Oct 14 07:49:05 1998
--- orig/zsh-3.0.0/Src/subst.c	Mon Jul 29 00:29:59 1996
***************
*** 452,459 ****
      char c[strlen(*(char **) a) + 1];
      char d[strlen(*(char **) b) + 1];
  # else
!     char *c = myhalloc(strlen(*(char **) a) + 1);
!     char *d = myhalloc(strlen(*(char **) b) + 1);
  # endif
      char *s, *t;
      int   cmp;
--- 452,459 ----
      char c[strlen(*(char **) a) + 1];
      char d[strlen(*(char **) b) + 1];
  # else
!     char *c = halloc(strlen(*(char **) a) + 1);
!     char *d = halloc(strlen(*(char **) b) + 1);
  # endif
      char *s, *t;
      int   cmp;
***************
*** 482,489 ****
      char c[strlen(*(char **) a) + 1];
      char d[strlen(*(char **) b) + 1];
  # else
!     char *c = myhalloc(strlen(*(char **) a) + 1);
!     char *d = myhalloc(strlen(*(char **) b) + 1);
  # endif
      char *s, *t;
      int   cmp;
--- 482,489 ----
      char c[strlen(*(char **) a) + 1];
      char d[strlen(*(char **) b) + 1];
  # else
!     char *c = halloc(strlen(*(char **) a) + 1);
!     char *d = halloc(strlen(*(char **) b) + 1);
  # endif
      char *s, *t;
      int   cmp;
***************
*** 533,539 ****
      if (lr == ls)
  	return str;
  
!     r = ret = (char *)myhalloc(lr + 1);
  
      if (prenum) {
  	if (postnum) {
--- 533,539 ----
      if (lr == ls)
  	return str;
  
!     r = ret = (char *)halloc(lr + 1);
  
      if (prenum) {
  	if (postnum) {
***************
*** 1670,1676 ****
  		    tc = *tt;
  		    *tt = '\0';
  		    nl = al + strlen(t) + strlen(copy);
! 		    ptr1 = tmp = (char *)myhalloc(nl + 1);
  		    if (all)
  			for (ptr2 = all; *ptr2;)
  			    *ptr1++ = *ptr2++;
--- 1670,1676 ----
  		    tc = *tt;
  		    *tt = '\0';
  		    nl = al + strlen(t) + strlen(copy);
! 		    ptr1 = tmp = (char *)halloc(nl + 1);
  		    if (all)
  			for (ptr2 = all; *ptr2;)
  			    *ptr1++ = *ptr2++;
diff -c -r zsh-3.0.0/Src/system.h orig/zsh-3.0.0/Src/system.h
*** zsh-3.0.0/Src/system.h	Wed Oct 14 08:20:57 1998
--- orig/zsh-3.0.0/Src/system.h	Mon Jul  1 20:20:44 1996
***************
*** 228,234 ****
      * hence the declaration for struct termios is missing       */
  #  include <sys/termios.h>
  # else
! #  include <sys/termio.h>  /* QNX 4.23 + Watcom 10 */
  # endif
  # define VDISABLEVAL 0
  # define HAS_TIO 1
--- 228,234 ----
      * hence the declaration for struct termios is missing       */
  #  include <sys/termios.h>
  # else
! #  include <termios.h>
  # endif
  # define VDISABLEVAL 0
  # define HAS_TIO 1
diff -c -r zsh-3.0.0/Src/utils.c orig/zsh-3.0.0/Src/utils.c
*** zsh-3.0.0/Src/utils.c	Wed Oct 14 07:49:41 1998
--- orig/zsh-3.0.0/Src/utils.c	Wed Aug 14 18:18:34 1996
***************
*** 2892,2898 ****
  	    buf = memcpy(zalloc(len + meta + 1), buf, len);
  	    break;
  	case META_HEAPDUP:
! 	    buf = memcpy(myhalloc(len + meta + 1), buf, len);
  	    break;
  	case META_STATIC:
  #ifdef DEBUG
--- 2892,2898 ----
  	    buf = memcpy(zalloc(len + meta + 1), buf, len);
  	    break;
  	case META_HEAPDUP:
! 	    buf = memcpy(halloc(len + meta + 1), buf, len);
  	    break;
  	case META_STATIC:
  #ifdef DEBUG
diff -c -r zsh-3.0.0/Src/zle_hist.c orig/zsh-3.0.0/Src/zle_hist.c
*** zsh-3.0.0/Src/zle_hist.c	Wed Oct 14 07:50:09 1998
--- orig/zsh-3.0.0/Src/zle_hist.c	Sun Jul 28 22:48:29 1996
***************
*** 659,665 ****
  void
  doisearch(int dir)
  {
!     char *s, *ibuf = myhalloc(80), *sbuf = ibuf + FIRST_SEARCH_CHAR;
      int sbptr = 0, cmd, top_spot = 0, pos, sibuf = 80;
      int nomatch = 0, skip_line = 0, skip_pos = 0;
      int odir = dir, *obindtab = bindtab, sens = zmult == 1 ? 3 : 1;
--- 659,665 ----
  void
  doisearch(int dir)
  {
!     char *s, *ibuf = halloc(80), *sbuf = ibuf + FIRST_SEARCH_CHAR;
      int sbptr = 0, cmd, top_spot = 0, pos, sibuf = 80;
      int nomatch = 0, skip_line = 0, skip_pos = 0;
      int odir = dir, *obindtab = bindtab, sens = zmult == 1 ? 3 : 1;
***************
*** 944,950 ****
  int
  getvisrchstr(void)
  {
!     char *sbuf = myhalloc(80);
      int sptr = 1, cmd, ret = 0, ssbuf = 80;
      int *obindtab = bindtab;
  
--- 944,950 ----
  int
  getvisrchstr(void)
  {
!     char *sbuf = halloc(80);
      int sptr = 1, cmd, ret = 0, ssbuf = 80;
      int *obindtab = bindtab;
  
***************
*** 1016,1022 ****
  	  case z_selfinsert:
  	  ins:
  	    if(sptr == ssbuf - 1) {
! 		char *newbuf = myhalloc(ssbuf *= 2);
  		strcpy(newbuf, sbuf);
  		statusline = sbuf = newbuf;
  	    }
--- 1016,1022 ----
  	  case z_selfinsert:
  	  ins:
  	    if(sptr == ssbuf - 1) {
! 		char *newbuf = halloc(ssbuf *= 2);
  		strcpy(newbuf, sbuf);
  		statusline = sbuf = newbuf;
  	    }
diff -c -r zsh-3.0.0/Src/zle_misc.c orig/zsh-3.0.0/Src/zle_misc.c
*** zsh-3.0.0/Src/zle_misc.c	Wed Oct 14 08:25:10 1998
--- orig/zsh-3.0.0/Src/zle_misc.c	Tue Aug 13 22:24:14 1996
***************
*** 530,536 ****
  	if (*l == '\'')
  	    qtct++;
      *len += 2 + qtct*3;
!     l = ol = (char *)myhalloc(*len);
      *l++ = '\'';
      for (; str < end; str++)
  	if (*str == '\'') {
--- 530,536 ----
  	if (*l == '\'')
  	    qtct++;
      *len += 2 + qtct*3;
!     l = ol = (char *)halloc(*len);
      *l++ = '\'';
      for (; str < end; str++)
  	if (*str == '\'') {
***************
*** 551,557 ****
  executenamedcommand(char *prmt)
  {
      int len, cmd, t0, l = strlen(prmt);
!     char *ptr, *buf = myhalloc(l + NAMLEN + 2);
      int *obindtab = bindtab;
  
      strcpy(buf, prmt);
--- 551,557 ----
  executenamedcommand(char *prmt)
  {
      int len, cmd, t0, l = strlen(prmt);
!     char *ptr, *buf = halloc(l + NAMLEN + 2);
      int *obindtab = bindtab;
  
      strcpy(buf, prmt);
diff -c -r zsh-3.0.0/Src/zle_refresh.c orig/zsh-3.0.0/Src/zle_refresh.c
*** zsh-3.0.0/Src/zle_refresh.c	Wed Oct 14 07:50:31 1998
--- orig/zsh-3.0.0/Src/zle_refresh.c	Mon Aug 12 03:39:05 1996
***************
*** 504,510 ****
      if (cleareol 		/* request to clear to end of line */
  	|| !nllen 		/* no line buffer given */
  	|| (ln == 0 && (put_rpmpt != oput_rpmpt))) {	/* prompt changed */
! 	p1 = myhalloc(winw + 1);
  	if (nllen)
  	    strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', winw - nllen);
--- 504,510 ----
      if (cleareol 		/* request to clear to end of line */
  	|| !nllen 		/* no line buffer given */
  	|| (ln == 0 && (put_rpmpt != oput_rpmpt))) {	/* prompt changed */
! 	p1 = halloc(winw + 1);
  	if (nllen)
  	    strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', winw - nllen);
***************
*** 515,521 ****
  	    nl = p1;		/* shouldn't happen */
  	nllen = winw;
      } else if (ollen > nllen) { /* make new line at least as long as old */
! 	p1 = myhalloc(ollen + 1);
  	strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', ollen - nllen);
  	p1[ollen] = '\0';
--- 515,521 ----
  	    nl = p1;		/* shouldn't happen */
  	nllen = winw;
      } else if (ollen > nllen) { /* make new line at least as long as old */
! 	p1 = halloc(ollen + 1);
  	strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', ollen - nllen);
  	p1[ollen] = '\0';
diff -c -r zsh-3.0.0/Src/zle_tricky.c orig/zsh-3.0.0/Src/zle_tricky.c
*** zsh-3.0.0/Src/zle_tricky.c	Wed Oct 14 07:51:32 1998
--- orig/zsh-3.0.0/Src/zle_tricky.c	Sun Aug 11 21:15:35 1996
***************
*** 781,787 ****
  	(iblank(line[cs]) && (!cs || line[cs-1] != '\\')) ||
  	line[cs] == ')' || line[cs] == '`') {
  	*ptmp = (char *)line;
! 	line = (unsigned char *)myhalloc(strlen((char *)line) + 3);
  	memcpy(line, *ptmp, cs);
  	line[cs] = 'x';
  	strcpy((char *)line + cs + 1, (*ptmp) + cs);
--- 781,787 ----
  	(iblank(line[cs]) && (!cs || line[cs-1] != '\\')) ||
  	line[cs] == ')' || line[cs] == '`') {
  	*ptmp = (char *)line;
! 	line = (unsigned char *)halloc(strlen((char *)line) + 3);
  	memcpy(line, *ptmp, cs);
  	line[cs] = 'x';
  	strcpy((char *)line + cs + 1, (*ptmp) + cs);
***************
*** 1397,1403 ****
  		e += s - t;
  	    }
  	    if (cc) {
! 		tt = (char *)myhalloc(strlen(ppre) + strlen(psuf) + sl + 1);
  		strcpy(tt, ppre);
  		strcat(tt, s);
  		strcat(tt, psuf);
--- 1397,1403 ----
  		e += s - t;
  	    }
  	    if (cc) {
! 		tt = (char *)halloc(strlen(ppre) + strlen(psuf) + sl + 1);
  		strcpy(tt, ppre);
  		strcat(tt, s);
  		strcat(tt, psuf);
***************
*** 2825,2831 ****
  	 * get the words we have to expand.                        */
  	zleparse = 1;
  	lexsave();
! 	tmpbuf = (char *)myhalloc(strlen(cc->str) + 5);
  	sprintf(tmpbuf, "foo %s", cc->str); /* KLUDGE! */
  	inpush(tmpbuf, 0);
  	strinbeg();
--- 2825,2831 ----
  	 * get the words we have to expand.                        */
  	zleparse = 1;
  	lexsave();
! 	tmpbuf = (char *)halloc(strlen(cc->str) + 5);
  	sprintf(tmpbuf, "foo %s", cc->str); /* KLUDGE! */
  	inpush(tmpbuf, 0);
  	strinbeg();
diff -c -r zsh-3.0.0/Src/zle_utils.c orig/zsh-3.0.0/Src/zle_utils.c
*** zsh-3.0.0/Src/zle_utils.c	Wed Oct 14 07:51:52 1998
--- orig/zsh-3.0.0/Src/zle_utils.c	Sat Aug  3 00:08:55 1996
***************
*** 258,264 ****
      ue->suff = sf;
      ue->len = t2 - t;
      ue->cs = lastcs;
!     memcpy(ue->change = (char *)myhalloc(ue->len), (char *)t, ue->len);
      if(linesz + 1 > lastlinelen) {
  	free(lastline);
  	lastline = (unsigned char *)zalloc(lastlinelen = linesz + 1);
--- 258,264 ----
      ue->suff = sf;
      ue->len = t2 - t;
      ue->cs = lastcs;
!     memcpy(ue->change = (char *)halloc(ue->len), (char *)t, ue->len);
      if(linesz + 1 > lastlinelen) {
  	free(lastline);
  	lastline = (unsigned char *)zalloc(lastlinelen = linesz + 1);
diff -c -r zsh-3.0.0/Src/zle_word.c orig/zsh-3.0.0/Src/zle_word.c
*** zsh-3.0.0/Src/zle_word.c	Wed Oct 14 07:52:11 1998
--- orig/zsh-3.0.0/Src/zle_word.c	Fri Jun 28 15:43:51 1996
***************
*** 427,433 ****
  	    return;
  	}
  	for (p1 = p2; p1 && iword(line[p1 - 1]); p1--);
! 	pp = temp = (char *)myhalloc(p4 - p1 + 1);
  	struncpy(&pp, (char *) line + p3, p4 - p3);
  	struncpy(&pp, (char *) line + p2, p3 - p2);
  	struncpy(&pp, (char *) line + p1, p2 - p1);
--- 427,433 ----
  	    return;
  	}
  	for (p1 = p2; p1 && iword(line[p1 - 1]); p1--);
! 	pp = temp = (char *)halloc(p4 - p1 + 1);
  	struncpy(&pp, (char *) line + p3, p4 - p3);
  	struncpy(&pp, (char *) line + p2, p3 - p2);
  	struncpy(&pp, (char *) line + p1, p2 - p1);

