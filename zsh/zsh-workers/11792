From zsh-workers-return-11792-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jun 07 07:37:07 2000
Return-Path: <zsh-workers-return-11792-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8852 invoked from network); 7 Jun 2000 07:37:05 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Jun 2000 07:37:05 -0000
Received: (qmail 25193 invoked by alias); 7 Jun 2000 07:36:51 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11792
Received: (qmail 25186 invoked from network); 7 Jun 2000 07:36:50 -0000
Date: Wed, 7 Jun 2000 09:36:44 +0200 (MET DST)
Message-Id: <200006070736.JAA12452@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: zparseopts


This adds the -K option to zparseopts as discussed. I.e. it makes it
keep the original values of the arrays if no corresponding options
were found.

The patch is mostly re-indentation.

Bye
 Sven

Index: Doc/Zsh/mod_zutil.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_zutil.yo,v
retrieving revision 1.8
diff -u -r1.8 mod_zutil.yo
--- Doc/Zsh/mod_zutil.yo	2000/05/23 15:00:38	1.8
+++ Doc/Zsh/mod_zutil.yo	2000/06/07 07:36:01
@@ -131,7 +131,7 @@
 This implements the internals of the `tt(_regex_arguments)'.
 )
 findex(zparseopts)
-item(tt(zparseopts) [ tt(-D) ] [ tt(-E) ] [ tt(-a) var(array) ] [ tt(-A) var(assoc) ] var(specs))(
+item(tt(zparseopts) [ tt(-D) ] [ tt(-K) ] [ tt(-E) ] [ tt(-a) var(array) ] [ tt(-A) var(assoc) ] var(specs))(
 This builtin simplifies the parsing of options in positional
 parameters, i.e. the set of arguments given by tt($*).  Each var(spec)
 describes one option and should be of the form
@@ -161,21 +161,40 @@
 parsing always stops at a positional parameter equal to `tt(-)' or
 `tt(-)tt(-)'.
 
-If the tt(-A) option is given, the options and their values will also
+The other
+
+startitem()
+item(tt(-a) var(array))(
+As described above, this specifies the default array to store the
+recognised options in.
+)
+item(tt(-A) var(assoc))(
+If this is given, the options and their values will also
 be put into an associative array with the option names as keys and the 
 arguments (if any) as the values.  Note that it is an error to give
 var(specs) without a `tt(=)var(array)' and not use either the tt(-a)
 or tt(-A) option.
-
-If the tt(-D) option is given, all options found are removed from the
+)
+item(tt(-D))(
+If this option is given, all options found are removed from the
 positional parameters, up to but not including any not described by the
 var(specs).  This means that any options processed by tt(zparseopts) are
 removed from the positional parameters.
-
-Since tt(-E) changes the parsing rules, it can be used to test for or
-(if used together with tt(-D)) extract options and their arguments,
-ignoring all other options and arguments that may be in the positional 
-parameters.
+)
+item(tt(-K))(
+With this option, the arrays specified with the tt(-a) and tt(-A)
+options and with the `tt(=)var(array)' forms will be left unchanged
+when none of the var(specs) for them is used.  This allows to assign
+default values to them before calling tt(zparseopts).
+)
+item(tt(-E))(
+This changes the parsing rules to em(not) stop at the first string
+that isn't described by one of the var(spec)s.  It can be used to test
+for or (if used together with tt(-D)) extract options and their
+arguments, ignoring all other options and arguments that may be in the
+positional parameters.
+)
+enditem()
 
 For example,
 
Index: Src/Modules/zutil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/zutil.c,v
retrieving revision 1.5
diff -u -r1.5 zutil.c
--- Src/Modules/zutil.c	2000/05/23 13:19:11	1.5
+++ Src/Modules/zutil.c	2000/06/07 07:36:01
@@ -1262,7 +1262,7 @@
 bin_zparseopts(char *nam, char **args, char *ops, int func)
 {
     char *o, *p, *n, **pp, **aval, **ap, *assoc = NULL, **cp, **np;
-    int del = 0, f, extract = 0;
+    int del = 0, f, extract = 0, keep = 0;
     Zoptdesc sopts[256], d;
     Zoptarr a, defarr = NULL;
     Zoptval v;
@@ -1298,6 +1298,14 @@
 		}
 		extract = 1;
 		break;
+	    case 'K':
+		if (o[2]) {
+		    args--;
+		    o = NULL;
+		    break;
+		}
+		keep = 1;
+		break;
 	    case 'a':
 		if (defarr) {
 		    zwarnnam(nam, "default array given more than once", NULL, 0);
@@ -1478,18 +1486,20 @@
 	    *cp++ = *pp++;
 
     for (a = opt_arrs; a; a = a->next) {
-	aval = (char **) zalloc((a->num + 1) * sizeof(char *));
-	for (ap = aval, v = a->vals; v; ap++, v = v->next) {
-	    if (v->str)
-		*ap = ztrdup(v->str);
-	    else {
-		*ap = ztrdup(v->name);
-		if (v->arg)
-		    *++ap = ztrdup(v->arg);
+	if (!keep || a->num) {
+	    aval = (char **) zalloc((a->num + 1) * sizeof(char *));
+	    for (ap = aval, v = a->vals; v; ap++, v = v->next) {
+		if (v->str)
+		    *ap = ztrdup(v->str);
+		else {
+		    *ap = ztrdup(v->name);
+		    if (v->arg)
+			*++ap = ztrdup(v->arg);
+		}
 	    }
+	    *ap = NULL;
+	    setaparam(a->name, aval);
 	}
-	*ap = NULL;
-	setaparam(a->name, aval);
     }
     if (assoc) {
 	int num;
@@ -1498,31 +1508,33 @@
 	    if (d->vals)
 		num++;
 
-	aval = (char **) zalloc(((num * 2) + 1) * sizeof(char *));
-	for (ap = aval, d = opt_descs; d; d = d->next) {
-	    if (d->vals) {
-		*ap++ = n = (char *) zalloc(strlen(d->name) + 2);
-		*n = '-';
-		strcpy(n + 1, d->name);
+	if (!keep || num) {
+	    aval = (char **) zalloc(((num * 2) + 1) * sizeof(char *));
+	    for (ap = aval, d = opt_descs; d; d = d->next) {
+		if (d->vals) {
+		    *ap++ = n = (char *) zalloc(strlen(d->name) + 2);
+		    *n = '-';
+		    strcpy(n + 1, d->name);
 
-		for (num = 1, v = d->vals; v; v = v->onext) {
-		    num += (v->arg ? strlen(v->arg) : 0);
-		    if (v->next)
-			num++;
-		}
-		*ap++ = n = (char *) zalloc(num);
-		for (v = d->vals; v; v = v->onext) {
-		    if (v->arg) {
-			strcpy(n, v->arg);
-			n += strlen(v->arg);
+		    for (num = 1, v = d->vals; v; v = v->onext) {
+			num += (v->arg ? strlen(v->arg) : 0);
+			if (v->next)
+			    num++;
+		    }
+		    *ap++ = n = (char *) zalloc(num);
+		    for (v = d->vals; v; v = v->onext) {
+			if (v->arg) {
+			    strcpy(n, v->arg);
+			    n += strlen(v->arg);
+			}
+			*n = ' ';
 		    }
-		    *n = ' ';
+		    *n = '\0';
 		}
-		*n = '\0';
 	    }
+	    *ap = NULL;
+	    sethparam(assoc, aval);
 	}
-	*ap = NULL;
-	sethparam(assoc, aval);
     }
     if (del) {
 	if (extract) {

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

