From zsh-workers-request@math.gatech.edu Fri May 08 06:18:15 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21365 invoked from network); 8 May 1998 06:18:12 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 8 May 1998 06:18:12 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id CAA10335;
	Fri, 8 May 1998 02:12:07 -0400 (EDT)
Resent-Date: Fri, 8 May 1998 02:12:07 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199805080611.BAA02528@hzoli.home>
Subject: PATCH: read builtin cleanup
To: zsh-workers@math.gatech.edu (Zsh hacking and development)
Date: Fri, 8 May 1998 01:10:58 -0500 (CDT)
X-Mailer: ELM [version 2.4ME+ PL31 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"yIaTn2.0.QX2.s8gKr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3949
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

This patch does some cleanup in the read builtin and adds proper handling
of backslashes which should escape whithespaces and backslashes.

Zoli


*** Src/builtin.c	1997/06/16 05:11:38	3.1.3.1
--- Src/builtin.c	1997/07/13 05:21:43	3.1.3.2
*************** int
*** 2718,2724 ****
  bin_read(char *name, char **args, char *ops, int func)
  {
      char *reply, *readpmpt;
!     int bsiz, c = 0, gotnl = 0, al = 0, first, nchars = 1;
      int haso = 0;	/* true if /dev/tty has been opened specially */
      int isem = !strcmp(term, "emacs");
      char *buf, *bptr, *firstarg, *zbuforig;
--- 2718,2724 ----
  bin_read(char *name, char **args, char *ops, int func)
  {
      char *reply, *readpmpt;
!     int bsiz, c = 0, gotnl = 0, al = 0, first, nchars = 1, bslash;
      int haso = 0;	/* true if /dev/tty has been opened specially */
      int isem = !strcmp(term, "emacs");
      char *buf, *bptr, *firstarg, *zbuforig;
*************** bin_read(char *name, char **args, char *
*** 2767,2793 ****
      } else if (ops['u'] && !ops['p']) {
  	/* -u means take input from the specified file descriptor. *
  	 * -up means take input from the coprocess.                */
! 	for (readfd = 0; readfd < 10; ++readfd)
! 	    if (ops[readfd + '0'])
! 		break;
! 	if (readfd == 10)
! 	    readfd = 0;
      } else if (ops['p'])
  	readfd = coprocin;
!     else {
! 	/* last resort: take input from plain old stdin */
! 	attachtty((jobtab[thisjob].gleader) ? jobtab[thisjob].gleader : mypgrp);
  	readfd = 0;
! #if 0
! 	  else if (isset(SHINSTDIN) && unset(INTERACTIVE)) {
! 	    /* use stdout or stderr, if either is a tty */
! 	    if (isatty(1))
! 		readfd = 1;
! 	    else if (isatty(2))
! 		readfd = 2;
! 	}
! #endif
!     }
      /* handle prompt */
      if (firstarg) {
  	for (readpmpt = firstarg;
--- 2767,2778 ----
      } else if (ops['u'] && !ops['p']) {
  	/* -u means take input from the specified file descriptor. *
  	 * -up means take input from the coprocess.                */
! 	for (readfd = 9; readfd && !ops[readfd + '0']; --readfd);
      } else if (ops['p'])
  	readfd = coprocin;
!     else
  	readfd = 0;
! 
      /* handle prompt */
      if (firstarg) {
  	for (readpmpt = firstarg;
*************** bin_read(char *name, char **args, char *
*** 2874,2895 ****
      zbuforig = zbuf = (!ops['z']) ? NULL :
  	(nonempty(bufstack)) ? (char *) getlinknode(bufstack) : ztrdup("");
      first = 1;
      while (*args || (ops['A'] && !gotnl)) {
  	buf = bptr = (char *)zalloc(bsiz = 64);
  	/* get input, a character at a time */
! 	for (;;) {
! 	    if (gotnl)
! 		break;
  	    c = zread();
  	    /* \ at the end of a line indicates a continuation *
  	     * line, except in raw mode (-r option)            */
! 	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
! 		bptr--;
  		continue;
  	    }
  	    if (c == EOF || c == '\n')
  		break;
! 	    if (isep(c)) {
  		if (bptr != buf || (!iwsep(c) && first)) {
  		    first |= !iwsep(c);
  		    break;
--- 2859,2879 ----
      zbuforig = zbuf = (!ops['z']) ? NULL :
  	(nonempty(bufstack)) ? (char *) getlinknode(bufstack) : ztrdup("");
      first = 1;
+     bslash = 0;
      while (*args || (ops['A'] && !gotnl)) {
  	buf = bptr = (char *)zalloc(bsiz = 64);
  	/* get input, a character at a time */
! 	while (!gotnl) {
  	    c = zread();
  	    /* \ at the end of a line indicates a continuation *
  	     * line, except in raw mode (-r option)            */
! 	    if (bslash && c == '\n') {
! 		bslash = 0;
  		continue;
  	    }
  	    if (c == EOF || c == '\n')
  		break;
! 	    if (!bslash && isep(c)) {
  		if (bptr != buf || (!iwsep(c) && first)) {
  		    first |= !iwsep(c);
  		    break;
*************** bin_read(char *name, char **args, char *
*** 2897,2902 ****
--- 2881,2889 ----
  		first |= !iwsep(c);
  		continue;
  	    }
+ 	    bslash = c == '\\' && !bslash && !ops['r'];
+ 	    if (bslash)
+ 		continue;
  	    first = 0;
  	    if (imeta(c)) {
  		*bptr++ = Meta;
*************** bin_read(char *name, char **args, char *
*** 2964,2987 ****
      }
      buf = bptr = (char *)zalloc(bsiz = 64);
      /* any remaining part of the line goes into one parameter */
      if (!gotnl)
  	for (;;) {
  	    c = zread();
  	    /* \ at the end of a line introduces a continuation line, except in
  	    raw mode (-r option) */
! 	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
! 		bptr--;
  		continue;
  	    }
  	    if (c == EOF || (c == '\n' && !zbuf))
  		break;
! 	    if (isep(c) && bptr == buf)
  		if (iwsep(c))
  		    continue;
  		else if (!first) {
  		    first = 1;
  		    continue;
  		}
  	    if (imeta(c)) {
  		*bptr++ = Meta;
  		*bptr++ = c ^ 32;
--- 2951,2978 ----
      }
      buf = bptr = (char *)zalloc(bsiz = 64);
      /* any remaining part of the line goes into one parameter */
+     bslash = 0;
      if (!gotnl)
  	for (;;) {
  	    c = zread();
  	    /* \ at the end of a line introduces a continuation line, except in
  	    raw mode (-r option) */
! 	    if (bslash && c == '\n') {
! 		bslash = 0;
  		continue;
  	    }
  	    if (c == EOF || (c == '\n' && !zbuf))
  		break;
! 	    if (!bslash && isep(c) && bptr == buf)
  		if (iwsep(c))
  		    continue;
  		else if (!first) {
  		    first = 1;
  		    continue;
  		}
+ 	    bslash = c == '\\' && !bslash && !ops['r'];
+ 	    if (bslash)
+ 		continue;
  	    if (imeta(c)) {
  		*bptr++ = Meta;
  		*bptr++ = c ^ 32;

