From zsh-workers-request@math.gatech.edu  Sun Jul 16 08:54:40 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.mira.net.au (8.6.12/8.6.9) with SMTP id IAA22974 for <mason@werple.mira.net.au>; Sun, 16 Jul 1995 08:54:36 +1000
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA13708
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Sat, 15 Jul 1995 18:54:32 -0400
Received: by math (5.x/SMI-SVR4)
	id AA22899; Sat, 15 Jul 1995 18:50:49 -0400
Resent-Date: Sat, 15 Jul 1995 23:51:50 +0100 (BST)
Old-Return-Path: <zefram@dcs.warwick.ac.uk>
From: Zefram <A.Main@dcs.warwick.ac.uk>
Message-Id: <25122.199507152251@stone.dcs.warwick.ac.uk>
Subject: print option fixes
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Sat, 15 Jul 1995 23:51:50 +0100 (BST)
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]5984.76
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"iCC0d1.0.fb5.8P42m"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/214
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

The patch below makes several combinations of print options work
together.  For example, previously -P was overridden by -c, even though
the two do not conflict.  Similarly -D.  It also fixes a bug that
stopped the -N option from working.

 -zefram

      *** Src/builtin.c.old	Sat Jul 15 22:39:24 1995
      --- Src/builtin.c	Sat Jul 15 23:42:22 1995
      ***************
      *** 4415,4424 ****
        int
        bin_print(char *name, char **args, char *ops, int func)
        {
      !     int nnl = 0, fd;
            Histent ent;
            FILE *fout = stdout;
        
            /* -z option -- push the arguments onto the editing buffer stack */
            if (ops['z']) {
        	permalloc();
      --- 4415,4454 ----
        int
        bin_print(char *name, char **args, char *ops, int func)
        {
      !     int nnl = 0, fd, argc = arrlen(args), n;
      !     int *len = (int *)alloc(argc * sizeof(int));
            Histent ent;
            FILE *fout = stdout;
        
      +     /* compute lengths, and interpret according to -P, -D, -e, etc. */
      +     for(n = 0; n < argc; n++) {
      + 	/* first \ sequences */
      + 	if (!ops['e'] && (ops['R'] || ops['r'] || ops['E']))
      +             len[n] = strlen(args[n]);
      +         else
      + 	    args[n] = getkeystring(args[n], &len[n],
      + 				    func != BIN_ECHO && !ops['e'], &nnl);
      + 	/* -P option -- interpret as a prompt sequence */
      + 	if(ops['P']) {
      + 	    char *arg = putprompt(args[n], &len[n], NULL, 0);
      + 	    args[n] = (char *)alloc(len[n] + 1);
      + 	    memcpy(args[n], arg, len[n]);
      + 	    args[n][len[n]] = 0;
      + 	    free(arg);
      + 	}
      + 	/* -D option -- interpret as a directory, and use ~ */
      + 	if(ops['D']) {
      + 	    int dn = finddir(args[n]);
      + 	    if(dn != -1) {
      + 		char *arg = alloc(strlen(args[n]) + 1);
      + 		sprintf(arg, "~%s%s", namdirs[dn].name,
      + 			args[n] + namdirs[dn].len);
      + 		args[n] = arg;
      + 		len[n] = strlen(args[n]);
      + 	    }
      + 	}
      +     }
      + 
            /* -z option -- push the arguments onto the editing buffer stack */
            if (ops['z']) {
        	permalloc();
      ***************
      *** 4439,4446 ****
        	heapalloc();
        	return 0;
            }
      -     if (ops['R'])
      - 	ops['r'] = 1;	/* -R implies -r */
            /* -u and -p -- output to other than standard output */
            if (ops['u'] || ops['p']) {
        	if (ops['u']) {
      --- 4469,4474 ----
      ***************
      *** 4460,4465 ****
      --- 4488,4494 ----
        	    return 1;
        	}
            }
      + 
            /* -o and -O -- sort the arguments */
            if (ops['o']) {
        	if (ops['i'])
      ***************
      *** 4474,4479 ****
      --- 4503,4513 ----
        	else
        	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
            }
      +     /* after sorting arguments, recalculate lengths */
      +     if(ops['o'] || ops['O'])
      + 	for(n = 0; n < argc; n++)
      + 	    len[n] = strlen(args[n]);
      + 
            /* -c -- output in columns */
            if (ops['c']) {
        	int l, nc, nr, sc, n, t, i;
      ***************
      *** 4506,4531 ****
        	return 0;
            }
            /* normal output */
      !     for (; *args; args++) {
      ! 	char *arg = *args;
      ! 	int len;
      ! 
      ! 	if (!ops['e'] && (ops['r'] || ops['E']))
      !             len = strlen(arg);
      !         else
      ! 	    arg = getkeystring(arg, &len, func != BIN_ECHO && !ops['e'], &nnl);
      ! 	if (ops['D'])
      ! 	    fprintdir(arg, fout);
      ! 	else {
      ! 	    if (ops['P'])
      ! 		arg = putprompt(arg, &len, NULL, 0);
      ! 	    fwrite(arg, len, 1, fout);
      ! 	    if(ops['P'])
      ! 		free(arg);
      ! 	}
      ! 
        	if (args[1])
      ! 	    fputc(ops['l'] ? '\n' : ops['0'] ? '\0' : ' ', fout);
            }
            if (!(ops['n'] || nnl))
        	fputc(ops['N'] ? '\0' : '\n', fout);
      --- 4540,4549 ----
        	return 0;
            }
            /* normal output */
      !     for (; *args; args++, len++) {
      ! 	fwrite(*args, *len, 1, fout);
        	if (args[1])
      ! 	    fputc(ops['l'] ? '\n' : ops['N'] ? '\0' : ' ', fout);
            }
            if (!(ops['n'] || nnl))
        	fputc(ops['N'] ? '\0' : '\n', fout);

-----BEGIN PGP SIGNATURE-----
Version: 2.6.i

iQBVAgUBMAhGImWJ8JfKi+e9AQHenQH/X/4e0QbuLIYZ/ASInsyzci+JA+qPlb7V
0rmv/fo0DWgpD+0NpNAeEIgt6HqGy71BDsgZcATQ6OmSAi4VSqKAxQ==
=fno6
-----END PGP SIGNATURE-----

