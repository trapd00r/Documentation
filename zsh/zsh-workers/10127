From zsh-workers-return-10127-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Mar 14 09:38:41 2000
Return-Path: <zsh-workers-return-10127-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2576 invoked from network); 14 Mar 2000 09:38:40 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Mar 2000 09:38:40 -0000
Received: (qmail 11513 invoked by alias); 14 Mar 2000 09:38:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10127
Received: (qmail 11495 invoked from network); 14 Mar 2000 09:38:31 -0000
Date: Tue, 14 Mar 2000 10:38:26 +0100 (MET)
Message-Id: <200003140938.KAA05831@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Fri, 10 Mar 2000 16:47:07 +0000
Subject: Re: Saving the zle display stuff


Oliver Kiddle wrote:

> Sven Wischnowsky wrote:
> > 
> > It would be relatively easy to make it remember how long the list
> > below the prompt is (it should already know about the presence of a
> > list -- at least in most cases).
> > So, are you suggesting a zle-option to make it put the prompt `below
> > the list if there is one'?
> 
> Yes: a zle-widget that puts the prompt below the list if there is one.
> That allows me to keep the current list for later reference if I decide
> that I want to.

I wonder why I never tried to write this before... having wanted that
sometimes, too.


So, this adds the `end-of-list' widget. If the shell knows that there
is a list displayed below the prompt, it puts the prompt below the
list. The name `end-of-list' is modelled after some of the movement
commands, obviously, although this isn't really a movement command, is 
it ok for everyone?

I hope the way how it tries to find out if there is still a list is
correct, please tell me if you find a case where end-of-list has no
effect even though there is still a list or where it moves the prompt
down even though there isn't a list.

There is one case I know about: if you use `zle -R' to display both a
status line and a list and then call `zle end-of-list' directly after
it, the prompt is moved below the list, but where once was the status
line is now an empty line. We would have to save the statusline
displayed with -R, make it be reset whenever needed and make it be
re-used in end-of-list. This didn't seem worth it.


The patch also contains the docs for $MARK, which I had plainly
forgotten, sorry.

Bye
 Sven

diff -ru ../z.old/Doc/Zsh/zle.yo Doc/Zsh/zle.yo
--- ../z.old/Doc/Zsh/zle.yo	Mon Mar 13 17:49:48 2000
+++ Doc/Zsh/zle.yo	Tue Mar 14 09:15:29 2000
@@ -129,6 +129,10 @@
 Attempts to move the cursor outside the buffer will result in the
 cursor being moved to the appropriate end of the buffer.
 )
+vindex(MARK)
+item(tt(MARK) (integer))(
+Like tt(CURSOR), but for the mark.
+)
 vindex(LBUFFER)
 item(tt(LBUFFER) (scalar))(
 The part of the buffer that lies to the left of the cursor position.
@@ -937,6 +941,11 @@
 Perform menu completion, like tt(menu-complete), except that if
 a menu completion is already in progress, move to the em(previous)
 completion rather than the next.
+)
+tindex(end-of-list)
+item(tt(end-of-list))(
+When a previous completion displayed a list below the prompt, this
+widget can be used to move the prompt below the list.
 )
 enditem()
 texinode(Miscellaneous)()(Completion)(Zsh Line Editor)
diff -ru ../z.old/Src/Zle/compresult.c Src/Zle/compresult.c
--- ../z.old/Src/Zle/compresult.c	Tue Mar 14 09:12:32 2000
+++ Src/Zle/compresult.c	Tue Mar 14 09:15:29 2000
@@ -1528,6 +1528,7 @@
     showinglist = listshown = 0;
 
     clearflag = (isset(USEZLE) && !termflags && dolastprompt);
+    lastlistlen = 0;
 
     /* Maybe we have to ask if the user wants to see the list. */
     if ((!minfo.cur || !minfo.asked) &&
@@ -1756,16 +1757,20 @@
 	    pnl = 1;
 	g = g->next;
     }
+    lastlistlen = 0;
     if (clearflag) {
 	/* Move the cursor up to the prompt, if always_last_prompt *
 	 * is set and all that...                                  */
 	if ((ml = listdat.nlines + nlnct - 1) < lines) {
 	    tcmultout(TCUP, TCMULTUP, ml);
 	    showinglist = -1;
+
+	    lastlistlen = listdat.nlines;
 	} else
 	    clearflag = 0, putc('\n', shout);
     } else
 	putc('\n', shout);
+
     listshown = (clearflag ? 1 : -1);
 
     return printed;
diff -ru ../z.old/Src/Zle/iwidgets.list Src/Zle/iwidgets.list
--- ../z.old/Src/Zle/iwidgets.list	Tue Mar 14 10:37:16 2000
+++ Src/Zle/iwidgets.list	Tue Mar 14 10:37:21 2000
@@ -44,6 +44,7 @@
 "end-of-history", endofhistory, 0
 "end-of-line", endofline, 0
 "end-of-line-hist", endoflinehist, 0
+"end-of-list", endoflist, ZLE_MENUCMP | ZLE_KEEPSUFFIX | ZLE_LASTCOL
 "exchange-point-and-mark", exchangepointandmark, 0
 "execute-last-named-cmd", NULL, 0
 "execute-named-cmd", NULL, 0
diff -ru ../z.old/Src/Zle/zle_main.c Src/Zle/zle_main.c
--- ../z.old/Src/Zle/zle_main.c	Tue Mar 14 09:12:33 2000
+++ Src/Zle/zle_main.c	Tue Mar 14 09:15:30 2000
@@ -593,7 +593,7 @@
     trashzle();
     free(lpromptbuf);
     free(rpromptbuf);
-    zleactive = zlereadflags = 0;
+    zleactive = zlereadflags = lastlistlen = 0;
     alarm(0);
 
     freeundo();
diff -ru ../z.old/Src/Zle/zle_misc.c Src/Zle/zle_misc.c
--- ../z.old/Src/Zle/zle_misc.c	Tue Mar 14 09:12:33 2000
+++ Src/Zle/zle_misc.c	Tue Mar 14 09:15:30 2000
@@ -641,7 +641,7 @@
 {
     Thingy cmd;
     int len, l = strlen(prmt), feep = 0, listed = 0, curlist = 0;
-    int ols = (listshown && validlist);
+    int ols = (listshown && validlist), olll = lastlistlen;
     char *ptr;
     char *okeymap = curkeymapname;
 
@@ -659,9 +659,10 @@
 	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
 	    statusline = NULL;
 	    selectkeymap(okeymap, 1);
-	    if ((listshown = ols))
+	    if ((listshown = ols)) {
 		showinglist = -2;
-	    else if (listed)
+		lastlistlen = olll;
+	    } else if (listed)
 		clearlist = listshown = 1;
 
 	    return NULL;
@@ -725,9 +726,10 @@
 		    unrefthingy(r);
 		    statusline = NULL;
 		    selectkeymap(okeymap, 1);
-		    if ((listshown = ols))
+		    if ((listshown = ols)) {
 			showinglist = -2;
-		    else if (listed)
+			lastlistlen = olll;
+		    } else if (listed)
 			clearlist = listshown = 1;
 		    return r;
 		}
diff -ru ../z.old/Src/Zle/zle_refresh.c Src/Zle/zle_refresh.c
--- ../z.old/Src/Zle/zle_refresh.c	Tue Mar 14 09:12:33 2000
+++ Src/Zle/zle_refresh.c	Tue Mar 14 09:15:30 2000
@@ -59,6 +59,11 @@
 /**/
 mod_export int listshown;
 
+/* Length of last list displayed (if it is below the prompt). */
+
+/**/
+mod_export int lastlistlen;
+
 /* Non-zero if ALWAYS_LAST_PROMPT has been used, meaning that the *
  * screen below the buffer display should not be cleared by       *
  * zrefresh(), but should be by trashzle().                       */
@@ -282,7 +287,7 @@
 	    clearflag = 0;
 	    resetneeded = 1;
 	}
-	listshown = 0;
+	listshown = lastlistlen = 0;
 	if (showinglist != -2)
 	    showinglist = 0;
     }
diff -ru ../z.old/Src/Zle/zle_thingy.c Src/Zle/zle_thingy.c
--- ../z.old/Src/Zle/zle_thingy.c	Tue Mar 14 09:12:33 2000
+++ Src/Zle/zle_thingy.c	Tue Mar 14 10:32:29 2000
@@ -416,12 +416,18 @@
 
 	    zmult = 1;
 	    listlist(l);
+	    if (statusline)
+		lastlistlen++;
 	    showinglist = clearlist = 0;
 	    zmult = zmultsav;
-	} else if (ops['c'])
+	} else if (ops['c']) {
 	    clearlist = 1;
-    } else if (ops['c'])
+	    lastlistlen = 0;
+	}
+    } else if (ops['c']) {
 	clearlist = listshown = 1;
+	lastlistlen = 0;
+    }
     zrefresh();
 
     clearlist = ocl;
diff -ru ../z.old/Src/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- ../z.old/Src/Zle/zle_tricky.c	Tue Mar 14 09:12:34 2000
+++ Src/Zle/zle_tricky.c	Tue Mar 14 10:30:08 2000
@@ -2009,6 +2009,8 @@
 	    putc('\n', shout);
 	settyinfo(&shttyinfo);
     }
+    lastlistlen = (clearflag ? nlines : 0);
+
     if (ncols) {
 	if (isset(LISTROWSFIRST)) {
 	    for (col = 1, p = data, lenp = lens; *p;
@@ -2252,4 +2254,27 @@
     ret = expandorcomplete(args);
     comppref = 0;
     return ret;
+}
+
+/**/
+int
+endoflist(char **args)
+{
+    if (lastlistlen > 0) {
+	int i;
+
+	clearflag = 0;
+	trashzle();
+
+	for (i = lastlistlen; i > 0; i--)
+	    putc('\n', shout);
+
+	showinglist = lastlistlen = 0;
+
+	if (sfcontext)
+	    zrefresh();
+
+	return 0;
+    }
+    return 1;
 }

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

