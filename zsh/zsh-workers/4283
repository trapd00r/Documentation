From zsh-workers-request@math.gatech.edu Fri Aug 07 07:43:31 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28042 invoked from network); 7 Aug 1998 07:43:28 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 7 Aug 1998 07:43:28 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id DAA01750;
	Fri, 7 Aug 1998 03:17:45 -0400 (EDT)
Resent-Date: Fri, 7 Aug 1998 03:17:45 -0400 (EDT)
Date: Fri, 7 Aug 1998 09:19:49 +0200 (MET DST)
Message-Id: <199808070719.JAA19408@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
In-reply-to: "Bart Schaefer"'s message of Thu, 6 Aug 1998 10:50:04 -0700
Subject: Re: ideas: free-search-complete, noexpand
Resent-Message-ID: <"n7D96.0.HR.Oegor"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4283
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Bart Schaefer wrote:

> 
> On Aug 6, 10:03am, Sven Wischnowsky wrote:
> } Subject: Re: ideas: free-search-complete, noexpand
> }
> } Bart Schaefer wrote:
> } 
> } > As a general remark, I find myself frowning over a number of the option
> } > choices, particularly "-t+ +", but in most cases I eventually (sometimes
> } > many paragraphs of your message later) figure out why you did things, so
> } > I don't immediately have any alternatives to suggest.
> } 
> } Again, I wholeheartedly agree. I would prefer to put things into
> } separation sequences: one like `+' but meaning inclusive-or, one like
> } `-' but meaning `continue to test patterns' and so on. This would make 
> } parsing more complicated and I just didn't find enough good sequences
> } 
> } So, hesitantly, I used only one option for all of them (but at least
> } that gave me the possibility to use characters that should be easy to
> } remember).
> 
> That's not quite what I meant.  For example, it's not clear that in
> 
> 	compctl -k '(foo bar)' -t+ + -k foobar + -f
> 
> that the + immediately after the -t+ is an "or" but the next + is an
> "xor".  That is, the "scope" of -t isn't obvious.  If I wrote
> 
> 	compctl -t+ -k '(foo bar)' + -k foobar + -f
> 
> then it would (I think) mean the same thing, but now it -looks- as if
> it means something different.  In this case, I think any mnemonic value
> in using + to follow -t is outweighed by the (human) parsing confusion.
> 
> My problem with the -J/-V options is that they look just like all the
> options that can be freely reordered, but they're order-dependent.  The
> best thing about + (and the use of - within extended completion) is
> that they don't resemble any of the simple flags etc.  I'd almost rather
> have seen \( ... \) for sorted groups and \{ ... \} for unsorted, or
> something like that.
> 

That was what I meant by `sequences'. For some of the `continue
with...' things this is easy. For the grouping stuff this is rather
complicated, because they are independent of things like xor'ed
completion, extended completion and even different compctls used.

> (Which brings me back to the long-ago complaint that completion is really
> too complex to be a command, and ought instead to be its own language or
> function-body-like control structure.)
> 

Yes, I was beginning to wish for something like that, too, when I
implemented the or'ing-stuff.

Maybe we should think about developing an easy to read syntax for
completion control. Then we could use a shell function or module to
parse that into compctls, or we could change the shell and provide a
shell function or module to parse the current compctl syntax.

> } > 	compctl -x 'r[-e,;]' -l '' -- xterm
> } > 
> } > What's really meant there is not really "a word beginning with ';'" but
> } > rather "the end of this command" which may be signified by any of ; & |
> } > ;; && || or }.  I suspect this idiom arose from the "find" example in the
> } > man page, where it -does- mean "a word beginning with ';'", and it just
> } > happens to work for most cases.
> } 
> } The `r[-e,;]' matches a quoted `;', not the command separator.  In
> } fact there is no way to match the command separator, since the
> } completion code uses only the words of the current command.
> 
> Er, yes, if I'd thought about it a bit longer, I did know that.  What I
> was trying to get at was not the need to match the command separator, but
> the need to have something that doesn't match -anything-, so as to force
> the range to extend to the end of the argument list.  Using ';' works
> only because it's very rare to pass a quoted ';' as an argument, but it
> is really just a workaround for a missing concept and is meaningless to
> anyone who doesn't know the idiom.
> 

That is relatively simple. We can make the comma and the second string 
optional, meaning: check only if we are after a word with the first
string.

The patch below does that (and looks larger than it is).

Bye
 Sven

diff -c Src/Zle/compctl.c ../Src/Zle/compctl.c
*** Src/Zle/compctl.c	Fri Aug  7 08:55:57 1998
--- ../Src/Zle/compctl.c	Fri Aug  7 08:58:43 1998
***************
*** 647,673 ****
  		    c->u.s.s[l] = ztrdup(tt);
  		} else if (c->type == CCT_RANGESTR ||
  			   c->type == CCT_RANGEPAT) {
  		    /* -r[..,..] or -R[..,..]:  two strings expected */
! 		    for (; *t && *t != '\201'; t++);
  		    if (!*t) {
  			zwarnnam(name, "error in condition", NULL, 0);
  			freecompcond(m);
  			return 1;
  		    }
  		    *t = '\0';
  		    c->u.l.a[l] = ztrdup(tt);
! 		    tt = ++t;
! 		    /* any more commas are text, not active */
! 		    for (; *t && *t != '\200'; t++)
! 			if (*t == '\201')
! 			    *t = ',';
! 		    if (!*t) {
! 			zwarnnam(name, "error in condition", NULL, 0);
! 			freecompcond(m);
! 			return 1;
  		    }
! 		    *t = '\0';
! 		    c->u.l.b[l] = ztrdup(tt);
  		} else {
  		    /* remaining patterns are number followed by string */
  		    for (; *t && *t != '\200' && *t != '\201'; t++);
--- 647,680 ----
  		    c->u.s.s[l] = ztrdup(tt);
  		} else if (c->type == CCT_RANGESTR ||
  			   c->type == CCT_RANGEPAT) {
+ 		    int hc;
+ 
  		    /* -r[..,..] or -R[..,..]:  two strings expected */
! 		    for (; *t && *t != '\201' && *t != '\200'; t++);
  		    if (!*t) {
  			zwarnnam(name, "error in condition", NULL, 0);
  			freecompcond(m);
  			return 1;
  		    }
+ 		    hc = (*t == '\201');
  		    *t = '\0';
  		    c->u.l.a[l] = ztrdup(tt);
! 		    if (hc) {
! 			tt = ++t;
! 			/* any more commas are text, not active */
! 			for (; *t && *t != '\200'; t++)
! 			    if (*t == '\201')
! 				*t = ',';
! 			if (!*t) {
! 			    zwarnnam(name, "error in condition", NULL, 0);
! 			    freecompcond(m);
! 			    return 1;
! 			}
! 			*t = '\0';
! 			c->u.l.b[l] = ztrdup(tt);
  		    }
! 		    else
! 			c->u.l.b[l] = NULL;
  		} else {
  		    /* remaining patterns are number followed by string */
  		    for (; *t && *t != '\200' && *t != '\201'; t++);
diff -c Src/Zle/zle_tricky.c ../Src/Zle/zle_tricky.c
*** Src/Zle/zle_tricky.c	Fri Aug  7 08:55:58 1998
--- ../Src/Zle/zle_tricky.c	Fri Aug  7 08:58:41 1998
***************
*** 2409,2415 ****
  			    }
  			    zsfree(s);
  			}
! 			if (t) {
  			    if (cc->type == CCT_RANGEPAT)
  				tokenize(sc = dupstring(cc->u.l.b[i]));
  			    for (j++; j < clwnum; j++) {
--- 2409,2415 ----
  			    }
  			    zsfree(s);
  			}
! 			if (t && cc->u.l.b[i]) {
  			    if (cc->type == CCT_RANGEPAT)
  				tokenize(sc = dupstring(cc->u.l.b[i]));
  			    for (j++; j < clwnum; j++) {
diff -c Doc/Zsh/compctl.yo ../Doc/Zsh/compctl.yo
*** Doc/Zsh/compctl.yo	Thu Aug  6 15:51:28 1998
--- ../Doc/Zsh/compctl.yo	Fri Aug  7 09:03:04 1998
***************
*** 534,540 ****
  item(tt(r[)var(str1)tt(,)var(str2)tt(])...)(
  Matches if the cursor is after a word with prefix var(str1).  If there
  is also a word with prefix var(str2) on the command line it matches
! only if the cursor is before this word.
  )
  item(tt(R[)var(str1)tt(,)var(str2)tt(])...)(
  Like tt(r) but using pattern matching instead.
--- 534,541 ----
  item(tt(r[)var(str1)tt(,)var(str2)tt(])...)(
  Matches if the cursor is after a word with prefix var(str1).  If there
  is also a word with prefix var(str2) on the command line it matches
! only if the cursor is before this word. If the comma and var(str2) are
! omitted, it matches if the cursor is after a word with prefix var(str1).
  )
  item(tt(R[)var(str1)tt(,)var(str2)tt(])...)(
  Like tt(r) but using pattern matching instead.


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

