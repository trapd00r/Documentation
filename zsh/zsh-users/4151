From zsh-users-return-4151-mason-zsh=primenet.com.au@sunsite.dk Mon Aug 20 18:27:28 2001
Return-Path: <zsh-users-return-4151-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14636 invoked from network); 20 Aug 2001 18:27:27 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Aug 2001 18:27:27 -0000
Received: (qmail 1135 invoked by alias); 20 Aug 2001 18:27:05 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4151
Received: (qmail 1122 invoked from network); 20 Aug 2001 18:27:03 -0000
From: Bart Schaefer <schaefer@brasslantern.com>
Message-Id: <1010820182638.ZM20357@candle.brasslantern.com>
Date: Mon, 20 Aug 2001 18:26:38 +0000
In-Reply-To: <20010815230024.3E7F614284@pwstephenson.fsnet.co.uk>
Comments: In reply to Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
        "Zsh Guide chapter 5 (substitutions)" (Aug 16, 12:00am)
References: <20010815230024.3E7F614284@pwstephenson.fsnet.co.uk>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Peter Stephenson <pws@pwstephenson.fsnet.co.uk>, zsh-users@sunsite.dk
Subject: Re: Zsh Guide chapter 5 (substitutions)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

In this example:

   % fn() { print "Twice ${1:-0} is $(( 2 * ${1:-0} ))"; }
   % fn
   Twice 0 is 0

It'd be even more exemplary to write:

     fn() { print "Twice ${1:=0} is $(( 2 * $1 ))"; }

Moving on:

 the `^' character turns on the option just for that expansion, as `='
 does with SH_WORD_SPLIT (can't think of a good mnemonic, sorry).

Think of proofreaders' marks, where a carat means to insert a new word in
between two other words.

 In addition to `*' and `?', which are so basic that even DOS had them
 (though I never quite worked out exactly what it was doing with them a
 lot of the time)

I'm going to guess that you really don't want to know.

 ... anywhere where history substitution doesn't get it's hands
 on the `!' first.                                   ^^^^

Apostrophe abuse!

 Note one point mentioned in the FAQ --- probably indicating the reason
 that `^' is only available with EXTENDED_GLOB switched on.  Some
 commands use an initial `^' to indicate a control character

In fact, there's another reason:  Some keyboards used not to have a `|'
character, so many older versions of the Bourne shell interpret `^' as
`|', that is, `echo foo^grep f' would run grep and output `foo'.

 Slightly less obviously, the `**/*' matches files in the current
 directory, while the `*/CVS' never matches a `CVS' in the current
 directory, so that could appear. If you want to, you can fix that up
 like this:

    print **/*~(*/|)CVS(/*|)(/)

Easier is

    print ./**/*~*/CVS(/)

but I suppose that doesn't show that slashes can appear in parens on
the right side of the tilde.

 A `~' at the beginning is never treated as excluding what follows; as
 you already know, it has other uses.

Might be worth pointing out here or elsewhere that (#i)~/foo does NOT
mean ~(#i)/foo, but rather means (#i)(|)~/foo, that is, the presence of
(#i) means that `~' is no longer at the start of the pattern.  Or maybe
that's a bug?

In the table of ksh glob equivalences quoted from the FAQ, you've included
the footnote reference [1] but not the footnote itself.

 ... since no-one would right two *'s in a row for any other reason.

They might, however, write two wrongs.

There are a couple of minor typos in the first few paragraphs about glob
qualifiers: "usual" for "usually" and "t((%b))" for "((%b))".  Also,
"whackier" -- on this side of the pond we spell it without the "h", but
maybe this is a "colour programme" sort of thing.

Gotta stop now, back later for sections 5.9.7 and later.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

