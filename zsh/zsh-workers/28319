From zsh-workers-return-28319-mason-zsh=primenet.com.au@zsh.org Tue Oct 05 21:40:59 2010
Return-Path: <zsh-workers-return-28319-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4306 invoked by alias); 5 Oct 2010 21:40:59 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28319
Received: (qmail 18537 invoked from network); 5 Oct 2010 21:40:53 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at ntlworld.com designates 81.103.221.56 as permitted sender)
Date: Tue, 5 Oct 2010 22:11:39 +0100
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: Zsh Hackers' List <zsh-workers@zsh.org>
Subject: PATCH: fix some (z) splitting oddities
Message-ID: <20101005221139.6aa1e472@pws-pc>
X-Mailer: Claws Mail 3.7.6 (GTK+ 2.20.1; x86_64-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-Cloudmark-Analysis: v=1.1 cv=4QByPj+6Iq2k/6L54d+eVKTdgQxdscpRskJJReCfdXo= c=1 sm=0 a=QEuicpHXzuIA:10 a=4YI7mmuYAqcA:10 a=kj9zAlcOel0A:10 a=NLZqzBF-AAAA:8 a=wKwfD6OWTEdnhWJEUTkA:9 a=Lz72OnjfpAQa6-mBL_AA:7 a=VtXxPKTPfAzwYdrGjzoDApiLhiQA:4 a=CjuIK1q_8ugA:10 a=_dQi-Dcv4p4A:10 a=GooGpLhqkFOw9EpQ:21 a=OVgd_B9r1DpXhovl:21 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117

No question of these being special syntactic markers, they were just
plain wrong and inconsistent; see the new test for the cases I fixed.

I've take the easy way out when fixing them on the basis that the results
are at least consistent if not necessarily ideal.

Index: Src/hist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/hist.c,v
retrieving revision 1.101
diff -p -u -r1.101 hist.c
--- Src/hist.c	2 Oct 2010 21:03:04 -0000	1.101
+++ Src/hist.c	5 Oct 2010 21:04:59 -0000
@@ -2869,6 +2869,7 @@ bufferwords(LinkList list, char *buf, in
     int num = 0, cur = -1, got = 0, ne = noerrs;
     int owb = wb, owe = we, oadx = addedx, ozp = zleparse, onc = nocomments;
     int ona = noaliases, ocs = zlemetacs, oll = zlemetall;
+    int forloop = 0;
     char *p, *addedspaceptr;
 
     if (!list)
@@ -2942,25 +2943,84 @@ bufferwords(LinkList list, char *buf, in
 	ctxtlex();
 	if (tok == ENDINPUT || tok == LEXERR)
 	    break;
-	if (tokstr && *tokstr) {
-	    untokenize((p = dupstring(tokstr)));
-	    if (ingetptr() == addedspaceptr + 1) {
-		/*
-		 * Whoops, we've read past the space we added, probably
-		 * because we were expecting a terminator but when
-		 * it didn't turn up we shrugged our shoulders thinking
-		 * it might as well be a complete string anyway.
-		 * So remove the space.  C.f. below for the case
-		 * where the missing terminator caused a lex error.
-		 * We use the same paranoid test.
-		 */
-		int plen = strlen(p);
-		if (plen && p[plen-1] == ' ' &&
-		    (plen == 1 || p[plen-2] != Meta))
-		    p[plen-1] = '\0';
+	if (tok == FOR) {
+	    /*
+	     * The way for (( expr1 ; expr2; expr3 )) is parsed is:
+	     * - a FOR tok
+	     * - a DINPAR with no tokstr
+	     * - two DINPARS with tokstr's expr1, expr2.
+	     * - a DOUTPAR with tokstr expr3.
+	     *
+	     * We'll decrement the variable forloop as we verify
+	     * the various stages.
+	     *
+	     * Don't ask me, ma'am, I'm just the programmer.
+	     */
+	    forloop = 5;
+	} else {
+	    switch (forloop) {
+	    case 1:
+		if (tok != DOUTPAR)
+		    forloop = 0;
+		break;
+
+	    case 2:
+	    case 3:
+	    case 4:
+		if (tok != DINPAR)
+		    forloop = 0;
+		break;
+
+	    default:
+		/* nothing to do */
+		break;
+	    }
+	}
+	if (tokstr) {
+	    switch (tok) {
+	    case ENVARRAY:
+		p = dyncat(tokstr, "=(");
+		break;
+
+	    case DINPAR:
+		if (forloop) {
+		    /* See above. */
+		    p = dyncat(tokstr, ";");
+		} else {
+		    /*
+		     * Mathematical expressions analysed as a single
+		     * word.  That's correct because it behaves like
+		     * double quotes.  Whitespace in the middle is
+		     * similarly retained, so just add the parentheses back.
+		     */
+		    p = tricat("((", tokstr, "))");
+		}
+		break;
+
+	    default:
+		p = dupstring(tokstr);
+		break;
+	    }
+	    if (*p) {
+		untokenize(p);
+		if (ingetptr() == addedspaceptr + 1) {
+		    /*
+		     * Whoops, we've read past the space we added, probably
+		     * because we were expecting a terminator but when
+		     * it didn't turn up we shrugged our shoulders thinking
+		     * it might as well be a complete string anyway.
+		     * So remove the space.  C.f. below for the case
+		     * where the missing terminator caused a lex error.
+		     * We use the same paranoid test.
+		     */
+		    int plen = strlen(p);
+		    if (plen && p[plen-1] == ' ' &&
+			(plen == 1 || p[plen-2] != Meta))
+			p[plen-1] = '\0';
+		}
+		addlinknode(list, p);
+		num++;
 	    }
-	    addlinknode(list, p);
-	    num++;
 	} else if (buf) {
 	    if (IS_REDIROP(tok) && tokfd >= 0) {
 		char b[20];
@@ -2973,6 +3033,16 @@ bufferwords(LinkList list, char *buf, in
 		num++;
 	    }
 	}
+	if (forloop) {
+	    if (forloop == 1) {
+		/*
+		 * Final "))" of for loop to match opening,
+		 * since we've just added the preceding element.
+ 		 */
+		addlinknode(list, dupstring("))"));
+	    }
+	    forloop--;
+	}
 	if (!got && !zleparse) {
 	    got = 1;
 	    cur = num - 1;
Index: Test/D04parameter.ztst
===================================================================
RCS file: /cvsroot/zsh/zsh/Test/D04parameter.ztst,v
retrieving revision 1.43
diff -p -u -r1.43 D04parameter.ztst
--- Test/D04parameter.ztst	12 May 2010 10:17:58 -0000	1.43
+++ Test/D04parameter.ztst	5 Oct 2010 21:04:59 -0000
@@ -389,6 +389,34 @@
 >)
 >ten( more
 
+  strings=(
+    'foo=(1 2 3)'
+    '(( 3 + 1 == 8 / 2 ))'
+    'for (( i = 1 ; i < 10 ; i++ ))'
+  )
+  for string in $strings; do
+    array=(${(z)string})
+    for (( i = 1; i <= ${#array}; i++ )); do
+      print -r -- "${i}:${array[i]}:"
+    done
+  done
+0:Some syntactical expressions that are hard to split into words with (z).
+>1:foo=(:
+>2:1:
+>3:2:
+>4:3:
+>5:):
+>1:(( 3 + 1 == 8 / 2 )):
+>1:for:
+>2:((:
+# Leading whitespace is removed, because the word proper hasn't started;
+# trailing whitespace is left because the word is terminated by the
+# semicolon or double parentheses.  Bit confusing but sort of consistent.
+>3:i = 1 ;:
+>4:i < 10 ;:
+>5:i++ :
+>6:)):
+
   psvar=(dog)
   setopt promptsubst
   foo='It shouldn'\''t $(happen) to a %1v.'


-- 
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

