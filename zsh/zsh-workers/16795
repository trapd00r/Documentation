From zsh-workers-return-16795-mason-zsh=primenet.com.au@sunsite.dk Mon Mar 11 08:44:22 2002
Return-Path: <zsh-workers-return-16795-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8101 invoked from network); 11 Mar 2002 08:44:20 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 11 Mar 2002 08:44:20 -0000
Received: (qmail 15058 invoked by alias); 11 Mar 2002 08:44:15 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16795
Received: (qmail 15042 invoked from network); 11 Mar 2002 08:44:14 -0000
From: Sven Wischnowsky <wischnow@berkom.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-ID: <15500.28153.769884.199234@wischnow.berkom.de>
Date: Mon, 11 Mar 2002 09:42:33 +0100
To: zsh-workers@sunsite.dk
Subject: Re: Redirection completion 
In-Reply-To: <15496.50795.888698.447601@wischnow.berkom.de>
References: <15496.46201.219885.149096@wischnow.berkom.de>
	<22196.1015596405@csr.com>
	<15496.50795.888698.447601@wischnow.berkom.de>
X-Mailer: VM 6.95 under 21.5 (patch 3) "asparagus" XEmacs Lucid


Hi

Whew.  Thinking some more lead to the patch below which is probably
entirely different from what everyone expected.  It removes the -T
completion type handling again.  Ahem.  Let me explain.

Because of that `LDFLAGS=-I<TAB>' thing I mentioned I was definitely
preferring to put everything into the command/context part of the
context name because otherwise part of the information would get lost
later.  Then I was looking at it again and trying to imaginge what our
customers would think if they see that they have to use `-T values foo'
when defining functions but `-value-foo' when defining styles.  I
doubt they would understand it -- and they would be right, wouldn't
they?  And, besides, if we were to put the variable name or
redirection operator somewhere else in the context name this wouldn't
be much different.

So, I wrote the patch below.  Removing the -T stuff and consistently
using names like `-value-foo' or `-redirect-echo-2>' everywhere, both
for the context used for styles and for compdef/#compdef (that's why
we don't need separated sets of completion functions anymore).

The patch also contains the doc changes and a change to compdef so
that -p and -P can now e given like -T could be given before, i.e. in
a list of names, toggling to define patterns.  And a new -N can be
used to toggle back.

I'm not going to commit this patch before I get replies, but I like
it.  A lot.  Because it makes things easier without losing power.
One thing we could think about is a standard for offering more
information in the context name.  I used parts separated by hyphens
becuase that's what we used before for sub-commands, but maybe there's
a better way or more places where we can offer more information.

Comments?


Bye
  Sven

diff -ur -r ../oz/Completion/Base/Completer/_complete ./Completion/Base/Completer/_complete
--- ../oz/Completion/Base/Completer/_complete	Sun Mar 10 12:52:38 2002
+++ ./Completion/Base/Completer/_complete	Sun Mar 10 13:05:38 2002
@@ -95,7 +95,7 @@
 
 comp="$_comps[-first-]"
 if [[ -n "$comp" ]]; then
-  service="${_servicecomps[-first-]:--first-}"
+  service="${_services[-first-]:--first-}"
   ccarray[3]=-first-
   eval "$comp" && ret=0
   if [[ "$_compskip" = all ]]; then
@@ -124,7 +124,7 @@
   ccarray[3]="$cname"
 
   comp="$_comps[$cname]"
-  service="${_servicecomps[$cname]:-$cname}"
+  service="${_services[$cname]:-$cname}"
 
   # If not, we use default completion, if any.
 
@@ -134,7 +134,7 @@
       return 1
     fi
     comp="$_comps[-default-]"
-    service="${_servicecomps[-default-]:--default-}"
+    service="${_services[-default-]:--default-}"
   fi
   [[ -n "$comp" ]] && eval "$comp" && ret=0
 fi
diff -ur -r ../oz/Completion/Base/Core/_dispatch ./Completion/Base/Core/_dispatch
--- ../oz/Completion/Base/Core/_dispatch	Sun Mar 10 12:52:38 2002
+++ ./Completion/Base/Core/_dispatch	Sun Mar 10 14:09:39 2002
@@ -1,8 +1,7 @@
 #autoload
 
 local comp pat val name i ret=1 _compskip="$_compskip"
-local curcontext="$curcontext" service str comptype noskip def
-local __comps __patcomps __postpatcomps __services
+local curcontext="$curcontext" service str noskip def pre
 
 # If we get the option `-s', we don't reset `_compskip'.
 
@@ -17,17 +16,9 @@
 
 [[ -z "$noskip" ]] && _compskip=
 
-comptype=$1
+pre="$1"
 
-__comps=_$1
-
-(( ${(P)+__comps} )) || return 1
-
-__patcomps=_pat$1
-__postpatcomps=_postpat$1
-__services=_service$1
-
-shift
+set -- "$1${(@)^argv[2,-1]}"
 
 # See if there are any matching pattern completions.
 
@@ -35,9 +26,10 @@
 
   for str in "$@"; do
     [[ -n "$str" ]] || continue
-    service="${${(e):-\$${__services}[\$str]}:-$str}"
-    for i in "${(@e):-\$${__patcomps}[(K)\$str]}"; do
-      "$i" && ret=0
+    service="${_services[$str]:-$str}"
+    for i in "${(@)_patcomps[(K)$str]}"; do
+      curcontext="${curcontext%:*:*}:${str}:"
+      eval "$i" && ret=0
       if [[ "$_compskip" = *patterns* ]]; then
         break
       elif [[ "$_compskip" = all ]]; then
@@ -54,8 +46,8 @@
 for str in "$@"; do
   [[ -n "$str" ]] || continue
   name="$str"
-  comp="${(e):-\$${__comps}[\$str]}"
-  service="${${(e):-\$${__services}[\$str]}:-$str}"
+  comp="${_comps[$str]}"
+  service="${_services[$str]:-$str}"
 
   [[ -z "$comp" ]] || break
 done
@@ -64,20 +56,23 @@
 
 if [[ -n "$comp" ]]; then
   _compskip=patterns
+  curcontext="${curcontext%:*:*}:${str}:"
   eval "$comp" && ret=0
   [[ "$_compskip" = (all|*patterns*) ]] && return ret
 elif [[ "$_compskip" != *default* ]]; then
-  name=-default-
-  comp="${(e):-\$${__comps}[-default-]}"
+  name="$pre-default-"
+  comp="${_comps[$pre-default-]}"
+  [[ -z "$comp" ]] && name="-default-" comp="${_comps[-default-]}"
 fi
 
 if [[ "$_compskip" != (all|*patterns*) ]]; then
   for str; do
     [[ -n "$str" ]] || continue
-    service="${${(e):-\$${__services}[\$str]}:-$str}"
-    for i in "${(@e):-\$${__postpatcomps}[(K)\$str]}"; do
+    service="${_services[$str]:-$str}"
+    for i in "${(@)_postpatcomps[(K)$str]}"; do
       _compskip=default
-      "$i" && ret=0
+      curcontext="${curcontext%:*:*}:${str}:"
+      eval "$i" && ret=0
       if [[ "$_compskip" = *patterns* ]]; then
         break
       elif [[ "$_compskip" = all ]]; then
@@ -88,9 +83,10 @@
   done
 fi
 
-[[ "$name" = -default- && -n "$comp" &&
+[[ "$name" = *-default- && -n "$comp" &&
    "$_compskip" != (all|*default*) ]] &&
-  service="${${(e):-\$${__services}[-default-]}:--default-}" &&
+  service="${_services[$name]:-$name}" &&
+  curcontext="${curcontext%:*:*}:${name}:"
    eval "$comp" && ret=0
 
 _compskip=''
diff -ur -r ../oz/Completion/Base/Core/_normal ./Completion/Base/Core/_normal
--- ../oz/Completion/Base/Core/_normal	Sun Mar 10 12:52:38 2002
+++ ./Completion/Base/Core/_normal	Sun Mar 10 13:37:51 2002
@@ -22,4 +22,4 @@
 
 _set_command
 
-_dispatch -d "$skip[@]" comps "$_comp_command1" "$_comp_command2"
+_dispatch -d "$skip[@]" '' "$_comp_command1" "$_comp_command2"
diff -ur -r ../oz/Completion/Base/Utility/_set_command ./Completion/Base/Utility/_set_command
--- ../oz/Completion/Base/Utility/_set_command	Sun Mar 10 12:52:38 2002
+++ ./Completion/Base/Utility/_set_command	Sun Mar 10 14:09:51 2002
@@ -11,21 +11,16 @@
 
 if (( $+builtins[$command] + $+functions[$command] )); then
   _comp_command1="$command"
-  curcontext="${curcontext%:*:*}:${_comp_command1}:"
 elif [[ "$command[1]" = '=' ]]; then
   eval _comp_command2\=$command
   _comp_command1="$command[2,-1]"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
 elif [[ "$command" = ..#/* ]]; then
   _comp_command1="${PWD}/$command"
   _comp_command2="${command:t}"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
 elif [[ "$command" = */* ]]; then
   _comp_command1="$command"
   _comp_command2="${command:t}"
-  curcontext="${curcontext%:*:*}:${_comp_command2}:"
 else
   _comp_command1="$command"
   _comp_command2="$commands[$command]"
-  curcontext="${curcontext%:*:*}:${_comp_command1}:"
 fi
diff -ur -r ../oz/Completion/Unix/Command/_gcc ./Completion/Unix/Command/_gcc
--- ../oz/Completion/Unix/Command/_gcc	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Command/_gcc	Sun Mar 10 13:23:04 2002
@@ -1,13 +1,13 @@
-#compdef gcc g++ -T values LDFLAGS CFLAGS CPPFLAGS
+#compdef gcc g++ -value-LDFLAGS -value-CFLAGS -value-CPPFLAGS
 
 local curcontext="$curcontext" state line ret=1 expl args args2
 typeset -A opt_args
 
-if [[ "$comptype" = values ]]; then
+if [[ "$service" = -value-* ]]; then
   compset -q
   words=( fake "$words[@]" )
   (( CURRENT++ ))
-  if [[ "$service" = LDFLAGS ]]; then
+  if [[ "$service" = *LDFLAGS ]]; then
     args2=( '-R:runtime path:->rundir' )
   else
     args2=()
diff -ur -r ../oz/Completion/Unix/Command/_make ./Completion/Unix/Command/_make
--- ../oz/Completion/Unix/Command/_make	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Command/_make	Sun Mar 10 14:04:30 2002
@@ -45,6 +45,7 @@
     fi
     _wanted targets expl 'make target' compadd -a tmp && return 0
   fi
+  compstate[parameter]="${PREFIX%%\=*}"
   compset -P 1 '*='
-  _files
+  _value "$@"
 fi
diff -ur -r ../oz/Completion/Unix/Command/_su ./Completion/Unix/Command/_su
--- ../oz/Completion/Unix/Command/_su	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Command/_su	Sun Mar 10 13:37:36 2002
@@ -17,4 +17,4 @@
 shell="${${(M@)${(@f)$(</etc/passwd)}:#$usr*}##*:}"
 compset -n $base
 
-_dispatch comps $shell $shell:t -default-
+_dispatch -d '' $shell $shell:t
diff -ur -r ../oz/Completion/Unix/Type/_files ./Completion/Unix/Type/_files
--- ../oz/Completion/Unix/Type/_files	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Type/_files	Sun Mar 10 13:25:22 2002
@@ -1,4 +1,4 @@
-#compdef -T redirs -default-
+#compdef -redirect--default-
 
 local opts tmp glob pat pats expl tag i def descr end ign ret=1 match tried
 local type sdef
diff -ur -r ../oz/Completion/Unix/Type/_printers ./Completion/Unix/Type/_printers
--- ../oz/Completion/Unix/Type/_printers	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Type/_printers	Sun Mar 10 13:23:57 2002
@@ -1,4 +1,4 @@
-#compdef -T values PRINTER LPDEST
+#compdef -value-PRINTER -value-LPDEST
 
 local expl ret=1 list disp sep
 
diff -ur -r ../oz/Completion/Unix/Type/_terminals ./Completion/Unix/Type/_terminals
--- ../oz/Completion/Unix/Type/_terminals	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Type/_terminals	Sun Mar 10 13:24:06 2002
@@ -1,4 +1,4 @@
-#compdef infocmp -T values TERM
+#compdef infocmp -value-TERM
 
 local desc expl
 
diff -ur -r ../oz/Completion/Unix/Type/_time_zone ./Completion/Unix/Type/_time_zone
--- ../oz/Completion/Unix/Type/_time_zone	Sun Mar 10 12:52:38 2002
+++ ./Completion/Unix/Type/_time_zone	Sun Mar 10 13:24:20 2002
@@ -1,4 +1,4 @@
-#compdef -T values TZ
+#compdef -value-TZ
 
 local expl
 
diff -ur -r ../oz/Completion/X/Type/_x_display ./Completion/X/Type/_x_display
--- ../oz/Completion/X/Type/_x_display	Sun Mar 10 12:52:38 2002
+++ ./Completion/X/Type/_x_display	Sun Mar 10 13:24:35 2002
@@ -1,3 +1,3 @@
-#compdef -T values DISPLAY
+#compdef -value-DISPLAY
 
 _tags displays && _hosts -S ':0 ' -r :
diff -ur -r ../oz/Completion/Zsh/Command/_compdef ./Completion/Zsh/Command/_compdef
--- ../oz/Completion/Zsh/Command/_compdef	Sun Mar 10 12:52:38 2002
+++ ./Completion/Zsh/Command/_compdef	Sun Mar 10 16:34:55 2002
@@ -1,24 +1,37 @@
 #compdef compdef
 
-local state line expl list disp curcontext="$curcontext"
+local state line expl list disp curcontext="$curcontext" pat normal ret=1
+local args1 args2
 typeset -A opt_args
 
-_arguments -C -s -A "-*" -S \
-  '(-d)-a[make function autoloadable]' \
-  '(-d -p -P)-n[leave existing definitions intact]' \
-  "*-T[select type of completion function]:completion function type:($_comp_assocs)" \
+args2=()
+if (( ! ${words[2,-1][(I)[^-]*]} || ${words[(I)-[kK]]} )); then
+  args1=(
+    -A '-*'
+    '(-d)-a[make function autoloadable]'
+    '(-d)-n[leave existing definitions intact]'
+  )
+  args2=(
+     - d
+      '(-a -n)-d[delete]:*:completed command:->ccom'
+     - k
+      '-k[define widget and key binding]:completion function:->cfun:style:->style:*:key'
+     - K
+      '-K[define multiple widgets based on function]:*::: :->multi'
+  )
+else
+  args1=(
+    '-N[completion for named command]'
+  )
+fi
+
+_arguments -C -s -S \
+  "$args1[@]" \
+  '-p[completion for command matching pattern]' \
+  '-P[completion for command matching pattern]' \
   ':completion function:->cfun' \
-  '*:commands: _command_names' \
- - d \
-  '(-a -n)-d[delete]:*:completed command:->ccom' \
- - p \
-  '(-n)-p[completion for command matching pattern]:completion function:->cfun:pattern' \
- - P \
-  '(-n)-P[as -p for commands without own completion]:completion function:->cfun:pattern' \
- - k \
-  '-k[define widget and key binding]:completion function:->cfun:style:->style:*:key' \
- - K \
-  '-K[define multiple widgets based on function]:*::: :->multi' && return 0
+  '*:commands:->com' \
+  "$args2[@]" && return 0
 
 if [[ $state = multi ]]; then
   case $(( CURRENT % 3 )) in
@@ -30,6 +43,15 @@
 fi
 
 case $state in
+  com)
+    pat="${words[(I)-[pP]]}"
+    normal="${words[(I)-N]}"
+    if (( pat && pat > normal )); then
+      _message -e patterns 'pattern'
+    else
+      _command_names
+    fi
+  ;;
   ccom)
     _wanted commands expl 'completed command' compadd -k _comps
   ;;
diff -ur -r ../oz/Completion/Zsh/Context/_in_vared ./Completion/Zsh/Context/_in_vared
--- ../oz/Completion/Zsh/Context/_in_vared	Sun Mar 10 12:52:38 2002
+++ ./Completion/Zsh/Context/_in_vared	Sun Mar 10 13:35:24 2002
@@ -32,4 +32,4 @@
 
 compstate[insert]="${compstate[insert]//tab /}"
 
-_dispatch comps "$also"
+_dispatch '' "$also"
diff -ur -r ../oz/Completion/Zsh/Context/_redirect ./Completion/Zsh/Context/_redirect
--- ../oz/Completion/Zsh/Context/_redirect	Sun Mar 10 12:52:38 2002
+++ ./Completion/Zsh/Context/_redirect	Sun Mar 10 13:33:46 2002
@@ -7,11 +7,12 @@
 
 _set_command
 
-strs=( "$compstate[redirect]" )
+strs=( "${compstate[redirect]:s/:/-/}" )
 
 if [[ -n "$_comp_command1" ]]; then
-  strs=( "${_comp_command1}:$strs[-1]" "$strs[@]" )
-  [[ -n "$_comp_command2" ]] && strs=( "${_comp_command2}:$strs[1]" "$strs[@]" )
+  strs=( "${_comp_command1}-$strs[-1]" "$strs[@]" )
+  [[ -n "$_comp_command2" ]] && strs=( "${_comp_command2}-$strs[-1]"
+                                       "$strs[@]" )
 fi
 
-_dispatch -d redirs "$strs[@]"
+_dispatch -d -redirect- "$strs[@]"
diff -ur -r ../oz/Completion/Zsh/Context/_subscript ./Completion/Zsh/Context/_subscript
--- ../oz/Completion/Zsh/Context/_subscript	Sun Mar 10 12:52:38 2002
+++ ./Completion/Zsh/Context/_subscript	Sun Mar 10 13:36:13 2002
@@ -113,5 +113,5 @@
 
   return 1
 else
-  _dispatch comps -math-
+  _dispatch '' -math-
 fi
diff -ur -r ../oz/Completion/Zsh/Context/_value ./Completion/Zsh/Context/_value
--- ../oz/Completion/Zsh/Context/_value	Sun Mar 10 12:52:38 2002
+++ ./Completion/Zsh/Context/_value	Sun Mar 10 14:06:41 2002
@@ -1,4 +1,4 @@
-#compdef -value- -array-value- -T values -default-
+#compdef -value- -array-value- -value--default-
 
 # You can customize completion for different parameters by writing
 # functions with the tag-line `#compdef -T value <name>'.
@@ -6,7 +6,7 @@
 # and `<param-name>'. If the line contains a command (as in `make foo=<TAB>')
 # the string `<command>:<param-name>:<param-type>' is also searched for.
 
-if [[ "$service" != -default- ]]; then
+if [[ "$service" != -value-?* ]]; then
   local strs type
 
   type="${(Pt)compstate[parameter]}"
@@ -21,15 +21,15 @@
     fi
   fi
 
-  strs=( "${compstate[parameter]}:$type" "$compstate[parameter]" )
+  strs=( "${compstate[parameter]}-$type" "$compstate[parameter]" )
 
   if [[ "$compstate[context]" != *value && -n "$_comp_command1" ]]; then
-    strs=( "${_comp_command1}:$^strs[@]" "$strs[@]" )
+    strs=( "${_comp_command1}-$^strs[@]" "$strs[@]" )
     [[ -n "$_comp_command2" ]] &&
-        strs=( "${_comp_command2}:${(@)^strs[-2,-1]}" "$strs[@]" )
+        strs=( "${_comp_command2}-${(@)^strs[-2,-1]}" "$strs[@]" )
   fi
 
-  _dispatch -d values "$strs[@]"
+  _dispatch -d -value- "$strs[@]"
 else
   if [[ "$compstate[parameter]" != *-* &&
         "$compstate[context]" = *value &&
diff -ur -r ../oz/Completion/compdump ./Completion/compdump
--- ../oz/Completion/compdump	Sun Mar 10 12:52:38 2002
+++ ./Completion/compdump	Sun Mar 10 13:19:07 2002
@@ -35,43 +35,34 @@
 
 print "#files: $#_d_files" > $_d_file
 
-# First dump the arrays _comps, _servicecomps and _patcomps.  The quoting
+# Dump the arrays _comps, _services and _patcomps.  The quoting
 # hieroglyphics ensure that a single quote inside a variable is itself
 # correctly quoted.
 
-for _d_name in $_comp_assocs; do
-
-  print "\n\ntypeset -gA _$_d_name _service$_d_name _pat$_d_name _postpat$_d_name"
-
-  _d_tmp="_${_d_name}"
-  print "\n_${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
-
-  _d_tmp="_service${_d_name}"
-  print "\n_service${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_comps=(" >> $_d_file
+for _d_f in ${(ok)_comps}; do
+  print -r - "${(q)_d_f}" "${(q)_comps[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
-  _d_tmp="_pat${_d_name}"
-  print "\n_pat${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_services=(" >> $_d_file
+for _d_f in ${(ok)_services}; do
+  print -r - "${(q)_d_f}" "${(q)_services[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
-  _d_tmp="_postpat${_d_name}"
-  print "\n_postpat${_d_name}=("
-  for _d_f in ${(Pok)_d_tmp}; do
-    print -r - "${(q)_d_f}" "${(q)${(e):-\$${_d_tmp}[$_d_f]}}"
-  done
-  print ")"
+print "\n_patcomps=(" >> $_d_file
+for _d_f in ${(ok)_patcomps}; do
+  print -r - "${(q)_d_f}" "${(q)_patcomps[$_d_f]}"
+done >> $_d_file
+print ")" >> $_d_file
 
+_d_tmp="_postpatcomps"
+print "\n_postpatcomps=(" >> $_d_file
+for _d_f in ${(ok)_postpatcomps}; do
+  print -r - "${(q)_d_f}" "${(q)_postpatcomps[$_d_f]}"
 done >> $_d_file
+print ")" >> $_d_file
 
 print "\n_compautos=(" >> $_d_file
 for _d_f in "${(ok@)_compautos}"; do
diff -ur -r ../oz/Completion/compinit ./Completion/compinit
--- ../oz/Completion/compinit	Sun Mar 10 12:52:38 2002
+++ ./Completion/compinit	Sun Mar 10 15:03:18 2002
@@ -102,21 +102,10 @@
   esac
 done
 
-# The name suffixes for the associative arrays containing the functions
-# to call.
-
-typeset -gUa _comp_assocs
-
-_comp_assocs=(comps)
-
 # The associative arrays containing the definitions for the commands and
 # services.
-# Definitions for patterns will be stored in the associations `_pat*'
-# and `_postpat*'.
-# The assocs for the other function types are created automatically by
-# compdef.
 
-typeset -gA _comps _servicecomps _patcomps _postpatcomps
+typeset -gA _comps _services _patcomps _postpatcomps
 
 # `_compautos' contains the names and options for autoloaded functions
 # that get options.
@@ -191,9 +180,6 @@
 # The option `-P' is like `-p', but the function will be called after
 # trying to find a function defined for the command on the line if no
 # such function could be found.
-# In each of these cases the argument list may also contain `-T assoc'
-# options to specify the associactive arrays to which the following
-# definitions should be added.
 # With the `-k' option a function for a special completion keys is 
 # defined and immediately bound to those keys. Here, the extra arguments
 # are the name of one of the builtin completion widgets and any number
@@ -209,8 +195,7 @@
 # whose names are given as arguments. If combined with the `-p' option
 # it deletes the definitions for the patterns given as argument.
 # The `-d' option may not be combined with the `-k' option, i.e.
-# definitions for key function can not be removed. But one `-T assoc'
-# option may follow the `-d' to say which definitions should be removed.
+# definitions for key function can not be removed.
 #
 # Examples:
 #
@@ -232,7 +217,7 @@
 #   delete the definitions for the command names `bar' and `baz'
 
 compdef() {
-  local opt autol type func delete new i ret=0 cmd svc assoc=comps
+  local opt autol type func delete new i ret=0 cmd svc
 
   # Get the options.
 
@@ -277,38 +262,26 @@
 
     if [[ "$1" = *\=* ]]; then
       while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          if [[ "$1" = *\=* ]]; then
-	    cmd="${1%%\=*}"
-	    svc="${1#*\=}"
-            func="$_comps[${(e):-\${(k)_service${assoc}[(R)$svc]:-$svc}}]"
-            [[ -n ${(e):-\$_service${assoc}[$svc]} ]] &&
-                svc=${(e):-\$_service${assoc}[$svc]}
-	    [[ -z "$func" ]] &&
-	        func="${${(e):-\$_pat${assoc}[(K)$svc][1]}:-${(e):-\$_postpat${assoc}[(K)$svc][1]}}"
-            if [[ -n "$func" ]]; then
-	      eval "_${assoc}"'[$cmd]="$func"'
-	      eval "_service${assoc}"'[$cmd]="$svc"'
-	    else
-	      echo "$0: unknown command or service: $svc"
-	      ret=1
-	    fi
+        if [[ "$1" = *\=* ]]; then
+	  cmd="${1%%\=*}"
+	  svc="${1#*\=}"
+          func="$_comps[${_services[(R)$svc]:-$svc}]"
+          [[ -n ${_services[$svc]} ]] &&
+              svc=${_services[$svc]}
+	  [[ -z "$func" ]] &&
+	      func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}"
+          if [[ -n "$func" ]]; then
+	    _comps[$cmd]="$func"
+	    _services[$cmd]="$svc"
 	  else
-	    echo "$0: invalid argument: $1"
+	    echo "$0: unknown command or service: $svc"
 	    ret=1
 	  fi
-          shift
-        fi
+	else
+	  echo "$0: invalid argument: $1"
+	  ret=1
+	fi
+        shift
       done
 
       return ret
@@ -322,42 +295,6 @@
     shift
 
     case "$type" in
-    pattern)
-      while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          eval "_pat${assoc}"'[$1]="$func"'
-          shift
-        fi
-      done
-      ;;
-    postpattern)
-      while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
-        else
-          eval "_postpat${assoc}"'[$1]="$func"'
-          shift
-        fi
-      done
-      ;;
     widgetkey)
       while [[ -n $1 ]]; do
 	if [[ $# -lt 3 ]]; then
@@ -406,54 +343,48 @@
       # For commands store the function name in the
       # associative array, command names as keys.
       while (( $# )); do
-        if [[ $1 = -T ]]; then
-          shift
-          if (( ! $# )); then
-            echo "$0: missing type"
-            return 1
-          fi
-          _comp_assocs=( "$_comp_assocs[@]" "$1" )
-          typeset -gA _$1 _service$1 _pat$1 _postpat$1
-          assoc="$1"
-          shift
+        if [[ "$1" = -N ]]; then
+          type=normal
+        elif [[ "$1" = -p ]]; then
+          type=pattern
+        elif [[ "$1" = -P ]]; then
+          type=postpattern
         else
-          if [[ "$1" = *\=* ]]; then
-	    cmd="${1%%\=*}"
-	    svc=yes
-          else
-	    cmd="$1"
-	    svc=
-          fi
-          if [[ -z "$new" || -z "${(e):-\$_${assoc}[$1]}" ]]; then
-            eval "_${assoc}"'[$cmd]="$func"'
-	    [[ -n "$svc" ]] && eval "_service${assoc}"'[$cmd]="${1#*\=}"'
-	  fi
-          shift
+          case "$type" in
+          pattern)
+            _patcomps[$1]="$func"
+            ;;
+          postpattern)
+            _postpatcomps[$1]="$func"
+            ;;
+          *)
+            if [[ "$1" = *\=* ]]; then
+	      cmd="${1%%\=*}"
+	      svc=yes
+            else
+	      cmd="$1"
+	      svc=
+            fi
+            if [[ -z "$new" || -z "${_comps[$1]}" ]]; then
+              _comps[$cmd]="$func"
+	      [[ -n "$svc" ]] && _services[$cmd]="${1#*\=}"
+	    fi
+            ;;
+          esac
         fi
+        shift
       done
       ;;
     esac
   else
     # Handle the `-d' option, deleting.
 
-    if [[ $1 = -T ]]; then
-      shift
-      if (( ! $# )); then
-        echo "$0: missing type"
-        return 1
-      fi
-      _comp_assocs=( "$_comp_assocs[@]" "$1" )
-      typeset -gA _$1 _service$1 _pat$1 _postpat$1
-      assoc="$1"
-      shift
-    fi
-
     case "$type" in
     pattern)
-      unset "_pat${assoc}[$^@]"
+      unset "_patcomps[$^@]"
       ;;
     postpattern)
-      unset "_postpat${assoc}[$^@]"
+      unset "_postpatcomps[$^@]"
       ;;
     key)
       # Oops, cannot do that yet.
@@ -462,7 +393,7 @@
       return 1
       ;;
     *)
-      unset "_${assoc}[$^@]"
+      unset "_comps[$^@]"
     esac
   fi
 }
diff -ur -r ../oz/Doc/Zsh/compsys.yo ./Doc/Zsh/compsys.yo
--- ../oz/Doc/Zsh/compsys.yo	Sun Mar 10 12:52:38 2002
+++ ./Doc/Zsh/compsys.yo	Sun Mar 10 15:21:30 2002
@@ -159,7 +159,8 @@
 The tags are:
 
 startitem()
-item(tt(#compdef) var(names...))(
+item(tt(#compdef) var(names...) [ tt(-[pP]) var(patterns...) [ tt(-N)
+var(names...) ] ])(
 The file will be made autoloadable and the function defined 
 in it will be called when completing var(names), each of which is
 either the name of a command whose arguments are to be completed or one of
@@ -174,33 +175,18 @@
 to the string `tt(service)'.  The function can then use that parameter 
 to decide what to complete.
 
-Finally, the list of var(names) may contain tt(-T) options, each
-followed by a type name.  These type names describe in which set of
-completion function definitions the function is to be stored.  The
-default without a tt(-T) option is `tt(comps)', saying that the
-function is a normal completion function.  Other type names currently
-understood by the completion system are tt(redirs) and tt(values).
-The first is used to define specialised completion functions for
-use after redirection operators for certain commands and the latter is
-used to define functions used when completing values of parameters.
-For example, to define the function that should be used when
-completing after `tt(foo=<TAB>)' one would use the tag line:
-
-example(#compdef -T values foo)
-
-When the function is called, the parameter tt($comptype) will be set
-to the type name, making it easy to distinguish what should be
-completed.
-)
-item(tt(#compdef -p) var(patterns...))(
-The file will be made autoloadable and the function defined in it will be
-called when completing for a command whose name matches the given
-var(pattern) (a standard globbing pattern).  As in the first case, the
-list of var(patterns) may contain tt(-T) options.
-)
-item(tt(#compdef -P) var(patterns...))(
-Like the previous one, but the function will be called only if no
-completion function for the command on the line could be found.
+If the list of var(names) contains a tt(-p) or tt(-P) option, the
+following words are taken to be patterns.  When completing for a
+command or context whose name matches one of the patterns, the
+function will be called.  In the case of tt(-P), this will only be
+done if no other completion function for the command or context could
+be found (i.e. this can be used to define default completion for
+commands or contexts matching one of the patterns which don't have a
+completion function specifically defined for them).
+
+If the list contains the tt(-N) option, the following words are used
+as in the normal case again.  Another tt(-p) or tt(-P) option can be
+usedto toggle back to defining patterns again. 
 )
 item(tt(#compdef -k) var(style key-sequences...))(
 This can be used to bind special completion functions to the
@@ -272,10 +258,8 @@
 findex(compdef)
 cindex(completion system, adding definitions)
 startitem()
-xitem(tt(compdef) [ tt(-an) ] var(function names) [ tt(-T) var(type) ] ...))
-xitem(tt(compdef -d) [ tt(-T) var(type) ] var(names...))
-xitem(tt(compdef -p) [ tt(-a) ] var(function patterns) [ tt(-T) var(type) ] ...)
-xitem(tt(compdef -P) [ tt(-a) ] var(function patterns) [ tt(-T) var(type) ] ...)
+xitem(tt(compdef) [ tt(-an) ] var(function names...) [ tt(-[pP]) var(patterns...) ])
+xitem(tt(compdef -d) var(names...))
 xitem(tt(compdef -k) [ tt(-an) ] var(function style key-sequences...))
 item(tt(compdef -K) [ tt(-an) ] var(function name style key-sequences ...))(
 The first form tells the completion system to call the given
@@ -297,27 +281,25 @@
 
 example(compdef '_files -g "*.h"' foo)
 
-The tt(-T) options in the list of var(names) define for which type of
-completions the function is to be used, i.e. in which set of
-completion functions definitions it should be added.  Currently used
-tt(type)s are tt(comps) (the default, for normal completion functions
-for command completion), tt(values) for completion of parameter values
-in assignments and tt(redirs) for completion after redirection
-operators.
-
 If the
 tt(-n) option is given, any existing completion behaviour for particular
 contexts or commands will not be altered.  These definitions can be deleted
 by giving the tt(-d) option as in the second form.
 
-The form with tt(-p) is similar to the first, but var(function) will be
-called for all commands whose name matches the var(pattern); this is like
-the tt(#compdef -p) function tag.
-
-The form with tt(-P) is like the third, but the var(function) will be
-called only if no function for the command itself was found or if one
-was found and it set the tt(_compskip) parameter to a value em(not)
-containing the substring tt(patterns).
+In both of the first two cases forms and as for the tt(#compdef) tag
+described above, the var(names) may also contain tt(-p), tt(-P) and
+tt(-N) options.  The first two make the following arguments be used as
+patterns and the var(function) will be called for all commands and
+contexts matching one of the patterns.  Wtih tt(-P) this will only
+happen if no specific function is defined for the command or context.
+The tt(-N) option toggles back to using the var(names) as described
+above.
+
+Inside functions defined for patterns, the parameter tt($_compskip)
+may be used.  If it is set to a value containing the substring
+`tt(patterns)' none of the pattern-functions will be called.  If it is
+set to a value containing the substring `tt(all)', no other function
+will be called.
 
 The form with tt(-k) defines a widget with the same name as the var(function)
 which will be called for each of the var(key-sequences); this is like the
@@ -2566,6 +2548,25 @@
 (e.g. completion for the `tt(-tilde-)' context is done by the function 
 named `tt(_tilde)').
 
+The functions for some contexts re-dispatch by calling the function
+tt(_dispatch) with more specific information.  Currently this is done
+for the contexts tt(-value-)/tt(-array-value-) and tt(-redirect-).
+Functions for completing parameter values are searched for by using
+`tt(-value-)var(name)tt(-)var(type)', `tt(-value-)var(name)' and, for
+cases like `tt(make LDFLAGS=<TAB>)' also
+`tt(-value-)var(command)tt(-)var(name)tt(-)var(type)' and
+`tt(-value-)var(command)tt(-)var(name)'.  Functions for completing
+redirections are searched for using
+`tt(-redirect-)var(command)tt(-)var(operator)' and
+`tt(-redirect-)var(operator)'.
+
+For example:
+
+example(compdef '_files -g "*.log"' '-redirect-2>')
+
+could be used to complete files matching `tt(*.log)' when completing
+after `tt(foo 2> <TAB>)'.
+
 Before trying to find a function for a specific context, tt(_complete) 
 checks if the parameter `tt(compcontext)' is set.  If it is set to an
 array, the elements are taken to be the possible matches which will be
@@ -3657,17 +3658,17 @@
 passed down to the builtins which implement the internals of completion.
 )
 findex(_dispatch)
-item(tt(_dispatch) [ tt(-d) ] var(type strings ...))(
-This function looks up the function defined for the first var(string)
-in the set of definitions named var(type) (these are those definitions
-defined with `tt(-T )var(type)').  If one is found, it is called to
-generate completions.  Otherwise the definition for the second
-var(string) is looked up and so on.  If none is found and the tt(-d)
-option is given, the definition for the special name tt(-default-) is
-used.
-
-This function is the one responsible for setting the parameters
-tt($service) and tt($comptype).
+item(tt(_dispatch) [ tt(-d) ] var(prefix strings ...))(
+This looks up the functions defined for the var(strings) (prefixed
+with var(prefix)) one after another until it finds one that is
+defined. That function is then called to generate the matches.  If no
+function is found and the tt(-d) option is given, the definition for
+either the special names var(prefix)tt(-default-) or tt(-default-) is
+used, if defined.
+
+This function is the one responsible for setting the parameter
+tt($service) and for setting the var(context/command) field of the
+tt($curcontext) parameter.
 )
 findex(_files)
 item(tt(_files))(

-- 
Sven Wischnowsky                          wischnow@berkom.de

