From zsh-users-return-12901-mason-zsh=primenet.com.au@sunsite.dk Tue Jun 10 03:51:11 2008
Return-Path: <zsh-users-return-12901-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15518 invoked from network); 10 Jun 2008 03:51:00 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.4 (2008-01-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.2.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 10 Jun 2008 03:51:00 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 20694 invoked from network); 10 Jun 2008 03:50:48 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 10 Jun 2008 03:50:48 -0000
Received: (qmail 25305 invoked by alias); 10 Jun 2008 03:50:36 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 12901
Received: (qmail 25289 invoked from network); 10 Jun 2008 03:50:36 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 10 Jun 2008 03:50:36 -0000
Received: from wf-out-1314.google.com (wf-out-1314.google.com [209.85.200.175])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 0E2368028AC3
	for <zsh-users@sunsite.dk>; Tue, 10 Jun 2008 05:50:31 +0200 (CEST)
Received: by wf-out-1314.google.com with SMTP id 23so2535160wfg.3
        for <zsh-users@sunsite.dk>; Mon, 09 Jun 2008 20:50:30 -0700 (PDT)
Received: by 10.143.33.12 with SMTP id l12mr320087wfj.272.1212813580513;
        Fri, 06 Jun 2008 21:39:40 -0700 (PDT)
Received: by 10.142.239.10 with HTTP; Fri, 6 Jun 2008 21:39:40 -0700 (PDT)
Message-ID: <13ed09c00806062139g6e0e81eaxb350eaca45698a94@mail.gmail.com>
Date: Sat, 7 Jun 2008 05:39:40 +0100
From: "Robert Knight" <robertknight@gmail.com>
To: zsh-users@sunsite.dk
Subject: Re: idea for new feature (was: Re: sticky-note and zle bindings)
In-Reply-To: <20080128163340.GA18831@spiegl.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline
References: <080125095733.ZM20873@torch.brasslantern.com>
	 <080124215848.ZM19758@torch.brasslantern.com>
	 <2d460de70801250149t360f9938u18d458b03f464c72@mail.gmail.com>
	 <1B47D24854C7BC4FA8DA28BEBB59B0BA02E64EAC@orsmsx419.amr.corp.intel.com>
	 <2d460de70801260729q34fb7ed8o11446e63a320b2ad@mail.gmail.com>
	 <13ed09c00801251018l1007ac9an9c453651d5695c46@mail.gmail.com>
	 <080125181227.ZM21172@torch.brasslantern.com>
	 <2d460de70801260741q16e4f197he2307be6e4f81c82@mail.gmail.com>
	 <080126153143.ZM6173@torch.brasslantern.com>
	 <20080128163340.GA18831@spiegl.de>
X-Virus-Scanned: ClamAV 0.92.1/7417/Tue Jun 10 03:14:29 2008 on bifrost
X-Virus-Status: Clean

Hi folks,

I'd like to implement my part of this quite soon.  So here is a more
concrete proposal:

(1)  The terminal emulator creates a unique alphanumeric ID string for each
new session and passes it to the shell as an environment variable
$SHELL_SESSION_ID.
When the shell is killed via a SIGHUP it saves that state and the
associated session ID.
When restoring that session, the terminal emulator starts a new
instance of the shell as
usual, with the previously used $SHELL_SESSION_ID value.  The shell
looks for state saved
under that name and restores the previous state.  If no state is saved
against the id then
the shell can assume that it is a new session.  The ID would be
alphanumeric, with no fixed
length or format.  I would probably use Qt's UUID generator to come up
with something suitable
but users might choose human-readable names if they wanted to do their
own session management.

(2)  The terminal emulator specifies a file for the shell to save its
state information
to.  If the file is empty or does not exist then the shell assumes
this is a new session.  Otherwise it restores the contents of the
file.  The save/restore handling then works as in (1).

I favour the first option because the shell can pick a suitable place
to store its
state information which is in the same location/format as the rest of
its data.  Unlike a filename, an ID also works over remote
connections.

Policies over exactly what gets saved and restored and how long that
information should be kept for would be left up to the shell to begin
with.
I can make suggestions about what would be most useful however,
roughly in priority order.
The real gist is to minimize the time spent doing repetetive setup
routines to prepare for
working on various tasks.

- Environment variables (probably not the complete environment but
rather a delta between
the environment inherited by the shell when it started and the
environment in the shell when
it was closed)
- Prompt
- Aliases
- Functions

Digging back through my mail from users, something which would earn
much love from sysadmins
would be if they could save the state of their terminal, with 10-20
connections to various
machines via SSH and later restore that again instantly - including as
much state as possible
on the remote end.

Regards,
Robert.

2008/1/28 Andy Spiegl <zsh.Andy@spiegl.de>:
> On 2008-01-26, 15:31, Bart Schaefer wrote:
>> } Restoring the programs that ran is a very interesting idea. I like it :)
>>
>> Not "the programs that ran".  The programs that *were running*; that is,
>> something the shell had to SIGHUP when it exited.  I'd be very leery of
>> automatically restarting anything other than the foreground job, though,
>> and maybe not even that if it was a pipeline.
>
> I really like the idea of restoring the program that was running
> before the "crash", but I'd suggest not to reexecute it (which may
> have fatal side effects) but just putting it on the command line.
> The user can then decide whether to press enter or not.
>
> Chau,
>  Andy.
>
> --
>  Once you've seen one shopping center you've seen a mall.
>

