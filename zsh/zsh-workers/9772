From zsh-workers-return-9772-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 17 10:58:26 2000
Return-Path: <zsh-workers-return-9772-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17559 invoked from network); 17 Feb 2000 10:58:14 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Feb 2000 10:58:14 -0000
Received: (qmail 16646 invoked by alias); 17 Feb 2000 10:58:06 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9772
Received: (qmail 16638 invoked from network); 17 Feb 2000 10:58:05 -0000
Date: Thu, 17 Feb 2000 11:58:03 +0100 (MET)
Message-Id: <200002171058.LAA12952@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Wed, 16 Feb 2000 17:41:39 +0000
Subject: Re: 3.1.6-dev-18


Peter Stephenson wrote:

> Sven Wischnowsky wrote:
> > Err, hadn't thought about putting that into _main_complete (where we
> > can optimise).
> > 
> > One last question: wouldn't it then be better to just have a
> > matcher-list style, taken as an array, containing the match specs to
> > try one after another?
> 
> Under those circumstances, probably yes; there's no obvious advantage in
> pretending you have multiple matching functions if you don't.

Ok, here is the matcher-list style. Ultra-short description: it is
enough to set:

  zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}'

(or whatever you prefer). No fiddling with the completer style and so
on... unless you want it and you may want it because I couldn't hold
myself back to make this more powerful, see the docs for further
enlightenment. I hope to have made this easy for simple cases and
still as powerful as the _matcher completer. (But note that due to the 
first problem mentioned in 9771 the lookup-name for the first
completer is wrong.)

And the _matcher file can, of course, be removed now.


For writers of completers (real completers, not simple completion
functions): we should now test again if we are using the first matcher 
to avoid executing completers that don't use match specs more than
once. See _approximate, _expand, etc. for an example. I've made the
whole list of matchers, the current matcher and the index into the
array of matchers available via the parameters _matchers, _matcher,
and _matcher_num (the completers, btw. are available as $_completers,
$_completer, and $_completer_num).

Bye
 Sven

diff -ru ../z.old/Completion/Core/_approximate Completion/Core/_approximate
--- ../z.old/Completion/Core/_approximate	Thu Feb 17 10:23:18 2000
+++ Completion/Core/_approximate	Thu Feb 17 10:49:37 2000
@@ -5,12 +5,13 @@
 # shown in a list and one can cycle through them as in a menucompletion
 # or get the corrected prefix.
 
-local _comp_correct _correct_expl comax cfgacc
-local curcontext="${curcontext}" oldcontext opm="$compstate[pattern_match]"
+# We don't try correction if the string is too short or we have tried it
+# already.
 
-# We don't try correction if the string is too short.
+[[ _matcher_num -gt 1 || "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1
 
-[[ "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1
+local _comp_correct _correct_expl comax cfgacc
+local curcontext="${curcontext}" oldcontext opm="$compstate[pattern_match]"
 
 [[ "$curcontext" != [^:]#:correct:* ]] &&
     curcontext="${curcontext/:[^:]#:/:approximate:}"
diff -ru ../z.old/Completion/Core/_description Completion/Core/_description
--- ../z.old/Completion/Core/_description	Thu Feb 17 10:23:18 2000
+++ Completion/Core/_description	Thu Feb 17 10:54:42 2000
@@ -27,7 +27,7 @@
     [[ -z "$gname" ]] && gname="$1"
 zstyle -s ":completion:${curcontext}:$1" matcher match &&
     opts=($opts -M "${(q)match}")
-[[ -n "$_comp_matcher" ]] && opts=($opts -M "${(q)_comp_matcher}")
+[[ -n "$_matcher" ]] && opts=($opts -M "${(q)_matcher}")
 
 if zstyle -a ":completion:${curcontext}:$1" ignored-patterns _comp_ignore; then
   opts=( $opts -F _comp_ignore)
diff -ru ../z.old/Completion/Core/_expand Completion/Core/_expand
--- ../z.old/Completion/Core/_expand	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_expand	Thu Feb 17 10:50:08 2000
@@ -7,6 +7,8 @@
 # the expansions done produce no result or do not change the original
 # word from the line.
 
+[[ _matcher_num -gt 1 ]] && return 1
+
 local exp word="$PREFIX$SUFFIX" sort expr expl subd suf=" "
 local curcontext="${curcontext/:[^:]#:/:expand:}"
 
diff -ru ../z.old/Completion/Core/_list Completion/Core/_list
--- ../z.old/Completion/Core/_list	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_list	Thu Feb 17 10:50:22 2000
@@ -4,6 +4,8 @@
 # insert possible completions only after the list has been shown at
 # least once.
 
+[[ _matcher_num -gt 1 ]] && return 1
+
 local pre suf expr curcontext="${curcontext/:[^:]#:/:list:}"
 
 # Get the strings to compare.
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_main_complete	Thu Feb 17 11:31:12 2000
@@ -20,7 +20,8 @@
 unsetopt markdirs globsubst shwordsplit nounset ksharrays
 
 local comp post ret=1 _compskip format _comp_ignore \
-      _completers _completers_left _comp_matcher \
+      _completers _completer _completer_num \
+      _matchers _matcher _matcher_num \
       context state line opt_args val_args curcontext="$curcontext" \
       _last_nmatches=-1 _last_menu_style _def_menu_style _menu_style sel \
       _saved_exact="${compstate[exact]}" \
@@ -62,14 +63,22 @@
 # And now just call the completer functions defined.
 
 _completers=( "$@" )
-_completers_left=( "$@" )
+_completer_num=1
 
-for comp; do
-  if "$comp"; then
-    ret=0
-    break;
-  fi
-  shift 1 _completers_left
+for _completer; do
+  _matcher="${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}"
+  zstyle -a ":completion:${curcontext/::/:${_matcher}:}:" matcher-list _matchers ||
+      _matchers=( '' )
+
+  _matcher_num=1
+  for _matcher in "$_matchers[@]"; do
+    if "$_completer"; then
+      ret=0
+      break 2
+    fi
+    (( _matcher_num++ ))
+  done
+  (( _completer_num++ ))
 done
 
 if [[ $compstate[nmatches] -gt 1 ]]; then
diff -ru ../z.old/Completion/Core/_match Completion/Core/_match
--- ../z.old/Completion/Core/_match	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_match	Thu Feb 17 10:50:35 2000
@@ -9,6 +9,8 @@
 # expand-or-complete function because otherwise the pattern will
 # be expanded using globbing.
 
+[[ _matcher_num -gt 1 ]] && return 1
+
 local tmp opm="$compstate[pattern_match]" ret=0 orig ins
 local curcontext="${curcontext/:[^:]#:/:match:}"
 
diff -ru ../z.old/Completion/Core/_menu Completion/Core/_menu
--- ../z.old/Completion/Core/_menu	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_menu	Thu Feb 17 10:50:43 2000
@@ -1,5 +1,7 @@
 #autoload
 
+[[ _matcher_num -gt 1 ]] && return 1
+
 local curcontext="${curcontext/:[^:]#:/:menu:}"
 
 # This completer is an example showing how menucompletion can be
diff -ru ../z.old/Completion/Core/_oldlist Completion/Core/_oldlist
--- ../z.old/Completion/Core/_oldlist	Thu Feb 17 10:23:19 2000
+++ Completion/Core/_oldlist	Thu Feb 17 10:50:51 2000
@@ -1,5 +1,7 @@
 #autoload
 
+[[ _matcher_num -gt 1 ]] && return 1
+
 local curcontext="${curcontext/:[^:]#:/:oldlist:}" list
 
 zstyle -s ":completion:${curcontext}:" list list
diff -ru ../z.old/Completion/Core/_prefix Completion/Core/_prefix
--- ../z.old/Completion/Core/_prefix	Thu Feb 17 10:23:21 2000
+++ Completion/Core/_prefix	Thu Feb 17 10:44:02 2000
@@ -4,10 +4,10 @@
 
 [[ -n "$SUFFIX" ]] || return 1
 
-local curcontext="${curcontext/:[^:]#:/:prefix-${(M)#${(@)_completers[1,-$#_completers_left]}:#_prefix}:}" comp i
+local curcontext="${curcontext/:[^:]#:/:prefix-${(M)#_completers[1,_completer_num]:#_prefix}:}" comp i
 
 zstyle -a ":completion:${curcontext}:" completer comp ||
-  comp=( "${(@)_completers[1,-${#_completers_left}-1][(R)_prefix,-1]}" )
+  comp=( "${(@)_completers[1,_completer_num][(R)_prefix,-1]}" )
 
 if zstyle -t ":completion:${curcontext}:" add-space; then
   ISUFFIX=" $SUFFIX"
@@ -16,14 +16,8 @@
 fi
 SUFFIX=''
 
-local _completers _completer_left
-
-_completers=( "$comp[@]" )
-_completers_left=( "$comp[@]" )
-
 for i in "$comp[@]"; do
   [[ "$i" != _prefix ]] && "$i" && return 0
-  shift 1 _completers_left
 done
 
 return 1
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Thu Feb 17 10:23:00 2000
+++ Doc/Zsh/compsys.yo	Thu Feb 17 11:47:02 2000
@@ -1089,11 +1089,50 @@
 ifzman(the section `Matching Control' in zmanref(zshcompwid))\
 ifnzman(noderef(Matching Control))\
 .
-
-This style is also used by the tt(_matcher) completer, see
-ifzman(the section `Control Functions' below)\
-ifnzman(noderef(Control Functions)) 
-for more information.
+)
+item(tt(matcher-list))(
+This style is used by the main completion function to retrieve match
+specifications that are to be used everywhere. Its value should be a
+list of such specifications. The completion system will try them one
+after another for each completer selected. For example, to first try
+simple completion and, if that generates no matches, case-insensitive
+completion one would do:
+
+example(zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')
+
+But the style allows even finer control: the style is looked up for
+every completer tried with the name of the completer (without the
+leading underscore) in the context name. For example, if one uses the
+completers tt(_complete) and tt(_prefix) and wants to try
+case-insensitive completion only when using the tt(_complete)
+completer, one would do:
+
+example(zstyle ':completion:*' completer _complete _prefix
+zstyle ':completion:*:complete*:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')
+
+Note that there is no colon directly after the `tt(complete)'. That's
+because the completion system really uses the name of the completer
+followed by a minus sign and a number in the var(completer) field of
+the context name. This is useful if, for example, one wants to try
+normal completion without a match specification and with
+case-insensitive matching first, correction if that doesn't generate
+any matches and partial-word completion if that doesn't yield any
+matches either. In such a case one can give the tt(_complete)
+completer more than once in the tt(completer) style and give different
+match specification to them, as in:
+
+example(zstyle ':completion:*' completer _complete _correct _complete
+zstyle ':completion:*:complete-1:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}'
+zstyle ':completion:*:complete-2:*' matcher-list \
+    'm:{a-zA-Z}={A-Za-z} r:|[-_./]=* r:|=*')
+
+Note that in any case an unset style makes the completion code use no
+global match specification. Also, some completers (like tt(_correct)
+and tt(_approximate)) do not use the match specifications. But even if 
+such completers are used one can use the simple form to set this style 
+(as in the first example above) because such completers will make sure 
+that they are executed only once even if multiple match specifications 
+have been given.
 )
 item(tt(max-errors))(
 This is used by the tt(_approximate) and tt(_correct) completer functions
@@ -1608,42 +1647,6 @@
 
 Note that the matcher specifications defined globally or used by the
 completion functions will not be used.
-)
-findex(_matcher)
-item(tt(_matcher))(
-This completer allows to define a match specification (see
-ifzman(the section `Matching Control' in zmanref(zshcompwid))\
-ifnzman(noderef(Matching Control))\
-) that is to be used by all following completers. This is comparable
-to the global match specifications that can be defined for the
-tt(compctl) builtin, but gives much better control. The match
-specification to use is looked up using the tt(matcher) style. For
-this, the completer field of the context name will contain the string
-`tt(matcher-)var(n)', where `var(n)' is the number of the call to
-tt(_matcher). For example:
-
-example(zstyle ':completion:::::' completer _matcher _complete _matcher _complete
-zstyle ':completion:*:matcher-1:::' matcher 'm:{a-z-}={A-Z_}'
-zstyle ':completion:*:matcher-2:::' matcher 'm:{a-z-}={A-Z_}' 'r:|[-_./]=* r:|=*')
-
-Since tt(_matcher) is called as the first completer, the tt(_complete) 
-completer called after it will first use the match specification
-`tt(m:{a-z-}={A-Z_})'. If that doesn't generate any matches, the next
-call to tt(_matcher) will make the second call to tt(_complete) use
-the specification `tt(r:|[-_./]=* r:|=*)' in addition to the one
-already used by the first attempt (but note that the specification has 
-to be given again).
-
-If the tt(matcher) style is not set for one of the invocations of
-tt(_matcher), this has the same effect as setting it to the empty
-string: it makes the following completion function not use any match
-specifications besides those used by the functions themselves.
-
-Note that currently only the tt(_complete) completer and the
-tt(_prefix) completer (if it has its own tt(completer) style
-containing tt(_complete)) use the match specifications, so one doesn't 
-need to repeat all completers one wants to use after each call to
-tt(_matcher) in the completer list.
 )
 findex(_expand)
 item(tt(_expand))(

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

