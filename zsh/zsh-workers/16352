From zsh-workers-return-16352-mason-zsh=primenet.com.au@sunsite.dk Mon Dec 17 11:19:26 2001
Return-Path: <zsh-workers-return-16352-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8420 invoked from network); 17 Dec 2001 11:19:24 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 17 Dec 2001 11:19:24 -0000
Received: (qmail 12104 invoked by alias); 17 Dec 2001 11:19:19 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16352
Received: (qmail 12092 invoked from network); 17 Dec 2001 11:19:19 -0000
X-VirusChecked: Checked
X-Authentication-Warning: iris.logica.co.uk: Host kiddleo@rambo.logica.co.uk [158.234.33.58] claimed to be yahoo.co.uk
Sender: kiddleo@iris.logica.co.uk
Message-ID: <3C1DD498.35F6733F@yahoo.co.uk>
Date: Mon, 17 Dec 2001 11:18:48 +0000
From: Oliver Kiddle <okiddle@yahoo.co.uk>
X-Mailer: Mozilla 4.77 [en] (X11; U; Linux 2.2.15 i686)
X-Accept-Language: en
MIME-Version: 1.0
To: zsh-workers@sunsite.dk
Subject: output formats for zcalc
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

I noticed that the to do section of zcalc mentions setting of output
formats. My own zcalc like function[1] already does this so it was easy
enough to move across. Note that this uses printf so won't work on
4.0.

I used syntax that would be familiar to anyone else who used Casio
calculators:
    fix n - set to n fixed decimal places
    sci n - set to n significant figures
    eng n - use engineering notation
    norm  - return to normal

I'd actually prefer a `base' command to set the number base to the zsh
like [#16] stuff and hex, oct, dec, bin shortcuts.

I've also renamed $latest to $ans and removed the part that clears it.
The Ans variable on many calculators is a shortcut to retrieve the last
answer and is useful here as an alternative to looking what number the
last command was.

[1] - My zcalc like function differs from zcalc in that it doesn't have
it's own command-line. I just have a noglob alias to it and use it
directly from the zsh prompt. What would be nice was if zcalc was
adapted to also work in this way so if invoked with parameters, it
would just arithmetically evaluate its arguments and print the result.
$ans should then be left global. And I could then delete my function.

Oliver

Index: Functions/Misc/zcalc
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Misc/zcalc,v
retrieving revision 1.6
diff -u -r1.6 zcalc
--- Functions/Misc/zcalc	2001/12/07 12:59:09	1.6
+++ Functions/Misc/zcalc	2001/12/17 11:13:57
@@ -82,8 +82,6 @@
 # To do:
 # - separate zcalc history from shell history using arrays --- or allow
 #   zsh to switch internally to and from array-based history.
-# - allow setting number of decimal places for display, scientific notation, 
-#   etc.
 
 emulate -L zsh
 setopt extendedglob
@@ -107,9 +105,11 @@
 }
 trap zcalc_restore HUP INT QUIT EXIT
 
-local line latest base defbase match mbegin mend psvar optlist opt arg
-integer num
+local line ans base defbase forms match mbegin mend psvar optlist opt arg
+integer num outdigits outform=1
 
+forms=( '%2$g' '%.*g' '%.*f' '%.*E' )
+
 zmodload -i zsh/mathfunc 2>/dev/null
 
 : ${ZCALCPROMPT="%1v> "}
@@ -178,30 +178,53 @@
   else
     base=$defbase
   fi
-  # Exit if `q' on its own.
-  [[ $line = [[:blank:]]#q[[:blank:]]# ]] && return 0
 
   print -s -- $line
-  if [[ $line = [[:blank:]]#local([[:blank:]]##*|) ]]; then
-    eval $line
-  else
+
+  case ${${line##[[:blank:]]#}%%[[:blank:]]#} in
+    q) # Exit if `q' on its own.
+      return 0
+    ;;
+    norm) # restore output format to default
+      outform=1
+    ;;
+    sci[[:blank:]]#(#b)(<->)(#B))
+      outdigits=$match[1]
+      outform=2
+    ;;
+    fix[[:blank:]]#(#b)(<->)(#B))
+      outdigits=$match[1]
+      outform=3
+    ;;
+    eng[[:blank:]]#(#b)(<->)(#B))
+      outdigits=$match[1]
+      outform=4
+    ;;
+    local([[:blank:]]##*|))
+      eval $line
+      line=
+      continue
+    ;;
+    *)
     # Latest value is stored as a string, because it might be floating
     # point or integer --- we don't know till after the evaluation, and
     # arrays always store scalars anyway.
     # 
     # Since it's a string, we'd better make sure we know which
     # base it's in, so don't change that until we actually print it.
-    latest=
-    eval "latest=\$(( $line ))"
-    # on error $latest is not set; let user re-edit line
-    [[ -n $latest ]] || continue
-    argv[num++]=$latest
+    eval "ans=\$(( $line ))"
+    # on error $ans is not set; let user re-edit line
+    [[ -n $ans ]] || continue
+    argv[num++]=$ans
     psvar[1]=$num
-    if [[ -z $base ]]; then
-      print -- $latest
-    else
-      print -- $(( $base $latest ))
-    fi
+    ;;
+  esac
+  if [[ -n $base ]]; then
+    print -- $(( $base $ans ))
+  elif [[ $ans = *.* ]] || (( outdigits )); then
+    printf "$forms[outform]\n" $outdigits $ans
+  else
+    printf "%d\n" $ans
   fi
   line=
 done

_____________________________________________________________________
This message has been checked for all known viruses by the 
MessageLabs Virus Scanning Service. For further information visit
http://www.messagelabs.com/stats.asp

