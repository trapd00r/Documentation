From zsh-workers-return-6901-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jun 29 06:56:44 1999
Return-Path: <zsh-workers-return-6901-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6268 invoked from network); 29 Jun 1999 06:56:43 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Jun 1999 06:56:43 -0000
Received: (qmail 21576 invoked by alias); 29 Jun 1999 06:56:03 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6901
Received: (qmail 21569 invoked from network); 29 Jun 1999 06:56:02 -0000
Date: Tue, 29 Jun 1999 08:56:01 +0200 (MET DST)
Message-Id: <199906290656.IAA18345@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: that execution stuff


Ok, I couldn't hold myself back...

This tries to get the always-pgrp-behavior back without losing the
other things that were fixed in the meanwhile. Now please test your
favorite execution bugs everyone and tell me what does not work.

I don't need to point out that `while true; do gzip ...; done' is not
expected to be ^C'able again, do I? Maybe we should document this?
(Together with the ^Z/fg/^C-trick?)

Bye
 Sven

diff -u os/exec.c Src/exec.c
--- os/exec.c	Mon Jun 28 16:18:30 1999
+++ Src/exec.c	Mon Jun 28 22:03:09 1999
@@ -2210,9 +2210,8 @@
 		    attachtty(jobtab[thisjob].gleader);
 	    }
 	}
-	else if (!(list_pipe || list_pipe_child || pline_level > 1) &&
-		 (!jobtab[thisjob].gleader ||
-		  setpgrp(0L, jobtab[thisjob].gleader) == -1)) {
+	else if (!jobtab[thisjob].gleader ||
+		 setpgrp(0L, jobtab[thisjob].gleader) == -1) {
 	    jobtab[thisjob].gleader = getpid();
 	    if (list_pipe_job != thisjob &&
 		!jobtab[list_pipe_job].gleader)
diff -u os/init.c Src/init.c
--- os/init.c	Mon Jun 28 16:18:31 1999
+++ Src/init.c	Mon Jun 28 20:38:26 1999
@@ -390,16 +390,7 @@
 #ifdef JOB_CONTROL
     /* If interactive, make the shell the foreground process */
     if (opts[MONITOR] && interact && (SHTTY != -1)) {
-      /* Since we now sometimes execute programs in the process group
-       * of the parent shell even when using job-control, we have to
-       * make sure that we run in our own process group. Otherwise if
-       * we are called from a program that doesn't put us in our own
-       * group a SIGTSTP that we ignore might stop our parent process.
-       * Instead of the two calls below we once had:
-       *   attachtty(GETPGRP());
-       */
-	attachtty(getpid());
-	setpgrp(0L, 0L);
+	attachtty(GETPGRP());
 	if ((mypgrp = GETPGRP()) > 0) {
 	    while ((ttpgrp = gettygrp()) != -1 && ttpgrp != mypgrp) {
 		sleep(1);
diff -u os/jobs.c Src/jobs.c
--- os/jobs.c	Mon Jun 28 16:18:31 1999
+++ Src/jobs.c	Mon Jun 28 21:52:44 1999
@@ -800,7 +800,7 @@
 		    if (!p) {
 			jn->stat &= ~STAT_SUPERJOB;
 			if (WIFEXITED(jn->procs->status) &&
-			    !(jn->stat & STAT_CURSH))
+			    killpg(jn->gleader, 0) == -1)
 			    jn->gleader = mypgrp;
 			/* This deleted the job too early if the parent
 			   shell waited for a command in a list that will

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

