From zsh-workers-request@euclid.skiles.gatech.edu Sat Mar 22 16:43:09 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 6478 invoked from network); 22 Mar 1997 16:43:06 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 22 Mar 1997 16:43:06 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id LAA14003; Sat, 22 Mar 1997 11:34:13 -0500 (EST)
Resent-Date: Sat, 22 Mar 1997 11:34:13 -0500 (EST)
Date: Sat, 22 Mar 1997 16:36:50 GMT
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <13339.199703221636@stone.dcs.warwick.ac.uk>
Subject: recursive ZLE
X-Patch: 218
Resent-Message-ID: <"jPwsd1.0.kQ3.5e0Dp"@euclid>
To: zsh-workers@math.gatech.edu
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3013
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

This patch fixes the handling of a couple of variables concerning what
can be done from within ZLE.

The inzlefunc variable is used in bin_read() as an indicator that it is
being called from within a compctl -K function, and can therefore look
at line and clwords.  I rename it to incompctlfunc, as this is now not
the only way a function can be called from ZLE.  I also use it to stop
widgets being called from such functions (when it would be bad to change
the contents of the line).

Some checks of zleactive are used, to avoid trouble with calling ZLE
recursively.  (I plan to actually make ZLE reentrant in a future patch.)
I made zleread() execute essentially the fallback_zleread() code if it is
called recursively.  vared, because it relies very much on editing a line
that starts off non-empty, now complains if it is called from within ZLE.

The mechanism to disable history references in ZLE -- set in_vared,
call zleread(), and then reset it -- is changed, adding a third
parameter to zleread() to make it more convenient.  select used to
allow history recall.  I also renamed the variable to histallowed
(reversing its sense), and moved it into the zle module (as it is no
longer referenced elsewhere).

Bits of this depend on my widget patch (3002), and on the patch to make
module autoloading be attempted only once (3010).

 -zefram

 *** Src/builtin.c	1997/03/20 13:52:35	1.63
 --- Src/builtin.c	1997/03/22 00:52:12
 ***************
 *** 2792,2801 ****
   
       /* option -l is used in compctl functions */
       if (ops['l']) {
 ! 	/* only allowed to be called by ZLE */
 ! 	if (!inzlefunc) {
 ! 	    zwarnnam(name, "option valid only in functions called from zle",
 ! 		     NULL, 0);
   	    return 1;
   	}
   	/* -ln gives the index of the word the cursor is currently on, which is
 --- 2792,2802 ----
   
       /* option -l is used in compctl functions */
       if (ops['l']) {
 ! 	/* only allowed to be called for completion */
 ! 	if (!incompctlfunc) {
 ! 	    zwarnnam(name,
 ! 		    "option valid only in functions called for completion",
 ! 		    NULL, 0);
   	    return 1;
   	}
   	/* -ln gives the index of the word the cursor is currently on, which is
 ***************
 *** 2826,2835 ****
       if (ops['c']) {
   	int i;
   
 ! 	/* only allowed to be called by ZLE */
 ! 	if (!inzlefunc) {
 ! 	    zwarnnam(name, "option valid only in functions called from zle",
 ! 		     NULL, 0);
   	    return 1;
   	}
   	/* -cn gives the current cursor position within the current word, which
 --- 2827,2837 ----
       if (ops['c']) {
   	int i;
   
 ! 	/* only allowed to be called for completion */
 ! 	if (!incompctlfunc) {
 ! 	    zwarnnam(name,
 ! 		    "option valid only in functions called for completion",
 ! 		    NULL, 0);
   	    return 1;
   	}
   	/* -cn gives the current cursor position within the current word, which
 *** Src/globals.h	1997/03/17 00:38:08	1.36
 --- Src/globals.h	1997/03/22 01:17:09
 ***************
 *** 528,539 ****
   EXTERN int clwsize, clwnum, clwpos;
   EXTERN char **clwords;
   
 ! /* != 0 if we're in vared */
 ! 
 ! EXTERN int in_vared;
 ! 
 ! /* != 0 if executing a shell function called from zle */
 ! EXTERN int inzlefunc;
   
   /* != 0 if the line editor is active */
   EXTERN int zleactive;
 --- 528,536 ----
   EXTERN int clwsize, clwnum, clwpos;
   EXTERN char **clwords;
   
 ! /* != 0 if in a shell function called from completion, such that read -[cl]  *
 !  * will work (i.e., the line is metafied, and the above word arrays are OK). */
 ! EXTERN int incompctlfunc;
   
   /* != 0 if the line editor is active */
   EXTERN int zleactive;
 ***************
 *** 574,580 ****
   
   typedef void (*ZleVoidFn) _((void));
   typedef void (*ZleVoidIntFn) _((int));
 ! typedef unsigned char * (*ZleReadFn) _((char *, char *));
   
   extern ZleVoidFn trashzleptr, gotwordptr, refreshptr;
   extern ZleVoidIntFn spaceinlineptr;
 --- 571,577 ----
   
   typedef void (*ZleVoidFn) _((void));
   typedef void (*ZleVoidIntFn) _((int));
 ! typedef unsigned char * (*ZleReadFn) _((char *, char *, int));
   
   extern ZleVoidFn trashzleptr, gotwordptr, refreshptr;
   extern ZleVoidIntFn spaceinlineptr;
 *** Src/init.c	1997/03/20 13:52:38	1.42
 --- Src/init.c	1997/03/22 01:19:02
 ***************
 *** 814,831 ****
   
   /**/
   unsigned char *
 ! autoload_zleread(char *lp, char *rp)
   {
       zlereadptr = fallback_zleread;
       load_module("zle");
 !     return zleread(lp, rp);
   }
   
   # endif /* UNLINKED_XMOD_zle */
   
   /**/
   unsigned char *
 ! fallback_zleread(char *lp, char *rp)
   {
       char *pptbuf;
       int pptlen;
 --- 814,831 ----
   
   /**/
   unsigned char *
 ! autoload_zleread(char *lp, char *rp, int ha)
   {
       zlereadptr = fallback_zleread;
       load_module("zle");
 !     return zleread(lp, rp, ha);
   }
   
   # endif /* UNLINKED_XMOD_zle */
   
   /**/
   unsigned char *
 ! fallback_zleread(char *lp, char *rp, int ha)
   {
       char *pptbuf;
       int pptlen;
 *** Src/input.c	1997/01/29 03:25:16	1.18
 --- Src/input.c	1997/03/22 01:19:15
 ***************
 *** 226,232 ****
   	}
   	ingetcline = (unsigned char *)shingetline();
       } else
 ! 	ingetcline = zleread((char *)ingetcpmptl, (char *)ingetcpmptr);
       if (!ingetcline) {
   	return lexstop = 1;
       }
 --- 226,232 ----
   	}
   	ingetcline = (unsigned char *)shingetline();
       } else
 ! 	ingetcline = zleread((char *)ingetcpmptl, (char *)ingetcpmptr, 1);
       if (!ingetcline) {
   	return lexstop = 1;
       }
 *** Src/loop.c	1997/03/04 00:40:12	1.10
 --- Src/loop.c	1997/03/22 01:19:22
 ***************
 *** 145,151 ****
   	    selectlist(args);
   	    if (empty(bufstack)) {
   	    	if (interact && SHTTY != -1 && isset(USEZLE))
 ! 		    str = (char *)zleread(prompt3, NULL);
   	    	else {
   		    int pptlen;
   		    str = putprompt(prompt3, &pptlen, NULL, 1);
 --- 145,151 ----
   	    selectlist(args);
   	    if (empty(bufstack)) {
   	    	if (interact && SHTTY != -1 && isset(USEZLE))
 ! 		    str = (char *)zleread(prompt3, NULL, 0);
   	    	else {
   		    int pptlen;
   		    str = putprompt(prompt3, &pptlen, NULL, 1);
 *** Src/utils.c	1997/03/17 14:23:42	1.66
 --- Src/utils.c	1997/03/22 00:26:20
 ***************
 *** 569,575 ****
       int period = getiparam("PERIOD");
       int mailcheck = getiparam("MAILCHECK");
   
 -     in_vared = 0;
       /* If NOTIFY is not set, then check for completed *
        * jobs before we print the prompt.               */
       if (unset(NOTIFY))
 --- 569,574 ----
 *** Src/zsh.h	1997/03/17 14:23:44	1.47
 --- Src/zsh.h	1997/03/22 01:18:08
 ***************
 *** 40,46 ****
   
   #ifndef IN_ZLE
   # define trashzle()      trashzleptr()
 ! # define zleread(X,Y)    zlereadptr(X,Y)
   # define spaceinline(X)  spaceinlineptr(X)
   # define gotword()       gotwordptr()
   # define refresh()       refreshptr()
 --- 40,46 ----
   
   #ifndef IN_ZLE
   # define trashzle()      trashzleptr()
 ! # define zleread(X,Y,H)  zlereadptr(X,Y,H)
   # define spaceinline(X)  spaceinlineptr(X)
   # define gotword()       gotwordptr()
   # define refresh()       refreshptr()
 *** Src/Zle/zle.h	1997/03/18 23:56:48	1.22
 --- Src/Zle/zle.h	1997/03/22 01:22:43
 ***************
 *** 81,86 ****
 --- 81,90 ----
   /* Hashtable of thingies.  Enabled nodes are those that refer to widgets. */
   ZLEXTERN HashTable thingytab;
   
 + /* Are references to earlier history lines permitted?  == 0 if       *
 +  * editing or reading a standalone line, such as in vared or select. */
 + ZLEXTERN int histallowed;
 + 
   /* size of line buffer */
   ZLEXTERN int linesz;
   
 *** Src/Zle/zle_hist.c	1997/03/19 15:47:08	1.14
 --- Src/Zle/zle_hist.c	1997/03/22 01:23:04
 ***************
 *** 101,107 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 101,107 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 ***************
 *** 143,149 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 143,149 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 ***************
 *** 181,187 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 181,187 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 ***************
 *** 225,231 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 225,231 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 ***************
 *** 267,273 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 267,273 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 ***************
 *** 304,310 ****
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || in_vared) {
   	    feep();
   	    return;
   	}
 --- 304,310 ----
   	int m = zmult;
   
   	cs = ocs;
 ! 	if (virangeflag || !histallowed) {
   	    feep();
   	    return;
   	}
 *** Src/Zle/zle_main.c	1997/03/22 00:05:19	1.28
 --- Src/Zle/zle_main.c	1997/03/22 01:20:51
 ***************
 *** 320,326 ****
   
   /**/
   unsigned char *
 ! zleread(char *lp, char *rp)
   {
       unsigned char *s;
       int old_errno = errno;
 --- 320,326 ----
   
   /**/
   unsigned char *
 ! zleread(char *lp, char *rp, int ha)
   {
       unsigned char *s;
       int old_errno = errno;
 ***************
 *** 336,341 ****
 --- 336,354 ----
       tv.tv_sec = 0;
   #endif
   
 +     /* ZLE doesn't currently work recursively.  This is needed in case a *
 +      * select loop is used in a function called from ZLE.  vared handles *
 +      * this differently itself.                                          */
 +     if(zleactive) {
 + 	char *pptbuf;
 + 	int pptlen;
 + 
 + 	pptbuf = putprompt(lp, &pptlen, NULL, 1);
 + 	write(2, (WRITE_ARG_2_T)pptbuf, pptlen);
 + 	free(pptbuf);
 + 	return (unsigned char *)shingetline();
 +     }
 + 
       keytimeout = getiparam("KEYTIMEOUT");
       if (!shout) {
   	if (SHTTY != -1)
 ***************
 *** 358,363 ****
 --- 371,377 ----
       resetneeded = 0;
       lpmpt = lp;
       rpmpt = rp;
 +     histallowed = ha;
       PERMALLOC {
   	histline = curhist;
   #ifdef HAVE_SELECT
 ***************
 *** 499,507 ****
   	    zsfree(msg);
   	    feep();
   	} else {
 - 	  inzlefunc++;
   	  doshfunc(l, NULL, 0, 1);
 - 	  inzlefunc--;
   	  lastcmd = 0;
   	}
       }
 --- 513,519 ----
 ***************
 *** 624,636 ****
   	    return 1;
   	}
       }
       /* edit the parameter value */
       PERMALLOC {
   	pushnode(bufstack, ztrdup(s));
       } LASTALLOC;
 !     in_vared = !ops['h'];
 !     t = (char *) zleread(p1, p2);
 !     in_vared = 0;
       if (!t || errflag) {
   	/* error in editing */
   	errflag = 0;
 --- 636,652 ----
   	    return 1;
   	}
       }
 + 
 +     if(zleactive) {
 + 	zwarnnam(name, "ZLE cannot be used recursively (yet)", NULL, 0);
 + 	return 1;
 +     }
 + 
       /* edit the parameter value */
       PERMALLOC {
   	pushnode(bufstack, ztrdup(s));
       } LASTALLOC;
 !     t = (char *) zleread(p1, p2, ops['h']);
       if (!t || errflag) {
   	/* error in editing */
   	errflag = 0;
 *** Src/Zle/zle_thingy.c	1997/03/19 15:47:10	1.4
 --- Src/Zle/zle_thingy.c	1997/03/22 00:53:23
 ***************
 *** 449,456 ****
   {
       Thingy t;
   
 !     if(!inzlefunc) {
 ! 	zerrnam(name, "widgets can only be called when zle is active",
   	    NULL, 0);
   	return 1;
       }
 --- 449,456 ----
   {
       Thingy t;
   
 !     if(!zleactive || incompctlfunc) {
 ! 	zerrnam(name, "widgets can only be called when ZLE is active",
   	    NULL, 0);
   	return 1;
       }
 *** Src/Zle/zle_tricky.c	1997/03/22 00:05:20	1.24
 --- Src/Zle/zle_tricky.c	1997/03/22 00:52:32
 ***************
 *** 2732,2741 ****
   	    }
   
   	    /* This flag allows us to use read -l and -c. */
 ! 	    inzlefunc++;
   	    /* Call the function. */
   	    doshfunc(list, args, 0, 1);
 ! 	    inzlefunc--;
   	    /* And get the result from the reply parameter. */
   	    if ((r = get_user_var("reply")))
   		while (*r)
 --- 2732,2741 ----
   	    }
   
   	    /* This flag allows us to use read -l and -c. */
 ! 	    incompctlfunc = 1;
   	    /* Call the function. */
   	    doshfunc(list, args, 0, 1);
 ! 	    incompctlfunc = 0;
   	    /* And get the result from the reply parameter. */
   	    if ((r = get_user_var("reply")))
   		while (*r)

-----BEGIN PGP SIGNATURE-----
Version: 2.6.3ia
Charset: ascii

iQCVAwUBMzM72XD/+HJTpU/hAQHEzwQAoJPEl3JCDHxCjz8m/W3FAbRPGjJYWdks
O1Un4tRD+eWO8fUhRqDKsNBi41TTIprErXk+SI8F0sdBugDKiEsDLZ0BoXYSnPB2
cQJXALNUkvJios+reRVcHlDnvXaSAvibFQHeGpe/lCQJ6KwFvDog1fFTOjaI9aYR
KIIGbkQgVPQ=
=qVJe
-----END PGP SIGNATURE-----

