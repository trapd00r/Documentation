From zsh-workers-return-10801-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Apr 18 07:35:01 2000
Return-Path: <zsh-workers-return-10801-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4908 invoked from network); 18 Apr 2000 07:34:58 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Apr 2000 07:34:58 -0000
Received: (qmail 867 invoked by alias); 18 Apr 2000 07:34:52 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10801
Received: (qmail 860 invoked from network); 18 Apr 2000 07:34:52 -0000
Date: Tue, 18 Apr 2000 09:34:49 +0200 (MET DST)
Message-Id: <200004180734.JAA19474@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Mon, 17 Apr 2000 14:01:39 +0100
Subject: Re: PATCH: scrolling completion lists (was: Re: Questions)


Peter Stephenson wrote:

>
> ...
> 
> Maybe select-prompt is more consistent than select-status, which implies a
> returned value, although it should be the same as the parameter.
> 
> It occurs to me that you can display other stuff in this prompt, e.g. info
> about the currently selected file in menu-select mode.  But that's nothing
> to do with scrolling.

>:-> yesssss...


Anyway, this patch:

- Removes the (unused) `st' capability from ZLS_COLO(|U)RS.
- Renames LISTSTATUS to LISTPROMPT and SELECTSTATUS to SELECTPROMPT.
- Adds the styles list-prompt, select-prompt and select-scroll as an
  interface to the underlying parameters. All are tested (only) with
  the default tag.
  select-prompt has the default value suggested by Peter and
  list-prompt also turns on list-scrolling (and loads complist).
- Finally, the patch adds the `listscroll' keymap that is used when
  listing a completion lists that is too big for the screen and the
  shell is waiting at the list-prompt. It has some default bindings,
  but of course one can now use whatever keys one wants.


Bye
 Sven

Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.6
diff -u -r1.6 _zstyle
--- Completion/Builtins/_zstyle	2000/04/17 08:22:44	1.6
+++ Completion/Builtins/_zstyle	2000/04/18 07:32:43
@@ -41,6 +41,7 @@
   list			 c:listwhen
   list-colors		 c:
   list-packed		 c:bool
+  list-prompt            c:
   list-rows-first	 c:bool
   local			 c:
   matcher-list		 c:
@@ -55,6 +56,8 @@
   prefix-needed		 c:bool
   prompt		 c:
   remove-all-dups	 c:bool
+  select-prompt          c:
+  select-scroll          c:
   single-ignored         c:single-ignored
   sort			 c:bool
   special-dirs		 c:sdirs
Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.6
diff -u -r1.6 _main_complete
--- Completion/Core/_main_complete	2000/04/12 09:28:57	1.6
+++ Completion/Core/_main_complete	2000/04/18 07:32:43
@@ -56,6 +56,16 @@
                 )
 _last_menu_style=()
 
+if zstyle -s ":completion:${curcontext}:default" list-prompt LISTPROMPT &&
+   [[ -n "$LISTPROMPT" ]]; then
+  zmodload -i zsh/complist
+  compstate[list_max]=scroll
+fi
+zstyle -s ":completion:${curcontext}:default" select-prompt SELECTPROMPT ||
+    SELECTPROMPT='%SScrolling active: current selection at %p'
+zstyle -s ":completion:${curcontext}:default" select-scroll SELECTSCROLL ||
+    SELECTSCROLL=1
+
 # Get the names of the completers to use in the positional parameters.
 
 if (( $# )); then
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.18
diff -u -r1.18 compsys.yo
--- Doc/Zsh/compsys.yo	2000/04/17 08:22:44	1.18
+++ Doc/Zsh/compsys.yo	2000/04/18 07:32:44
@@ -1267,6 +1267,19 @@
 tt(LIST_PACKED) option were set for them. If it is set to `false',
 they are listed normally.
 )
+kindex(list-prompt, completion style)
+item(tt(list-prompt))(
+If this style is set to a non-empty value for the tt(default) tag,
+completion lists that don't fit on the screen can be scrolled (see
+ifzman(the description of the tt(zsh/complist) module in zmanref(zshmodules))\
+ifnzman(noderef(The zsh/complist Module))\
+). The value will be displayed after every screenful, prompting for a
+key and may contain the escape `tt(%l)' which will be replaced by the
+number of the last line displayed and the total number of lines. As
+usual, the `tt(%S)', `tt(%s)', `tt(%B)', `tt(%b)', `tt(%U)', `tt(%u)',
+and `tt(%{)...tt(%})' escapes for the terminal display modes are
+understood, too.
+)
 kindex(list-rows-first, completion style)
 item(tt(list-rows-first))(
 This style is tested like the tt(list-packed) style and determines if
@@ -1558,6 +1571,28 @@
 The tt(_history_complete_word) bindable command uses this to decide if 
 all duplicate matches should be removed, rather than just consecutive
 duplicates.
+)
+kindex(select-prompt, completion style)
+item(tt(select-prompt))(
+If this is set to a non-empty string for the tt(default) tag, its
+value will be displayed during menu-selection (see the tt(menu) style
+above) when the completion list does not fit on the screen as a
+whole. The same escapes as for the tt(list-prompt) style are
+understood, plus `tt(%m)' which is replaced by the number of the
+currently selected match and the total number of matches and `tt(%p)'
+which is replaced by `tt(Top)' when the mark is on the first line,
+`tt(Bottom)' when it is on the last line and the relative position of
+the mark in the list given as a percentage.
+)
+kindex(select-scroll, completion style)
+item(tt(select-scroll))(
+This style is tested for the tt(default) tag and determines how a
+completion list is scrolled during a menu-selection (see the tt(menu)
+style above) when the completion list does not fit on the screen as a
+whole. Its value should be `tt(0)' (zero) to scroll by
+half-screenfuls, a positive integer to scroll by that many lines and a
+negative number to scroll by the number of lines of the screen minus
+that number (or plus the number, since it is negative).
 )
 kindex(single-ignored, completion style)
 item(tt(single-ignored))(
Index: Doc/Zsh/compwid.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compwid.yo,v
retrieving revision 1.4
diff -u -r1.4 compwid.yo
--- Doc/Zsh/compwid.yo	2000/04/12 09:12:16	1.4
+++ Doc/Zsh/compwid.yo	2000/04/18 07:32:45
@@ -247,7 +247,7 @@
 vindex(list_max, compstate)
 item(tt(list_max))(
 Initially this is set to the value of the tt(LISTMAX) parameter.
-It may be set to any other numeric value; when the widget exits this value
+It may be set to any other value; when the widget exits this value
 will be used in the same way as the value of tt(LISTMAX).
 )
 vindex(list_lines, compstate)
Index: Doc/Zsh/mod_complist.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_complist.yo,v
retrieving revision 1.2
diff -u -r1.2 mod_complist.yo
--- Doc/Zsh/mod_complist.yo	2000/04/17 11:17:10	1.2
+++ Doc/Zsh/mod_complist.yo	2000/04/18 07:32:46
@@ -133,26 +133,30 @@
 parameter has to be set to the string `tt(scroll)'. If it has this
 value, the completion code will not ask if the list should be
 shown. Instead it immediately starts displaying the list, stopping
-after the first screenful, showing a simple prompt at the bottom,
-waiting for a keypress. The following keys have a special meaning:
+after the first screenful, showing a prompt at the bottom,
+waiting for a keypress after temporarily switching to the
+tt(listscroll) keymap. Some of the zle functions have special meaning:
 
 startitem()
-item(tt(Space), tt(Tab))(
-scroll forward one screenful
+item(tt(send-break))(
+stops listing discarding the key pressed
 )
-item(tt(Return), tt(Newline))(
-scroll forward one line
+xitem(tt(accept-line), tt(down-history), tt(down-line-or-history))
+item(tt(down-line-or-search), tt(vi-down-line-or-history))(
+scrolls forward one line
 )
-item(tt(q))(
-stops listing and redisplays the command line without inserting the
-`tt(q)'
+item(tt(complete-word), tt(menu-complete), tt(expand-or-complete))(
+item(tt(expand-or-complete-prefix), tt(menu-complete-or-expand))(
+scrolls forward one screenful
 )
 enditem()
 
 Every other character stops listing and immediately processes the key
-as usual.
+as usual. Any key that is not bound in the tt(listscroll) keymap or
+that is bound to tt(undefined-key) is looked up in the keymap
+currently selected.
 
-If the parameter tt(LISTSTATUS) is set, its value will be used as the
+If the parameter tt(LISTPROMPT) is set, its value will be used as the
 prompt.  The value may contain escapes of the form `tt(%x)'. It
 supports the escapes `tt(%B)', `tt(%b)', `tt(%S)', `tt(%s)', `tt(%U)',
 `tt(%u)' and `tt(%{...%})' known from the shell prompts and the
@@ -160,6 +164,11 @@
 last line shown and the total number of lines in the form
 `var(number)tt(/)var(total)'.
 
+As for the tt(ZLS_COLORS) and tt(ZLS_COLOURS) parameters,
+tt(LISTPROMPT) should not be set directly when using the shell
+function based completion system. Instead, the tt(list-prompt) style
+should be used.
+
 subsect(Menu selection)
 cindex(completion, selecting by cursor)
 vindex(SELECTMIN)
@@ -197,9 +206,9 @@
 control sequence as for the `tt(%S)' escape in prompts is used.
 
 If there are more matches than fit on the screen and the parameter
-tt(SELECTSTATUS) is set, its value will be shown below the
+tt(SELECTPROMPT) is set, its value will be shown below the
 matches. Next to the escape sequences understood for the
-tt(LISTSTATUS) parameter, a `tt(%m)' will be replaced by a string
+tt(LISTPROMPT) parameter, a `tt(%m)' will be replaced by a string
 containing the number of the match the mark is on and the total number 
 of matches in the form `var(number)tt(/)var(total)' and the sequence
 `tt(%p)' will be replaced with `tt(Top)', `tt(Bottom)' or the position
@@ -210,8 +219,14 @@
 scrolled. If the parameter is unset, this is done line by line, if it
 is set to `tt(0)' (zero), the list will scrolled half the number of
 lines of the screen. If the value is positive, it gives the number of
-lines to scroll and if it is negative, the list will be scrolled one
+lines to scroll and if it is negative, the list will be scrolled
 the number of lines of the screen minus the (absolute) value.
+
+As for the tt(ZLS_COLORS), tt(ZLS_COLOURS) and tt(LISTPROMPT)
+parameters, neither tt(SELECTPROMPT) nor tt(SELECTSCROLL) should be
+set directly when using the shell function based completion
+system. Instead, the tt(select-prompt) and tt(select-scroll) styles
+should be used.
 
 The completion code sometimes decides not to show all of the matches
 in the list. These hidden matches are either matches for which the
Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.2
diff -u -r1.2 complist.c
--- Src/Zle/complist.c	2000/04/17 11:17:10	1.2
+++ Src/Zle/complist.c	2000/04/18 07:32:46
@@ -37,7 +37,7 @@
 
 
 static Widget w_menuselect;
-static Keymap mskeymap;
+static Keymap mskeymap, lskeymap;
 
 /* Indixes into the terminal string arrays. */
 
@@ -59,9 +59,8 @@
 #define COL_MA 15
 #define COL_HI 16
 #define COL_DU 17
-#define COL_ST 18
 
-#define NUM_COLS 19
+#define NUM_COLS 18
 
 /* Maximum number of in-string colours supported. */
 
@@ -71,14 +70,14 @@
 
 static char *colnames[] = {
     "no", "fi", "di", "ln", "pi", "so", "bd", "cd", "ex", "mi",
-    "lc", "rc", "ec", "tc", "sp", "ma", "hi", "du", "st", NULL
+    "lc", "rc", "ec", "tc", "sp", "ma", "hi", "du", NULL
 };
 
 /* Default values. */
 
 static char *defcols[] = {
     "0", "0", "1;34", "1;36", "33", "1;35", "1;33", "1;33", "1;32", NULL,
-    "\033[", "m", NULL, "0", "0", "7", "0", "0", "7"
+    "\033[", "m", NULL, "0", "0", "7", "0", "0"
 };
 
 /* This describes a terminal string for a file type. */
@@ -347,12 +346,9 @@
 	
 	if ((s = tcstr[TCSTANDOUTBEG]) && s[0]) {
 	    c->files[COL_MA] = filecol(s);
-	    c->files[COL_ST] = filecol(s);
 	    c->files[COL_EC] = filecol(tcstr[TCSTANDOUTEND]);
-	} else {
+	} else
 	    c->files[COL_MA] = filecol(defcols[COL_MA]);
-	    c->files[COL_ST] = filecol(defcols[COL_ST]);
-	}
 	lr_caplen = 0;
 	if ((max_caplen = strlen(c->files[COL_MA]->col)) <
 	    (l = strlen(c->files[COL_EC]->col)))
@@ -657,32 +653,46 @@
 static int
 asklistscroll(int ml)
 {
-    int v, i;
+    Thingy cmd;
+    int i, ret = 0;
 
     compprintfmt(NULL, -1, 1, 1, ml, NULL);
 
     fflush(shout);
     zsetterm();
-    v = getzlequery(0);
+    selectlocalmap(lskeymap);
+    if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak))
+	ret = 1;
+    else if (cmd == Th(z_acceptline) ||
+	     cmd == Th(z_downhistory) ||
+	     cmd == Th(z_downlineorhistory) ||
+	     cmd == Th(z_downlineorsearch) ||
+	     cmd == Th(z_vidownlineorhistory))
+	mrestlines = 1;
+    else if (cmd == Th(z_completeword) ||
+		   cmd == Th(z_expandorcomplete) ||
+		   cmd == Th(z_expandorcompleteprefix) ||
+		   cmd == Th(z_menucomplete) ||
+		   cmd == Th(z_menuexpandorcomplete) ||
+		   !strcmp(cmd->nam, "menu-select") ||
+		   !strcmp(cmd->nam, "complete-word") ||
+		   !strcmp(cmd->nam, "expand-or-complete") ||
+		   !strcmp(cmd->nam, "expand-or-complete-prefix") ||
+		   !strcmp(cmd->nam, "menu-complete") ||
+	     !strcmp(cmd->nam, "menu-expand-or-complete"))
+	mrestlines = lines - 1;
+    else {
+	ungetkeycmd();
+	ret = 1;
+    }
+    selectlocalmap(NULL);
     settyinfo(&shttyinfo);
     putc('\r', shout);
     for (i = columns - 1; i--; )
 	putc(' ', shout);
-
     putc('\r', shout);
-
-    if (v == '\n' || v == '\r') {
-	mrestlines = 1;
-	return 0;
-    }
-    mrestlines = lines - 1;
 
-    if (v == ' ' || v == '\t')
-	return 0;
-    if (v != 'q')
-	ungetkey(v);
-
-    return 1;
+    return ret;
 }
 
 #define dolist(X)   ((X) >= mlbeg && (X) < mlend)
@@ -720,8 +730,8 @@
 	    if (!(fmt = mstatus))
 		return 0;
 	    cc = -1;
-	} else if (!(fmt = getsparam("LISTSTATUS")))
-	    fmt = "continue? ";
+	} else if (!(fmt = getsparam("LISTPROMPT")))
+	    fmt = "Continue? ";
     }
     for (p = fmt; *p; p++) {
 	if (doesc && *p == '%') {
@@ -1417,7 +1427,7 @@
     mscroll = 0;
 
     if (mselect >= 0 || mlbeg >= 0 ||
-	((p = getsparam("LISTMAX")) && !strcmp(p, "scroll"))) {
+	((p = complistmax) && !strcmp(p, "scroll"))) {
 	trashzle();
 	showinglist = listshown = 0;
 
@@ -1536,8 +1546,8 @@
 	    if ((step += lines - nlnct) < 0)
 		step = 1;
     }
-    mstatus = getsparam("SELECTSTATUS");
-    mhasstat = !!mstatus;
+    mstatus = getsparam("SELECTPROMPT");
+    mhasstat = (mstatus && *mstatus);
     fdat = dat;
     selectlocalmap(mskeymap);
     noselect = 0;
@@ -2054,6 +2064,14 @@
     bindkey(mskeymap, "\33OB",  refthingy(t_downlineorhistory), NULL);
     bindkey(mskeymap, "\33OC",  refthingy(t_forwardchar), NULL);
     bindkey(mskeymap, "\33OD",  refthingy(t_backwardchar), NULL);
+    lskeymap = newkeymap(NULL, "listscroll");
+    linkkeymap(lskeymap, "listscroll", 1);
+    bindkey(lskeymap, "\t", refthingy(t_completeword), NULL);
+    bindkey(lskeymap, " ", refthingy(t_completeword), NULL);
+    bindkey(lskeymap, "\n", refthingy(t_acceptline), NULL);
+    bindkey(lskeymap, "\r", refthingy(t_acceptline), NULL);
+    bindkey(lskeymap, "\33[B",  refthingy(t_downlineorhistory), NULL);
+    bindkey(lskeymap, "\33OB",  refthingy(t_downlineorhistory), NULL);
     return 0;
 }
 
@@ -2068,6 +2086,7 @@
     deletehookfunc("comp_list_matches", (Hookfn) complistmatches);
     deletehookfunc("menu_start", (Hookfn) domenuselect);
     unlinkkeymap("menuselect", 1);
+    unlinkkeymap("listscroll", 1);
     return 0;
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

