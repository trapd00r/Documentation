From zsh-users-return-15470-mason-zsh=primenet.com.au@zsh.org Fri Oct 22 08:16:49 2010
Return-Path: <zsh-users-return-15470-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10762 invoked by alias); 22 Oct 2010 08:16:49 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15470
Received: (qmail 4727 invoked from network); 22 Oct 2010 08:16:46 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,HTML_MESSAGE,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at _spf.google.com designates 74.125.82.43 as permitted sender)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:received:mime-version:received:in-reply-to
         :references:from:date:message-id:subject:to:cc:content-type;
        bh=3JhYx38SZh8qw/ragpGZttvigk1SgAtyxNAn17YTFIw=;
        b=F0D719Xv1CAxz0k2654ZzZqVKRtTrASCFVCwkqqUxSttDj8yp91L/yZ511AaSfvrrU
         7ZqBGTfp75SgMrHXQzhidQ2veESk2M7gLeqS4cnywH3kt1XlpRtG6x9AN/Oy57wPr04+
         G7NBBU6AkRHK/rmPX+NzJd2mVLHBBqCTXG20M=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=mime-version:in-reply-to:references:from:date:message-id:subject:to
         :cc:content-type;
        b=GnxS+i/M4VNn6AqJzlyijvLUavDbwnYm+ji8BHLPiOwTaO8g/l2BqhzmVh94rVZdnb
         joFDYU0c/9yI/vmsDs+egm2zP4M2FI/mvisAKVS8zwcJFNt275hwWp+3/+wWwasDJbkf
         EDdLWnYoVrsKIeb+fp4E3W2shrIVGCTCP8BRY=
MIME-Version: 1.0
In-Reply-To: <AANLkTimewqEvxBaQwqv1Sp=+OOjwmK_cgghM=VVC-Db2@mail.gmail.com>
References: <AANLkTikBOSBNfBHXDFdfiCkijVt5G5+-1UVFz_VqY3wZ@mail.gmail.com>
 <101021210513.ZM30802@torch.brasslantern.com> <AANLkTimewqEvxBaQwqv1Sp=+OOjwmK_cgghM=VVC-Db2@mail.gmail.com>
From: Julien Nicoulaud <julien.nicoulaud@gmail.com>
Date: Fri, 22 Oct 2010 10:09:37 +0200
Message-ID: <AANLkTi=DCtaYoZWDdyouuaCD_xJe+-8JqDhDO8mQ9tf=@mail.gmail.com>
Subject: Re: Neat hash -d trick
To: Mikael Magnusson <mikachu@gmail.com>
Cc: Zsh Users <zsh-users@zsh.org>
Content-Type: multipart/alternative; boundary=0016364d20811ea78c0493302b64

--0016364d20811ea78c0493302b64
Content-Type: text/plain; charset=ISO-8859-1

I use this too:

rationalise-dot() {
  if [[ $LBUFFER = *.. ]]; then
    LBUFFER+=/..
  else
    LBUFFER+=.
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot

2010/10/22 Mikael Magnusson <mikachu@gmail.com>

> On 22 October 2010 06:05, Bart Schaefer <schaefer@brasslantern.com> wrote:
> > [Aside to -workers:  This reminds me about Mikael Magnusson's thread
> > for his proposed HASH_LOOKUP option, which sort of died out without
> > resolution after a discussion of findcmd() behaving oddly.]
>
> [I'm still meaning to look into that, it's just that hacking on zsh C
> code requires a pretty rare set of circumstances, being both pretty
> bored, but also in a very optimistic mood. :)]
>
> > On Oct 22, 12:34am, Nikolai Weibull wrote:
> > }
> > } for ((i = 1; i < 9; i++)); do
> >
> > You probably mean <= 9 there?  Or just
> >
> >  for i in {1..9}
> >
> > }   hash -d .$i=${(j:/:)${(l:2::.:)${(s::)${(l:i::.:)}}}}
> >
> >    hash -d .$i=${${(l:i*3::../:)}%/}
> >
> > } done
> > }
> > } cd ~.4/dir
> >
> > A generic word of caution about using "hash -d": if you for any reason
> > change the value of $PATH or $path after this, all your custom hash
> > entries are lost when the table is rebuilt for the new searchpath.
>
> Hmm? Doesn't seem to happen for me.
>
> > A similar trick:
> >
> >    dotdot() {
> >      if (( NUMERIC > 0 ))
> >      then LBUFFER+=..; repeat $((NUMERIC-1)) LBUFFER+=/..
> >      else LBUFFER+=.
> >      fi
> >    }
> >    zle -N dotdot
> >    bindkey . dotdot
> >
> > Now you can type ESC 4 . to insert ../../../.. (or ESC 9 ESC 9 . to
> > insert 99 levels, if for some insane reason you need that many).
>
> Doing this actually causes you to be unable to type dots in an isearch
> widget, since it aborts on custom bindings. I think pws is partly
> responsible for this
> # just type '...' to get '../..'
> rationalise-dot() {
> local MATCH
> if [[ $LBUFFER =~ '(^|/| |      |'$'\n''|\||;|&)\.\.$' ]]; then
>  LBUFFER+=/
>  zle self-insert
>  zle self-insert
> else
>  zle self-insert
> fi
> }
> zle -N rationalise-dot
> bindkey . rationalise-dot
> # without this, typing a . aborts incremental history search
> bindkey -M isearch . self-insert
>
> You only need the last line to avoid the problem of course.
>
> > } What would be even sweeter is if someone would come up with a way to
> > } do this with only one call to hash -d without writing out all the
> > } expansions
> >
> > Because the counter has to be referenced twice in the expansion, I
> > don't think there's any way of avoiding the "for" loop that's worth
> > the effort to figure out.  However,
> >
> >    for i in {1..9}; h+=(.$i=${${(l:i*3::../:)}%/}); hash -d $h
> >
> > Or to avoid leaving $i and $h with a value at the end,
> >
> >    hash -d $( for i in {1..9}; print .$i=${${(l:i*3::../:)}%/} )
>
> To avoid leaving $i and $h with a value and a fork ;)
> % () {local i h; for i in {1..9}; h+=(.$i=${${(l:i*3::../:)}%/}); hash -d
> $h}
> % path+=/tmp
> % path[2]=()
> % hash -d|head -1
> .1=..
>
> I also have a vaguely related custom widget, in case you're unsure
> just how many dotdots you need.
>
> function _showcurrargrealpath() {
>  setopt localoptions nonomatch
>  local REPLY REALPATH
>  _split_shell_arguments_under
>  #zle -M "$(realpath ${(Q)${~REPLY}} 2> /dev/null | head -n1 || echo
> 1>&2 "No such path")"
>  REALPATH=( ${(Q)${~REPLY}}(N:A) )
>  zle -M "${REALPATH:-Path not found: $REPLY}"
> }
> zle -N _showcurrargrealpath
> bindkey "^X." _showcurrargrealpath
>
> # which i now notice in turn relies on this bit:
> autoload -U modify-current-argument
> autoload -U split-shell-arguments
>
> function _split_shell_arguments_under()
> {
>  local -a reply
>  integer REPLY2
>  split-shell-arguments
>  #have to duplicate some of modify-current-argument to get the word
>  #_under_ the cursor, not after.
>  setopt localoptions noksharrays multibyte
>  if (( REPLY > 1 )); then
>    if (( REPLY & 1 )); then
>      (( REPLY-- ))
>    fi
>  fi
>  REPLY=${reply[$REPLY]}
> }
>
> I also noticed now that if you mistype a named dir and run that
> widget, the whole command line aborted due to the failed $~ expansion,
> not sure why it would do that. That's why I added the setopt nonomatch
> just now, it'll print the original path with (:A) appended as if it
> succeeds but at least better than eating the command line.
>
> [aside to -workers: would it make sense if ~ also checked for
> nullglob? i noticed in the code that it checks for nomatch only
> (merely looking at zsh C code is possible more often than editing it).
> not sure how many different bits use that same function to expand
> stuff though.]
>
> --
> Mikael Magnusson
>

--0016364d20811ea78c0493302b64--

