From zsh-users-return-3401-mason-zsh=primenet.com.au@sunsite.auc.dk Sun Aug 27 17:03:47 2000
Return-Path: <zsh-users-return-3401-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5236 invoked from network); 27 Aug 2000 17:03:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Aug 2000 17:03:47 -0000
Received: (qmail 19488 invoked by alias); 27 Aug 2000 17:03:08 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 3401
Received: (qmail 19473 invoked from network); 27 Aug 2000 17:03:05 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000827170259.ZM14669@candle.brasslantern.com>
Date: Sun, 27 Aug 2000 17:02:58 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.auc.dk
Subject: Revised version of "promptnl"
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

This fixes a couple of bugs:

1. Typeahead confused it.  This version attempts to consume all typeahead
   and pushes anything it gets onto the ZLE buffer stack, whence ZLE will
   fetch it again after the prompt is printed.  This still isn't quite the
   same as if ZLE read those bytes directly, and it's still possible to
   confuse it by typing continually so that your strokes get mixed into
   the cursor position string, but this should handle common cases.

2.  "read -t" doesn't set REPLY to the empty string when it fails, so it's
    necessary to test the result and only append to RECV on success.

---- 8< ---- cut here ---- 8< ----
#autoload
emulate -L zsh

# VT100 and ANSI terminals will report the cursor position when sent
# the sequence ESC [ 6 n -- it comes back as ESC [ column ; line R
# with of course no trailing newline.  Column and line are 1-based.

local RECV='' SEND='\e[6n' REPLY=X

# If you are on a very slow tty, you may need to increase WAIT here.
integer WAIT=1

# Make sure there's no typeahead, or it'll confuse things.  Remove
# this block entirely to use this function in 3.0.x at your own risk.
while read -t -k 1
do
    RECV=$RECV$REPLY
done
if [[ -n $RECV ]]
then
    print -z -r -- $RECV
    RECV=''
    REPLY=X
fi

# This is annoying, but zsh immediately resets it properly, so ...
stty -echo

# Output the SEND sequence and read back into RECV.  In case this is
# not a terminal that understands SEND, do a non-blocking read and
# retry for at most WAIT seconds before giving up.  Requires 3.1.9.
# For 3.0.x, remove "-t" but don't call this on the wrong terminal!

print -n $SEND

integer N=$SECONDS
while [[ $REPLY != R ]] && ((SECONDS - N <= WAIT))
do
    if read -t -k 1
    then
	((N=SECONDS))
	RECV=$RECV$REPLY
    fi
done

# If the cursor is not in the first column, emit EOLMARK and newline.

(( ${${RECV#*\;}%R} > 1 )) && print -P -- $EOLMARK

return 0
---- 8< ---- cut here ---- 8< ----

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

