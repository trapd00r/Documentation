From zsh-workers-return-8679-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Nov 19 10:05:01 1999
Return-Path: <zsh-workers-return-8679-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29950 invoked from network); 19 Nov 1999 10:05:00 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 19 Nov 1999 10:05:00 -0000
Received: (qmail 20630 invoked by alias); 19 Nov 1999 10:04:54 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8679
Received: (qmail 20623 invoked from network); 19 Nov 1999 10:04:53 -0000
Date: Fri, 19 Nov 1999 11:04:52 +0100 (MET)
Message-Id: <199911191004.LAA02387@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: job-completion with strings


This makes _jobs use the `strings' style. If that is true, the job
references generated as matches will use the stuff from the job-texts
instead of the numbers (i.e. `%foo' instead of `%1'). So:

  compstyle '*:jobs' strings yes

For those who like that.

I've made this slightly more complicated because I wanted to avoid
that we get unnecessary long matches like `%for\ i\ in\ ...'. It
tries to use only the shorted unambiguous string for each job.

Bye
 Sven

diff -u -r oldcompletion/Base/_jobs Completion/Base/_jobs
--- oldcompletion/Base/_jobs	Fri Nov 19 09:55:54 1999
+++ Completion/Base/_jobs	Fri Nov 19 10:58:28 1999
@@ -22,13 +22,47 @@
   _description expl job
 fi
 
-disp=()
-jobs=()
-for job in "$jids[@]"; do
-  [[ -n "$desc" ]] &&
-      disp=( "$disp[@]" "${pfx}${(r:2:: :)job} -- ${(r:COLUMNS-8:: :)jobtexts[$job]}" )
-  jobs=( "$jobs[@]" "$job" )
-done
+if [[ -n "$desc" ]]; then
+  disp=()
+  for job in "$jids[@]"; do
+    [[ -n "$desc" ]] &&
+        disp=( "$disp[@]" "${pfx}${(r:2:: :)job} -- ${(r:COLUMNS-8:: :)jobtexts[$job]}" )
+  done
+fi
+
+if _style jobs strings; then
+  local texts i text str tmp
+
+  # Find shortest unambiguous strings.
+
+  texts=( "$jobtexts[@]" )
+  jobs=()
+  for i in "$jids[@]"; do
+    text="$jobtexts[$i]"
+    str="${text%% *}"
+    if [[ "$text" = *\ * ]]; then
+      text="${text#* }"
+    else
+      text=""
+    fi
+    tmp=( "${(@M)texts:#${str}*}" )
+    while [[ -n "$text" && $#tmp -ge 2 ]]; do
+      str="${str} ${text%% *}"
+      if [[ "$text" = *\ * ]]; then
+        text="${text#* }"
+      else
+        text=""
+      fi
+      tmp=( "${(@M)texts:#${str}*}" )
+    done
+
+    jobs=( "$jobs[@]" "$str" )
+  done
+
+  [[ -n "$pfx" && -n "$desc" ]] && disp=( "${(@)disp#%}" )
+else
+  jobs=( "$jids[@]" )
+fi
 
 if [[ -n "$desc" ]]; then
   compadd "$@" "$expl[@]" -ld disp - "%$^jobs[@]"
diff -u olddoc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- olddoc/Zsh/compsys.yo	Thu Nov 18 11:01:38 1999
+++ Doc/Zsh/compsys.yo	Fri Nov 19 10:59:55 1999
@@ -1065,6 +1065,11 @@
 and it will stop when the last match is inserted. If this style is set
 to tt(verbose) a message will be displayed when the last match is reached.
 )
+item(tt(strings))(
+This is used with the tt(jobs) tag. If it is `true', the completions
+will use the shortest unambiguous strings of the jobs' command lines
+instead of the job numbers.
+)
 item(tt(substitute))(
 If this is unset or set to the empty string, the tt(_expand) completer
 will first try to expand all substitutions in the string (such as

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

