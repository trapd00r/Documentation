From zsh-users-return-7280-mason-zsh=primenet.com.au@sunsite.dk Sun Mar 28 20:09:11 2004
Return-Path: <zsh-users-return-7280-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16479 invoked from network); 28 Mar 2004 20:09:10 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 28 Mar 2004 20:09:10 -0000
Received: (qmail 8264 invoked by alias); 28 Mar 2004 20:08:58 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 7280
Received: (qmail 8198 invoked from network); 28 Mar 2004 20:08:56 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 28 Mar 2004 20:08:56 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [130.225.247.86] by sunsite.dk (MessageWall 1.0.8) with SMTP; 28 Mar 2004 20:8:56 -0000
Received: (qmail 8055 invoked from network); 28 Mar 2004 20:08:56 -0000
Received: from madrid10.amenworld.com (62.193.203.32)
  by a.mx.sunsite.dk with SMTP; 28 Mar 2004 20:08:54 -0000
Received: from DervishD.pleyades.net (212.Red-80-35-44.pooles.rima-tde.net [80.35.44.212])
	by madrid10.amenworld.com (8.10.2/8.10.2) with ESMTP id i2SK8iK20273;
	Sun, 28 Mar 2004 22:08:45 +0200
Received: from raul@pleyades.net by DervishD.pleyades.net with local (Exim MTA 2.05)
	  id <1B7gZY-0001eC-00>; Sun, 28 Mar 2004 22:07:56 +0200
Date: Sun, 28 Mar 2004 22:07:56 +0200
From: DervishD <raul@pleyades.net>
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: Zsh Users <zsh-users@sunsite.dk>
Subject: Re: Is this the Zsh way for doing this?
Message-ID: <20040328200756.GB6311@DervishD>
Mail-Followup-To: Bart Schaefer <schaefer@brasslantern.com>,
	Zsh Users <zsh-users@sunsite.dk>
References: <20040325223228.GA13221@DervishD> <1040328005531.ZM19873@candle.brasslantern.com> <1040328010324.ZM19900@candle.brasslantern.com> <20040325223228.GA13221@DervishD> <1040328005531.ZM19873@candle.brasslantern.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <1040328010324.ZM19900@candle.brasslantern.com> <1040328005531.ZM19873@candle.brasslantern.com>
User-Agent: Mutt/1.4.2.1i
Organization: Pleyades
X-Spam-Checker-Version: SpamAssassin 2.63 on a.mx.sunsite.dk
X-Spam-Level: 
X-Spam-Status: No, hits=0.0 required=6.0 tests=none autolearn=no version=2.63
X-Spam-Hits: 0.0

    Hi Bart :)

    Thanks a lot for your answer :)

 * Bart Schaefer <schaefer@brasslantern.com> dixit:
> } tail +2 .CDinfo | while read song
> This is fine, but you might prefer the more obvious:
> tail +2 .CDinfo | while read ignored_word track_number track_name

    I *always* forget that 'read' can be used with more than one
parameter O:) This way, using IFS, it can be used as a simple
tokenizer.

>     # At this point ignored_word is always "Track" and track_number
>     # still has a trailing colon that we need to strip off.  Also
>     # track_name contains single quotes, but based on this example:
>     #    Track 10: 'This song really doesn't exist...'
>     # they aren't balanced single quotes, so we have to strip them.

    Yes, they're always balanced, is the output from cdda2wav.

>     # At this point you might also want to clean wildcards and slashes
>     # out of $track_name, but that's up to you.  Your original doesn't.

    No, it doesn't because I didn't thought of it :( Thanks for
pointing. Could it be solved using the (q) flag or should I use ${//}
and substitute every dangerous character for a safe version?

> If you really desperately want to write it all as one command rather
> than have the two extra assignments:
> 
>     mv audio_${(l.2..0.)track_number/#(#b)([0-9]#):/$match[1]}.cdr \
>         ${(l.2..0.)match[1]}.${${track_name%\'}#\'}.cdr

    Thanks for the recipe :))
 
> As to your specific pattern-matching questions:
> }     ${song/#(#b)Track #([0-9]##):'(*)'/${(l.2..0.)match[1]}.${match[2]}}.cdr
> } AFAIK, when pattern matching takes place
> } at the point of the "'(*)'", it is implicitly anchored to the end of
> } the string and is the longest match
> No, it's not implicitly anchored at the end, but it is the longest match,
> which (since there is always a single-quote at the end of the string) is
> equivalent in this case.

    Nice, then.
 
> However, you do need to escape the single quotes, and there is a space
> after the colon:

    Sorry, they are, but when I copied the command line it got mangled
:(, don't know why (I would swear I copied it from my .history, but
obviously I didn't because it is correctly shown there :?).

> 	(#b)Track #([0-9]##): \'(*)\'
> } [Why can't I] use the (#b) flag before the '/' (together with 'song')
> } or before the '#' (which indicates that 'Track' must match at the
> } beginning of the string) [...?]
> What you've asked is very similar to asking about C,
> 
>     Why can't I put the "--" before the "+" or before the "=" in
>     the expression "song += --pattern" ?
> This is because the / and the # together constitute an operator on the
> value of the variable, whereas (#b) is part of the pattern which is an
> argument to that operator.

    Ok. I don't know why I thought that the globbing flags could be
used at any point in the expression involving patterns, because the
manual clearly states that they 'affect any text to their right up
to the end of the enclosing group or to the end of the pattern'.
Sorry for the noise O:(

> } BTW, is that '#' necessary or not?
> It's not necessary as long as none of the names is "The Track 27: song"
> or some such.

    So it is necessary for me, because I don't know what kind of
names this function may get.

    Again, Bart, thanks a lot for your invaluable help. I can't think
of a way of returning you all you do for people like me :) You're
great, I really mean it.

    Raúl Núñez de Arenas Coronado

-- 
Linux Registered User 88736
http://www.pleyades.net & http://raul.pleyades.net/

