From zsh-workers-request@math.gatech.edu Wed Dec 16 13:41:16 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17490 invoked from network); 16 Dec 1998 13:41:13 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 16 Dec 1998 13:41:13 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id IAA08494;
	Wed, 16 Dec 1998 08:32:53 -0500 (EST)
Resent-Date: Wed, 16 Dec 1998 08:32:53 -0500 (EST)
Message-Id: <9812161316.AA32226@ibmth.df.unipi.it>
To: zsh-workers@math.gatech.edu
Subject: PATCH: pws-3: AIX fix for setup/finish
In-Reply-To: "Sven Wischnowsky"'s message of "Wed, 16 Dec 1998 09:10:57 NFT."
             <199812160810.JAA00618@beta.informatik.hu-berlin.de> 
Date: Wed, 16 Dec 1998 14:16:29 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>
Resent-Message-ID: <"TXMs43.0.c42.5QxTs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4822
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

(This hasn't come back to me on the mailing list, due presumably to
Mathematica memory madness.  I don't know, however, whether that was
on the outward or return leg, so this may be a repeat.)

Sven Wischnowsky wrote:
> Thanks for the help, I searched but didn't find modentry.c. (This file
> calls `boot_' and `cleanup_', how is this turned into `boot_foo' and
> `cleanup_foo'??)

If you're using pws-3, modentry.c should be Src/modentry.c.  The
mechanism is that, if DYNAMIC_NAME_CLASH_OK is defined, boot_foo and
cleanup_foo in module foo get turned into boot_ and cleanup_ by
makepro.awk (it took some finding there).  I've extended this to deal
with setup_ and finish_.  There's a long line in the makepro.awk chunk
which I hope mailers can deal with nowadays.  If not, it's just the
old line with `|setup|finish' stuck in it in the obvious place.

> Anyway, this might indeed require that we make setup and finish
> mandatory. I have to say a bit more about this which I will send as a
> separate mail.

It's certainly true for AIX anyway...

> > % zmodload deltochar
> > deltochar: name clash when adding ZLE function `delete-to-char'
> > deltochar: name clash when adding ZLE function `delete-to-char'
> 
> This doesn't happen for me, are you sure that you haven't configured
> deltochar to be statically included in zsh?

No, the problem was that calling 'setup_deltochar' and then
'init_deltochar' (and 'finish_deltochar') were indistinguishable from
one another due to the modentry mechanism, and only deltochar() prints
an error message for this --- it might be a good idea for `example' to
have more error handling too.

I've now altered modentry so that setup_ and finish_ are called.
Since there's no dlsym() or equivalent, they have to be defined for
all modules.  This is rather a pain in the neck, but should be less so
for new modules since the basics tend just to be copied over anyway.
I've put this inside #ifdef AIXDYNAMIC at the moment, except for
`example' where I've put some printf's inside to see that they are being
called correctly.  This verifies that things are now OK on AIX.

(If it's any consolation (i) zftp would never have been written if I
didn't have dynamic loading on AIX (ii) it's even worse when some
memory hog is running Mathematica on your machine so that nothing will
compile.)

*** Src/Builtins/rlimits.c.sw	Wed Dec 16 10:33:45 1998
--- Src/Builtins/rlimits.c	Wed Dec 16 10:39:15 1998
***************
*** 590,593 ****
--- 590,610 ----
      deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_rlimits(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_rlimits(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Builtins/sched.c.sw	Wed Dec 16 10:33:45 1998
--- Src/Builtins/sched.c	Wed Dec 16 10:38:53 1998
***************
*** 211,214 ****
--- 211,230 ----
      return 0;
  }
  
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_sched(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_sched(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Modules/cap.c.sw	Wed Dec 16 10:33:45 1998
--- Src/Modules/cap.c	Wed Dec 16 10:38:25 1998
***************
*** 138,141 ****
--- 138,158 ----
      deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_cap(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_cap(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Modules/clone.c.sw	Wed Dec 16 10:33:45 1998
--- Src/Modules/clone.c	Wed Dec 16 10:37:03 1998
***************
*** 112,115 ****
--- 112,132 ----
      deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_clone(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_clone(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Modules/example.c.sw	Wed Dec 16 10:33:45 1998
--- Src/Modules/example.c	Wed Dec 16 10:54:12 1998
***************
*** 127,130 ****
--- 127,149 ----
      deletewrapper(m, wrapper);
      return 0;
  }
+ 
+ /**/
+ int
+ setup_example(Module m)
+ {
+     printf("The example module has now been set up.\n");
+     fflush(stdout);
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_example(Module m)
+ {
+     printf("Thank you for using the example module.  Have a nice day.\n");
+     fflush(stdout);
+     return 0;
+ }
+ 
  #endif
*** Src/Modules/files.c.sw	Sun May 31 12:25:28 1998
--- Src/Modules/files.c	Wed Dec 16 10:33:07 1998
***************
*** 525,528 ****
--- 525,545 ----
      deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_files(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_files(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Modules/stat.c.sw	Wed Dec  9 10:04:31 1998
--- Src/Modules/stat.c	Wed Dec 16 10:32:39 1998
***************
*** 586,589 ****
--- 586,605 ----
      return 0;
  }
  
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_stat(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_stat(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Modules/zftp.c.sw	Wed Dec 16 10:30:47 1998
--- Src/Modules/zftp.c	Wed Dec 16 10:30:19 1998
***************
*** 2593,2596 ****
--- 2593,2612 ----
      return 0;
  }
  
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_zftp(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_zftp(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Zle/comp1.c.sw	Wed Dec  9 14:37:14 1998
--- Src/Zle/comp1.c	Wed Dec 16 10:31:04 1998
***************
*** 458,461 ****
--- 458,477 ----
      return 0;
  }
  
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_comp1(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_comp1(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif /* MODULE */
*** Src/Zle/compctl.c.sw	Wed Nov  4 16:23:24 1998
--- Src/Zle/compctl.c	Wed Dec 16 10:31:27 1998
***************
*** 1660,1663 ****
--- 1660,1680 ----
      compctl_widgetptr = NULL;
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_compctl(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_compctl(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Zle/deltochar.c.sw	Fri Nov  6 09:47:38 1998
--- Src/Zle/deltochar.c	Wed Dec 16 10:31:47 1998
***************
*** 93,96 ****
--- 93,113 ----
      deletezlefunction(w_deletetochar);
      return 0;
  }
+ 
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_deltochar(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_deltochar(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif
*** Src/Zle/zle_main.c.sw	Wed Dec  9 18:08:25 1998
--- Src/Zle/zle_main.c	Wed Dec 16 10:28:04 1998
***************
*** 917,920 ****
--- 917,936 ----
      return 0;
  }
  
+ #ifdef AIXDYNAMIC
+ /**/
+ int
+ setup_zle(Module m)
+ {
+     return 0;
+ }
+ 
+ /**/
+ int
+ finish_zle(Module m)
+ {
+     return 0;
+ }
+ #endif
+ 
  #endif /* MODULE */
*** Src/makepro.awk.sw	Tue Oct 27 00:01:07 1998
--- Src/makepro.awk	Wed Dec 16 10:23:01 1998
***************
*** 104,110 ****
  	gsub(/@!/, ",", dcltor)
  
  	# If this is a module boot/cleanup function, conditionally rename it.
! 	if(" " dtype " " ~ / int / && dcltor ~ / *@\+(boot|cleanup)_[_0-9A-Za-z]+@- *_\(\( *Module +[_0-9A-Za-z]+ *\)\) */) {
  	    modtype = dnam
  	    sub(/_.*$/, "", modtype)
  	    output = output "# if defined(DYNAMIC_NAME_CLASH_OK) && defined(MODULE)\n"
--- 104,110 ----
  	gsub(/@!/, ",", dcltor)
  
  	# If this is a module boot/cleanup function, conditionally rename it.
! 	if(" " dtype " " ~ / int / && dcltor ~ / *@\+(boot|cleanup|setup|finish)_[_0-9A-Za-z]+@- *_\(\( *Module +[_0-9A-Za-z]+ *\)\) */) {
  	    modtype = dnam
  	    sub(/_.*$/, "", modtype)
  	    output = output "# if defined(DYNAMIC_NAME_CLASH_OK) && defined(MODULE)\n"
*** Src/modentry.c.sw	Fri Oct 30 15:56:15 1998
--- Src/modentry.c	Wed Dec 16 09:58:48 1998
***************
*** 1,15 ****
  #include "zsh.mdh"
  
  int boot_ _((Module));
  int cleanup_ _((Module));
  int modentry _((int boot, Module m));
  
  /**/
  int
  modentry(int boot, Module m)
  {
!     if (boot)
  	return boot_(m);
!     else
  	return cleanup_(m);
  }
--- 1,35 ----
  #include "zsh.mdh"
  
+ int setup_ _((Module));
  int boot_ _((Module));
  int cleanup_ _((Module));
+ int finish_ _((Module));
  int modentry _((int boot, Module m));
  
  /**/
  int
  modentry(int boot, Module m)
  {
!     switch (boot) {
!     case 0:
! 	return setup_(m);
! 	break;
! 
!     case 1:
  	return boot_(m);
! 	break;
! 
!     case 2:
  	return cleanup_(m);
+ 	break;
+ 
+     case 3:
+ 	return finish_(m);
+ 	break;
+ 
+     default:
+ 	zerr("bad call to modentry", NULL, 0);
+ 	return 1;
+ 	break;
+     }
  }
*** Src/module.c.sw	Wed Dec 16 10:02:06 1998
--- Src/module.c	Wed Dec 16 10:51:16 1998
***************
*** 366,372 ****
  static void
  setup_module(Module m)
  {
!     return ((int (*)_((int,Module))) m->handle)(2, m);
  }
  
  /**/
--- 366,372 ----
  static void
  setup_module(Module m)
  {
!     ((int (*)_((int,Module))) m->handle)(0, m);
  }
  
  /**/
***************
*** 380,393 ****
  static int
  cleanup_module(Module m)
  {
!     return ((int (*)_((int,Module))) m->handle)(0, m);
  }
  
  /**/
  static void
  finish_module(Module m)
  {
!     return ((int (*)_((int,Module))) m->handle)(3, m);
  }
  
  #else
--- 380,393 ----
  static int
  cleanup_module(Module m)
  {
!     return ((int (*)_((int,Module))) m->handle)(2, m);
  }
  
  /**/
  static void
  finish_module(Module m)
  {
!     ((int (*)_((int,Module))) m->handle)(3, m);
  }
  
  #else

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

