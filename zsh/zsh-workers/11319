From zsh-workers-return-11319-mason-zsh=primenet.com.au@sunsite.auc.dk Thu May 11 08:37:18 2000
Return-Path: <zsh-workers-return-11319-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 491 invoked from network); 11 May 2000 08:37:17 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 May 2000 08:37:17 -0000
Received: (qmail 1531 invoked by alias); 11 May 2000 08:36:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11319
Received: (qmail 1510 invoked from network); 11 May 2000 08:36:57 -0000
Date: Thu, 11 May 2000 10:36:51 +0200 (MET DST)
Message-Id: <200005110836.KAA14836@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Andrej Borsenkow's message of Wed, 10 May 2000 21:14:07 +0400
	(MSD)
Subject: PATCH: Re: "Cancel" menu selection & Co?


Andrej Borsenkow wrote:

> Currently, as soon as menu selection is started, there seems to be no way
> to cancel it - that is, revert input line to original state. The closest
> it, exit menu selection and hit Undo.
> 
> Does anybody really use ^G to switch from menu selection to menu
> completion? I hardly see any point here. So, the suggestion is, to make ^G
> really cancel selection and revert line to it's original state (before
> match was inserted). This is also consistent behaviour for ^G, that
> normally cancels actions in other places.

Like Bart I prefer this, too. I just didn't want to make incompatible
changes, but since menu-selection is now completely different from
what it was when it started...

> As a related (to me at least) question or request - is it possible to
> enter menu selection immediately if list does not fit on screen? May be,
> not always (if somebody just wants a list with ^D he prkbably does not
> want menu selection). OTOH if menu selection can be quit with ^G it can be
> used as replacement for listing, but replacement that supports scrolling,
> paging, going back etc.

That's quite simple to add to the `menu' style. The patch makes
`scroll=long' mean: use selection if list does not fit on screen. It
also makes `scroll=long-list' mean: use selection if list is too long
for screen, in all cases, even if the widget is d-c-o-l or something
like that which would normally not start menu selection. (Well, it did 
before this patch, but this was a bug.)


Bye
 Sven

Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.16
diff -u -r1.16 _main_complete
--- Completion/Core/_main_complete	2000/05/10 04:55:10	1.16
+++ Completion/Core/_main_complete	2000/05/11 08:35:45
@@ -129,11 +129,20 @@
 nm=$compstate[nmatches]
 
 if [[ $compstate[old_list] = keep || nm -gt 1 ]]; then
-  [[ _last_nmatches -ge 0 && _last_nmatches -ne $compstate[nmatches] ]] &&
+  [[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] &&
       _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
-  if [[ "$compstate[insert]" = "$_saved_insert" ]]; then
-    if [[ -n "$_menu_style[(r)(yes|true|1|on)]" ||
+  tmp=$(( compstate[list_lines] + BUFFERLINES + 1 ))
+
+  _menu_style=( "$_menu_style[@]" "$_def_menu_style[@]" )
+
+  if [[ -z "$compstate[insert]" ]]; then
+    [[ -n "$_menu_style[(r)select=long-list]" && tmp -gt LINES ]] &&
+        compstate[insert]=menu
+  elif [[ "$compstate[insert]" = "$_saved_insert" ]]; then
+    if [[ -n "$_menu_style[(r)select=long]" && tmp -gt LINES ]]; then
+        compstate[insert]=menu
+    elif [[ -n "$_menu_style[(r)(yes|true|1|on)]" ||
           ( -n "$_menu_style[(r)auto*]" &&
             "$compstate[insert]" = automenu ) ]]; then
       compstate[insert]=menu
@@ -154,11 +163,12 @@
     fi
   fi
 
-  _menu_style=( "$_menu_style[@]" "$_def_menu_style[@]" )
-
   if [[ "$compstate[insert]" = *menu* ]]; then
     if [[ -n "$_menu_style[(r)no-select*]" ]]; then
       unset MENUSELECT
+    elif [[ -n "$_menu_style[(r)select=long*]" && tmp -gt LINES ]]; then
+      zmodload -i zsh/complist
+      MENUSELECT=0
     else
       sel=( "${(@M)_menu_style:#select*}" )
 
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.43
diff -u -r1.43 compsys.yo
--- Doc/Zsh/compsys.yo	2000/05/11 00:01:03	1.43
+++ Doc/Zsh/compsys.yo	2000/05/11 08:35:51
@@ -1498,6 +1498,13 @@
 smallest one is taken). Starting menuselection can explicitly be
 turned off by defining a value containing the string
 `tt(no-select)'.
+
+There is also support to start menu-selection only when the list of
+matches does not fit on the screen, turned on by using the string
+`tt(select=long)' in the value. However, this will only start
+menu-selection if the widget invoked does completion and not only
+listing (like tt(delete-char-or-list)). To start menu-selection even
+for such widgets one can include the string `tt(select=long-list)'.
 )
 kindex(numbers, completion style)
 item(tt(numbers))(
Index: Doc/Zsh/mod_complist.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_complist.yo,v
retrieving revision 1.7
diff -u -r1.7 mod_complist.yo
--- Doc/Zsh/mod_complist.yo	2000/05/11 00:01:03	1.7
+++ Doc/Zsh/mod_complist.yo	2000/05/11 08:35:52
@@ -253,7 +253,8 @@
 accepts the current match and leaves menu selection
 )
 item(tt(send-break))(
-leaves menu selection and continues with normal menu completion
+leaves menu selection and restores the previous contents of the
+command line
 )
 item(tt(redisplay), tt(clear-screen))(
 execute their normal function without leaving menu selection
Index: Src/Zle/compcore.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compcore.c,v
retrieving revision 1.17
diff -u -r1.17 compcore.c
--- Src/Zle/compcore.c	2000/05/09 11:04:45	1.17
+++ Src/Zle/compcore.c	2000/05/11 08:35:55
@@ -499,12 +499,22 @@
 {
     if (menucmp && !oldmenucmp) {
 	struct chdata dat;
+	int ret;
 
 	dat.matches = amatches;
 	dat.num = nmatches;
 	dat.cur = NULL;
-	if (runhookdef(MENUSTARTHOOK, (void *) &dat))
+	if ((ret = runhookdef(MENUSTARTHOOK, (void *) &dat))) {
 	    menucmp = menuacc = 0;
+	    if (ret == 2) {
+		cs = 0;
+		foredel(ll);
+		inststr(origline);
+		cs = origcs;
+		clearlist = 1;
+		invalidatelist();
+	    }
+	}
     }
     return 0;
 }
Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.14
diff -u -r1.14 complist.c
--- Src/Zle/complist.c	2000/05/08 08:16:33	1.14
+++ Src/Zle/complist.c	2000/05/11 08:35:57
@@ -2135,7 +2135,7 @@
 	showinglist = -2;
 	minfo.asked = 0;
     }
-    if (!noselect) {
+    if (!noselect && (!dat || acc)) {
 	showinglist = -2;
 	onlyexpl = oe;
 	if (!smatches)
@@ -2145,7 +2145,7 @@
     mlbeg = -1;
     fdat = NULL;
 
-    return (!noselect ^ acc);
+    return (dat ? (acc ? 1 : 2) : (!noselect ^ acc));
 }
 
 /* The widget function. */

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

