<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>Git Magic</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
alink="#0000FF">
  <div lang="vi" class="book" title="Git Magic">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="idp130512" id=
          "idp130512"></a>Git Magic</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="surname">Lynn</span>,
            <span class="firstname">Ben</span></h3>
          </div>
        </div>

        <div>
          <div class="revhistory">
            <table border="1" width="100%" summary=
            "Revision history">
              <tr>
                <th align="left" valign="top" colspan="3">
                <b>Revision History</b></th>
              </tr>

              <tr>
                <td align="left"></td>

                <td align="left">2007</td>

                <td align="left">BL</td>
              </tr>
            </table>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Mục lục</b></p>

      <dl>
        <dt><span class="preface"><a href=
        "#_l%E1%BB%9Di_n%C3%B3i_%C4%91%E1%BA%A7u">Lời nói
        đầu</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_l%E1%BB%9Di_c%E1%BA%A3m_%C6%A1n">Lời cảm
            ơn!</a></span></dt>

            <dt><span class="section"><a href=
            "#_gi%E1%BA%A5y_ph%C3%A9p_s%E1%BB%AD_d%E1%BB%A5ng">Giấy
            phép sử dụng</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_gi%E1%BB%9Bi_thi%E1%BB%87u">1. Giới
        thiệu</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_c%C3%B4ng_vi%E1%BB%87c_gi%E1%BB%91ng_nh%C6%B0_tr%C3%B2_ch%C6%A1i">
            Công Việc giống như Trò Chơi</a></span></dt>

            <dt><span class="section"><a href=
            "#_qu%E1%BA%A3n_l%C3%BD_m%C3%A3_ngu%E1%BB%93n">Quản Lý
            Mã Nguồn</a></span></dt>

            <dt><span class="section"><a href=
            "#_h%E1%BB%87_th%E1%BB%91ng_ph%C3%A2n_t%C3%A1n">Hệ
            Thống Phân Tán</a></span></dt>

            <dt><span class="section"><a href=
            "#_quan_ni%E1%BB%87m_c%E1%BB%95_h%E1%BB%A7">Quan Niệm
            Cổ Hủ</a></span></dt>

            <dt><span class="section"><a href=
            "#_xung_%C4%91%E1%BB%99t_khi_tr%E1%BB%99n">Xung Đột Khi
            Trộn</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_c%C3%A1c_th%E1%BB%A7_thu%E1%BA%ADt_c%C6%A1_b%E1%BA%A3n">2.
        Các Thủ Thuật Cơ Bản</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_ghi_l%E1%BA%A1i_tr%E1%BA%A1ng_th%C3%A1i">Ghi lại
            Trạng thái</a></span></dt>

            <dt><span class="section"><a href=
            "#_th%C3%AAm_x%C3%B3a_%C4%91%E1%BB%95i_t%C3%AAn">Thêm,
            Xóa, Đổi Tên</a></span></dt>

            <dt><span class="section"><a href=
            "#_ch%E1%BB%A9c_n%C4%83ng_undo_redo">Chức Năng
            Undo/Redo</a></span></dt>

            <dt><span class="section"><a href=
            "#_s%E1%BB%B1_quay_l%E1%BA%A1i">Sự quay
            lại</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%E1%BA%A1o_nh%E1%BA%ADt_k%C3%BD_c%C3%A1c_thay_%C4%91%E1%BB%95i">
            Tạo Nhật Ký các thay đổi</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%E1%BA%A3i_v%E1%BB%81_c%C3%A1c_t%E1%BB%87p_tin">Tải
            về các Tệp tin</a></span></dt>

            <dt><span class="section"><a href=
            "#_th%E1%BB%AD_nghi%E1%BB%87m">Thử
            Nghiệm</a></span></dt>

            <dt><span class="section"><a href=
            "#_xu%E1%BA%A5t_b%E1%BA%A3n">Xuất Bản</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%C3%B4i_%C4%91%C3%A3_l%C3%A0m_%C4%91%C6%B0%E1%BB%A3c_g%C3%AC">
            Tôi Đã Làm Được Gì?</a></span></dt>

            <dt><span class="section"><a href=
            "#_b%C3%A0i_t%E1%BA%ADp">Bài Tập</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_nh%C3%A2n_b%E1%BA%A3n">3. Nhân Bản</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%C4%91%E1%BB%93ng_b%E1%BB%99_h%C3%B3a_c%C3%A1c_m%C3%A1y_t%C3%ADnh">
            Đồng bộ hóa Các Máy tính</a></span></dt>

            <dt><span class="section"><a href=
            "#_qu%E1%BA%A3n_l%C3%BD_theo_c%C3%A1ch_c%C5%A9">Quản lý
            theo cách Cũ</a></span></dt>

            <dt><span class="section"><a href=
            "#_m%C3%A3_ngu%E1%BB%93n_ri%C3%AAng_t%C6%B0">Mã nguồn
            riêng tư</a></span></dt>

            <dt><span class="section"><a href=
            "#_kho_thu%E1%BA%A7n">Kho thuần</a></span></dt>

            <dt><span class="section"><a href=
            "#_push_ng%C6%B0%E1%BB%A3c_v%E1%BB%9Bi_pull">Push ngược
            với pull</a></span></dt>

            <dt><span class="section"><a href=
            "#_r%E1%BA%BD_nh%C3%A1nh_m%E1%BB%99t_d%E1%BB%B1_%C3%A1n">
            Rẽ Nhánh một Dự Án</a></span></dt>

            <dt><span class="section"><a href=
            "#_sao_l%C6%B0u_kh%C3%B4ng_gi%E1%BB%9Bi_h%E1%BA%A1n">Sao
            Lưu Không Giới Hạn</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%C3%A0m_nhi%E1%BB%81u_vi%E1%BB%87c_c%C3%B9ng_l%C3%BAc">
            Làm nhiều việc cùng lúc</a></span></dt>

            <dt><span class="section"><a href=
            "#_song_h%C3%A0nh_c%C3%B9ng_c%C3%A1c_h%E1%BB%87_th%E1%BB%91ng_scm_kh%C3%A1c">
            Song Hành cùng các hệ thống SCM khác</a></span></dt>

            <dt><span class="section"><a href=
            "#_mercurial">Mercurial</a></span></dt>

            <dt><span class="section"><a href=
            "#_bazaar">Bazaar</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%E1%BA%A1i_sao_t%C3%B4i_s%E1%BB%AD_d%E1%BB%A5ng_git">
            Tại sao Tôi sử dụng Git</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_th%E1%BB%A7_thu%E1%BA%ADt_t%E1%BA%A1o_nh%C3%A1nh">4. Thủ
        Thuật Tạo Nhánh</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_n%C3%BAt_%C4%91i%E1%BB%81u_khi%E1%BB%83n">Nút Điều
            Khiển</a></span></dt>

            <dt><span class="section"><a href=
            "#_b%E1%BA%A3n_nh%C3%A1p">Bản Nháp</a></span></dt>

            <dt><span class="section"><a href=
            "#_s%E1%BB%ADa_nhanh">Sửa Nhanh</a></span></dt>

            <dt><span class="section"><a href=
            "#_tr%E1%BB%99n">Trộn</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%C3%A0m_vi%E1%BB%87c_li%C3%AAn_t%E1%BB%A5c">Làm
            Việc Liên Tục</a></span></dt>

            <dt><span class="section"><a href=
            "#_c%E1%BA%A3i_t%E1%BB%95_l%E1%BA%A1i_s%E1%BB%B1_pha_tr%E1%BB%99n">
            Cải Tổ Lại Sự Pha Trộn</a></span></dt>

            <dt><span class="section"><a href=
            "#_qu%E1%BA%A3n_l%C3%BD_c%C3%A1c_nh%C3%A1nh">Quản Lý
            Các Nhánh</a></span></dt>

            <dt><span class="section"><a href=
            "#_nh%C3%A1nh_t%E1%BA%A1m">Nhánh Tạm</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%C3%A0m_theo_c%C3%A1ch_c%E1%BB%A7a_m%C3%ACnh">Làm
            Theo Cách Của Mình</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_b%C3%A0i_h%E1%BB%8Dc_v%E1%BB%81_l%E1%BB%8Bch_s%E1%BB%AD">
        5. Bài Học về Lịch Sử</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_d%E1%BB%ABng_l%E1%BA%A1i_s%E1%BB%ADa_ch%E1%BB%AFa">Dừng
            Lại Sửa Chữa</a></span></dt>

            <dt><span class="section"><a href=
            "#_8230_v%C3%A0_sau_%C4%91%C3%B3_l%C3%A0_nhi%E1%BB%81u_l%E1%BA%A7n">
            … Và Sau đó là Nhiều Lần</a></span></dt>

            <dt><span class="section"><a href=
            "#_thay_%C4%91%E1%BB%95i_ri%C3%AAng_s%E1%BA%AFp_x%E1%BA%BFp_sau">
            Thay Đổi Riêng Sắp Xếp Sau</a></span></dt>

            <dt><span class="section"><a href=
            "#_vi%E1%BA%BFt_l%E1%BA%A1i_l%E1%BB%8Bch_s%E1%BB%AD">Viết
            Lại Lịch Sử</a></span></dt>

            <dt><span class="section"><a href=
            "#_t%E1%BB%B1_t%E1%BA%A1o_l%E1%BB%8Bch_s%E1%BB%AD">Tự
            Tạo Lịch Sử</a></span></dt>

            <dt><span class="section"><a href=
            "#_v%E1%BB%8B_tr%C3%AD_n%C3%A0o_ph%C3%A1t_sinh_l%E1%BB%97i">
            Vị Trí Nào Phát Sinh Lỗi?</a></span></dt>

            <dt><span class="section"><a href=
            "#_ai_%C4%91%C3%A3_l%C3%A0m_n%C3%B3_sai">Ai Đã Làm Nó
            Sai?</a></span></dt>

            <dt><span class="section"><a href=
            "#_kinh_nghi%E1%BB%87m_ri%C3%AAng">Kinh Nghiệm
            Riêng</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%C4%91a_ng%C6%B0%E1%BB%9Di_d%C3%B9ng">6. Đa Người
        Dùng</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_t%C3%B4i_l%C3%A0_ai">Tôi Là Ai?</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_th%C3%B4ng_qua_ssh_http">Git Thông Qua SSH,
            HTTP</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_th%C3%B4ng_qua_m%E1%BB%8Di_th%E1%BB%A9">Git
            Thông Qua Mọi Thứ</a></span></dt>

            <dt><span class="section"><a href=
            "#_v%C3%A1_s%E1%BB%B1_th%E1%BB%8Bnh_h%C3%A0nh_to%C3%A0n_c%E1%BA%A7u">
            Vá: Sự Thịnh Hành Toàn Cầu</a></span></dt>

            <dt><span class="section"><a href=
            "#_r%E1%BA%A5t_ti%E1%BA%BFc_t%C3%B4i_%C4%91%C3%A3_chuy%E1%BB%83n_%C4%91i">
            Rất tiếc! Tôi đã chuyển đi</a></span></dt>

            <dt><span class="section"><a href=
            "#_nh%C3%A1nh_tr%C3%AAn_m%E1%BA%A1ng">Nhánh Trên
            Mạng</a></span></dt>

            <dt><span class="section"><a href=
            "#_%C4%91a_m%C3%A1y_ch%E1%BB%A7">Đa Máy
            chủ</a></span></dt>

            <dt><span class="section"><a href=
            "#_s%E1%BB%9F_th%C3%ADch_ri%C3%AAng_c%E1%BB%A7a_t%C3%B4i">
            Sở Thích Riêng Của Tôi</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_tr%E1%BB%9F_th%C3%A0nh_ki%E1%BB%87n_t%C6%B0%E1%BB%9Bng">7.
        Trở Thành Kiện Tướng</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_ph%C3%A1t_h%C3%A0nh_m%C3%A3_ngu%E1%BB%93n">Phát hành
            Mã Nguồn</a></span></dt>

            <dt><span class="section"><a href=
            "#_ch%E1%BB%89_commit_nh%E1%BB%AFng_g%C3%AC_thay_%C4%91%E1%BB%95i">
            Chỉ Commit Những Gì Thay Đổi</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%E1%BA%A7n_commit_n%C3%A0y_nhi%E1%BB%81u_qu%C3%A1">Lần
            commit này Nhiều Quá!</a></span></dt>

            <dt><span class="section"><a href=
            "#_m%E1%BB%A5c_l%E1%BB%A5c_v%C3%B9ng_tr%E1%BA%A1ng_th%C3%A1i_c%E1%BB%A7a_git">
            Mục Lục: Vùng trạng thái của Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_%C4%91%E1%BB%ABng_qu%C3%AAn_head_c%E1%BB%A7a_m%C3%ACnh">
            Đừng Quên HEAD Của Mình</a></span></dt>

            <dt><span class="section"><a href=
            "#_s%C4%83n_t%C3%ACm_head">Săn tìm-HEAD</a></span></dt>

            <dt><span class="section"><a href=
            "#_x%C3%A2y_d%E1%BB%B1ng_tr%C3%AAn_git">Xây Dựng trên
            Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_c%E1%BB%A9_phi%C3%AAu_l%C6%B0u">Cứ Phiêu
            Lưu</a></span></dt>

            <dt><span class="section"><a href=
            "#_ng%C4%83n_ng%E1%BB%ABa_commit_sai">Ngăn Ngừa Commit
            Sai</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_b%C3%AD_quy%E1%BA%BFt_c%E1%BB%A7a_git">8. Bí Quyết của
        Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_t%C3%ADnh_%E1%BA%A9n">Tính Ẩn</a></span></dt>

            <dt><span class="section"><a href=
            "#_to%C3%A0n_v%E1%BA%B9n_d%E1%BB%AF_li%E1%BB%87u">Toàn
            Vẹn Dữ Liệu</a></span></dt>

            <dt><span class="section"><a href=
            "#_th%C3%B4ng_minh">Thông Minh</a></span></dt>

            <dt><span class="section"><a href=
            "#_m%E1%BB%A5c_l%E1%BB%A5c">Mục Lục</a></span></dt>

            <dt><span class="section"><a href=
            "#_ngu%E1%BB%93n_g%E1%BB%91c_c%E1%BB%A7a_git">Nguồn Gốc
            của Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_c%C6%A1_s%E1%BB%9F_d%E1%BB%AF_li%E1%BB%87u">
            Đối tượng Cơ Sở Dữ Liệu</a></span></dt>

            <dt><span class="section"><a href=
            "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_blob">Đối Tượng
            Blob</a></span></dt>

            <dt><span class="section"><a href=
            "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_tree">Đối Tượng
            Tree</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%E1%BA%A7n_commit">Lần Commit</a></span></dt>

            <dt><span class="section"><a href=
            "#_kh%C3%B3_ph%C3%A2n_bi%E1%BB%87t_%C4%91%C6%B0%E1%BB%A3c_s%E1%BB%B1_th%E1%BA%A7n_k%E1%BB%B3">
            Khó Phân Biệt Được sự Thần Kỳ</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_ph%E1%BB%A5_l%E1%BB%A5c_a_h%E1%BA%A1n_ch%E1%BA%BF_c%E1%BB%A7a_git">
        9. Phụ lục A: Hạn chế của Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%C4%91i%E1%BB%83m_y%E1%BA%BFu_sha1">Điểm Yếu
            SHA1</a></span></dt>

            <dt><span class="section"><a href=
            "#_microsoft_windows">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href=
            "#_c%C3%A1c_t%E1%BB%87p_tin_kh%C3%B4ng_li%C3%AAn_quan">Các
            Tệp tin Không liên quan</a></span></dt>

            <dt><span class="section"><a href=
            "#_ai_s%E1%BB%ADa_v%C3%A0_s%E1%BB%ADa_g%C3%AC">Ai Sửa
            và Sửa gì?</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%E1%BB%8Bch_s%E1%BB%AD_t%E1%BB%87p_tin">Lịch Sử Tệp
            Tin</a></span></dt>

            <dt><span class="section"><a href=
            "#_kh%E1%BB%9Fi_t%E1%BA%A1o_b%E1%BA%A3n_sao">Khởi tạo
            Bản Sao</a></span></dt>

            <dt><span class="section"><a href=
            "#_c%C3%A1c_d%E1%BB%B1_%C3%A1n_hay_thay_%C4%91%E1%BB%95i">
            Các Dự Án Hay Thay Đổi</a></span></dt>

            <dt><span class="section"><a href=
            "#_b%E1%BB%99_%C4%91%E1%BA%BFm">Bộ Đếm</a></span></dt>

            <dt><span class="section"><a href=
            "#_v%E1%BB%9Bi_th%C6%B0_m%E1%BB%A5c_r%E1%BB%97ng">Với
            Thư Mục Rỗng</a></span></dt>

            <dt><span class="section"><a href=
            "#_l%E1%BA%A7n_commit_kh%E1%BB%9Fi_t%E1%BA%A1o">Lần
            Commit Khởi tạo</a></span></dt>

            <dt><span class="section"><a href=
            "#_giao_di%E1%BB%87n_l%E1%BA%ADp_l%E1%BB%9D">Giao diện
            Lập lờ</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_ph%E1%BB%A5_l%E1%BB%A5c_b_d%E1%BB%8Bch_b%E1%BA%A3n_h%C6%B0%E1%BB%9Bng_d%E1%BA%ABn_n%C3%A0y">
        10. Phụ lục B: Dịch Bản Hướng Dẫn Này</a></span></dt>
      </dl>
    </div>

    <div class="preface" title="Lời nói đầu">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_l%E1%BB%9Di_n%C3%B3i_%C4%91%E1%BA%A7u"></a>Lời nói
            đầu</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_l%E1%BB%9Di_c%E1%BA%A3m_%C6%A1n">Lời cảm
          ơn!</a></span></dt>

          <dt><span class="section"><a href=
          "#_gi%E1%BA%A5y_ph%C3%A9p_s%E1%BB%AD_d%E1%BB%A5ng">Giấy
          phép sử dụng</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target=
      "_top">Git</a> là công cụ quản lý mã nguồn vạn năng. Đây là
      một công cụ quản lý mã nguồn tin cậy, ổn định, đa dụng và sự
      cực kỳ mềm dẻo và chính sự mềm dẻo của Git làm cho việc học
      nó trở nên khó khăn, tất nhiên là không nói đến người tạo ra
      nó.</p>

      <p>Theo quan sát của Arthur C. Clarke, bất kể công nghệ tiên
      tiến nào cũng không thể phân biệt rạch ròi là nó có kỳ diệu
      hay không. Đây cũng là cách hay đề đề cập đến Git: những
      người mới sử dụng không cần quan tâm đến bên trong Git làm
      việc như thế nào mà hãy xem khả năng thần kỳ của nó như là
      một điệu gizmo có thể làm những người coi nó là bạn sửng sốt
      và làm điên đầu các những người đối lập.</p>

      <p>Thay vì đi sâu vào chi tiết, chúng tôi đưa ra phác thảo
      cách làm việc của các hiệu ứng chuyên biệt. Sau khi sử dụng
      lặp lại nhiều lần, từ từ bạn sẽ hiểu từng mẹo một, và thực
      hiện được những việc mà mình muốn làm.</p>

      <div class="itemizedlist" title="Bản dịch">
        <p class="title"><b>Bản dịch</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/zh_cn/" target="_top">Tiếng Trung
          Giản thể</a>: dịch bởi JunJie, Meng và JiangWei. Đã
          chuyển đổi sang: <a class="ulink" href=
          "/~blynn/gitmagic/intl/zh_tw/" target="_top">Tiếng Trung
          Phồn thể</a> thông qua lệnh <code class="literal">cconv
          -f UTF8-CN -t UTF8-TW</code>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/fr/" target="_top">Tiếng Pháp</a>:
          dịch bởi Alexandre Garel; và đồng thời được xuất bản tại
          <a class="ulink" href="http://tutoriels.itaapy.com/"
          target="_top">itaapy</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/de/" target="_top">Tiếng Đức</a>:
          dịch bởi Benjamin Bellee và Armin Stebich. Armin ; và
          đồng thời xuất bản <a class="ulink" href=
          "http://gitmagic.lordofbikes.de/" target="_top">bản dịch
          tiếng Đức trên website của chính mình</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git" target=
          "_top">Tiếng Bồ Đào Nha</a>: dịch bởi Leonardo Siqueira
          Rodrigues [<a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git-verso-odt"
          target="_top">định dạng ODT</a>].</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/ru/" target="_top">Tiếng Nga</a>:
          dịch bởi Tikhon Tarnavsky, Mikhail Dymskov và một số
          người khác.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/es/" target="_top">Tiếng Tây Ban
          Nha</a>: dịch bởi Rodrigo Toledo và Ariset Llerena
          Tapia.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/vi/" target="_top">Tiếng Việt</a>:
          dịch bởi Trần Ngọc Quân và đồng thời xuất bản bản dịch
          này trên <a class="ulink" href=
          "http://vnwildman.users.sourceforge.net/gitmagic/"
          target="_top">trang Web cá nhân của mình</a>.</li>
        </ul>
      </div>

      <div class="itemizedlist" title="Các định dạng khác">
        <p class="title"><b>Các định dạng khác</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href="book.html"
          target="_top">Trang web đơn</a>: định dạng HTML đơn giản,
          không định dạng bằng CSS.</li>

          <li class="listitem"><a class="ulink" href="book.pdf"
          target="_top">Định dạng PDF</a>: thuận tiện cho việc in
          ấn.</li>

          <li class="listitem"><a class="ulink" href=
          "http://packages.debian.org/gitmagic" target="_top">Gói
          dành cho Debian</a>, <a class="ulink" href=
          "http:://packages.ubuntu.com/gitmagic" target="_top">gói
          dành cho Ubuntu</a>: cài tự động tại địa chỉ này. Hay tải
          về và cài đặt thủ công tại <a class="ulink" href=
          "http://csdcf.stanford.edu/status/" target="_top">đây</a>
          khi bạn không nối mạng.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.amazon.com/Git-Magic-Ben-Lynn/dp/1451523343/"
          target="_top">Sách giấy [Amazon.com</a>]: 64 trang,
          15.24cm x 22.86cm, đen trắng. Rất tiện sử dụng vì chẳng
          cần đến điện.</li>
        </ul>
      </div>

      <div class="section" title="Lời cảm ơn!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%E1%BB%9Di_c%E1%BA%A3m_%C6%A1n"></a>Lời cảm
              ơn!</h2>
            </div>
          </div>
        </div>

        <p>Tôi gửi lời cảm ơn đến những người đã dịch quyển sách
        này. Tôi rất cảm kích vì có được số lượng độc giả rộng lớn
        có được bởi những người đã được nêu tên ở trên.</p>

        <p>Dustin Sallings, Alberto Bertogli, James Cameron,
        Douglas Livingstone, Michael Budde, Richard Albury,
        Tarmigan, Derek Mahar, Frode Aannevik, Keith Rarick, Andy
        Somerville, Ralf Recker, Øyvind A. Holm, Miklos Vajna,
        Sébastien Hinderer, Thomas Miedema, Joe Malin, Tyler
        Breisacher và Sonia Hamilton đã đóng góp trong việc sửa
        chữa và cải tiến nội dung.</p>

        <p>François Marier đã bảo trì gói Debian do Daniel Baumann
        khởi xướng.</p>

        <p>Tôi cũng gửi lời cảm ơn tới sự giúp đỡ và sự tán dương
        của các bạn. Tôi muốn trích dẫn những lời đó ra đây, nhưng
        làm như thế có vẻ hơi lố bịch, tự cao tự đại.</p>

        <p>Nếu tôi có sai sót gì, xin hãy thông tin hay gửi bản vá
        cho tôi!</p>

        <p><span class="strong"><strong>Nơi có dịch vụ Git miễn
        phí</strong></span>: Những địa chỉ sau đây cho phép lưu trữ
        các dự án công cộng miễn phí. Trân thành cảm ơn các máy chủ
        đã lưu giữ bản hướng dẫn này.</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://repo.or.cz/" target="_top">repo.or.cz</a></li>

            <li class="listitem"><a class="ulink" href=
            "http://gitorious.org/" target=
            "_top">Gitorious</a></li>

            <li class="listitem"><a class="ulink" href=
            "http://github.com/" target="_top">GitHub</a> lưu giữ
            các dự án riêng có thu phí.</li>

            <li class="listitem"><a class="ulink" href=
            "http://www.assembla.com/" target="_top">Assembla</a>:
            lưu giữ các dự án riêng có thu phí, nhưng dù sao thì
            một gigabyte đầu tiên là miễn phí.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Giấy phép sử dụng">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gi%E1%BA%A5y_ph%C3%A9p_s%E1%BB%AD_d%E1%BB%A5ng"></a>Giấy
              phép sử dụng</h2>
            </div>
          </div>
        </div>

        <p>Hướng dẫn này được phát hành dựa trên Giấy Ghép Công
        phiên bản 3 <a class="ulink" href=
        "http://www.gnu.org/licenses/gpl-3.0.html" target=
        "_top">the GNU General Public License version 3</a>. Đương
        nhiên, nội dung của quyển sách được quản lý bằng Git, và
        bạn có thể dễ dàng có được nó bằng cách gõ:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git  # Tạo ra thư mục "gitmagic".
</pre>

        <p>hay từ các máy chủ khác:</p>
        <pre class="literallayout">
$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git
$ git clone git://git.assembla.com/gitmagic.git
</pre>
      </div>
    </div>

    <div class="chapter" title="Chương&nbsp;1.&nbsp;Giới thiệu">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_gi%E1%BB%9Bi_thi%E1%BB%87u"></a>Chương&nbsp;1.&nbsp;Giới
            thiệu</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_c%C3%B4ng_vi%E1%BB%87c_gi%E1%BB%91ng_nh%C6%B0_tr%C3%B2_ch%C6%A1i">
          Công Việc giống như Trò Chơi</a></span></dt>

          <dt><span class="section"><a href=
          "#_qu%E1%BA%A3n_l%C3%BD_m%C3%A3_ngu%E1%BB%93n">Quản Lý Mã
          Nguồn</a></span></dt>

          <dt><span class="section"><a href=
          "#_h%E1%BB%87_th%E1%BB%91ng_ph%C3%A2n_t%C3%A1n">Hệ Thống
          Phân Tán</a></span></dt>

          <dt><span class="section"><a href=
          "#_quan_ni%E1%BB%87m_c%E1%BB%95_h%E1%BB%A7">Quan Niệm Cổ
          Hủ</a></span></dt>

          <dt><span class="section"><a href=
          "#_xung_%C4%91%E1%BB%99t_khi_tr%E1%BB%99n">Xung Đột Khi
          Trộn</a></span></dt>
        </dl>
      </div>

      <p>Tôi sử dụng cách ví von để giới thiệu về hệ thống quản lý
      mã nguồn. Xem <a class="ulink" href=
      "http://en.wikipedia.org/wiki/Revision_control" target=
      "_top">bài viết về quản lý mã nguồn trên Wikipedia</a> để có
      được sự giải thích thỏa đáng.</p>

      <div class="section" title="Công Việc giống như Trò Chơi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_c%C3%B4ng_vi%E1%BB%87c_gi%E1%BB%91ng_nh%C6%B0_tr%C3%B2_ch%C6%A1i">
              </a>Công Việc giống như Trò Chơi</h2>
            </div>
          </div>
        </div>

        <p>Tôi đã chơi trò chơi trên máy tính suốt từ bé đến giờ.
        Ngược lại, tôi chỉ bắt đầu sử dụng hệ thống quản lý mã
        nguồn khi đã trưởng thành. Tôi tin rằng không chỉ có tôi
        như thế, và việc so sánh giữa hai điều đó sẽ làm cho các
        khái niệm trở nên dễ hiểu, dễ giải thích hơn.</p>

        <p>Hãy nghĩ việc biên soạn mã nguồn, tài liệu cũng giống
        như việc chúng ta đang chơi trò chơi trên máy tính. Một khi
        bạn đã làm được kha khá, bạn sẽ muốn ghi lại thành quả công
        việc của mình. Để làm điều đó, bạn chỉ việc bấm vào nút
        <span class="emphasis"><em>Save</em></span> trong chương
        trình biên soạn của mình.</p>

        <p>Nhưng việc làm này sẽ ghi đè lên bản cũ. Điều này cũng
        giống như các trò chơi đã cũ chỉ cho phép ghi trên một tệp
        tin: bạn phải chắc chắn là mình muốn ghi lại, nếu không thì
        bạn không bao giờ có thể quay lại trạng thái cũ nữa. Và
        thật không may vì lần lưu trước đó có thể là đúng tại một
        điểm rất hay trong lượt chơi và bạn muốn thăm lại về sau.
        Tệ hơn nữa là khi bản ghi lại hiện tại lại không đúng, và
        thế là bạn sẽ phải bắt đầu lại từ đầu.</p>
      </div>

      <div class="section" title="Quản Lý Mã Nguồn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qu%E1%BA%A3n_l%C3%BD_m%C3%A3_ngu%E1%BB%93n"></a>Quản
              Lý Mã Nguồn</h2>
            </div>
          </div>
        </div>

        <p>Khi biên soạn, bạn có thể chọn <span class=
        "emphasis"><em>Save As…</em></span> để ghi lại tệp tin hiện
        tại nhưng với một cái tên khác, hay là sao chép tệp tin ra
        một chỗ khác trước khi bạn ghi lại, nếu như bạn muốn dùng
        cả các bản cũ. Bạn có thể nén chúng lại để tiết kiệm dung
        lượng lưu trữ. Đây là dạng thức nguyên thủy và tốn nhiều
        công sức cho việc quản lý dữ liệu. Trò chơi trên máy tính
        đã cải tiến cách trên từ rất lâu rồi, rất nhiều trong số
        chúng cung cấp cho bạn khả năng tự động ghi lại sau từng
        khoảng thời gian nhất định.</p>

        <p>Chúng ta sẽ giải quyết một vấn đề hơi hóc búa một chút
        nhé! Bạn nói rằng bạn có nhiều tệp tin có liên quan mật
        thiết với nhau, như mã nguồn cho một dự án chẳng hạn, hay
        các tệp tin cho một website. Bây giờ nếu bạn muốn giữ một
        phiên bản cũ bạn phải lưu giữ toàn bộ thư mục. Giữ nhiều
        phiên bản như thế bằng cách thủ công thật bất tiện, và sẽ
        nhanh chóng trở nên tốn kém.</p>

        <p>Đối với một số trò chơi, ghi lại một trò chơi thực tế là
        bao gồm toàn bộ thư mục. Những trò chơi này thực thi việc
        này tự động và chỉ đưa ra một giao diện thích hợp cho người
        chơi để quản lý các phiên bản của thư mục này.</p>

        <p>Các hệ thống quản lý mã nguồn cũng hoạt động theo cách
        ấy. Chúng có một giao diện tinh tế để quản lý một nhóm các
        thứ trong thư mục. Bạn có thể ghi lại trạng thái của thư
        mục một cách thường xuyên, và bạn có thể tải lên bất kỳ một
        trạng thái nào đã được ghi lại trước đó. Không giống như
        các trò chơi trên máy tính, chúng thường khôn khéo hơn về
        việc tiết kiệm không gian lưu trữ. Thông thường, chỉ có một
        số ít tài liệu được sửa đổi giữa các phiên bản, và cũng
        không nhiều. Nó chỉ lưu giữ những cái có thay đổi thay vì
        toàn bộ tất cả.</p>
      </div>

      <div class="section" title="Hệ Thống Phân Tán">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_h%E1%BB%87_th%E1%BB%91ng_ph%C3%A2n_t%C3%A1n"></a>Hệ
              Thống Phân Tán</h2>
            </div>
          </div>
        </div>

        <p>Bây giờ hãy tưởng tượng có một trò chơi rất khó. Khó để
        hoàn thành đến mức là có nhiều game thủ lão luyện trên toàn
        thế giới quyết định lập thành đội và chia sẻ những trò chơi
        mà họ đã lưu lại với mục đích là để tất cả mọi người có thể
        theo dõi được nhau. Speedruns là những ví dụ trong đời sống
        thực: các đấu thủ được phân hóa theo các mức của cùng một
        trò chơi hợp tác với nhau để đạt được các kết quả đáng kinh
        ngạc.</p>

        <p>Làm thế nào bạn có thể cài đặt một hệ thống mà chúng có
        thể lấy được từng bản ghi của mỗi người một cách dễ dàng?
        Và tải lên cái mới hơn?</p>

        <p>Ngày xưa, mọi dự án đều sử dụng hệ thống quản lý tập
        trung. Máy chủ ở một chỗ đâu đó và giữ tất cả các trò chơi
        đã được ghi lại. Không còn ai khác làm điều đó nữa. Mọi
        người giữ phần lớn các trò chơi được ghi lại trong máy của
        họ. Khi một đấu thủ muốn chơi, họ có thể tải về bản ghi lại
        cuối cùng đã lưu lại ở máy chủ, chơi một lúc, ghi lại và
        tải trở lại máy chủ để mọi người có thể sử dụng.</p>

        <p>Điều gì xảy ra khi một người chơi, vì một lý do nào đó,
        muốn có được lần chơi cũ hơn? Lý do có thể là lần chơi hiện
        tại không ổn định hay có sai sót bởi vì một người chơi nào
        đó quên không chỉnh lại trò chơi về mức 3, và họ muốn tìm
        lần chơi đã ghi lại cuối cùng mà họ vẫn chưa hoàn thành.
        Hay có thể là họ muốn so sánh sự khác nhau giữa các lần
        chơi để thấy được thành quả của từng người chơi.</p>

        <p>Có rất nhiều lý do vì sao cần đến bản cũ hơn, nhưng kết
        cục là giống nhau. Họ phải hỏi máy chủ trung tâm để lấy về
        trò chơi cũ đã được lưu lại. Càng ghi lại nhiều trò chơi,
        họ càng cần phải liên lạc nhiều với nhau.</p>

        <p>Những hệ thống quản lý mã nguồn thế hệ mới, Git cũng nằm
        trong số đó, được biết đến như một hệ thống phân tán, và có
        thể coi nó là một hệ thống tập trung có mở rộng. Khi người
        chơi tải về từ máy chủ chính, họ lấy toàn bộ tất cả các lần
        đã ghi lại, không chỉ mỗi bản cuối cùng. Điều đó có nghĩa
        là họ trở thành bản sao của máy chủ trung tâm.</p>

        <p>Việc khởi tạo bản sao như thế có vẻ hơi xa hoa, đặc biệt
        là nếu nó có lịch sử phát triển lâu dài, nhưng cái giá phải
        trả cũng chỉ là việc cần nhiều thời gian để lấy về. Một lợi
        ích trực tiếp của việc này là khi các tài liệu cũ cần đến,
        việc liên lạc với máy chủ trung tâm là không cần thiết
        nữa.</p>
      </div>

      <div class="section" title="Quan Niệm Cổ Hủ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_quan_ni%E1%BB%87m_c%E1%BB%95_h%E1%BB%A7"></a>Quan
              Niệm Cổ Hủ</h2>
            </div>
          </div>
        </div>

        <p>Một quan niệm phổ biến là hệ thống phân tán không thích
        hợp với các dự án có yêu cầu một kho chứa trung tâm chính
        thức. Không điều gì có thể chà đạp lên sự thật. Chụp ảnh ai
        đó không có nghĩa là lấy đi linh hồn họ. Cũng như thế, nhân
        bản kho chính cũng không làm giảm đi sự quan trọng của
        nó.</p>

        <p>Tóm lại, một hệ thống phân tán đã thiết kế tốt thì làm
        bất cứ công việc nào cũng khá hơn một hệ thống quản lý mã
        nguồn tập trung. Tài nguyên mạng thường thì tốn kém hơn các
        tài nguyên nội bộ. Chúng ta sẽ nói đến các hạn chế của hệ
        thống phân tán sau, sự so sánh như sau thường đúng: hệ
        thống phân tán thường tốt hơn.</p>

        <p>Một dự án nhỏ có thể chỉ cần dùng một phần nhỏ các đặc
        tính được đưa ra bởi một hệ thống như thế, nhưng việc sử
        dụng một hệ thống không có khả năng mở rộng cho một dự án
        nhỏ thì cũng giống như việc sử dụng hệ thống số La Mã để
        tính toán các số nhỏ.</p>

        <p>Hơn thế nữa, dự án của bạn có thể lớn vượt ra ngoài dự
        kiến ban đầu. Việc sử dụng Git từ lúc khởi sự thì cũng
        giống như việc sử dụng một bộ dao vạn năng chỉ để phục vụ
        cho mỗi việc mở nút chai. Đến một ngày nào đó bạn cấn đến
        một cái chìa vít bạn sẽ vui sướng vì mình không chỉ có mỗi
        cái mở nút chai.</p>
      </div>

      <div class="section" title="Xung Đột Khi Trộn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_xung_%C4%91%E1%BB%99t_khi_tr%E1%BB%99n"></a>Xung
              Đột Khi Trộn</h2>
            </div>
          </div>
        </div>

        <p>Với chủ đề này, dùng cách ví von nó với một trò chơi
        trên máy tính là hơi khó. Thay vì thế, để chúng tôi dùng
        việc biên soạn một tài liệu để giải thích cho bạn.</p>

        <p>Giả sử Alice chèn thêm một dòng vào đầu một tệp tin, và
        Bob nối một dòng vào cuối của bản sao của mình. Cả hai đều
        tải lên các thay đổi của mình. Phần lớn các hệ thống sẽ tự
        động tìm ra hành động hợp lý: chấp nhận và trộn các sự thay
        đổi của họ, do đó cả hai sự thay đổi mà Alice và Bob tạo ra
        đều được dùng.</p>

        <p>Bây giờ giả sử cả Alice và Bob cùng sửa một dòng. Thế
        thì mâu thuẫn này không thể sử lý được mà không có sự can
        thiệp của con người. Người thứ hai tải lên sẽ được thông
        báo có xung đột xảy ra, <span class="emphasis"><em>merge
        conflict</em></span>, và phải chọn một là sửa thêm nữa, hay
        sửa lại toàn bộ dòng đó.</p>

        <p>Nhiều tình huống phức tạp có thể nảy sinh. Hệ thống quản
        lý mã nguồn giữ phần dễ dàng cho chúng, và để lại những
        tình huống khó khăn cho chúng ta. Nhưng thông thường cách
        ứng xử của chúng có thể điều chỉnh được.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;2.&nbsp;Các Thủ Thuật Cơ Bản">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_c%C3%A1c_th%E1%BB%A7_thu%E1%BA%ADt_c%C6%A1_b%E1%BA%A3n">
            </a>Chương&nbsp;2.&nbsp;Các Thủ Thuật Cơ Bản</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_ghi_l%E1%BA%A1i_tr%E1%BA%A1ng_th%C3%A1i">Ghi lại Trạng
          thái</a></span></dt>

          <dt><span class="section"><a href=
          "#_th%C3%AAm_x%C3%B3a_%C4%91%E1%BB%95i_t%C3%AAn">Thêm,
          Xóa, Đổi Tên</a></span></dt>

          <dt><span class="section"><a href=
          "#_ch%E1%BB%A9c_n%C4%83ng_undo_redo">Chức Năng
          Undo/Redo</a></span></dt>

          <dt><span class="section"><a href=
          "#_s%E1%BB%B1_quay_l%E1%BA%A1i">Sự quay
          lại</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%E1%BA%A1o_nh%E1%BA%ADt_k%C3%BD_c%C3%A1c_thay_%C4%91%E1%BB%95i">
          Tạo Nhật Ký các thay đổi</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%E1%BA%A3i_v%E1%BB%81_c%C3%A1c_t%E1%BB%87p_tin">Tải
          về các Tệp tin</a></span></dt>

          <dt><span class="section"><a href=
          "#_th%E1%BB%AD_nghi%E1%BB%87m">Thử Nghiệm</a></span></dt>

          <dt><span class="section"><a href=
          "#_xu%E1%BA%A5t_b%E1%BA%A3n">Xuất Bản</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%C3%B4i_%C4%91%C3%A3_l%C3%A0m_%C4%91%C6%B0%E1%BB%A3c_g%C3%AC">
          Tôi Đã Làm Được Gì?</a></span></dt>

          <dt><span class="section"><a href=
          "#_b%C3%A0i_t%E1%BA%ADp">Bài Tập</a></span></dt>
        </dl>
      </div>

      <p>Thay vì lao vào cả một biển lệnh với Git, bạn hãy sử dụng
      các ví dụ cơ bản để bắt đầu. Mặc dù chúng rất đơn giản, nhưng
      tất cả chúng đều rất hữu dụng. Quả thực là vậy, trong tháng
      đầu tiên sử dụng Git tôi chưa bao giờ vượt qua những gì nói
      trong chương này.</p>

      <div class="section" title="Ghi lại Trạng thái">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ghi_l%E1%BA%A1i_tr%E1%BA%A1ng_th%C3%A1i"></a>Ghi
              lại Trạng thái</h2>
            </div>
          </div>
        </div>

        <p>Bạn muốn thử thực hiện một số lệnh gì đó với Git? Trước
        khi làm điều đó, thực hiện các lệnh sau trong thư mục hiện
        hành chứa các mã nguồn hay văn bản mà bạn muốn quản lý:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Bản sao lưu đầu tiên"
</pre>

        <p>Bây giờ nếu như các sửa đổi vừa xong của bạn không như
        mong đợi, hãy phục hồi lại bản cũ:</p>
        <pre class="literallayout">
$ git reset --hard # Đặt lại trạng thái và dữ liệu như lần commit cuối
</pre>

        <p>Sau đó sửa nội dung cho đúng ý bạn rồi ghi lại thành một
        trạng thái mới:</p>
        <pre class="literallayout">
$ git commit -a -m "Bản sao lưu khác"
</pre>
      </div>

      <div class="section" title="Thêm, Xóa, Đổi Tên">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_th%C3%AAm_x%C3%B3a_%C4%91%E1%BB%95i_t%C3%AAn"></a>Thêm,
              Xóa, Đổi Tên</h2>
            </div>
          </div>
        </div>

        <p>Lệnh ở trên chỉ giữ dấu vết các tệp tin hiện diện tại
        thời điểm bạn chạy lệnh <span class="strong"><strong>git
        add</strong></span>. Nếu bạn thêm các tệp tin hay thư mục,
        thì bạn sẽ phải thông báo với Git:</p>
        <pre class="literallayout">
$ git add readme.txt Documentation
</pre>

        <p>Tương tự như vậy, nếu bạn muốn Git bỏ đi các tệp tin nào
        đó:</p>
        <pre class="literallayout">
$ git rm kludge.h obsolete.c
$ git rm -r incriminating/evidence/ #gỡ bỏ một cách đệ qui
</pre>

        <p>Git xóa bỏ những tệp tin nếu như bạn chưa làm.</p>

        <p>Đổi tên tệp tin thì cũng giống như là việc bạn gỡ bỏ tên
        cũ và đặt vào nó cái tên mới. Sử dụng lệnh <span class=
        "strong"><strong>git mv</strong></span> có cú pháp rất
        giống lệnh <span class="strong"><strong>mv</strong></span>
        của hệ thống Linux. Ví dụ:</p>
        <pre class="literallayout">
$ git mv bug.c feature.c
</pre>
      </div>

      <div class="section" title="Chức Năng Undo/Redo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ch%E1%BB%A9c_n%C4%83ng_undo_redo"></a>Chức Năng
              Undo/Redo</h2>
            </div>
          </div>
        </div>

        <p>Đôi khi bạn chỉ muốn quay trở lại và bỏ đi những thay
        đổi trong quá khứ tại một thời điểm nào đó bởi vì chúng tất
        cả đã sai. Thì lệnh:</p>
        <pre class="literallayout">
$ git log
</pre>

        <p>sẽ hiển thị cho bạn danh sách các lần commit gần đây
        cùng với giá trị băm SHA1:</p>
        <pre class="screen">
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob &lt;bob@example.com&gt;
Date:   Tue Mar 14 01:59:26 2000 -0800

    Replace printf() with write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice &lt;alice@example.com&gt;
Date:   Thu Jan 1 00:00:00 1970 +0000

    Initial commit.
</pre>

        <p>Chỉ vài ký tự của giá trị băm là đủ để chỉ ra một commit
        cụ thể; một cách khác là chép và dán giá trị băm. Gõ:</p>
        <pre class="literallayout">
$ git reset --hard 766f
</pre>

        <p>để phục hồi lại trạng thái đã được chỉ ra và xóa bỏ tất
        cả các lần commit mới hơn kể từ đó.</p>

        <p>Một lúc nào đó bạn lại muốn nhảy tới một bản cũ hơn.
        Trong trường hợp này thì gõ:</p>
        <pre class="literallayout">
$ git checkout 82f5
</pre>

        <p>Nó giúp bạn quay lại đúng thời điểm đó, trong khi vẫn
        giữ lại những lần commit mới hơn. Tuy nhiên, giống như cỗ
        máy thời gian trong các bộ phim khoa học viễn tưởng, nếu
        bây giờ bạn sửa sau đó commit, bạn sẽ ở trong một thực tại
        khác, bởi vì hành động của bạn bây giờ đã khác với khi
        chúng ta lần đầu tiên ở tại đây.</p>

        <p>Có cách thực tế hơn là sử dụng <span class=
        "emphasis"><em>branch</em></span>, và <a class="link" href=
        "#branch">chúng ta có nhiều điều để nói về nó sau này</a>.
        Bây giờ, chỉ cần nhớ là:</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>sẽ mang chúng ta trở về hiện tại. Ngoài ra, để tránh rủi
        ro khi sử dụng Git, thì luôn luôn commit hay reset các thay
        đổi của bạn trước khi chạy lệnh checkout.</p>

        <p>Sự tương đồng với game trên máy tính:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git reset
            --hard</code></strong></span>: lấy cái cũ đã được lưu
            lại và xóa tất cả các games mới hơn cái vừa lấy.</li>

            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git
            checkout</code></strong></span>: lấy một cái cũ, nhưng
            chỉ chơi với nó, trạng thái của game sẽ tách riêng về
            phía mới hơn chỗ mà bạn đã ghi lại lần đầu tiên. Bất kỳ
            game nào bạn tạo từ bây giờ sẽ là bản cuối cùng trong
            nhánh riêng rẽ tương ứng với một thực tại khác mà bạn
            đã gia nhập vào. <a class="link" href="#branch">chúng
            tôi sẽ nói sau</a>.</li>
          </ul>
        </div>

        <p>Bạn có thể chọn chỉ phục hồi lại các tệp tin hay thư mục
        bạn muốn bằng cách thêm vào chúng vào phần sau của câu
        lệnh:</p>
        <pre class="literallayout">
$ git checkout 82f5 some.file another.file
</pre>

        <p>Bạn phải cẩn thận khi sử dụng các lệnh, như là lệnh
        <span class="strong"><strong>checkout</strong></span> có
        thể âm thầm ghi đè lên các tệp tin. Để ngăn ngừa rủi ro như
        thế, hãy commit trước khi chạy lệnh checkout, nhất là khi
        mới học sử dụng Git. Tóm lại, bất kỳ khi nào bạn không chắc
        chắn về một lệnh nào đó, dù có là lệnh của Git hay không,
        đầu tiên hãy chạy lệnh <span class="strong"><strong>git
        commit -a</strong></span>.</p>

        <p>Bạn không thích việc cắt dán ư? Hãy sử dụng:</p>
        <pre class="literallayout">
$ git checkout :/"My first b"
</pre>

        <p>để nhảy tới lần commit mà phần chú thích của nó bắt đầu
        với chuỗi bạn đã cho. Bạn cũng có thể yêu cầu trạng thái
        thứ 5 kể từ cái cuối cùng:</p>
        <pre class="literallayout">
$ git checkout master~5
</pre>
      </div>

      <div class="section" title="Sự quay lại">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_s%E1%BB%B1_quay_l%E1%BA%A1i"></a>Sự quay lại</h2>
            </div>
          </div>
        </div>

        <p>Trong một phiên tòa, mỗi sự kiện được gắn với một bản
        ghi. Cũng giống thế, bạn có thể chọn lệnh commit để
        undo.</p>
        <pre class="literallayout">
$ git commit -a
$ git revert 1b6d
</pre>

        <p>sẽ chỉ undo lần commit với giá trị băm đã chỉ ra. Sự
        quay trở lại được ghi nhận như là một lần commit mới, bạn
        có thể xác nhận lại điều này bằng lệnh <span class=
        "strong"><strong>git log</strong></span>.</p>
      </div>

      <div class="section" title="Tạo Nhật Ký các thay đổi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%E1%BA%A1o_nh%E1%BA%ADt_k%C3%BD_c%C3%A1c_thay_%C4%91%E1%BB%95i">
              </a>Tạo Nhật Ký các thay đổi</h2>
            </div>
          </div>
        </div>

        <p>Một số dự án yêu cầu có một <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Changelog" target=
        "_top">changelog</a>. Tạo một cái bằng cách gõ:</p>
        <pre class="literallayout">
$ git log &gt; ThayĐổi
</pre>
      </div>

      <div class="section" title="Tải về các Tệp tin">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%E1%BA%A3i_v%E1%BB%81_c%C3%A1c_t%E1%BB%87p_tin"></a>Tải
              về các Tệp tin</h2>
            </div>
          </div>
        </div>

        <p>Lấy về một bản sao của một dự án quản lý bằng Git bằng
        cách gõ:</p>
        <pre class="literallayout">
$ git clone git://server/path/to/files
</pre>

        <p>Ví dụ, để lấy tất cả các tệp tin mà tôi đã dùng để tạo
        ra cho quyển sách này là:</p>
        <pre class="literallayout">
$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>Chúng ta sẽ có nhiều điều để nói về lệnh <span class=
        "strong"><strong>clone</strong></span> sớm thôi.</p>
      </div>

      <div class="section" title="Thử Nghiệm">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_th%E1%BB%AD_nghi%E1%BB%87m"></a>Thử Nghiệm</h2>
            </div>
          </div>
        </div>

        <p>Nếu bạn đã tải về một bản sao của một dự án bằng lệnh
        <span class="strong"><strong>git clone</strong></span>, bạn
        có thể lấy về phiên bản cuối cùng với lệnh:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Xuất Bản">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_xu%E1%BA%A5t_b%E1%BA%A3n"></a>Xuất Bản</h2>
            </div>
          </div>
        </div>

        <p>Giả sử bạn đã tạo được một kho Git và bạn muốn chia sẻ
        nó với người khác. Bạn có thể bảo họ tải về từ máy tính của
        mình, nhưng nếu họ làm như thế trong khi bạn đang cải tiến
        nó hay có những thay đổi mang tính thử nghiệm, họ có thể
        gặp trục trặc. Dĩ nhiên, đây là lý do tại sao mà chu kỳ
        phát hành phần mềm lại tồn tại phải không nào. Những người
        phát triển có thể làm việc thường xuyên trên một dự án,
        nhưng họ chỉ xuất bản những đoạn mã mà họ cảm thấy nó có
        thể dùng được để tránh ảnh hưởng đến người khác.</p>

        <p>Thực hiện điều này với Git, trong thư mục làm việc của
        Git:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Bản phát hành đầu tiên"
</pre>

        <p>Sau đó nói với những người cùng sử dụng hãy chạy:</p>
        <pre class="literallayout">
$ git clone your.computer:/path/to/script
</pre>

        <p>để tải dữ liệu về. Giả định là họ truy cập thông qua
        ssh. Nếu không, chạy <span class="strong"><strong>git
        daemon</strong></span> và nói với người sử dụng là chạy
        lệnh sau để thay thế:</p>
        <pre class="literallayout">
$ git clone git://your.computer/path/to/script
</pre>

        <p>Kể từ lúc này, bất cứ khi nào mã nguồn của bạn đã có thể
        sử dụng được, chỉ việc thực hiện:</p>
        <pre class="literallayout">
$ git commit -a -m "Bản phát hành tiếp"
</pre>

        <p>và những người sử dụng có thể cập nhật dữ liệu của họ
        bằng cách chuyển tới thư mục làm việc tương ứng và gõ:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Những người sử dụng sẽ không bao giờ thấy được dữ liệu
        cuối cùng của bạn mà bạn không muốn họ thấy.</p>
      </div>

      <div class="section" title="Tôi Đã Làm Được Gì?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%C3%B4i_%C4%91%C3%A3_l%C3%A0m_%C4%91%C6%B0%E1%BB%A3c_g%C3%AC">
              </a>Tôi Đã Làm Được Gì?</h2>
            </div>
          </div>
        </div>

        <p>Tìm tất cả các thay đổi kề từ lần bạn commit lần cuối
        bằng lệnh:</p>
        <pre class="literallayout">
$ git diff
</pre>

        <p>Hay từ hôm qua:</p>
        <pre class="literallayout">
$ git diff "@{yesterday}"
</pre>

        <p>Hay giữa một bản nào đó và bản trước đây 2 bản:</p>
        <pre class="literallayout">
$ git diff 1b6d "master~2"
</pre>

        <p>Trong từng trường hợp, đầu ra là một miếng vá mà nó có
        thể được sử dụng với lệnh <span class="strong"><strong>git
        apply</strong></span>. Cũng có thể dùng lệnh:</p>
        <pre class="literallayout">
$ git whatchanged --since="2 weeks ago"
</pre>

        <p>Thường thường, tôi duyệt lịch sử bằng <a class="ulink"
        href="http://sourceforge.net/projects/qgit" target=
        "_top">qgit</a> để thay thế cách ở trên, bởi vì nó có giao
        diện đồ họa bóng bẩy, hay <a class="ulink" href=
        "http://jonas.nitro.dk/tig/" target="_top">tig</a>, có giao
        diện dòng lệnh làm việc rất tốt với các máy có kết nối mạng
        chậm. Một lựa chọn khác là cài đặt máy chủ web, chạy lệnh
        <span class="strong"><strong>git instaweb</strong></span>
        và sử dụng bất kỳ trình duyệt web nào.</p>
      </div>

      <div class="section" title="Bài Tập">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_b%C3%A0i_t%E1%BA%ADp"></a>Bài Tập</h2>
            </div>
          </div>
        </div>

        <p>Coi A, B, C, D là 4 lần commit thành công, nơi mà B
        giống A ngoại trừ một số tệp tin bị xóa bỏ. Chúng ta muốn
        thêm các tệp tin đó trở lại D. Chúng ta thực hiện điều này
        bằng cách nào?</p>

        <p>Ở đây chúng ta có ít nhất 3 giải pháp. Giả thiết chúng
        ta đang ở D:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">Sự khác nhau giữa A và B là việc
              các tệp tin đã bị gỡ bỏ. Chúng ta có thể tạo miếng vá
              tương ứng với sự khác biệt này và apply nó:</p>
              <pre class="literallayout">
$ git diff B A | git apply
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Kể từ sau khi chúng ta ghi lại các
              tệp tin tại A trở đi, chúng ta có thể lấy lại:</p>
              <pre class="literallayout">
$ git checkout A foo.c bar.h
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Chúng ta có thể xem sự di chuyển
              từ A tới B giống như là một thay đổi mà chúng ta muốn
              undo:</p>
              <pre class="literallayout">
$ git revert B
</pre>
            </li>
          </ol>
        </div>

        <p>Lựa chọn nào là tốt nhất? Cách nào bạn thích nhất. Thật
        dễ dàng để có được thứ mà bạn muốn với Git, và thường là có
        nhiều hơn một cách để thực hiện được một thứ bạn muốn.</p>
      </div>
    </div>

    <div class="chapter" title="Chương&nbsp;3.&nbsp;Nhân Bản">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_nh%C3%A2n_b%E1%BA%A3n"></a>Chương&nbsp;3.&nbsp;Nhân
            Bản</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%C4%91%E1%BB%93ng_b%E1%BB%99_h%C3%B3a_c%C3%A1c_m%C3%A1y_t%C3%ADnh">
          Đồng bộ hóa Các Máy tính</a></span></dt>

          <dt><span class="section"><a href=
          "#_qu%E1%BA%A3n_l%C3%BD_theo_c%C3%A1ch_c%C5%A9">Quản lý
          theo cách Cũ</a></span></dt>

          <dt><span class="section"><a href=
          "#_m%C3%A3_ngu%E1%BB%93n_ri%C3%AAng_t%C6%B0">Mã nguồn
          riêng tư</a></span></dt>

          <dt><span class="section"><a href=
          "#_kho_thu%E1%BA%A7n">Kho thuần</a></span></dt>

          <dt><span class="section"><a href=
          "#_push_ng%C6%B0%E1%BB%A3c_v%E1%BB%9Bi_pull">Push ngược
          với pull</a></span></dt>

          <dt><span class="section"><a href=
          "#_r%E1%BA%BD_nh%C3%A1nh_m%E1%BB%99t_d%E1%BB%B1_%C3%A1n">Rẽ
          Nhánh một Dự Án</a></span></dt>

          <dt><span class="section"><a href=
          "#_sao_l%C6%B0u_kh%C3%B4ng_gi%E1%BB%9Bi_h%E1%BA%A1n">Sao
          Lưu Không Giới Hạn</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%C3%A0m_nhi%E1%BB%81u_vi%E1%BB%87c_c%C3%B9ng_l%C3%BAc">
          Làm nhiều việc cùng lúc</a></span></dt>

          <dt><span class="section"><a href=
          "#_song_h%C3%A0nh_c%C3%B9ng_c%C3%A1c_h%E1%BB%87_th%E1%BB%91ng_scm_kh%C3%A1c">
          Song Hành cùng các hệ thống SCM khác</a></span></dt>

          <dt><span class="section"><a href=
          "#_mercurial">Mercurial</a></span></dt>

          <dt><span class="section"><a href=
          "#_bazaar">Bazaar</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%E1%BA%A1i_sao_t%C3%B4i_s%E1%BB%AD_d%E1%BB%A5ng_git">Tại
          sao Tôi sử dụng Git</a></span></dt>
        </dl>
      </div>

      <p>Trong các hệ thống quản lý mã nguồn trước đây, checkout là
      tác vụ cơ bản để lấy các tệp tin về. Bạn lấy về toàn bộ các
      tập tin được lưu giữ trong từng phiên bản riêng biệt.</p>

      <p>Với Git và các hệ thống quản lý mã nguồn phân tán, clone
      là tác vụ cơ bản. Để lấy các tệp tin, bạn tạo một của toàn bộ
      kho chứa. Nói cách khác, bạn thực tế là một bản sao của máy
      chủ trung tâm. Bất kỳ cái gì bạn thể làm được với kho chứa
      chính thì cũng làm được ở đây.</p>

      <div class="section" title="Đồng bộ hóa Các Máy tính">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91%E1%BB%93ng_b%E1%BB%99_h%C3%B3a_c%C3%A1c_m%C3%A1y_t%C3%ADnh">
              </a>Đồng bộ hóa Các Máy tính</h2>
            </div>
          </div>
        </div>

        <p>Tôi có thể tạo gói tarball hay sử dụng lệnh <span class=
        "strong"><strong>rsync</strong></span> để sao lưu dự phòng
        và đồng bộ hóa dữ liệu. Nhưng thỉnh thoảng, tôi biên tập
        trên máy tính xách tay của mình, nhưng lúc khác lại trên
        máy tính để bàn, và chúng có thể không có sự trao đổi được
        với nhau.</p>

        <p>Khởi tạo kho chứa Git và commit các tệp tin trên một máy
        tính. Sau đó trên máy tính kia chạy lệnh:</p>
        <pre class="literallayout">
$ git clone other.computer:/path/to/files
</pre>

        <p>để tạo một bản sao thứ hai cho các tệp tin và kho chứa.
        Từ giờ trở đi,</p>
        <pre class="literallayout">
$ git commit -a
$ git pull other.computer:/path/to/files HEAD
</pre>

        <p>sẽ lấy về một trạng thái của các tệp tin trên máy tính
        khác về máy bạn đang làm việc. Nếu bạn vừa tạo ra một sự
        chỉnh sửa xung đột trong cùng một tệp tin , Git sẽ cho bạn
        biết và bạn có thể commit lại sau khi đã sửa chữa
        chúng.</p>
      </div>

      <div class="section" title="Quản lý theo cách Cũ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qu%E1%BA%A3n_l%C3%BD_theo_c%C3%A1ch_c%C5%A9"></a>Quản
              lý theo cách Cũ</h2>
            </div>
          </div>
        </div>

        <p>Khởi tạo kho Git cho các tệp tin của bạn:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Lần commit khởi tạo"
</pre>

        <p>Trên máy chủ trung tâm, khởi tạo <span class=
        "emphasis"><em>kho bare</em></span> ở một thư mục nào
        đó:</p>
        <pre class="literallayout">
$ mkdir proj.git
$ cd proj.git
$ git init --bare
$ touch proj.git/git-daemon-export-ok
</pre>

        <p>Khởi động dịch vụ Git daemon nếu cần:</p>
        <pre class="literallayout">
$ git daemon --detach  # nó có thể đã hoạt động rồi
</pre>

        <p>Để làm một máy chủ chạy dịch vụ Git, làm theo các chỉ
        dẫn sau để cài đặt và khởi tạo kho Git. Cách thường thấy
        nhất là điền vào mẫu có sẵn trên trang web.</p>

        <p><span class="emphasis"><em>Push</em></span> dự án của
        bạn lên máy chủ trung tâm bằng lệnh:</p>
        <pre class="literallayout">
$ git push central.server/path/to/proj.git HEAD
</pre>

        <p>Để lấy về mã nguồn, các nhà phát triển phần mềm chỉ cần
        gõ:</p>
        <pre class="literallayout">
$ git clone central.server/path/to/proj.git
</pre>

        <p>Sau khi thay đổi, các nhà phát triển phần mềm sẽ lưu lại
        các thay đổi trên máy tính của mình:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Để cập nhật lên bản mới nhất:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Mọi xung đột phải được xử lý trước, sau đó mới
        commit:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Gửi thay đổi của mình lên máy chủ trung tâm:</p>
        <pre class="literallayout">
$ git push
</pre>

        <p>Nếu máy chủ trung tâm có thay đổi bởi hành động của một
        người phát triển phần mềm khác, quá trình push sẽ bị lỗi,
        và anh ta phải pull về bản mới nhất, xử lý các xung đột khi
        trộn, sau đó thử lại.</p>

        <p>Người dùng phải có quyền truy cập SSH mới có thể thực
        hiện được lệnh pull và push ở trên. Tuy nhiên, ai cũng có
        thể lấy mã nguồn về bằng lệnh::</p>
        <pre class="literallayout">
$ git clone git://central.server/path/to/proj.git
</pre>

        <p>Giao thức git nguyên bản thì cũng giống như là HTTP: ở
        đây không cần xác thực, do vậy ai cũng có thể lấy về dự án.
        Do vậy, theo mặc định, việc push thông qua giao thức git là
        không được phép.</p>
      </div>

      <div class="section" title="Mã nguồn riêng tư">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_m%C3%A3_ngu%E1%BB%93n_ri%C3%AAng_t%C6%B0"></a>Mã
              nguồn riêng tư</h2>
            </div>
          </div>
        </div>

        <p>Với một dự án nguồn-đóng, bỏ quên lệnh touch, và chắc
        chắn là chưa từng tạo ra file nào có tên <code class=
        "literal">git-daemon-export-ok</code>. Kho chứa từ giờ trở
        đi không thể lấy về thông qua giao thức git; chỉ những
        người có khả năng truy cập bằng SSH mới có thể thấy nó. Nếu
        tất cả các kho chứa đều đóng, việc chạy git daemon là không
        cần thiết nữa bởi vì tất cả việc truyền thông bây giờ đều
        thông qua SSH.</p>
      </div>

      <div class="section" title="Kho thuần">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_kho_thu%E1%BA%A7n"></a>Kho thuần</h2>
            </div>
          </div>
        </div>

        <p>Kho thuần (bare) được đặt tên như vậy vì nó không chứa
        thư mục làm việc; nó chỉ chứa các tệp tin thường là ẩn
        trong thư mục phụ <code class="literal">.git</code>. Hay
        nói cách khác, nó chứa lịch sử mã nguồn của một dự án, và
        không bao giờ giữ dữ liệu còn đang dang dở của bất kỳ phiên
        bản nào.</p>

        <p>Kho thuần có vai trò hoạt động giống như máy chủ trung
        tâm trong các hệ thống quản lý mã nguồn tập trung: thư mục
        chủ dự án của bạn. Các nhà phát triển phần mềm nhân bản dữ
        liệu dự án của bạn ở đây, và push các thay đổi chính thức
        lên đó. Thông thường nó đặt tại máy chủ mà máy này đôi khi
        còn làm một số việc khác nữa. Sự biên soạn mã nguồn xảy ra
        trên bản sao, vì vậy thư mục chủ của kho chứa có thể hoạt
        động mà không cần thư mục làm việc.</p>

        <p>Nhiều lệnh Git gặp lỗi trên kho thuần trừ phi biến môi
        trường <code class="literal">GIT_DIR</code> được đặt với
        giá trị là đường dẫn đến kho chứa, hay tùy chọn
        <code class="literal">--bare</code> được áp dụng.</p>
      </div>

      <div class="section" title="Push ngược với pull">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_push_ng%C6%B0%E1%BB%A3c_v%E1%BB%9Bi_pull"></a>Push
              ngược với pull</h2>
            </div>
          </div>
        </div>

        <p>Tại sao chúng tôi lại giới thiệu lệnh push, thay vì
        trông cậy vào lệnh pull quen thuộc? Trước hết, việc pull
        gặp lỗi trên kho thuần: thay vào đó bạn phải dùng lệnh
        <span class="emphasis"><em>fetch</em></span>, lệnh này
        chúng ta sẽ nói sau. Nhưng dù là chúng ta giữ kho chứa
        thông thường trên máy chủ trung tâm, việc pull lên nó hơi
        cồng kềnh. Chúng ta phải đăng nhập vào máy chủ trước, và
        cung cấp cho lệnh pull địa chỉ mạng của máy chúng ta đang
        pull từ đó. Chương trình tường lửa có thể gây trở ngại, và
        điều gì xảy ra khi chúng ta không có khả năng truy cập
        shell máy chủ trong chỗ đầu tiên đó?</p>

        <p>Tuy nhiên, ngoài trường hợp này ra, chúng ta còn nản
        lòng với việc push lên kho chứa, bởi vì tình trạng hỗn loạn
        có thể xảy khi thư mục đích có chứa thư mục làm việc.</p>

        <p>Tóm lại, khi bạn học Git, chỉ push khi đích là kho
        thuần; nếu không thì dùng pull.</p>
      </div>

      <div class="section" title="Rẽ Nhánh một Dự Án">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_r%E1%BA%BD_nh%C3%A1nh_m%E1%BB%99t_d%E1%BB%B1_%C3%A1n">
              </a>Rẽ Nhánh một Dự Án</h2>
            </div>
          </div>
        </div>

        <p>Bạn chán ngấy cách mà dự án mà bạn đang làm việc chạy?
        Bạn nghĩ mình có thể làm tốt hơn thế? Thế thì trên máy chủ
        của mình:</p>
        <pre class="literallayout">
$ git clone git://main.server/path/to/files
</pre>

        <p>Tiếp theo, nói với mọi người về việc nhánh rẽ từ dự án
        tại máy chủ của bạn.</p>

        <p>Từ bây giờ trở đi, bạn có thể trộn các sự thay đổi từ dự
        án gốc với lệnh:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Sao Lưu Không Giới Hạn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_sao_l%C6%B0u_kh%C3%B4ng_gi%E1%BB%9Bi_h%E1%BA%A1n"></a>Sao
              Lưu Không Giới Hạn</h2>
            </div>
          </div>
        </div>

        <p>Bạn muốn lưu trữ dự án của mình ở nhiều nơi khác nhau ư?
        Nếu dự án của bạn có nhiều người cùng phát triển, bạn không
        cần phải làm gì cả! Mỗi một bản sao đều đồng thời có tác
        dụng như một bản sao lưu dự phòng. Mỗi bản sao không chỉ
        lưu trạng thái hiện hành mà toàn bộ lịch sử trong dự án.
        Nhờ có giá trị băm bằng mật mã, nếu bản sao của người nào
        đó bị hỏng, nó sẽ được phát hiện ngay sau khi họ liên lạc
        với những người khác.</p>

        <p>Nếu dự án của bạn không phổ biến, hãy tìm máy chủ lưu
        giữ bản sao của mình càng nhiều càng tốt.</p>

        <p>Người mắc bệnh hoang tưởng sẽ luôn luôn ghi ra 20-byte
        giá trị băm SHA1 cuối cùng của HEAD ở đâu đó an toàn. Nó
        phải an toàn, không riêng tư. Ví dụ, xuất bản nó lên báo
        giấy cũng tốt, bởi vì rất khó để thay đổi tất cả các bản
        sao của nó.</p>
      </div>

      <div class="section" title="Làm nhiều việc cùng lúc">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%C3%A0m_nhi%E1%BB%81u_vi%E1%BB%87c_c%C3%B9ng_l%C3%BAc">
              </a>Làm nhiều việc cùng lúc</h2>
            </div>
          </div>
        </div>

        <p>Bạn muốn làm nhiều việc cùng một lúc trên một dự án. Thế
        thì hãy commit dự án của bạn và chạy:</p>
        <pre class="literallayout">
$ git clone . /some/new/directory
</pre>

        <p>Nhờ có <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Hard_link" target="_top">liên
        kết cứng</a>, việc nhân bản nội bộ yêu cầu ít không gian và
        thời gian hơn so với việc sao lưu thông thường.</p>

        <p>Bây giờ bạn có thể làm hai công việc độc lập nhau cùng
        một lúc. Ví dụ như, bạn có thể biên soạn trên bản sao này
        trong khi bản sao kia đang được biên dịch. Tại bất kỳ thời
        điểm nào, bạn cũng có thể commit và pull các thay đỏi từ
        một bản sao khác:</p>
        <pre class="literallayout">
$ git pull /the/other/clone HEAD
</pre>
      </div>

      <div class="section" title=
      "Song Hành cùng các hệ thống SCM khác">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_song_h%C3%A0nh_c%C3%B9ng_c%C3%A1c_h%E1%BB%87_th%E1%BB%91ng_scm_kh%C3%A1c">
              </a>Song Hành cùng các hệ thống SCM khác</h2>
            </div>
          </div>
        </div>

        <p>Bạn đang làm việc cho một dự án có sử dụng hệ thống quản
        lý mã nguồn cũ, và bạn lại muốn sử dụng Git? Thế thì hãy
        khởi tạo kho chứa Git trong thư mục bạn đang làm việc:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Lần commit khởi tạo"
</pre>

        <p>sau đó clone nó:</p>
        <pre class="literallayout">
$ git clone . /some/new/directory
</pre>

        <p>Bây giờ hãy chuyển đến thư mục mới đó và làm việc ở đây
        thay vì chỗ cũ, sử dụng Git để thỏa mãn tình yêu của mình.
        Đôi khi, bạn sẽ muốn đồng bộ hóa với những người khác nữa,
        trong trường hợp đó hãy chuyển tới thư mục nguyên gốc, đồng
        bộ hóa bằng cách sử dụng một hệ thống quản lý mã nguồn
        khác, và gõ:</p>
        <pre class="literallayout">
$ git add .
$ git commit -m "Đồng bộ hóa với những người khác"
</pre>

        <p>Sau đó chuyển tới thư mục mới và chạy:</p>
        <pre class="literallayout">
$ git commit -a -m "Mô tả về các thay đổi của mình"
$ git pull
</pre>

        <p>Thủ tục đem lại các thay đổi của bạn tới những người
        khác nữa trên hệ thống quản lý mã nguồn khác. Thư mục mới
        có chứa các tệp tin mà bạn thay đổi. Chạy các lệnh mà hệ
        thống quản lý mã nguồn khác cần để tải chúng lên kho chứa
        trung tâm.</p>

        <p>Subversion, có lẽ là hệ thống quản lý mã nguồn tập trung
        tốt nhất, được sử dụng bởi vô số các dự án. Lệnh
        <span class="strong"><strong>git svn</strong></span> sẽ tự
        động hóa những việc đã nói ở trên dành cho Subversion, bạn
        cũng có thể làm như thế để <a class="ulink" href=
        "http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html"
        target="_top">xuất dự án Git thành Subversion</a>.</p>
      </div>

      <div class="section" title="Mercurial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mercurial"></a>Mercurial</h2>
            </div>
          </div>
        </div>

        <p>Mercurial là hệ thống tương tự như hệ thống quản lý mã
        nguồn có thể làm việc gần giống như Git. Với plugin
        <code class="literal">hg-git</code>, người sử dụng
        Mercurial có thể push và pull từ kho Git mà không mất mát
        gì.</p>

        <p>Lấy plugin <code class="literal">hg-git</code> dành cho
        Git bằng cách:</p>
        <pre class="literallayout">
$ git clone git://github.com/schacon/hg-git.git
</pre>

        <p>hay là sử dụng Mercurial:</p>
        <pre class="literallayout">
$ hg clone http://bitbucket.org/durin42/hg-git/
</pre>

        <p>Thật buồn là tôi không biết rằng có một plugin tương tự
        dành cho Git. Vì vậy, tôi ủng hộ Git hơn Mercurial khi dùng
        cho kho chứa chính, dù là bạn thích Mercurial hơn. Với một
        dự án Mercurial, thường thường một người tình nguyện duy
        trì kho Git song song cho tương thích với người sử dụng
        Git, cũng phải cảm ơn plugin <code class=
        "literal">hg-git</code>, một dự án Git tự động tiếp nhận
        người sử dụng Mercurial.</p>

        <p>Mặc dù plugin có thể chuyển đổi Mercurial sang Git bằng
        cách push tới một kho rỗng, công việc này là dễ dàng với
        script <code class="literal">hg-fast-export.sh</code>, đã
        sẵn dùng từ:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/fast-export.git
</pre>

        <p>Để chuyển đổi, trong một thư mục rỗng hãy chạy:</p>
        <pre class="literallayout">
$ git init
$ hg-fast-export.sh -r /hg/repo
</pre>

        <p>sau khi đặt script vào trong biến môi trường
        <code class="literal">$PATH</code>.</p>
      </div>

      <div class="section" title="Bazaar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bazaar"></a>Bazaar</h2>
            </div>
          </div>
        </div>

        <p>Chúng tôi đề cập vắn tắt về Bazaar bởi vì nó là hệ thống
        quản lý mã nguồn phân tán miễn phí và phổ biến nhất chỉ sau
        Git và Mercurial.</p>

        <p>Bazaar có lợi thế vì phát triển sau, có tuổi tương đối
        trẻ; những người thiết kế ra nó có thể học hỏi được nhiều
        từ các sai lầm trong quá khứ, và tránh được vết xe đổ.
        Ngoài ra, các nhà phát triển còn lưu tâm đến khả năng
        chuyển đổi và tương tác với các hệ thống quản lý mã nguồn
        khác.</p>

        <p>Plugin <code class="literal">bzr-git</code> giúp người
        dùng Bazaar làm việc với kho Git trong chừng mực nào đó.
        Chương trình chuyển đổi Bazaar thành Git, và có thể làm hơn
        thế nữa, trong khi <code class=
        "literal">bzr-fast-export</code> thích hợp nhất cho việc
        chuyển đổi một lần duy nhất.</p>
      </div>

      <div class="section" title="Tại sao Tôi sử dụng Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%E1%BA%A1i_sao_t%C3%B4i_s%E1%BB%AD_d%E1%BB%A5ng_git">
              </a>Tại sao Tôi sử dụng Git</h2>
            </div>
          </div>
        </div>

        <p>Trước tiên, tôi chọn Git bởi tôi nghe nói nó làm được
        việc phi thường là có thể quản lý mã nguồn cho một thứ khó
        quản lý như hạt nhân của hệ điều hành Linux. Tôi chưa bao
        giờ nghĩ đến việc chuyển sang cái khác. Git làm được những
        việc thật đáng ngưỡng mộ, và tôi chưa từng bao giờ gặp các
        vấn đề với sai sót của nó. Do tôi hoạt động chủ yếu trên
        Linux, phát hành trên các nền tảng khác không phải là điều
        mà tôi quan tâm.</p>

        <p>Ngoài ra, tôi thích lập trình bằng ngôn ngữ C và bash
        scripts để thực thi như là Python script: ở đây có rất ít
        sự phụ thuộc, và tôi đam mê với những hệ thống thi hành
        nhanh chóng.</p>

        <p>Tôi đã nghĩ về việc làm thế nào để Git có thể phát
        triển, xa hơn nữa là tự mình viết một công cụ tương tự như
        Git, nhưng đây không phải là bài tập có tính thực tế. Khi
        tôi hoàn thành dự án của mình, dù sao đi nữa tôi vẫn sẽ
        dùng Git, với lợi thế là có thể chuyển đổi từ hệ thống cũ
        sang một cách nhanh chóng.</p>

        <p>Theo lẽ tự nhiên, những thứ cần thiết cho bạn và những
        thứ bạn mong muốn có lẽ khác nhau, và bạn có thể tốt hơn
        nếu ở một hệ thống khác. Dù sao đi nữa, bạn sẽ không bao
        giờ phải hối tiếc vì đã chọn Git.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;4.&nbsp;Thủ Thuật Tạo Nhánh">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_th%E1%BB%A7_thu%E1%BA%ADt_t%E1%BA%A1o_nh%C3%A1nh"></a>Chương&nbsp;4.&nbsp;Thủ
            Thuật Tạo Nhánh</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_n%C3%BAt_%C4%91i%E1%BB%81u_khi%E1%BB%83n">Nút Điều
          Khiển</a></span></dt>

          <dt><span class="section"><a href=
          "#_b%E1%BA%A3n_nh%C3%A1p">Bản Nháp</a></span></dt>

          <dt><span class="section"><a href=
          "#_s%E1%BB%ADa_nhanh">Sửa Nhanh</a></span></dt>

          <dt><span class="section"><a href=
          "#_tr%E1%BB%99n">Trộn</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%C3%A0m_vi%E1%BB%87c_li%C3%AAn_t%E1%BB%A5c">Làm Việc
          Liên Tục</a></span></dt>

          <dt><span class="section"><a href=
          "#_c%E1%BA%A3i_t%E1%BB%95_l%E1%BA%A1i_s%E1%BB%B1_pha_tr%E1%BB%99n">
          Cải Tổ Lại Sự Pha Trộn</a></span></dt>

          <dt><span class="section"><a href=
          "#_qu%E1%BA%A3n_l%C3%BD_c%C3%A1c_nh%C3%A1nh">Quản Lý Các
          Nhánh</a></span></dt>

          <dt><span class="section"><a href=
          "#_nh%C3%A1nh_t%E1%BA%A1m">Nhánh Tạm</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%C3%A0m_theo_c%C3%A1ch_c%E1%BB%A7a_m%C3%ACnh">Làm
          Theo Cách Của Mình</a></span></dt>
        </dl>
      </div>

      <p>Tạo Nhánh và Trộn là các đặc tính sát thủ của Git.</p>

      <p><span class="strong"><strong>Vấn đề đặt
      ra</strong></span>: Những nhân tố bên ngoài chắc hẳn có đòi
      hỏi việc hoán chuyển văb cảnh. Một lỗi tồi tệ xuất hiện trong
      phiên bản đã được phát hành mà không được cảnh báo gì. Điều
      tồi tệ nhất có thể xảy ra là phải xóa bỏ hẳn đặc tính kỹ
      thuật đó. Người phát triển phần mềm, người mà đã giúp bạn
      viết nó, cần biết lý do về việc bãi bỏ. Trong tất cả các
      trường hợp, bạn buộc phải xóa bỏ cái mà bạn đang làm và làm
      một cái hoàn toàn mới.</p>

      <p>Việc gán đoạn suy nghĩ có thể làm giảm hiệu suất làm việc
      của bạn, và việc hoán chuyển nội dung càng cồng kềnh vướng
      víu càng gây hậu quả nặng nề. Đối với các hệ thống quản lý mã
      nguồn tập trung chúng ta phải tải về một bản sao công việc
      mới từ máy chủ trung tâm. Các hệ thống phân tán hoạt động
      hiệu quả hơn, như là chúng ta có thể nhân bản một cách cục
      bộ.</p>

      <p>Nhưng việc nhân bản bắt buộc phải sao chép toàn bộ thư mục
      làm việc cũng như là toàn bộ các mục trong lịch sử cho đến
      thời điểm đã được chỉ ra. Dù là Git giảm bớt sự lãng phí cho
      việc này bằng cách chia sẻ và tạo ra các liên kết tệp tin
      cứng, chính bản thân các tệp tin dự án cũng phải được tạo ra
      trong các đề mục của chúng trong thư mục làm việc.</p>

      <p><span class="strong"><strong>Giải pháp</strong></span>:
      Git có một công cụ tốt hơn để sử lý tình huống này, nó nhanh
      và tiết kiệm không gian lưu trữ hơn lệnh nhân bản đó chính
      là: <span class="strong"><strong>git
      branch</strong></span>.</p>

      <p>Với vài câu thần chú, các tệp tin trong thư mục của bạn dễ
      dàng biến đổi từ phiên bản này sang phiên bản khác. Sự chuyển
      đổi này có thể làm nhiều hơn việc di chuyển trong trong lịch
      sử một các đơn thuần. Các tệp tin của bạn có thể chuyển hình
      thái từ bản phát hành cuối thành phiên bản thử nghiệm, thành
      phiên bản phát triển hiện hành, thành phiên bản của người bạn
      của bạn, và cứ như thế.</p>

      <div class="section" title="Nút Điều Khiển">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_n%C3%BAt_%C4%91i%E1%BB%81u_khi%E1%BB%83n"></a>Nút
              Điều Khiển</h2>
            </div>
          </div>
        </div>

        <p>Mỗi khi chơi trò chơi, bạn bấm vào nút (“nút điều
        khiển”), màn hình có lẽ hiển thị ngay ra một cái bảng hay
        một thứ gì đó? Thế thì nhỡ ông chủ của bạn đang đi lại
        trong văn phòng nơi bạn đang chơi trò chơi thì làm cách nào
        để nhanh chóng giấu chúng đi?</p>

        <p>Ở thư mục nào đó:</p>
        <pre class="literallayout">
$ echo "Tôi thông minh hơn xếp của mình" &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Lần commit đầu tiên"
</pre>

        <p>Chúng ta đã tạo ra kho chứa Git mà nó theo dõi một tệp
        tin văn bản có chứa một thông điệp đã biết trước. Giờ hãy
        gõ:</p>
        <pre class="literallayout">
$ git checkout -b boss  # dường như chẳng có gì thay đổi sau lệnh này
$ echo "Xếp thông minh hơn tôi" &gt; myfile.txt
$ git commit -a -m "Lần commit khác"
</pre>

        <p>Điều này cũng giống như việc chúng ta ghi đè lên tệp tin
        của mình sau đó commit nó. Nhưng không, đó chỉ là ảo tưởng.
        Gõ:</p>
        <pre class="literallayout">
$ git checkout master  # quay trở lại phiên bản nguyên gốc của tệp tin
</pre>

        <p>Ối trời ơi! Tệp tin văn bản lại trở về như cũ mất rồi.
        Và nếu ông chủ có ý định ngó qua thư mục của bạn thì hãy
        gõ:</p>
        <pre class="literallayout">
$ git checkout boss  # chuyển trở lại phiên bạn vừa mắt ông chủ
</pre>

        <p>Bạn có thể hoán chuyển giữa hai phiên bản của tệp tin
        tùy thích, và commit từng cái trong số chúng một cách độc
        lập.</p>
      </div>

      <div class="section" title="Bản Nháp">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_b%E1%BA%A3n_nh%C3%A1p"></a>Bản Nháp</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a>Bạn nói mình đang làm
        việc với một số đặc tính kỹ thuật, và vì lý do nào đó, bạn
        muốn quay trở lại bản cách đây ba bản và tạm thời đặt vài
        dòng lệnh in ra màn hình để có thể thấy được một số hàm
        hoạt động như thế nào. Thế thì:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout HEAD~3
</pre>

        <p>Giờ thì bạn có thể thêm những dòng mã lệnh tạm thời ở
        đâu mình muốn. Bạn còn có thể commit những thay đổi đó. Khi
        bạn đã làm xong, hãy thực hiện lệnh</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>để quay lại công việc chính. Chú ý là bất kỳ các thay
        đổi không được commit sẽ đổ xuống sông xuống biển.</p>

        <p>Nhưng bạn lại muốn ghi lại các thay đổi tạm thời đó sau
        khi làm xong? Rất dễ:</p>
        <pre class="literallayout">
$ git checkout -b dirty
</pre>

        <p>và commit trước khi quay trở lại nhánh master. Khi nào
        đó bạn muốn quay trở lại các thay đổi ở trên, đơn giản, chỉ
        cần gõ:</p>
        <pre class="literallayout">
$ git checkout dirty
</pre>

        <p>Chúng ta đã đụng chạm đến lệnh như trên ở những chương
        trước rồi, khi thảo luận về việc tải về một trạng thái cũ.
        Cuối cùng chúng ta có thể thuật lại toàn bộ câu chuyện: các
        tệp tin đã thay đổi theo trạng thái đã được yêu cầu, nhưng
        chúng ta phải rời bỏ nhánh master. Tất cả những lần commit
        được tạo ra từ đây sẽ dẫn bạn đi trên một nhánh khác, nhánh
        này có thể được đặt tên sau.</p>

        <p>Mặt khác, sau khi <span class="emphasis"><em>check
        out</em></span> một trạng thái cũ, Git tự động đặt bạn vào
        một trạng thái mới, một nhánh chưa có tên, và nhánh này có
        thể đặt tên và ghi lại với lệnh <span class=
        "strong"><strong>git checkout -b</strong></span>.</p>
      </div>

      <div class="section" title="Sửa Nhanh">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_s%E1%BB%ADa_nhanh"></a>Sửa Nhanh</h2>
            </div>
          </div>
        </div>

        <p>Bạn đang phân vân giữa ngã ba đường khi bạn phải xác
        định là xóa tất cả mọi thứ hoặc là sửa chữa các lỗi mới
        phát hiện ra trong lần commit <code class=
        "literal">1b6d...</code>:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout -b fixes 1b6d
</pre>

        <p>Một khi bạn đã sửa lỗi:</p>
        <pre class="literallayout">
$ git commit -a -m "Đã sửa"
$ git checkout master
</pre>

        <p>và quay lại công việc theo phận sự của mình. Bạn thậm
        chí có thể trộn với lần commit đã sửa để sửa lỗi:</p>
        <pre class="literallayout">
$ git merge fixes
</pre>
      </div>

      <div class="section" title="Trộn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_tr%E1%BB%99n"></a>Trộn</h2>
            </div>
          </div>
        </div>

        <p>Với một số hệ thống quản lý mã nguồn, việc tạo các nhánh
        rất dễ dàng nhưng trộn chúng trở lại là một bài toán hóc
        búa. Với Git, việc trộn là dễ dàng và bạn có thể không hay
        biết nó hoạt động như thế nào.</p>

        <p>Chúng ta đã sử dụng việc trộn từ lâu rồi. Lệnh
        <span class="strong"><strong>pull</strong></span> trên thực
        tế đã <span class="emphasis"><em>fetch</em></span> các lần
        commit và sau đó trộn chúng vào trong nhánh hiện hành của
        bạn. Nếu trên máy của mình bạn không có thay đổi gì cả, thế
        thì việc trộn sẽ là một <span class="emphasis"><em>fast
        forward</em></span>, trường hợp này cũng na ná như việc lấy
        về phiên bản cuối cùng trong hệ thống quản lý mã nguồn tập
        trung. Nhưng nếu bạn đã có thay đổi trên máy của mình, Git
        sẽ tự động trộn, và báo cáo cho bạn nếu có xung đột xảy
        ra.</p>

        <p>Thông thường, mỗi lần commit có một <span class=
        "emphasis"><em>commit cha</em></span>, tạm gọi thế, chính
        là lần commit trước. Việc trộn các nhánh với nhau phát sinh
        ra một lần commit với ít nhất hai <span class=
        "emphasis"><em>cha</em></span>. Điều này đặt ra câu hỏi:
        lần commit mà <code class="literal">HEAD~10</code> thực sự
        ám chỉ đến là lần nào? Một lần commit có thể có nhiều cha,
        thế thì chúng ta phải theo cái nào?</p>

        <p>Nó sẽ gọi ra <span class="emphasis"><em>cha</em></span>
        đầu tiên. Đây là điều ta mong muốn bởi vì nhánh hiện hành
        trở thành cha đầu tiên trong suốt quá trình trộn; một cách
        thường xuyên, bạn chỉ liên quan đến những thay đổi mình tạo
        ra trong nhánh hiện hành, cốt để mà đối lập với việc trộn
        thay đổi từ các nhánh khác.</p>

        <p>Bạn hãy nhớ Git quy một cha nào đó với một dấu mũ. Ví
        dụ, để hiển thị nhật ký tính từ <span class=
        "emphasis"><em>cha</em></span> thứ hai:</p>
        <pre class="literallayout">
$ git log HEAD^2
</pre>

        <p>Bạn có thể bỏ qua số dành cho cha đầu tiên. Ví dụ, để
        hiển thị sự khác nhau với cha đầu tiên:</p>
        <pre class="literallayout">
$ git diff HEAD^
</pre>

        <p>Bạn có thể tổ hợp các dấu mũ này với các kiểu khác nhau.
        Ví dụ:</p>
        <pre class="literallayout">
$ git checkout 1b6d^^2~10 -b ancient
</pre>

        <p>bắt đầu một nhánh mới “ancient” tương ứng với trạng thái
        lần commit thứ 10 trở về trước từ cha thứ hai của cha thứ
        nhất của lần commit bắt đầu với 1b6d.</p>
      </div>

      <div class="section" title="Làm Việc Liên Tục">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%C3%A0m_vi%E1%BB%87c_li%C3%AAn_t%E1%BB%A5c"></a>Làm
              Việc Liên Tục</h2>
            </div>
          </div>
        </div>

        <p>Thường trong các dự án phần cứng, bước thứ hai của kế
        hoạch phải chờ bước thứ nhất hoàn thành. Một chiếc xe hơi
        cần sửa chữa có thể phải nằm chờ trong xưởng sửa chữa cho
        đến khi các chi tiết phụ tùng đặc biệt được chuyển đến từ
        nhà máy. Một mẫu có thể phải chờ một con chip được làm ra
        trước khi quá trình chế tác có thể tiếp tục.</p>

        <p>Dự án phần mềm cũng có thể tương tự như thế. Bộ phận thứ
        hai có một số tính năng có thể phải chờ cho đến khi phần
        thứ nhất đã được phát hành và kiểm tra. Một số dự án yêu
        cầu mã nguồn của bạn phải được xem xét lại trước khi chấp
        nhận nó, vì vậy bạn có thể phải chờ cho đến khi bộ phận thứ
        nhất đã được chấp thuận trước khi bắt đầu phần thứ hai.</p>

        <p>Nhờ có việc tạo nhánh và trộn dễ dàng và cũng chẳng mất
        mát gì, chúng ta có thể phá vỡ quy tắc và làm việc trên
        Part II trước khi Part I chính thức sẵn sàng. Giả sử bạn đã
        commit Part I và gửi nó đi để xem xét. Giả sử bạn đang ở
        nhánh <code class="literal">master</code>. Thế thì hãy phân
        nhánh ra:</p>
        <pre class="literallayout">
$ git checkout -b part2
</pre>

        <p>Tiếp đến, làm việc trên Part II, commit những thay đổi
        của bạn bao nhiêu tùy thích. Lỗi là ở con người, và bạn sẽ
        phải thường xuyên quay trở lại để sửa lỗi nào đó trong Part
        I. Nếu may mắn, hay trong trường hợp tốt, bạn có thể bỏ qua
        những dòng này.</p>
        <pre class="literallayout">
$ git checkout master  # Quay trở lại Part I.
$ sửa_lỗi
$ git commit -a        # Commit sau khi sửa lỗi.
$ git checkout part2   # Quay trở lại Part II.
$ git merge master     # Trộn các thay đổi.
</pre>

        <p>Cuối cùng, Part I được chấp thuận:</p>
        <pre class="literallayout">
$ git checkout master  # Quay trở lại Part I.
$ submit files         # Xuất bản ra!
$ git merge part2      # Trộn vào Part II.
$ git branch -d part2  # Xóa nhánh "part2".
</pre>

        <p>Bây giờ chúng ta lại ở trong nhánh <code class=
        "literal">master</code>, với Part II trong thư mục làm
        việc.</p>

        <p>Thủ thuật này rất dễ dàng để mở rộng ra dành cho nhiều
        phần hơn. Nó cũng đễ dàng để phân nhánh ra từ quá khứ: giả
        sử muộn bạn mới nhận ra là mình phải tạo một nhánh từ trước
        đây 7 lần commit. Thế thì gõ:</p>
        <pre class="literallayout">
$ git branch -m master part2  # Đổi tên nhánh "master" thành "part2".
$ git checkout HEAD~7 -b master # Tạo nhánh "master" mới 7 lần commit ngược từ trước.
</pre>

        <p>Nhánh <code class="literal">master</code> bây giờ chỉ
        chứa Part I, và nhánh <code class="literal">part2</code>
        trở thành nhánh chứa. Chúng ta đang ở nhánh sau; chúng ta
        đã tạo nhánh <code class="literal">master</code> mà không
        chuyển đến nó, bởi vì chúng ta muốn tiếp tục làm việc trên
        <code class="literal">part2</code>. Điều này hơi bất
        thường. Cho đến lúc này, Chúng ta chuyển đến các nhánh ngay
        sau khi chúng được tạo ra, như là trong:</p>
        <pre class="literallayout">
$ git checkout HEAD~7 -b master  # Tạo một nhánh và chuyển tới nó.
</pre>
      </div>

      <div class="section" title="Cải Tổ Lại Sự Pha Trộn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_c%E1%BA%A3i_t%E1%BB%95_l%E1%BA%A1i_s%E1%BB%B1_pha_tr%E1%BB%99n">
              </a>Cải Tổ Lại Sự Pha Trộn</h2>
            </div>
          </div>
        </div>

        <p>Có lẽ bạn thích làm việc trên mọi khía cạnh của một dự
        án trên cùng một nhánh. Bạn muốn giữ riêng các thay đổi
        mình đang làm cho riêng mình và muốn những người khác chỉ
        thấy được các lần commit của bạn sau khi đã được tổ chức
        lại. Hãy chuẩn bị một cặp nhánh:</p>
        <pre class="literallayout">
$ git branch -b sanitized # Tạo một nhánh dùng cho việc dọn.
$ git checkout -b medley # Tạo và chuyển nhánh thành nơi làm việc.
</pre>

        <p>Tiếp theo, làm việc gì đó: sửa lỗi, thêm các đặc tính kỹ
        thuật, thêm mã lệnh tạm thời, vân vân, commit thường xuyên.
        Sau đó:</p>
        <pre class="literallayout">
$ git checkout sanitized
$ git cherry-pick medley^^
</pre>

        <p>áp dụng nhánh ông-bà của lần commit head của nhánh
        “medley” thành nhánh “sanitized”. Với lệnh thích hợp là
        cherry-picks bạn có thể cấu trúc một nhánh mà nó chỉ chứa
        mã nguồn không thay đổi, và những lần commit có liên quan
        sẽ được nhóm lại với nhau.</p>
      </div>

      <div class="section" title="Quản Lý Các Nhánh">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qu%E1%BA%A3n_l%C3%BD_c%C3%A1c_nh%C3%A1nh"></a>Quản
              Lý Các Nhánh</h2>
            </div>
          </div>
        </div>

        <p>Liệt kê tất cả các nhánh bằng cách gõ:</p>
        <pre class="literallayout">
$ git branch
</pre>

        <p>Theo mặc định, bạn bắt đầu tại nhánh có tên “master”.
        Một số người chủ trương rời bỏ nhánh “master” mà không động
        chạm gì đến nó và tạo các nhánh mới dành cho các chỉnh sửa
        của riêng mình.</p>

        <p>Các tùy chọn <span class=
        "strong"><strong>-d</strong></span> and <span class=
        "strong"><strong>-m</strong></span> cho phép bạn xóa hay di
        chuyển (đổi tên) các nhánh. Xem thêm <span class=
        "strong"><strong>git help branch</strong></span>.</p>

        <p>Nhánh “master” thông thường rất hữu dụng. Những người
        khác sẽ nghĩ rằng kho chứa của bạn có nhánh với tên này, và
        nhánh đó chứa phiên bản chính thức của dự án của bạn. Mặc
        dù bạn có thể đổi tên hay xóa bỏ nhánh “master”, nhưng bạn
        không nên làm như thế mà hãy tôn trọng thỏa thuận ngầm
        này.</p>
      </div>

      <div class="section" title="Nhánh Tạm">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_nh%C3%A1nh_t%E1%BA%A1m"></a>Nhánh Tạm</h2>
            </div>
          </div>
        </div>

        <p>Một lát sau bạn có lẽ nhận thức được rằng mình cần có
        các nhánh tạm thời vì các lý do như: mọi nhánh khác đơn
        thuần phục vụ cho việc ghi lại trạng thái hiện tại do vậy
        bạn có thể nhảy trở lại các trạng thái cũ hơn để mà sửa
        chữa các lỗi nghiêm trọng hay thứ gì đó.</p>

        <p>Điều này cũng tương tự như việc chuyển kênh trên TV một
        cách tạm thời để thấy chương trình khác đang chiếu cái gì.
        Nhưng thay vì chỉ cần nhấn vài cái nút, bạn phải tạo, check
        out, trộn và xóa nhánh tạm đó. May mắn thay, Git có cách
        ngắn gọn tiện lợi chẳng thua kém gì chiếc điều khiển từ xa
        của một chiếc TV:</p>
        <pre class="literallayout">
$ git stash
</pre>

        <p>Lệnh này ghi lại trạng thái hiện hành vào một vị trí tạm
        thời (một <span class="emphasis"><em>stash</em></span>) và
        phục hồi lại trạng thái trước đó. Thư mục bạn đang làm việc
        xuất hiện chính xác như trước khi bạn chỉnh sửa, và bạn có
        thể sửa lỗi, pull về các thay đổi ngược dòng, và cứ như
        thế. Khi bạn muốn qua trở lại trạng thái đã được tạm giấu
        đi đó, hãy gõ:</p>
        <pre class="literallayout">
$ git stash apply  # Bạn có thể sẽ phải giải quyết các xung đột có thể nảy sinh.
</pre>

        <p>Bạn có thể có nhiều trạng thái được tạm giấu đi, và vận
        dụng chúng theo nhiều cách khác nhau. Xem <span class=
        "strong"><strong>git help stash</strong></span> để biết
        thêm chi tiết. Bạn cũng có thể đoán được, Git duy trì các
        nhánh ở hậu trường để thực hiện việc này.</p>
      </div>

      <div class="section" title="Làm Theo Cách Của Mình">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%C3%A0m_theo_c%C3%A1ch_c%E1%BB%A7a_m%C3%ACnh"></a>Làm
              Theo Cách Của Mình</h2>
            </div>
          </div>
        </div>

        <p>Bạn có thể sẽ cảm thấy việc sử dụng nhánh phiền hà quá.
        Cuối cùng, clones có lẽ là lệnh nhanh nhất, và bạn có thể
        hoán chuyển giữa chúng với lệnh <span class=
        "strong"><strong>cd</strong></span> thay vì sử dụng lệnh
        riêng của Git.</p>

        <p>Ta thử xét đến các trình duyệt web. Tại sao việc hỗ trợ
        mở nhiều tab thì cũng tốt như mở trên nhiều cửa sổ khác
        nhau? Bởi vì cả hai điều này thể hiện tính đa dạng của quan
        điểm, phong cách sống. Một số người sử dụng lại thích chỉ
        giữ một cửa sổ trình duyệt được mở, và sử dụng các tab để
        hiển thị nhiều trang web một lúc. Những người khác có lẽ
        lại khăng khăng cực đoan cho rằng: mở trên nhiều cửa sổ
        khác nhau và chẳng cần tab nữa. Một nhóm khác lại thích cả
        hai một lúc.</p>

        <p>Việc tạo nhánh thì cũng giống như tạo các tab cho thư
        mục làm việc của bạn, còn việc nhân bản thì lại giống như
        việc mở một cửa sổ duyệt mới. Những việc này nhanh chóng và
        nội bộ, thế thì sao lại không thử nghiệm để tìm thấy cách
        thực hiện thích hợp nhất cho mình? Git giúp bạn làm việc
        chính xác như bạn muốn.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;5.&nbsp;Bài Học về Lịch Sử">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_b%C3%A0i_h%E1%BB%8Dc_v%E1%BB%81_l%E1%BB%8Bch_s%E1%BB%AD">
            </a>Chương&nbsp;5.&nbsp;Bài Học về Lịch Sử</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_d%E1%BB%ABng_l%E1%BA%A1i_s%E1%BB%ADa_ch%E1%BB%AFa">Dừng
          Lại Sửa Chữa</a></span></dt>

          <dt><span class="section"><a href=
          "#_8230_v%C3%A0_sau_%C4%91%C3%B3_l%C3%A0_nhi%E1%BB%81u_l%E1%BA%A7n">
          … Và Sau đó là Nhiều Lần</a></span></dt>

          <dt><span class="section"><a href=
          "#_thay_%C4%91%E1%BB%95i_ri%C3%AAng_s%E1%BA%AFp_x%E1%BA%BFp_sau">
          Thay Đổi Riêng Sắp Xếp Sau</a></span></dt>

          <dt><span class="section"><a href=
          "#_vi%E1%BA%BFt_l%E1%BA%A1i_l%E1%BB%8Bch_s%E1%BB%AD">Viết
          Lại Lịch Sử</a></span></dt>

          <dt><span class="section"><a href=
          "#_t%E1%BB%B1_t%E1%BA%A1o_l%E1%BB%8Bch_s%E1%BB%AD">Tự Tạo
          Lịch Sử</a></span></dt>

          <dt><span class="section"><a href=
          "#_v%E1%BB%8B_tr%C3%AD_n%C3%A0o_ph%C3%A1t_sinh_l%E1%BB%97i">
          Vị Trí Nào Phát Sinh Lỗi?</a></span></dt>

          <dt><span class="section"><a href=
          "#_ai_%C4%91%C3%A3_l%C3%A0m_n%C3%B3_sai">Ai Đã Làm Nó
          Sai?</a></span></dt>

          <dt><span class="section"><a href=
          "#_kinh_nghi%E1%BB%87m_ri%C3%AAng">Kinh Nghiệm
          Riêng</a></span></dt>
        </dl>
      </div>

      <p>Một hệ quả tất yếu của đặc tính phân tán của Git là việc
      lịch sử có thể biên soạn lại một cách dễ dàng. Nhưng nếu bạn
      xáo trộn quá khứ, hãy cẩn thận: chỉ biên soạn lại các phần
      trong lịch sử chỉ khi bạn sở hữu nó một mình. Cũng giống như
      việc các quốc gia tranh cãi không kết thúc xem ai là người
      tận tâm hành động nào là tàn ác, nếu một người khác có một
      bản sao mà lịch sử của nó lại khác với cái của bạn, bạn sẽ
      gặp rắc rối ngay khi cần tương tác với họ.</p>

      <p>Một số nhà phát triển phần mềm quả quyết rằng lịch sử
      không thể thay đổi, tất cả mọi thứ. Một số khác lại cho rằng
      chỉnh sửa lại cấu trúc trước khi phát hành nó ra đại chúng.
      Git chấp nhận cả hai quan điểm. Giống như việc nhân bản, tạo
      nhánh và hòa trộn, viết lại lịch sử đơn giản chỉ là một quyền
      lực mà Git trao cho bạn. Bạn có thể làm thế nếu muốn.</p>

      <div class="section" title="Dừng Lại Sửa Chữa">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_d%E1%BB%ABng_l%E1%BA%A1i_s%E1%BB%ADa_ch%E1%BB%AFa"></a>Dừng
              Lại Sửa Chữa</h2>
            </div>
          </div>
        </div>

        <p>Bạn vừa mới commit, nhưng lại ước mình đã gõ những dòng
        chú thích có nội dung khác phải không? Thế thì hãy
        chạy:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>để thay đổi chú thích cuối cùng. Bạn giật mình vì quên
        thêm các tệp tin vào? Chạy lệnh <span class=
        "strong"><strong>git add</strong></span> để thêm nó vào, và
        sau đó lại chạy lệnh ở trên.</p>

        <p>Bạn muốn thêm vài chỉnh sửa vào lần cuối mình đã commit
        ư? Thế thì cứ sửa chúng đi và sau đó chạy lệnh:</p>
        <pre class="literallayout">
$ git commit --amend -a
</pre>
      </div>

      <div class="section" title="… Và Sau đó là Nhiều Lần">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_8230_v%C3%A0_sau_%C4%91%C3%B3_l%C3%A0_nhi%E1%BB%81u_l%E1%BA%A7n">
              </a>… Và Sau đó là Nhiều Lần</h2>
            </div>
          </div>
        </div>

        <p>Giả sử vấn đề trục trặc ở lần commit cách đây mười lần.
        Sau một buổi làm việc dài, bạn đã tạo ra hàng tá các lần
        commit. Nhưng bạn không hoàn toàn hài lòng với cách mà
        chúng được tổ chức, và một số lần commit cần được soạn lại
        phần mô tả. Thế thì hãy gõ:</p>
        <pre class="literallayout">
$ git rebase -i HEAD~10
</pre>

        <p>và 10 lần commit cuối sẽ xuất hiện trong $EDITOR yêu
        thích của bạn. Dưới đây là một đoạn trích ví dụ:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Lần commit cũ đứng trước lần mới hơn trong danh sách,
        không giống như kết quả khi chạy lệnh <code class=
        "literal">log</code>. Ở đây, 5c6eb73 là lần commit cũ nhất,
        và 100834f là mới nhất. Thế thì:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">Xóa bỏ các lần commit bằng cách
            xóa các dòng tương ứng. Giống như lệnh revert, nhưng
            không ghi biên bản: nó sẽ coi như là lần commit đó chưa
            từng bao giờ tồn tại.</li>

            <li class="listitem">Đặt lại thứ tự các lần commit bằng
            cách thay đổi thứ tự các dòng.</li>

            <li class="listitem">
              <p class="simpara">Thay thế <code class=
              "literal">pick</code> bằng:</p>

              <div class="itemizedlist">
                <ul class="itemizedlist" type="circle">
                  <li class="listitem"><code class=
                  "literal">edit</code> để đánh dấu lần commit đó
                  là dành cho việc tu bổ.</li>

                  <li class="listitem"><code class=
                  "literal">reword</code> để thay đổi phần chú
                  giải.</li>

                  <li class="listitem"><code class=
                  "literal">squash</code> để hòa trộn với lần
                  commit trước.</li>

                  <li class="listitem"><code class=
                  "literal">fixup</code> để hòa trộn với lần commit
                  trước và bỏ qua việc ghi lại phần chú giải.</li>
                </ul>
              </div>
            </li>
          </ul>
        </div>

        <p>Ví dụ, chúng ta chẳng hạn thay thế <code class=
        "literal">pick</code> ở dòng thứ hai bằng <code class=
        "literal">squash</code>:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
squash a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Sau đó chúng ta ghi lại thay đổi và thoát ra. Git trộn
        lần a311a64 vào 5c6eb73. Vì vậy <span class=
        "strong"><strong>squash</strong></span> trộn với lần kế
        trước nó: có thể nghĩ đây là quá trình “nén dữ liệu”.</p>

        <p>Hơn thế nữa, Git sau đó tổ hợp nhật ký của chúng và hiện
        tại và chỉnh sửa lại. Lệnh <span class=
        "strong"><strong>fixup</strong></span> bỏ qua bước này;
        việc sửa nhật ký đơn giản là bỏ qua.</p>

        <p>Nếu bạn đánh dấu một lần commit bằng <span class=
        "strong"><strong>edit</strong></span>, Git đưa bạn trở lại
        quá khứ, tới lần commit lâu nhất đó. Bạn có thể tu bổ một
        lần commit cũ như đã mô tả ở phần trên, và thậm chí tạo ra
        các lần commit mới ở chỗ này. Một khi bạn đã hài lòng với
        việc “retcon”, hãy chạy <span class="emphasis"><em>cỗ máy
        thời gian</em></span> bằng cách chạy lệnh:</p>
        <pre class="literallayout">
$ git rebase --continue
</pre>

        <p>Git sửa commits cho tới <span class=
        "strong"><strong>edit</strong></span> kế tiếp, hoặc tới
        hiện tại nếu không còn việc gì cần phải làm.</p>

        <p>Bạn còn có thể bãi bỏ việc rebase bằng lệnh:</p>
        <pre class="literallayout">
$ git rebase --abort
</pre>

        <p>Do vậy cứ commit thoải mái và thường xuyên bởi vì bạn có
        thể dọn dẹp cho gọn gàng sau này bằng lệnh rebase.</p>
      </div>

      <div class="section" title="Thay Đổi Riêng Sắp Xếp Sau">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_thay_%C4%91%E1%BB%95i_ri%C3%AAng_s%E1%BA%AFp_x%E1%BA%BFp_sau">
              </a>Thay Đổi Riêng Sắp Xếp Sau</h2>
            </div>
          </div>
        </div>

        <p>Bạn đang làm việc trên một dự án đang hoạt động. Bạn đã
        tạo ra một số lần commit tại máy tính của mình, và sau đó
        bạn đồng bộ hóa với cây chính thức bằng cách hòa trộn. Chu
        kỳ này tự lặp chính nó một số lần trước khi bạn thực sự
        push tới cây trên máy chủ trung tâm.</p>

        <p>Nhưng hiện tại lịch sử bản sao Git trên máy tính của bạn
        là một mớ hỗn độn của những lần thay đổi trên máy tính
        riêng và máy chính thức. Bạn muốn thấy tất cả các thay đôi
        của riêng mình trong một đoạn liên tục không ngắt quãng, và
        sau tất cả các thay đổi từ văn phòng.</p>

        <p>Đây chính là công việc dành cho lệnh <span class=
        "strong"><strong>git rebase</strong></span> đã được miêu tả
        ở trên. Trong nhiều trường hợp bạn có thể sử dụng cờ
        <span class="strong"><strong>--onto</strong></span> và
        tránh xa sự tương tác với các máy tính khác.</p>

        <p>Xem thêm trong <span class="strong"><strong>git help
        rebase</strong></span> để thấy được chi tiết các ví dụ dành
        cho lệnh đáng kinh ngạc này. Bạn có thể chia cắt các lần
        commit. Bạn còn có thể xắp xếp lại các nhánh của một cấu
        trúc cây.</p>

        <p>Hãy cẩn thận: rebase là một lệnh mạnh mẽ. Với những lần
        rebases phức tạp, trước hết hãy tạo ra một bản sao lưu dự
        phòng bằng lệnh <span class="strong"><strong>git
        clone</strong></span>.</p>
      </div>

      <div class="section" title="Viết Lại Lịch Sử">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_vi%E1%BA%BFt_l%E1%BA%A1i_l%E1%BB%8Bch_s%E1%BB%AD"></a>Viết
              Lại Lịch Sử</h2>
            </div>
          </div>
        </div>

        <p>Thỉnh thoảng, bạn muốn việc quản lý mã nguồn giống việc
        người ta sơn vẽ chân dung một con người, tẩy xóa chúng từ
        lịch sử như theo ý của Stalinesque. Ví dụ, giả sử chúng ta
        có ý định phát hành dự án, nhưng lại liên đới đến một tệp
        tin mà nó phải được giữ bí mật vì lý do nào đó. Chẳng hạn
        như tôi đã quên khi ghi lại số thẻ tín dụng vào trong một
        tệp tin văn bản và ngẫu nhiên nó được thêm vào trong dự án.
        Việc xóa tệp tin này là chưa đủ, bởi vì ta có thể đọc nó từ
        lần commit cũ. Chúng ta phải gỡ bỏ tệp tin này từ tất cả
        các lần đã commit:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'rm top/secret/file' HEAD
</pre>

        <p>Xem <span class="strong"><strong>git help
        filter-branch</strong></span>, nội dung của nó sẽ thảo luận
        về ví dụ này và đưa ra một cách thức nhanh hơn. Đại thể,
        lệnh <span class=
        "strong"><strong>filter-branch</strong></span> giúp bạn
        thay đổi cả một chương lớn của lịch sử chỉ chỉ bằng một
        lệnh đơn.</p>

        <p>Sau này, thư mục <code class=
        "literal">.git/refs/original</code> mô tả trạng thái của
        công việc trước khi thực hiện. Kiểm tra lệnh filter-branch
        đã làm những thứ bạn muốn chưa, sau đó xóa thư mục này đi
        nếu bạn muốn chạy lệnh filter-branch lần nữa.</p>

        <p>Cuối cùng, thay thế bản sao của dự án của bạn bằng phiên
        bản bạn đã sửa lại nếu bạn muốn tương thích với chúng sau
        này.</p>
      </div>

      <div class="section" title="Tự Tạo Lịch Sử">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%E1%BB%B1_t%E1%BA%A1o_l%E1%BB%8Bch_s%E1%BB%AD"></a>Tự
              Tạo Lịch Sử</h2>
            </div>
          </div>
        </div>

        <p><a name="makinghistory" id="makinghistory"></a>Bạn muốn
        chuyển đổi dự án của mình sang sử dụng Git? Nếu nó được
        quản lý bởi một hệ thống nổi tiếng hơn, thế thì nếu may mắn
        sẽ có người nào đó đã viết sẵn một đoạn kịch bản để xuất
        toàn bộ lịch sử ra thành Git.</p>

        <p>Nếu không, thì nên xem xét đến việc sử dụng lệnh
        <span class="strong"><strong>git
        fast-import</strong></span>, lệnh này đọc văn bản đầu vào ở
        một định dạng riêng để mà tạo ra một lịch sử cho Git từ ban
        đầu. Thông thường một script sử dụng lệnh này là một nhóm
        lệnh tổ hợp với nhau và chỉ chạy một lần, di chuyển một dự
        án chỉ bằng một lệnh đơn.</p>

        <p>Dưới đây là một ví dụ, dán danh sách theo sau đâu vào
        một tệp tin tạm thời nào đó, chẳng hạn như là <code class=
        "literal">/tmp/history</code>:</p>
        <pre class="screen">
commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Initial commit.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Thế thì tạo một kho Git từ thư mục chứa các tệp tin tạm
        thời này bằng cách gõ:</p>
        <pre class="literallayout">
$ mkdir project; cd project; git init
$ git fast-import --date-format=rfc2822 &lt; /tmp/history
</pre>

        <p>Bạn có thể checkout phiên bản cuối của dự án với:</p>
        <pre class="literallayout">
$ git checkout master .
</pre>

        <p>Lệnh <span class="strong"><strong>git
        fast-export</strong></span> chuyển đổi bất kỳ một kho chứa
        nào thành định dạng phù hợp với lệnh <span class=
        "strong"><strong>git fast-import</strong></span>, và bạn có
        thể nghiên cứu nó để tạo riêng cho mình một chương trình
        xuất, và cũng làm như thế để tạo thành kho chuyên chở ở
        định dạng con người có thể đọc được. Thực vậy, những lệnh
        này có thể gửi một kho chứa ở dạng văn bản thông qua một
        kênh chỉ cho phép văn bản truyền đi.</p>
      </div>

      <div class="section" title="Vị Trí Nào Phát Sinh Lỗi?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_v%E1%BB%8B_tr%C3%AD_n%C3%A0o_ph%C3%A1t_sinh_l%E1%BB%97i">
              </a>Vị Trí Nào Phát Sinh Lỗi?</h2>
            </div>
          </div>
        </div>

        <p>Bạn vừa mới phát hiện ra một đặc tính không hoạt động
        trong chương trình mà bạn chắc chắn là nó đã hoạt động vài
        tháng trước. Tệ quá! Lỗi bắt đầu từ chỗ nào nhỉ? Nếu như
        chỉ có mình bạn kiểm tra cũng như phát triển đặc tính
        này.</p>

        <p>Lúc này thì đã quá muộn rồi. Tuy nhiên, chỉ cần bạn
        commit thường xuyên, Git có thể xác định vị trí của trục
        trặc:</p>
        <pre class="literallayout">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d
</pre>

        <p>Git checks out một trạng thái nằm giữa chúng. Kiểm tra
        đặc tính kỹ thuật, và nếu nó vẫn hỏng:</p>
        <pre class="literallayout">
$ git bisect bad
</pre>

        <p>Nếu không thì thay "bad" bằng "good". Git sẽ chuyên chở
        bạn qua lại nửa bước giữa hai trạng thái là phiên bản "tốt"
        và "xấu", thu hẹp khả năng lại. Sau khi lặp đi lặp lại một
        số lần, việc tìm kiếm nhị phân này sẽ dẫn bạn đến lần
        commit mà nó làm nguyên nhân dẫn đễ hỏng hóc. Một khi bạn
        đã hoàn tất việc điều tra, trở lại trạng thái nguyên bản
        của bạn bằng cách gõ:</p>
        <pre class="literallayout">
$ git bisect reset
</pre>

        <p>Thay vì thử nghiệm mọi thay đổi một cách thủ công, hãy
        tự động hóa sự tìm kiếm này bằng cách chạy:</p>
        <pre class="literallayout">
$ git bisect run my_script
</pre>

        <p>Git sử dụng giá trị trả về của lệnh đã cho, thông thường
        là từ các đoạn kịch bản, để quyết định là lệnh đã thực hiện
        tốt hay không: lệnh sẽ trả về giá trị 0 khi tốt, 125 khi sự
        thay đổi bị bỏ qua, và bất kỳ giá trị nào khác nằm giữa 1
        và 127 nếu gặp lỗi. Một giá trị âm sẽ bãi bỏ lệnh
        bisect.</p>

        <p>Bạn có thể làm nhiều hơn thế: trang trợ giúp giảng giải
        cho bạn làm thế nào để hiểu được lệnh bisect làm việc như
        thế nào, xem xét hay xem lại nhật ký lệnh bisect, và loại
        trừ các thay đổi ngớ ngẩn để tăng tốc độ tìm kiếm.</p>
      </div>

      <div class="section" title="Ai Đã Làm Nó Sai?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ai_%C4%91%C3%A3_l%C3%A0m_n%C3%B3_sai"></a>Ai Đã Làm
              Nó Sai?</h2>
            </div>
          </div>
        </div>

        <p>Giống như các hệ thống quản lý mã nguồn khác, Git cũng
        có lệnh blame:</p>
        <pre class="literallayout">
$ git blame bug.c
</pre>

        <p>lệnh này chú thích tất cả các dòng có trong tệp tin được
        chỉ ra cho thấy ai là người cuối cùng sửa nó, và là khi
        nào. Không giống các hệ thống quản lý mã nguồn khác, hành
        động này hoạt động không cần có mạng, việc đọc chỉ đơn
        thuần từ ổ đĩa của máy tính cá nhân.</p>
      </div>

      <div class="section" title="Kinh Nghiệm Riêng">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_kinh_nghi%E1%BB%87m_ri%C3%AAng"></a>Kinh Nghiệm
              Riêng</h2>
            </div>
          </div>
        </div>

        <p>Trong một hệ thống quản lý mã nguồn tập trung, thay đổi
        lịch sử là một việc làm khó khăn, và chỉ làm được thế nếu
        đó là người quản trị. Việc nhân bản, tạo nhánh và trộn
        không thể thiếu việc truyền thông qua mạng. Cũng như thế
        với các tác vụ cơ bản khác như là duyệt lịch sử, hay là
        commit một thay đổi. Trong một số hệ thống khác, người dùng
        yêu cầu có kết nối mạng chỉ để xem các thay đổi của họ hay
        mở một tệp tin để biên tập.</p>

        <p>Hệ thống tập trung không cho phép làm việc mà không có
        mạng, và đòi hỏi cơ sở hạ tầng mạng máy tính đắt đỏ tốn
        kém, đặc biệt là khi số nhà phát triển phần mềm tăng lên.
        Điều quan trọng, tất cả mọi tác vụ sẽ chậm hơn ở mức độ nào
        đó, thường thường những người sử dụng sẽ lảng tránh việc sử
        dụng các lệnh cao cấp trừ phi nó thực sự cần thiết. Trừ
        những trường hợp đặc biệt là các lệnh cơ bản. Khi những
        người dùng phải chạy các lệnh chạy chậm, hiệu suất bị giảm
        bởi vì nó làm gián đoạn công việc của cả một dây
        truyền.</p>

        <p>Tôi trực tiếp đã trải qua những hiện tượng đó. Git là hệ
        thống quản lý mã nguồn đầu tiên tôi sử dụng. Tôi nhanh
        chóng làm quen với nó, bị quyến rũ bởi những đặc tính kỹ
        thuật mà nó đã cung cấp. Tôi đơn giản cho rằng các hệ thống
        khác thì cũng tương tự: việc chọn lựa một hệ thống quản lý
        mã nguồn thì cũng chẳng khác việc chọn một trình biên soạn
        hay một trình duyệt web.</p>

        <p>Tôi sẽ sốc nếu như sau này bị bắt buộc sử dụng hệ thống
        quản lý mã nguồn tập trung. Một kết nối Internet chậm chạp
        cũng chẳng phải là vấn đề lớn đối với Git, nhưng nó sẽ làm
        cho các nhà phát triển phần mềm không thể chịu nổi khi nó
        cần sự tin cậy như ổ đĩa nội bộ. Thêm nữa, tôi đã gặp một
        số mắc mớ với một số lệnh, mà chính nó đã ngăn cản tôi làm
        việc một cách trôi chảy.</p>

        <p>Khi tôi phải chạy những lệnh cần nhiều thời gian, việc
        làm ngắt quãng việc suy nghĩ sẽ gây nên thiệt hại rất to
        lớn. Trong khi chờ cho việc truyền thông với máy chủ hoàn
        tất, tôi sẽ phải làm một vài thứ gì đó khác để lấp chỗ
        trống, chẳng hạn như lấy thư điện tử hay viết tài liệu. Sau
        một khoảng thời gian tôi quay trở lại nhiệm vụ chính của
        mình, lệnh đã hoàn tất từ lâu rồi, và tôi phải lãng phí
        thêm nhiều thời gian nữa để nhớ lại xem mình đang làm gì.
        Con người thường dở khi phải thay đổi mạch văn.</p>

        <p>Ở đây còn có một hậu quả rất đáng quan tâm nữa: đoán
        trước được việc tắc nghẽn của mạng máy tính, nhiều cá nhân
        riêng lẻ có thể chiếm dụng nhiều lưu lượng mạng hơn cần
        thiết trên các tác vụ khác nhau để cố gắng giảm thiểu sự
        chậm trễ có thể xảy ra trong tương lai. Hậu quả cuối cùng
        là sự quá tải quá mức, việc vô tình ủng hộ việc tiêu dùng
        cá nhân như thế làm đốt cháy nhiều lưu lượng mạng hơn và
        sau đó nó làm cho việc tắc nghẽn càng lúc càng trở nên tồi
        tệ hơn.</p>
      </div>
    </div>

    <div class="chapter" title="Chương&nbsp;6.&nbsp;Đa Người Dùng">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%C4%91a_ng%C6%B0%E1%BB%9Di_d%C3%B9ng"></a>Chương&nbsp;6.&nbsp;Đa
            Người Dùng</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_t%C3%B4i_l%C3%A0_ai">Tôi Là Ai?</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_th%C3%B4ng_qua_ssh_http">Git Thông Qua SSH,
          HTTP</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_th%C3%B4ng_qua_m%E1%BB%8Di_th%E1%BB%A9">Git Thông
          Qua Mọi Thứ</a></span></dt>

          <dt><span class="section"><a href=
          "#_v%C3%A1_s%E1%BB%B1_th%E1%BB%8Bnh_h%C3%A0nh_to%C3%A0n_c%E1%BA%A7u">
          Vá: Sự Thịnh Hành Toàn Cầu</a></span></dt>

          <dt><span class="section"><a href=
          "#_r%E1%BA%A5t_ti%E1%BA%BFc_t%C3%B4i_%C4%91%C3%A3_chuy%E1%BB%83n_%C4%91i">
          Rất tiếc! Tôi đã chuyển đi</a></span></dt>

          <dt><span class="section"><a href=
          "#_nh%C3%A1nh_tr%C3%AAn_m%E1%BA%A1ng">Nhánh Trên
          Mạng</a></span></dt>

          <dt><span class="section"><a href=
          "#_%C4%91a_m%C3%A1y_ch%E1%BB%A7">Đa Máy
          chủ</a></span></dt>

          <dt><span class="section"><a href=
          "#_s%E1%BB%9F_th%C3%ADch_ri%C3%AAng_c%E1%BB%A7a_t%C3%B4i">
          Sở Thích Riêng Của Tôi</a></span></dt>
        </dl>
      </div>

      <p>Lúc đầu tôi sử dụng Git cho dự án riêng của mình mà tôi
      cũng là người duy nhất phát triển nó. Trong số những lệnh
      liên quan đến bản chất phân tán của Git, tôi chỉ cần lệnh
      <span class="strong"><strong>pull</strong></span> và
      <span class="strong"><strong>clone</strong></span> để giữ
      cùng một dự án nhưng ở những chỗ khác nhau.</p>

      <p>Sau đó tôi muốn mã nguồn của mình được phổ biến trên mạng
      bằng việc sử dụng Git, và bao gồm cả những thay đổi từ những
      người đóng góp. Tôi đã phải học cách làm thế nào để quản lý
      các dự án có nhiều người phát triển phần mềm ở khắp nơi trên
      toàn thế giới. May mắn thay, đây là sở trường của Git, và
      người ta có thể nói đây là điều sống còn của một hệ thống
      quản lý mã nguồn.</p>

      <div class="section" title="Tôi Là Ai?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%C3%B4i_l%C3%A0_ai"></a>Tôi Là Ai?</h2>
            </div>
          </div>
        </div>

        <p>Mỗi lần commit sẽ lưu giữ tên và địa chỉ thư điện tử,
        điều này có thể nhìn thấy bằng lệnh <span class=
        "strong"><strong>git log</strong></span>. Theo mặc định,
        Git sử dụng các trường để lưu giữ các cài đặt trong hệ
        thống của mình. Để chỉ định chúng một cách rõ ràng, hãy
        gõ:</p>
        <pre class="literallayout">
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</pre>

        <p>Bỏ qua cờ global để đặt những thông tin này chỉ sử dụng
        cho kho chứa hiện tại.</p>
      </div>

      <div class="section" title="Git Thông Qua SSH, HTTP">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_th%C3%B4ng_qua_ssh_http"></a>Git Thông Qua SSH,
              HTTP</h2>
            </div>
          </div>
        </div>

        <p>Giả sử bạn có thể truy cập vào một máy chủ web qua SSH,
        nhưng Git lại chưa được cài đặt ở đây. Mặc dù không hiệu
        quả như giao thức nguyên bản của nó, nhưng Git vẫn có thể
        truyền thông thông qua HTTP.</p>

        <p>Tải về, dịch và cài Git bằng tài khoản của bạn, và tạo
        kho chứa tại thư mục chứa trang web của bạn:</p>
        <pre class="literallayout">
$ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample hooks/post-update
</pre>

        <p>Với các phiên bản Git cũ, lệnh copy không thực hiện được
        và bạn phải chạy:</p>
        <pre class="literallayout">
$ chmod a+x hooks/post-update
</pre>

        <p>Từ giờ bạn có thể xuất bản mới nhất của mình thông qua
        SSH từ một bản sao bất kỳ:</p>
        <pre class="literallayout">
$ git push web.server:/path/to/proj.git master
</pre>

        <p>và mọi người có thể lấy dự án của bạn với lệnh:</p>
        <pre class="literallayout">
$ git clone http://web.server/proj.git
</pre>
      </div>

      <div class="section" title="Git Thông Qua Mọi Thứ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_th%C3%B4ng_qua_m%E1%BB%8Di_th%E1%BB%A9"></a>Git
              Thông Qua Mọi Thứ</h2>
            </div>
          </div>
        </div>

        <p>Bạn muốn đồng bộ hóa kho chứa nhưng lại không có máy chủ
        và cũng không có mạng? Bạn cần trong những trường hợp khẩn
        cấp? Chúng ta đã biết lệnh <a class="link" href=
        "#makinghistory"><span class="strong"><strong>git
        fast-export</strong></span> và <span class=
        "strong"><strong>git fast-import</strong></span> có thể
        chuyển đổi một kho chứa thành một tệp tin đơn và ngược
        lại</a>. Chúng ta có thể chuyển qua chuyển lại như vậy để
        truyền kho Git đi thông qua bất kỳ phương tiện nào, nhưng
        có một công cụ hiệu quả hơn đó chính là <span class=
        "strong"><strong>git bundle</strong></span>.</p>

        <p>Người gửi tạo một <span class=
        "emphasis"><em>bundle</em></span>:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD
</pre>

        <p>sau đó gửi bundle, <code class=
        "literal">somefile</code>, tới người cần bằng cách nào đó:
        thư điện tử, ổ đĩa USB, và bản in <span class=
        "strong"><strong>xxd</strong></span> và một bộ quét nhận
        dạng chữ OCR, đọc các bit thông qua điện thoại, tín hiệu
        khói, v.v.. Người nhận khôi phục lại các lần commit từ
        bundle nhận được bằng cách gõ:</p>
        <pre class="literallayout">
$ git pull somefile
</pre>

        <p>Bộ nhận thậm chí có thể làm được việc này từ một kho
        chứa rỗng. Mặc dù kích thước của nó, <code class=
        "literal">somefile</code> chứa các mục kho Git nguyên
        thủy.</p>

        <p>Trong các dự án lớn hơn, việc triệt tiêu lãng phí bằng
        cách chỉ bundle những thay đổi còn thiếu kho chứa khác. Ví
        dụ, giả sử lần commit “1b6d…” là lần commit gần nhất đã
        được chia sẻ giữa cả hai thành viên:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD ^1b6d
</pre>

        <p>Nếu phải làm việc này thường xuyên, một khó khăn là bạn
        không thể nhớ được chính xác lần commit tương ứng với lần
        gửi cuối. Trang trợ giúp sẽ gợi ý cho bạn cách sử dụng các
        thẻ (tag) để giải quyết vấn đề này. Ấy là, sau khi bạn gửi
        một bundle, thì hãy gõ:</p>
        <pre class="literallayout">
$ git tag -f lastbundle HEAD
</pre>

        <p>và tạo một bản bundles mới với:</p>
        <pre class="literallayout">
$ git bundle create newbundle HEAD ^lastbundle
</pre>
      </div>

      <div class="section" title="Vá: Sự Thịnh Hành Toàn Cầu">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_v%C3%A1_s%E1%BB%B1_th%E1%BB%8Bnh_h%C3%A0nh_to%C3%A0n_c%E1%BA%A7u">
              </a>Vá: Sự Thịnh Hành Toàn Cầu</h2>
            </div>
          </div>
        </div>

        <p>Miếng vá được trình bày ở dạng văn bản các thay đổi của
        bạn, nó dễ dàng được đọc hiểu bởi con người cũng như là máy
        tính. Điều này mang lại cho chúng sức lôi cuốn toàn cầu.
        Bạn có thể gửi miếng vá qua thư điện tử cho những nhà phát
        triển phần mềm khác mà chẳng cần lo họ đang sử dụng hệ
        thống quản lý mã nguồn nào. Chừng nào mà độc giả của bạn có
        thể đọc được thư điện tử của mình thì họ còn có thể thấy
        được phần chỉnh sửa của bạn. Tương tự thế, về phía mình,
        những thứ bạn cần là có một địa chỉ thư điện tử: ở đây
        chẳng cần cài đặt kho chứa Git nào trên mạng.</p>

        <p>Sử dụng lại ví dụ từ chương đầu tiên:</p>
        <pre class="literallayout">
$ git diff 1b6d &gt; my.patch
</pre>

        <p>đầu ra là một miếng vá mà bạn có thể dán vào một thư
        điện tử để trao đổi với người khác. Ở kho Git, gõ:</p>
        <pre class="literallayout">
$ git apply &lt; my.patch
</pre>

        <p>để áp dụng miếng vá.</p>

        <p>Còn một hình thức định dạng khác nữa, tên và có lẽ cả
        chữ ký của tác giả cũng được ghi lại, tạo miếng vá tương
        ứng với một thời điểm chính xác trong quá khứ bằng cách
        gõ:</p>
        <pre class="literallayout">
$ git format-patch 1b6d
</pre>

        <p>Tệp tin lưu kết quả có thể chuyển cho lệnh <span class=
        "strong"><strong>git-send-email</strong></span>, hay có thể
        làm thủ công. Bạn cũng có thể chỉ định rõ một vùng
        commit:</p>
        <pre class="literallayout">
$ git format-patch 1b6d..HEAD^^
</pre>

        <p>Ở phía người nhận cuối, ghi lại thư điện tử thành tệp
        tin, sau đó chạy lệnh:</p>
        <pre class="literallayout">
$ git am &lt; email.txt
</pre>

        <p>Lệnh này sẽ áp dụng cho miếng vá nhận được, đồng thời
        tạo ra một lần commit, bao gồm các thông tin như là tác
        giả.</p>

        <p>Với một chương trình đọc thư điện tử, bạn có thể sử dụng
        con chuột để chuyển định dạng thư về dạng văn bản thuần
        trước khi ghi miếng vá thành một tệp tin.</p>

        <p>Có một số khác biệt nhỏ giữa các trình đọc đọc thư điện
        tử, nhưng nếu bạn sử dụng một trong số chúng, bạn hầu như
        chắc chắn là người mà có thể cấu hình chúng một cách dễ
        dàng mà chẳng cần phải đọc hướng dẫn sử dụng!</p>
      </div>

      <div class="section" title="Rất tiếc! Tôi đã chuyển đi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_r%E1%BA%A5t_ti%E1%BA%BFc_t%C3%B4i_%C4%91%C3%A3_chuy%E1%BB%83n_%C4%91i">
              </a>Rất tiếc! Tôi đã chuyển đi</h2>
            </div>
          </div>
        </div>

        <p>Sau khi nhân bản kho chứa, việc chạy lệnh <span class=
        "strong"><strong>git push</strong></span> hay <span class=
        "strong"><strong>git pull</strong></span> sẽ tự động push
        tới hay pull từ URL gốc. Git đã làm điều này như thế nào?
        Bí mật nằm ở chỗ các tùy chọn config đã được tạo ra cùng
        với bản sao. Hãy xem thử:</p>
        <pre class="literallayout">
$ git config --list
</pre>

        <p>Tùy chọn <code class="literal">remote.origin.url</code>
        sẽ lưu giữ URL; “origin” là cái tên được đặt cho kho nguồn.
        Với nhánh “master” theo như thường lệ, chúng ta có thể thay
        đổi hay xóa các tên này nhưng chẳng có lý do gì để phải làm
        như thế cả.</p>

        <p>Nếu kho chứa nguyên bản đã chuyển chỗ, chúng ta có thể
        cập nhật URL thông qua:</p>
        <pre class="literallayout">
$ git config remote.origin.url git://new.url/proj.git
</pre>

        <p>Tùy chọn <code class=
        "literal">branch.master.merge</code> chỉ ra nhánh remote
        mặc định trong lệnh <span class="strong"><strong>git
        pull</strong></span>. Trong suốt quá trình nhân bản, nó
        được đặt cho nhánh hiện hành của kho chứa mã nguồn, như thế
        cho dù HEAD của kho nguồn về sau có di chuyển đến một nhánh
        khác, lệnh pull sau này sẽ trung thành với nhánh nguyên
        gốc.</p>

        <p>Tùy chọn này chỉ áp dụng cho kho chứa chúng ta lần đầu
        tiên nhân bản từ, nó được ghi trong tùy chọn <code class=
        "literal">branch.master.remote</code>. Nếu chúng ta pull từ
        kho chứa khác chúng ta phải chỉ đích xác tên nhánh mà chúng
        ta muốn:</p>
        <pre class="literallayout">
$ git pull git://example.com/other.git master
</pre>

        <p>Phần phía trên giải thích tại sao một số lệnh push và
        pull ví dụ của chúng ta lại không có tham số.</p>
      </div>

      <div class="section" title="Nhánh Trên Mạng">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_nh%C3%A1nh_tr%C3%AAn_m%E1%BA%A1ng"></a>Nhánh Trên
              Mạng</h2>
            </div>
          </div>
        </div>

        <p>Khi bạn nhân bản một kho chứa, bạn cũng đồng thời nhân
        bản tất cả các nhánh của nó. Bạn sẽ không nhận được cảnh
        báo này bởi vì Git không thông báo cho bạn: bạn phải hỏi
        mới có thể biết chính xác. Việc làm này giúp ngăn ngừa
        phiền phức do nhánh mạng gây ra cho các nhánh của bạn, và
        cũng làm cho Git dễ dàng hơn với người mới dùng.</p>

        <p>Ta liệt kê các nhánh bằng lệnh:</p>
        <pre class="literallayout">
$ git branch -r
</pre>

        <p>Bạn nhận được kết quả trông giống như thế này:</p>
        <pre class="literallayout">
origin/HEAD
origin/master
origin/experimental
</pre>

        <p>Những nhánh tương ứng và HEAD của kho chứa remote, và
        bạn có thể sử dụng trong các lệnh Git thông thường. Ví dụ
        như là, giả sử bạn làm nhiều lần commit, và muốn so sánh
        chúng với bản đã fetch cuối cùng. Bạn cũng có thể tìm kiếm
        trong tệp tin log để có được giá trị băm SHA1 thích hợp,
        nhưng dễ dàng hơn việc gõ:</p>
        <pre class="literallayout">
$ git diff origin/HEAD
</pre>

        <p>Hay bạn có thể xem nhánh “experimental” đang làm gì:</p>
        <pre class="literallayout">
$ git log origin/experimental
</pre>
      </div>

      <div class="section" title="Đa Máy chủ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91a_m%C3%A1y_ch%E1%BB%A7"></a>Đa Máy chủ</h2>
            </div>
          </div>
        </div>

        <p>Giả sử hai người cùng phát triển trên một sự án của
        chúng ta, và họ muốn giữ lại sự khác biệt trên cả hai.
        Chúng ta theo dõi hơn một kho chứa tại một thời điểm với
        lệnh:</p>
        <pre class="literallayout">
$ git remote add other git://example.com/some_repo.git
$ git pull other some_branch
</pre>

        <p>Bây giờ chúng ta có thể trộn với nhánh của kho chứa thứ
        hai, và chúng ta dễ dàng truy cập tất cả các nhánh của tất
        cả các kho chứa:</p>
        <pre class="literallayout">
$ git diff origin/experimental^ other/some_branch~5
</pre>

        <p>Nhưng chúng ta chỉ muốn so sánh sự khác nhau giữ chúng
        nhưng không áp dụng các thay đổi này với chúng ta? Nói cách
        khác, chúng ta khảo sát các nhánh của họ nhưng không thay
        đổi những gì đang có trong thư mục làm việc của mình. Thế
        thì thay vì pull, ta dùng lệnh:</p>
        <pre class="literallayout">
$ git fetch        # Lấy về từ nguyên gốc, theo mặc định.
$ git fetch other  # Lấy về từ lập trình viên thứ hai.
</pre>

        <p>Lệnh này chỉ mang về phần lịch sử. Mặc dù thư mục làm
        việc vẫn còn nguyên chưa bị động đến, chúng ta có thể xét
        bất kỳ nhánh nào của bất kỳ kho chứa nào trong một lệnh Git
        bởi vì chúng ta bây giờ đang làm việc trên bản sao trên máy
        của mình.</p>

        <p>Giờ ta xét đến phần hậu trường, lệnh pull đơn giản là
        <span class="strong"><strong>fetch</strong></span> sau đó
        <span class="strong"><strong>merge</strong></span>. Thông
        thường chúng ta <span class=
        "strong"><strong>pull</strong></span> bởi vì chúng ta muốn
        trộn với lần commit cuối cùng sau khi fetch; việc làm này
        là một ngoại lệ đáng chú ý.</p>

        <p>Xem <span class="strong"><strong>git help
        remote</strong></span> để biết cách làm thế nào để gỡ bỏ
        kho chứa trên mạng, bỏ qua các nhánh xác định, và những thứ
        khác nữa.</p>
      </div>

      <div class="section" title="Sở Thích Riêng Của Tôi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_s%E1%BB%9F_th%C3%ADch_ri%C3%AAng_c%E1%BB%A7a_t%C3%B4i">
              </a>Sở Thích Riêng Của Tôi</h2>
            </div>
          </div>
        </div>

        <p>Với dự án của mình, tôi thích những người cộng tác tạo
        các kho chứa ở nơi mà tôi có thể pull. Một số dịch vụ Git
        cho phép bạn đặt nhánh riêng của mình từ một dự án trên đó
        chỉ cần sử dụng chuột.</p>

        <p>Sau khi tôi fetch một cây (tree), tôi chạy lệnh Git để
        di chuyển và xem xét các thay đổi, với ý tưởng là để tổ
        chức và mô tả tốt hơn. Tôi trộn với các thay đổi của chính
        mình, và có thể sẽ sửa thêm chút ít. Sau khi đã hài lòng,
        tôi push nó lên kho chứa chính.</p>

        <p>Mặc dù tôi ít nhận được sự cộng tác, nhưng tôi tin rằng
        việc này sẽ thay đổi theo chiều hướng tốt lên. Hãy đọc
        <a class="ulink" href=
        "http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html"
        target="_top">blog của Linus Torvalds</a>.</p>

        <p>Git thuận lợi trong việc tạo các miếng vá, cũng như là
        nó tiết kiệm công sức cho chúng ta trong việc chuyển đổi
        chúng thành những lần commit dành cho Git. Hơn thế nữa, Git
        lưu giữ các thông tin rất chi tiết như là ghi lại tên và
        địa chỉ thư điện tử của tác giả, cũng như là ngày tháng và
        thời gian, và nó cũng đòi hỏi tác giả phải mô tả về những
        thay đổi mà họ đã tạo ra.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;7.&nbsp;Trở Thành Kiện Tướng">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_tr%E1%BB%9F_th%C3%A0nh_ki%E1%BB%87n_t%C6%B0%E1%BB%9Bng">
            </a>Chương&nbsp;7.&nbsp;Trở Thành Kiện Tướng</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_ph%C3%A1t_h%C3%A0nh_m%C3%A3_ngu%E1%BB%93n">Phát hành
          Mã Nguồn</a></span></dt>

          <dt><span class="section"><a href=
          "#_ch%E1%BB%89_commit_nh%E1%BB%AFng_g%C3%AC_thay_%C4%91%E1%BB%95i">
          Chỉ Commit Những Gì Thay Đổi</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%E1%BA%A7n_commit_n%C3%A0y_nhi%E1%BB%81u_qu%C3%A1">Lần
          commit này Nhiều Quá!</a></span></dt>

          <dt><span class="section"><a href=
          "#_m%E1%BB%A5c_l%E1%BB%A5c_v%C3%B9ng_tr%E1%BA%A1ng_th%C3%A1i_c%E1%BB%A7a_git">
          Mục Lục: Vùng trạng thái của Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_%C4%91%E1%BB%ABng_qu%C3%AAn_head_c%E1%BB%A7a_m%C3%ACnh">
          Đừng Quên HEAD Của Mình</a></span></dt>

          <dt><span class="section"><a href=
          "#_s%C4%83n_t%C3%ACm_head">Săn tìm-HEAD</a></span></dt>

          <dt><span class="section"><a href=
          "#_x%C3%A2y_d%E1%BB%B1ng_tr%C3%AAn_git">Xây Dựng trên
          Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_c%E1%BB%A9_phi%C3%AAu_l%C6%B0u">Cứ Phiêu
          Lưu</a></span></dt>

          <dt><span class="section"><a href=
          "#_ng%C4%83n_ng%E1%BB%ABa_commit_sai">Ngăn Ngừa Commit
          Sai</a></span></dt>
        </dl>
      </div>

      <p>Bây giờ, bạn có thể thông qua lệnh <span class=
      "strong"><strong>git help</strong></span> để bật trang trợ
      giúp lên và có thể hiểu gần như tất cả mọi thứ. Tuy nhiên,
      việc xác định chính xác lệnh cần sử dụng để giải quyết các
      vấn đề thực tế đặt ra có lẽ chẳng dễ dàng gì. Có thể tôi có
      thể giúp bạn tiết kiệm được thời gian: bên dưới là một vài
      cách giải quyết các vấn đề thực tế đặt ra mà tôi đã từng sử
      dụng trong quá khứ.</p>

      <div class="section" title="Phát hành Mã Nguồn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ph%C3%A1t_h%C3%A0nh_m%C3%A3_ngu%E1%BB%93n"></a>Phát
              hành Mã Nguồn</h2>
            </div>
          </div>
        </div>

        <p>Với dự án của tôi, Git giữ theo dõi chính xác các tệp
        tin tôi muốn lưu trữ và phát hành tới người dùng. Để tạo
        gói tarball cho mã nguồn, tôi chạy:</p>
        <pre class="literallayout">
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" title="Chỉ Commit Những Gì Thay Đổi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ch%E1%BB%89_commit_nh%E1%BB%AFng_g%C3%AC_thay_%C4%91%E1%BB%95i">
              </a>Chỉ Commit Những Gì Thay Đổi</h2>
            </div>
          </div>
        </div>

        <p>Việc phải thông báo với Git khi bạn thêm, xóa hay đổi
        tên các tệp tin là việc rầy rà với các dự án nào đó. Thay
        vào đó, bạn có thể gõ:</p>
        <pre class="literallayout">
$ git add .
$ git add -u
</pre>

        <p>Git sẽ xem tất cả các tệp tin trong thư mục hiện tại và
        làm công việc mà nó phải làm. Thay vì chạy lệnh add thứ
        hai, hãy chạy <code class="literal">git commit -a</code>
        nếu bạn cũng có ý định commit vào lúc này. Xem <span class=
        "strong"><strong>git help ignore</strong></span> để biết
        làm cách nào để chỉ ra các tệp tin bỏ qua.</p>

        <p>Bạn có thể thi hành những điều trên chỉ cần một dòng
        lệnh:</p>
        <pre class="literallayout">
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>Tùy chọn <span class="strong"><strong>-z</strong></span>
        và <span class="strong"><strong>-0</strong></span> dùng để
        ngăn ngừa sai hỏng không mong muốn từ những tệp tin có chứa
        các ký tự đặc biệt. Bởi vì lệnh này bổ xung những tệp tin
        đã bị bỏ qua, bạn có thể muốn sử dụng tùy chọn <code class=
        "literal">-x</code> hay <code class=
        "literal">-X</code>.</p>
      </div>

      <div class="section" title="Lần commit này Nhiều Quá!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%E1%BA%A7n_commit_n%C3%A0y_nhi%E1%BB%81u_qu%C3%A1">
              </a>Lần commit này Nhiều Quá!</h2>
            </div>
          </div>
        </div>

        <p>Bạn quên việc commit quá lâu? Bạn quá mải mê với việc
        viết mã nguồn mà quên đi việc quản lý nó? Bạn muốn những
        thay đổi liên quan đến nhau phải được commit riêng từng lần
        và nối tiếp nhau, bởi vì đây là phong cách của bạn?</p>

        <p>Đừng lo lắng. Chạy:</p>
        <pre class="literallayout">
$ git add -p
</pre>

        <p>Với mỗi lần thay đổi mà bạn tạo ra, Git sẽ hiện cho bạn
        biết từng đoạn mã đã bị thay đổi, và hỏi nó có phải là một
        bộ phận của lần commit tiếp theo. Trả lời là "y" hay "n".
        Bạn có các sự lựa chọn khác, như là hoãn lại; gõ "?" để
        biết thêm chi tiết.</p>

        <p>Khi nào bạn thỏa mãn thì gõ</p>
        <pre class="literallayout">
$ git commit
</pre>

        <p>để commit chính xác các thay đổi mà bạn đã chọn lựa (các
        thay đổi về <span class="emphasis"><em>staged</em></span>).
        Hãy chắc chắn là bạn đã không dùng tùy chọn <span class=
        "strong"><strong>-a</strong></span>, nếu không thì Git sẽ
        commit tất cả.</p>

        <p>Nhưng bạn lại có những tài liệu đã được chỉnh sửa đặt
        tại nhiều chỗ khác nhau? Việc duyệt từng cái một sẽ làm bạn
        nản lòng. Trong trường hợp này, sử dụng lệnh <span class=
        "strong"><strong>git add -i</strong></span>, với giao diện
        không ít rắc rối hơn, nhưng uyển chuyển hơn. Chỉ cần gõ vài
        cái, bạn có thể đưa vào hay gỡ bỏ nhiều tệp tin vào một
        trạng thái cùng một lúc, hay xem xét và chọn các thay đổi
        chỉ trong các tệp tin riêng biệt. Có một sự lựa chọn khác,
        chạy lệnh <span class="strong"><strong>git commit
        --interactive</strong></span> mà nó sẽ tự động commit sau
        khi bạn làm xong.</p>
      </div>

      <div class="section" title=
      "Mục Lục: Vùng trạng thái của Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_m%E1%BB%A5c_l%E1%BB%A5c_v%C3%B9ng_tr%E1%BA%A1ng_th%C3%A1i_c%E1%BB%A7a_git">
              </a>Mục Lục: Vùng trạng thái của Git</h2>
            </div>
          </div>
        </div>

        <p>Chúng ta trốn tránh chưa muốn nói đến một thứ nổi tiếng
        của Git đó là <span class="emphasis"><em>index</em></span>
        (mục lục), nhưng chúng ta phải đối mặt với nó để mà giảng
        giải những điều ở trên. Chỉ mục là vùng trạng thái tạm
        thời. Git ít khi di chuyển dữ liệu qua lại một cách trực
        tiếp giữa dự án của bạn và lịch sử của nó. Đúng hơn là Git
        đầu tiên ghi dữ liệu vào mục lục, và sau đó sao chép dữ
        liệu trong chỉ mục vào chỗ cần ghi cuối.</p>

        <p>Ví dụ, lệnh <span class="strong"><strong>commit
        -a</strong></span> thực sự bao gồm hai quá trình. Bước thứ
        nhất là đặt toàn bộ dữ liệu hiện tại của mọi tệp tin cần
        theo dõi vào bảng mục lục. Bước thứ hai là ghi vào bảng mục
        lục. Việc commit không sử dụng tùy chọn <span class=
        "strong"><strong>-a</strong></span> chỉ thi hành bước thứ
        hai, và nó chỉ có ý nghĩa sau khi chạy lệnh mà lệnh này
        bằng cách này hay cách khác thay đổi bảng chỉ mục, như là
        lệnh <span class="strong"><strong>git add</strong></span>
        chẳng hạn.</p>

        <p>Thường thường chúng ta bỏ qua mục lục và lấy cớ là chúng
        ta đang đọc trực tiếp và ghi thẳng vào trong lịch sử. Vì lý
        do này, chúng ta muốn việc điều khiển chính xác, như vậy
        chúng ta chỉnh sửa mục lục bằng cách thủ công. Chúng ta đặt
        một dữ liệu hiện hành của một số, không phải tất cả, các
        thay đổi của chúng ta vào bảng mục lục, và sau đó ghi những
        cái này vào lịch sử.</p>
      </div>

      <div class="section" title="Đừng Quên HEAD Của Mình">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91%E1%BB%ABng_qu%C3%AAn_head_c%E1%BB%A7a_m%C3%ACnh">
              </a>Đừng Quên HEAD Của Mình</h2>
            </div>
          </div>
        </div>

        <p>Thẻ HEAD giống như một con trỏ, nó trỏ đến lần commit
        cuối cùng, tự động di chuyển theo mỗi lần commit mới. Một
        số lệnh của Git giúp bạn di chuyển nó. Ví dụ như:</p>
        <pre class="literallayout">
$ git reset HEAD~3
</pre>

        <p>sẽ chuyển HEAD lên vị trí lần commit cách đây ba lần.
        Thế thì tất cả các lệnh Git thi hành như khi bạn ở vị trí
        commit này, trong khi các tệp tin của bạn vẫn nằm ở hiện
        tại. Xem thêm phần trợ giúp cho một số ứng dụng.</p>

        <p>Nhưng ta lại muốn quay trở lại phần sau này? Lần commit
        cũ không biết gì về phần sau này cả.</p>

        <p>Nếu bạn có giá trị băm SHA1 của HEAD gốc thì:</p>
        <pre class="literallayout">
$ git reset 1b6d
</pre>

        <p>Nhưng giả sử bạn không có được nó? Đừng lo: với những
        lệnh như thế, Git ghi lại HEAD gốc với thẻ có tên là
        ORIG_HEAD, và bạn có thể trở về ngon lành và an toàn với
        lệnh:</p>
        <pre class="literallayout">
$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" title="Săn tìm-HEAD">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_s%C4%83n_t%C3%ACm_head"></a>Săn tìm-HEAD</h2>
            </div>
          </div>
        </div>

        <p>Có thể ORIG_HEAD là chưa đủ. Có lẽ bạn vừa nhận thấy
        mình vừa tạo ra một sai sót có quy mô lớn và bạn cần phải
        quay lại một lần commit cách đây lâu lắm rồi trong một
        nhánh mà bạn đã quên rồi vì nó đã quá lâu.</p>

        <p>Theo mặc định, Git giữ một lần commit ít nhất là hai
        tuần lễ, ngay cả khi bạn đã ra lệnh cho Git phá hủy nhánh
        chứa nó. Sự khó khăn là ở chỗ làm thế nào để tìm được giá
        trị băm thích hợp. Bạn có thể tìm kiếm tất cả các giá trị
        băm trong <code class="literal">.git/objects</code> và sử
        dụng phương pháp thử sai tất cả các giá trị để có được thứ
        mình muốn. Nhưng còn có cách dễ dàng hơn.</p>

        <p>Git ghi lại mọi giá trị băm của mọi lần commit trong máy
        tính tại thư mục <code class="literal">.git/logs</code>.
        Thư mục con <code class="literal">refs</code> chứa lịch sử
        của tất cả các hoạt động trên tất cả cách nhánh, trong khi
        tệp tin <code class="literal">HEAD</code> giữ tất cả các
        giá trị băm mà nó từng có được. Phần sau có thể được sử
        dụng để tìm kiếm giá trị băm của các lần commits trên các
        nhánh cái mà đã bị cắt đi một cách tình cờ.</p>

        <p>Lệnh reflog cung cấp cho chúng ta một giao diện thân
        thiện dành cho các tệp tin log. Bạn có thể thử bằng
        lệnh:</p>
        <pre class="literallayout">
$ git reflog
</pre>

        <p>Thay vì phải cắt và dán giá trị băm từ reflog, hãy
        thử:</p>
        <pre class="literallayout">
$ git checkout "@{10 minutes ago}"
</pre>

        <p>Hay checkout lần thứ 5 kể từ lần commit cuối viếng thăm
        thông qua lệnh:</p>
        <pre class="literallayout">
$ git checkout "@{5}"
</pre>

        <p>Xem chương “Specifying Revisions” từ lệnh <span class=
        "strong"><strong>git help rev-parse</strong></span> để biết
        thêm chi tiết.</p>

        <p>Bạn muốn cấu hình thời gian gia hạn lâu hơn việc xóa bỏ
        những lần commit. Ví dụ:</p>
        <pre class="literallayout">
$ git config gc.pruneexpire "30 days"
</pre>

        <p>có nghĩa là việc xóa một lần commit sẽ chỉ thực sự xảy
        ra khi 30 ngày đã qua và lệnh <span class=
        "strong"><strong>git gc</strong></span> được triệu gọi.</p>

        <p>Bạn cũng có thể không cho phép chạy lệnh <span class=
        "strong"><strong>git gc</strong></span> một cách tự
        động:</p>
        <pre class="literallayout">
$ git config gc.auto 0
</pre>

        <p>trong trường hợp này những lần commit sẽ chỉ bị xóa bỏ
        khi bạn chạy lệnh <span class="strong"><strong>git
        gc</strong></span>.</p>
      </div>

      <div class="section" title="Xây Dựng trên Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_x%C3%A2y_d%E1%BB%B1ng_tr%C3%AAn_git"></a>Xây Dựng
              trên Git</h2>
            </div>
          </div>
        </div>

        <p>Tuân thủ theo phong thái UNIX, Git được thiết kế cho
        phép nó dễ dàng được sử dụng như là một thành phần bên dưới
        của các chương trình khác, như là cho giao diện đồ họa GUI
        và giao diện Web để thay thế cho giao diện dòng lệnh, công
        cụ quản lý các miếng vá, các công cụ nhập và chuyển đổi, và
        những thứ tương tự như thế. Trên thực tế, một số lệnh Git
        bản chất nó cũng là các kịch bản đứng trên vai của những
        người khổng lồ, chính là hệ điều hành. Chỉ cần sửa đổi một
        chút, bạn có thể bắt Git làm việc phù hợp với sở thích của
        mình.</p>

        <p>Một mẹo nhỏ là sử dụng một tính năng dựng sẵn trong Git
        là gán bí danh cho các lệnh để nó trở nên ngắn gọn hơn sử
        dụng lệnh:</p>
        <pre class="literallayout">
$ git config --global alias.co checkout  #gán bí danh cho lệnh checkout là co
$ git config --global --get-regexp alias  # hiển thị bí danh hiện hành
alias.co checkout
$ git co foo                              # có kết quả giống như chạy lệnh 'git checkout foo'
</pre>

        <p>Một thứ khác là hiển thị nhánh hiện hành lên màn hình
        hay thanh tiêu đề của cửa sổ. Gọi lệnh</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD
</pre>

        <p>sẽ hiển thị tên của nhánh hiện hành. Trong thực tiễn,
        bạn thích hợp nhất muốn gỡ bỏ "refs/heads/" và tránh các
        lỗi:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>Thư mục con <code class="literal">contrib</code> là một
        kho báu được tìm thấy trong số các công cụ được xây dựng
        dành cho Git. Đúng lúc, một số trong số chúng có thể được
        xúc tiến thành lệnh chính thức. Trên hệ thống Debian và
        Ubuntu, thư mục này ở tại <code class=
        "literal">/usr/share/doc/git-core/contrib</code>.</p>

        <p>Một thư mục phổ biến khác là <code class=
        "literal">workdir/git-new-workdir</code>. Thông qua các
        liên kết tài tình, đoạn kịch bản này tạo ra một thư mục làm
        việc mới trong khi phần lịch sử thì chia sẻ với kho chứa
        nguyên gốc:</p>
        <pre class="literallayout">
$ git-new-workdir an/existing/repo new/directory
</pre>

        <p>Thư mục mới và các tệp tin trong nó có thể được coi như
        một bản sao, ngoại trừ phần lịch sử được chia sẻ dùng
        chung, hai cây được tự động đồng bộ hóa. Ở đây không cần có
        sự trộn, push, hay pull.</p>
      </div>

      <div class="section" title="Cứ Phiêu Lưu">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_c%E1%BB%A9_phi%C3%AAu_l%C6%B0u"></a>Cứ Phiêu
              Lưu</h2>
            </div>
          </div>
        </div>

        <p>Ngày nay, người sử dụng Git rất khó phá hủy dữ liệu.
        Nhưng nếu như bạn biết mình đang làm gì, bạn có thể vượt
        qua sự bảo vệ dành cho các lệnh thông thường đó.</p>

        <p><span class="strong"><strong>Checkout</strong></span>:
        Không commit các thay đổi là nguyên nhân của việc checkout
        gặp lỗi. Để phá hủy sự thay đổi của mình, và dẫu sao cũng
        checkout commit đã cho, sử dụng cờ bắt buộc (force):</p>
        <pre class="literallayout">
$ git checkout -f HEAD^
</pre>

        <p>Mặt khác, nếu bạn chỉ định rõ một đường dẫn chi tiết cho
        lệnh, thế thì ở đây không có sự kiểm tra an toàn nào cả.
        Đường dẫn được áp dụng sẽ bị âm thầm ghi đè lên. Hãy cẩn
        thận nếu bạn sử dụng lệnh checkout theo cách này.</p>

        <p><span class="strong"><strong>Reset</strong></span>: Lệnh
        reset cũng xảy ra lỗi khi không commit các thay đổi. Để bắt
        buộc nó, chạy:</p>
        <pre class="literallayout">
$ git reset --hard 1b6d
</pre>

        <p><span class="strong"><strong>Branch</strong></span>:
        Việc xóa các nhánh cũng gặp lỗi nếu đó là nguyên nhân khiến
        các thay đổi bị mất. Để ép buộc việc này, hãy gõ:</p>
        <pre class="literallayout">
$ git branch -D dead_branch  #thay vì sử dụng tùy chọn -d
</pre>

        <p>Cũng tương tự như thế, việc cố gắng ghi đè lên một nhánh
        bằng cách di chuyển nhánh khác đến nó cũng gây ra lỗi. Để
        ép buộc sự di chuyển nhánh, gõ:</p>
        <pre class="literallayout">
$ git branch -M source target  # thay vì sử dụng tùy chọn -m
</pre>

        <p>Không giống như checkout và reset, hai lệnh trên trì
        hoãn việc phá hủy dữ liệu. Các thay đổi vẫn còn lưu giữ
        trong thư mục con .git, và có thể lấy lại được bằng cách
        lấy giá trị băm <code class="literal">.git/logs</code>
        thích hợp (xem phần "Săn tìm - HEAD" ở phía trên). Theo mặc
        định, chúng sẽ giữ ít nhất là hai tuần lễ.</p>

        <p><span class="strong"><strong>Clean</strong></span>: Một
        số lệnh Git từ chối thi hành bởi vì chúng lo lắng về việc
        làm như thế làm mất dấu hoàn toàn các tệp tin. Nếu bạn chắc
        chắn về tất cả các tệp tin và thư mục không cần Git theo
        dõi nữa và muốn phá hủy chúng đi, thế thì xóa chúng triệt
        để với lệnh:</p>
        <pre class="literallayout">
$ git clean -f -d
</pre>

        <p>Sau này, lệnh rầy rà đó sẽ hoạt động!</p>
      </div>

      <div class="section" title="Ngăn Ngừa Commit Sai">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ng%C4%83n_ng%E1%BB%ABa_commit_sai"></a>Ngăn Ngừa
              Commit Sai</h2>
            </div>
          </div>
        </div>

        <p>Có một số lỗi ngớ ngẩn đã xảy ra với tôi. Điều tồi tệ
        nhất là để sót các tệp tin bởi vì quên lệnh <span class=
        "strong"><strong>git add</strong></span>. Ít tệ hại hơn là
        các ký tự khoảng trắng và những xung đột không cần phải
        trộn: mặc dù cũng chẳng tệ hại lắm, tôi mong rằng những
        điều này sẽ không xảy ra với mọi người.</p>

        <p>Tôi đã tránh được các lỗi ngu ngốc đó bằng cách sử dụng
        một <span class="emphasis"><em>hook</em></span> để nó cảnh
        báo người dùng khi có những vấn đề:</p>
        <pre class="literallayout">
$ cd .git/hooks
$ cp pre-commit.sample pre-commit  # Với phiên bản Git cũ cần chạy lệnh: chmod +x pre-commit
</pre>

        <p>Ngày nay Git sẽ không commit nếu khi nó trộn nó chỉ tìm
        thấy những khoảng trắng vô ích hay những xung đột không cần
        giải trộn.</p>

        <p>Với bản hướng dẫn này, tôi cuối cùng đã thêm vào dòng
        đầu của hook <span class=
        "strong"><strong>pre-commit</strong></span> để đề phòng khi
        ta lơ đãng:</p>
        <pre class="literallayout">
if git ls-files -o | grep '\.txt$'; then
  echo FAIL! Untracked .txt files.
  exit 1
fi
</pre>

        <p>Nhiều hoạt động của Git hỗ trợ hook; hãy xem
        <span class="strong"><strong>git help
        hooks</strong></span>. Chúng tôi đã kích hoạt một hook mẫu
        là <span class="strong"><strong>post-update</strong></span>
        trước khi nói đến Git thông qua HTTP. Cái này chạy mỗi khi
        head di chuyển. Đoạn script ví dụ post-update cập nhật các
        tệp tin Git cần cho việc truyền thông thông qua
        Git-agnostic chuyên chở bằng giao thức giống như là
        HTTP.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;8.&nbsp;Bí Quyết của Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_b%C3%AD_quy%E1%BA%BFt_c%E1%BB%A7a_git"></a>Chương&nbsp;8.&nbsp;Bí
            Quyết của Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_t%C3%ADnh_%E1%BA%A9n">Tính Ẩn</a></span></dt>

          <dt><span class="section"><a href=
          "#_to%C3%A0n_v%E1%BA%B9n_d%E1%BB%AF_li%E1%BB%87u">Toàn
          Vẹn Dữ Liệu</a></span></dt>

          <dt><span class="section"><a href=
          "#_th%C3%B4ng_minh">Thông Minh</a></span></dt>

          <dt><span class="section"><a href=
          "#_m%E1%BB%A5c_l%E1%BB%A5c">Mục Lục</a></span></dt>

          <dt><span class="section"><a href=
          "#_ngu%E1%BB%93n_g%E1%BB%91c_c%E1%BB%A7a_git">Nguồn Gốc
          của Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_c%C6%A1_s%E1%BB%9F_d%E1%BB%AF_li%E1%BB%87u">
          Đối tượng Cơ Sở Dữ Liệu</a></span></dt>

          <dt><span class="section"><a href=
          "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_blob">Đối Tượng
          Blob</a></span></dt>

          <dt><span class="section"><a href=
          "#_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_tree">Đối Tượng
          Tree</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%E1%BA%A7n_commit">Lần Commit</a></span></dt>

          <dt><span class="section"><a href=
          "#_kh%C3%B3_ph%C3%A2n_bi%E1%BB%87t_%C4%91%C6%B0%E1%BB%A3c_s%E1%BB%B1_th%E1%BA%A7n_k%E1%BB%B3">
          Khó Phân Biệt Được sự Thần Kỳ</a></span></dt>
        </dl>
      </div>

      <p>Chúng ta mổ xẻ để hiểu được làm thế nào mà Git có thể thi
      hành kỳ diệu như vậy. Tôi sẽ không thể nói quá chi tiết được.
      Nếu bạn muốn có được sự mô tả chỉ tiết thì hãy đọc <a class=
      "ulink" href="http://schacon.github.com/git/user-manual.html"
      target="_top">sổ tay hướng dẫn sử dụng Git</a>.</p>

      <div class="section" title="Tính Ẩn">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_t%C3%ADnh_%E1%BA%A9n"></a>Tính Ẩn</h2>
            </div>
          </div>
        </div>

        <p>Git làm việc có vẻ kín đáo? Chỉ cần nói riêng về việc sử
        dụng lệnh commit và merge, bạn có thể làm việc mà không cần
        biết đến sự tồn tại của hệ thống quản lý mã nguồn. Cho đến
        khi bạn cần nó, và cho đến khi bạn vui sướng vì Git đã
        trông coi mã nguồn cho bạn trong suốt thời gian qua.</p>

        <p>Các hệ thống quản lý mã nguồn khác ép buộc bạn luôn luôn
        phải tranh đấu với thói quan liêu. Quyền truy cập của các
        tệp tin có thể là chỉ cho phép đọc trừ phi bạn nói rõ với
        máy chủ trung tâm là các tệp tin nào bạn muốn chỉnh sửa.
        Tốc độ làm việc của phần lớn các lệnh sẽ tỷ lệ nghịch với
        số lượng người sử dụng. Mọi công việc sẽ đình trệ khi mạng
        máy tính hay máy chủ ngừng hoạt động.</p>

        <p>Đối lập với hạn chế trên, Git đơn giản giữ lịch sử của
        dự án của bạn tại thư mục <code class="literal">.git</code>
        trong thư mục làm việc của bạn. Đây là bản sao lịch sử của
        riêng bạn, do vậy bạn có thể làm việc không cần mạng cho
        đến khi cần truyền thông với những người khác. Bạn có toàn
        quyền quyết định với các tệp tin của mình bởi vì Git có thể
        tạo lại trạng thái đã ghi lại từ <code class=
        "literal">.git</code> bất kỳ lúc nào một cách dễ dàng.</p>
      </div>

      <div class="section" title="Toàn Vẹn Dữ Liệu">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_to%C3%A0n_v%E1%BA%B9n_d%E1%BB%AF_li%E1%BB%87u"></a>Toàn
              Vẹn Dữ Liệu</h2>
            </div>
          </div>
        </div>

        <p>Phần lớn mọi người sử dụng phương pháp mã hóa để giữ cho
        thông tin của mình không bị nhòm ngó, nhưng có thứ quan
        trọng không kém đó là giữ cho thông tin của mình được toàn
        vẹn. Chính việc sử dụng hàm băm mã hóa đã làm ngăn ngừa sự
        sai hỏng dữ liệu do rủi ro hay ác ý.</p>

        <p>Giá trị SHA1 có thể coi như là một số định danh 160-bit
        không trùng lắp cho mỗi chuỗi ký tự bạn dùng trong đời sống
        của mình. Trên thực tế nó còn làm được nhiều hơn thế: nó có
        thể thực hiện điều trên với mọi chuỗi ký tự mà mọi người có
        thể sử dụng trong suốt cuộc đời của mình.</p>

        <p>Bản thân giá trị SHA1 cũng là một chuỗi ký tự, chúng ta
        có thể băm chuỗi có chứa giá trị băm khác. Khả năng quan
        sát đơn giản này cực kỳ hữu dụng: tra cứu <span class=
        "emphasis"><em>hash chains</em></span> (tra cứu theo các
        chuỗi móc xích với nhau bằng giá trị băm). Sau này chúng ta
        sẽ thấy làm cách nào Git sử dụng nó để mà đảm bảo tính toàn
        vẹn của dữ liệu.</p>

        <p>Tóm lại, Git lưu giữ dữ liệu của bạn trong thư mục con
        <code class="literal">.git/objects</code>, thay vì sử dụng
        tên tệp tin như thông thường, bạn sẽ chỉ nhìn thấy ID của
        chúng. Bằng cách sử dụng ID để làm tên tệp tin, cũng tốt
        như là cách sử dụng kỹ thuật lockfiles (khóa tệp tin) và
        timestamp (theo dõi thời gian của tệp tin), Git biến hệ
        thống tệp tin thông thường bất kỳ nào trở thành một cơ sở
        dữ liệu hiệu quả và mạnh mẽ.</p>
      </div>

      <div class="section" title="Thông Minh">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_th%C3%B4ng_minh"></a>Thông Minh</h2>
            </div>
          </div>
        </div>

        <p>Làm thể nào mà Git biết bạn đã đổi tên một tệp tin, dù
        là bạn chẳng bao giờ đề cập đến điều này một cách rõ ràng?
        Chắc chắn rồi, bạn có lẽ đã chạy lệnh <span class=
        "strong"><strong>git mv</strong></span>, nhưng nó chính xác
        giống hệt như việc chạy lệnh <span class=
        "strong"><strong>git rm</strong></span> sau đó là lệnh
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git khám phá ra cách truy tìm các tệp tin đã được đổi
        tên hay sao chép giữa các phiên bản liên tiếp. Trên thực
        tế, nó có thể tìm ra từng đoạn mã nguồn đã bị di chuyển hay
        sao chép giữa các tệp tin! Dẫu cho nó không thể xử lý được
        mọi trường hợp, nó làm khá tốt, và đặc tính này luôn luôn
        được phát triển. Nếu nó không làm việc với bạn, hãy thử bật
        các tùy chọn dành cho việc phát hiện sự sao chép, và nên
        cất nhắc đến việc cập nhật.</p>
      </div>

      <div class="section" title="Mục Lục">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_m%E1%BB%A5c_l%E1%BB%A5c"></a>Mục Lục</h2>
            </div>
          </div>
        </div>

        <p>Với mọi tệp tin được theo dõi, Git ghi lại các thông tin
        như là kích thước, thời gian tạo và lần cuối sửa đổi trong
        một tệp tin được biết đến là một mục lục <span class=
        "emphasis"><em>index</em></span>. Để xác định rõ một tệp
        tin có bị thay đổi hay không, Git so sánh nó ở thời điểm
        hiện tại với phần lưu giữ trong bộ nhớ. Nếu chúng giống
        nhau, thế thì Git có thể bỏ qua việc đọc tệp tin đó lại lần
        nữa.</p>

        <p>Bởi vì gọi stat nhanh hơn đáng kể so với đọc tệp tin,
        nếu bạn chỉ chỉnh sửa vài tệp tin, Git có thể cập nhật
        trạng thái của nó cực kỳ nhanh chóng.</p>

        <p>Chúng ta đã nói trước rằng mục lục (index) là vùng làm
        việc của trạng thái. Tại sao lại là một chùm tệp tin stat
        vùng stage? Bởi vì lệnh add đặt các tệp tin vào trong cơ sở
        dữ liệu của Git và cập nhật những stats này, trong lúc lệnh
        commit được thực hiện, mà không có tùy chọn, tạo ra một
        commit trên cơ sở chỉ trên các stats và các tệp tin đã sẵn
        có trong cơ sở dữ liệu.</p>
      </div>

      <div class="section" title="Nguồn Gốc của Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ngu%E1%BB%93n_g%E1%BB%91c_c%E1%BB%A7a_git"></a>Nguồn
              Gốc của Git</h2>
            </div>
          </div>
        </div>

        <p><a class="ulink" href=
        "http://lkml.org/lkml/2005/4/6/121" target="_top">Linux
        Kernel Mailing List post</a> này miêu tả các sự kiện nối
        tiếp nhau về Git. Toàn bộ tuyến này chỉ dành cho các sử gia
        đam mê Git.</p>
      </div>

      <div class="section" title="Đối tượng Cơ Sở Dữ Liệu">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_c%C6%A1_s%E1%BB%9F_d%E1%BB%AF_li%E1%BB%87u">
              </a>Đối tượng Cơ Sở Dữ Liệu</h2>
            </div>
          </div>
        </div>

        <p>Mỗi một phiên bản của dữ liệu của bạn được giữ trong
        <span class="emphasis"><em>đối tượng cơ sở dữ
        liệu</em></span> (object database), mà nó nằm trong thư mục
        con <code class="literal">.git/objects</code>; cái khác nằm
        trong thư mục <code class="literal">.git/</code> lưu giữ ít
        dữ liệu hơn: mục lục, tên các nhánh, các thẻ tag, các tùy
        chọn cấu hình, nhật ký, vị trí hiện tại của head của lần
        commit, và những thứ tương tự như thế. Đối tượng cơ sở dữ
        liệu cho đến bây giờ vẫn là phần tử cơ bản xuất sắc nhất,
        và là cội nguồn sức mạnh của Git.</p>

        <p>Mỗi tệp tin trong <code class=
        "literal">.git/objects</code> là một <span class=
        "emphasis"><em>đối tượng</em></span>. Ở đây có 3 loại đối
        tượng liên quan đến chúng ta: đối tượng <span class=
        "emphasis"><em>blob</em></span>, đối tượng cây <span class=
        "emphasis"><em>tree</em></span>, và đối tượng <span class=
        "emphasis"><em>commit</em></span>.</p>
      </div>

      <div class="section" title="Đối Tượng Blob">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_blob"></a>Đối
              Tượng Blob</h2>
            </div>
          </div>
        </div>

        <p>Đầu tiên, hãy tạo một tệp tin bất kỳ. Đặt cho nó một cái
        tên, tên gì cũng được. Trong một thư mục rỗng:</p>
        <pre class="literallayout">
$ echo sweet &gt; YOUR_FILENAME
$ git init
$ git add .
$ find .git/objects -type f
</pre>

        <p>Bạn sẽ thấy <code class=
        "literal">.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d</code>.</p>

        <p>Làm sao mà tôi biết được tệp tin khi không thấy tên của
        nó? Đó là bởi vì đó là giá trị băm SHA1 của:</p>
        <pre class="literallayout">
"blob" SP "6" NUL "sweet" LF
</pre>

        <p>là aa823728ea7d592acc69b36875a482cdf3fd5c8d, với SP là
        khoảng trắng, NUL là byte có giá trị bằng 0 và LF ký tự
        xuống dòng. Bạn có thể xác minh lại bằng lệnh sau:</p>
        <pre class="literallayout">
$ printf "blob 6\000sweet\n" | sha1sum
</pre>

        <p>Git sử dụng cách <span class="emphasis"><em>lấy nội dung
        để làm tên cho tệp tin</em></span>: tệp tin không được lưu
        trữ như theo tên của chúng, mà bằng giá trị băm dữ liệu mà
        chúng chứa, trong tệp tin chúng ta gọi là một <span class=
        "emphasis"><em>đối tượng blob</em></span>. Chúng ta có thể
        nghĩ giá trị băm như là một định danh duy nhất cho nội dung
        của tệp tin, do vậy ta có tên tệp tin được định danh bởi
        nội dung của nó. Phần khởi đầu <code class="literal">blob
        6</code> đơn thuần chỉ là phần đầu để thể hiện kiểu của đối
        tượng và độ dài của nó tính bằng byte; việc làm này làm đơn
        giản hóa việc vận hành bên trong Git.</p>

        <p>Đến đây tôi có thể dễ dàng đoán được bạn nghĩ gì. Tên
        của tệp tin là không thích hợp: chỉ khi có dữ liệu bên
        trong được sử dụng để xây dựng nên đối tượng blob.</p>

        <p>Bạn có lẽ sẽ kinh ngạc với những gì xảy ra với các tệp
        tin có cùng nội dung. Hãy thử thêm một bản sao một tệp tin
        nào đó của bạn, với bất kỳ một cái tên nào cũng được. Nội
        dung của <code class="literal">.git/objects</code> ở tại
        cùng một chỗ cho dù bạn thêm vào bao nhiêu lần đi chăng
        nữa. Git chỉ lưu giữ dữ liệu một lần duy nhất.</p>

        <p>Nhưng dẫu sao, các tệp tin nằm trong <code class=
        "literal">.git/objects</code> đã bị nén lại theo chuẩn zlib
        do vậy bạn không thể xem chúng một cách trực tiếp được. Đọc
        chúng thông qua <a class="ulink" href=
        "http://www.zlib.net/zpipe.c" target="_top">zpipe -d</a>,
        hay gõ:</p>
        <pre class="literallayout">
$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>lệnh này trình bày đối tượng được cho ở dạng dễ đọc trên
        màn hình.</p>
      </div>

      <div class="section" title="Đối Tượng Tree">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91%E1%BB%91i_t%C6%B0%E1%BB%A3ng_tree"></a>Đối
              Tượng Tree</h2>
            </div>
          </div>
        </div>

        <p>Nhưng mà tên tệp tin ở đâu? Chúng phải được lưu giữ ở
        đâu đó chứ. Git lấy tên tệp tin trong quá trình commit:</p>
        <pre class="literallayout">
$ git commit  # Gõ chú thích.
$ find .git/objects -type f
</pre>

        <p>Bạn sẽ thấy ba đối tượng. Ở thời điểm này tôi không thể
        nói hai tệp tin mới này là cái gì, hãy nghĩ nó là một phần
        của tên tệp tin bạn đang xét. Chúng ta sẽ xuất phát từ giả
        định bạn chọn “rose”. Nếu bạn không làm thế, bạn có thể
        viết lại lịch sử để làm cho nó giống như bạn đã làm
        thế:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'mv YOUR_FILENAME rose'
$ find .git/objects -type f
</pre>

        <p>Bây giờ bạn có lẽ nhìn thấy tệp tin <code class=
        "literal">.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9</code>,
        bởi vì đây là giá trị băm SHA1 của nội dung của nó:</p>
        <pre class="literallayout">
"tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>Xác thực tệp tin này chứa thông tin như trên bằng cách
        gõ:</p>
        <pre class="literallayout">
$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
</pre>

        <p>Với lệnh zpipe, ta có thể dễ dàng xác thực một giá trị
        băm:</p>
        <pre class="literallayout">
$ zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
</pre>

        <p>Sự thẩm tra giá trị băm thì rắc rối hơn thông qua lệnh
        cat-file bởi vì phần kết xuất của nó chứa nhiều thông tin
        hơn đối tượng tệp tin thường không bị nén.</p>

        <p>Tệp tin này là một đối tượng cây <span class=
        "emphasis"><em>tree</em></span>: một danh sách các hàng bao
        gồm kiểu tệp tin, tên tệp tin, và giá trị băm. Trong ví dụ
        của chúng ta, kiểu tệp tin là 100644, điều này có nghĩa
        ‘rose` là tệp tin bình thường, và giá trị băm là một đối
        tượng blob mà nó chứa nội dung của `rose’. Dạng tệp tin
        khác có thể là tệp tin thi hành, symlinks hay các thư mục.
        Trong trường hợp cuối, giá trị băm sẽ chỉ đến đối tượng cây
        <span class="emphasis"><em>tree</em></span>.</p>

        <p>Nếu bạn đã chạy lệnh filter-branch, bạn sẽ có các đối
        tượng cũ bạn không cần đến sau này nữa. Mặc dù chúng sẽ bị
        loại bỏ một cách tự động một khi thời hạn chấm dứt đã đến,
        nhưng chúng ta sẽ xóa chúng ngay bây giờ theo cách dưới
        đây:</p>
        <pre class="literallayout">
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
</pre>

        <p>Với các dự án thật bạn nên tránh việc sử dụng lệnh như
        trên, làm như thế bạn đã phá hủy dữ liệu sao lưu dự phòng.
        Nếu bạn muốn làm sạch kho chứa, cách hay nhất là tạo một
        bản sao mới. Cũng thế, hãy cẩn thận khi thao tác trực tiếp
        với thư mục <code class="literal">.git</code>: điều gì xảy
        ra nếu một lệnh Git khác cũng đang thực thi cùng lúc, hay
        là mất điện đột ngột? Đại khái, refs có thể được xóa bằng
        lệnh <span class="strong"><strong>git update-ref
        -d</strong></span>, mặc dù thường thường nó an toàn hơn xóa
        <code class="literal">refs/original</code> bằng tay.</p>
      </div>

      <div class="section" title="Lần Commit">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%E1%BA%A7n_commit"></a>Lần Commit</h2>
            </div>
          </div>
        </div>

        <p>Chúng tôi đã giảng giải cho bạn 2 trong số 3 đối tượng
        của Git. Cái thứ 3 chính là <span class=
        "emphasis"><em>commit</em></span>. Nội dung của nó buộc
        chặt vào phần chú thích của lần commit cũng như thời gian,
        ngày tháng chúng được tạo ra. Để cho khớp với những thứ
        chúng ta có ở đây, chúng ta sẽ phải chỉnh nó một chút:</p>
        <pre class="literallayout">
$ git commit --amend -m Shakespeare  # Thay đổi phần chú thích.
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # dấu vết thời gian và tác giả đã bị gian lận.
$ find .git/objects -type f
</pre>

        <p>Bạn có thể thấy <code class=
        "literal">.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187</code>
        là giá trị băm SHA1 của nội dung của nó:</p>
        <pre class="literallayout">
"commit 158" NUL
"tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
"author Alice &lt;alice@example.com&gt; 1234567890 -0800" LF
"committer Bob &lt;bob@example.com&gt; 1234567890 -0800" LF
LF
"Shakespeare" LF
</pre>

        <p>Như ở phần trước, bạn có thể chạy lệnh zpipe hay
        cat-file để tự mình trông thấy.</p>

        <p>Đây là lần commit đầu tiên, do vậy lần commit này không
        có cha, nhưng những lần commit sau sẽ luôn luôn chứa it
        nhất là một dòng chỉ định commit cha.</p>
      </div>

      <div class="section" title="Khó Phân Biệt Được sự Thần Kỳ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_kh%C3%B3_ph%C3%A2n_bi%E1%BB%87t_%C4%91%C6%B0%E1%BB%A3c_s%E1%BB%B1_th%E1%BA%A7n_k%E1%BB%B3">
              </a>Khó Phân Biệt Được sự Thần Kỳ</h2>
            </div>
          </div>
        </div>

        <p>Bí mật của Git dường như có vẻ đơn giản. Nó giống như
        bạn có thể trộn lẫn cùng nhau một ít kịch bản và một ít mã
        C mà đun trong vài giờ: nhào trộn của quá trình hoạt động
        của hệ thống tệp tin và mã băm SHA1, bày biện thêm với các
        khóa và đồng bộ hóa tệp tin để tăng vị ngon. Trên thực tế,
        những mô tả như thế với Git các phiên bản trước kia là
        chính xác. Tuy nhiên, ngoài chiêu bài đóng gói để tiết kiệm
        không gian lưu trữ, sử dụng mục lục để tiết kiệm thời gian
        ra, giờ chúng ta còn biết thêm làm cách nào Git khéo léo
        thay đổi hệ thống tệp tin thành một cơ sở dữ liệu hoàn hảo
        cho việc quản lý mã nguồn.</p>

        <p>Ví dụ, nếu một tệp tin bất kỳ nào đó trong đối tượng cơ
        sở dữ liệu bị sai hỏng bởi lỗi do ổ đĩa, thế thì giá trị
        băm tương ứng của nó sẽ không đúng nữa, điều này sẽ mang
        lại rắc rối cho chúng ta. Bằng việc băm giá trị băm của đối
        tượng khác, chúng ta có thể duy trì tính toàn vẹn ở tất cả
        các mức. Commit là hạt nhân, thật vậy đấy, mỗi lần commit
        không bao giờ ghi lại nửa vời: chúng ta có thể chỉ tính
        toán mã băm của lần commit và lưu giữ giá trị của nó trong
        cơ sở dữ liệu sau khi chúng ta đã sẵn sàng lưu tất cả các
        đối tượng là trees, blobs và cha của các lần commit thích
        hợp. Đối tượng cơ sở dữ liệu không bị ảnh hưởng bởi các sự
        cố ngắt quãng bất ngờ như là mất điện đột ngột chẳng
        hạn.</p>

        <p>Chúng ta có thể làm thất bại ngay cả những kẻ phá hoại
        ranh mãnh. Giả sử người nào đó lén lút sửa chữa nội dung
        của một tệp tin trong một phiên bản cũ của dự án. Để giữ
        đối tượng cơ sở dữ liệu vẫn hoạt động tốt, họ đồng thời
        cũng phải thay đổi giá trị băm của đối tượng blob tương ứng
        vì lẽ rằng nó bây giờ đã khác trước. Điều đó có nghĩa là họ
        sẽ phải thay đổi giá trị băm của một đối tượng tree có liên
        quan đến tệp tin, và việc chỉnh sửa giá trị băm của tất cả
        các đối tượng commit kéo theo như là tree, thêm nữa là các
        giá trị băm của toàn bộ các lần commit con cháu của nó. Cái
        này kéo theo giá trị băm của head tại trung tâm không giống
        với thứ đó tại kho chứa sai hỏng. Bằng cách theo dõi sự
        tương khớp giá trị băm chúng ta có thể xác định được tệp
        tin bị sai hỏng, cũng như là lần commit nơi mà nó lần đầu
        bị hư hỏng.</p>

        <p>Nói ngắn gọn, dùng 20 byte để đại diện cho lần commit
        cuối là an toàn, nod không thể giả mạo với kho chứa
        Git.</p>

        <p>Đặc tính nào của Git là trứ danh nhất? Nhánh? Trộn? Hay
        Tags? Chỉ là chi tiết. Head hiện hành được giữ trong tệp
        tin <code class="literal">.git/HEAD</code>, mà nó có chứa
        giá trị băm của một đối tượng commit. Giá trị băm được cập
        nhật trong quá trình commit cũng như là một số lệnh khác.
        Nhánh đại thể cũng tương tự: chúng là các tệp tin trong thư
        mục <code class="literal">.git/refs/heads</code>. Tags cũng
        thế: chúng ở tại <code class=
        "literal">.git/refs/tags</code> nhưng chúng được cập nhật
        bởi các lệnh khác nhau.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;9.&nbsp;Phụ lục A: Hạn chế của Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_ph%E1%BB%A5_l%E1%BB%A5c_a_h%E1%BA%A1n_ch%E1%BA%BF_c%E1%BB%A7a_git">
            </a>Chương&nbsp;9.&nbsp;Phụ lục A: Hạn chế của Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Mục lục</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%C4%91i%E1%BB%83m_y%E1%BA%BFu_sha1">Điểm Yếu
          SHA1</a></span></dt>

          <dt><span class="section"><a href=
          "#_microsoft_windows">Microsoft Windows</a></span></dt>

          <dt><span class="section"><a href=
          "#_c%C3%A1c_t%E1%BB%87p_tin_kh%C3%B4ng_li%C3%AAn_quan">Các
          Tệp tin Không liên quan</a></span></dt>

          <dt><span class="section"><a href=
          "#_ai_s%E1%BB%ADa_v%C3%A0_s%E1%BB%ADa_g%C3%AC">Ai Sửa và
          Sửa gì?</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%E1%BB%8Bch_s%E1%BB%AD_t%E1%BB%87p_tin">Lịch Sử Tệp
          Tin</a></span></dt>

          <dt><span class="section"><a href=
          "#_kh%E1%BB%9Fi_t%E1%BA%A1o_b%E1%BA%A3n_sao">Khởi tạo Bản
          Sao</a></span></dt>

          <dt><span class="section"><a href=
          "#_c%C3%A1c_d%E1%BB%B1_%C3%A1n_hay_thay_%C4%91%E1%BB%95i">
          Các Dự Án Hay Thay Đổi</a></span></dt>

          <dt><span class="section"><a href=
          "#_b%E1%BB%99_%C4%91%E1%BA%BFm">Bộ Đếm</a></span></dt>

          <dt><span class="section"><a href=
          "#_v%E1%BB%9Bi_th%C6%B0_m%E1%BB%A5c_r%E1%BB%97ng">Với Thư
          Mục Rỗng</a></span></dt>

          <dt><span class="section"><a href=
          "#_l%E1%BA%A7n_commit_kh%E1%BB%9Fi_t%E1%BA%A1o">Lần
          Commit Khởi tạo</a></span></dt>

          <dt><span class="section"><a href=
          "#_giao_di%E1%BB%87n_l%E1%BA%ADp_l%E1%BB%9D">Giao diện
          Lập lờ</a></span></dt>
        </dl>
      </div>

      <p>Git bộc lộ một số nhược điểm mà tôi đã gặp qua. Một số có
      thể xử lý thủ công một cách dễ dàng bằng các đoạn kịch bản và
      hook, một số yêu cầu phải tổ chức lại hay xác lập lại dự án,
      một số ít rắc rối còn lại, chỉ còn cách là ngồi đợi. Hay tốt
      hơn cả là bắt tay vào và giúp đỡ họ viết!</p>

      <div class="section" title="Điểm Yếu SHA1">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%C4%91i%E1%BB%83m_y%E1%BA%BFu_sha1"></a>Điểm Yếu
              SHA1</h2>
            </div>
          </div>
        </div>

        <p>Thời gian trôi đi, những nhà mật mã đã phát hiện ra ngày
        càng nhiều điểm yếu của thuật toán SHA1. Thực tế người ta
        đã đã phát hiện thấy sự va chạm giá trị băm. Trong khoảng
        vài năm, có lẽ những chiếc PC thông thường cũng đủ sức để
        âm thầm làm hư hỏng một kho Git.</p>

        <p>Hy vọng là Git sẽ chuyển sang sử dụng hàm băm tốt hơn
        trước khi có người tìm ra cách phá mã SHA1.</p>
      </div>

      <div class="section" title="Microsoft Windows">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_microsoft_windows"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Sử dụng Git trên hệ điều hành Microsoft Windows có vẻ
        hơi cồng kềnh một chút:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://cygwin.com/" target="_top">Cygwin</a>, mô phỏng
            Linux dành cho Windows, có chứa <a class="ulink" href=
            "http://cygwin.com/packages/git/" target="_top">Git đã
            chuyển đổi để chạy trên Windows</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://code.google.com/p/msysgit/" target="_top">Git
            chạy trên MSys</a> là một thay thế với các hỗ trợ tối
            thiểu nhất, bởi vì chỉ cần một ít lệnh để thực hiện một
            số việc mà thôi.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Các Tệp tin Không liên quan">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_c%C3%A1c_t%E1%BB%87p_tin_kh%C3%B4ng_li%C3%AAn_quan">
              </a>Các Tệp tin Không liên quan</h2>
            </div>
          </div>
        </div>

        <p>Nếu dự án của bạn rất lớn và chứa rất nhiều tệp tin
        không có liên quan mà luôn luôn bị thay đổi, Git có thể
        chịu thiệt thòi hơn các hệ thống khác bởi vì các tệp tin
        không được giữ dấu viết từng cái riêng lẻ. Git giữ các dấu
        vết thay đổi cho toàn bộ dự án, điều này thường là có
        lợi.</p>

        <p>Giải pháp là chia nhỏ dự án của bạn ra, mỗi một phần bao
        gồm các tệp tin liên quan đến nhau. Hãy sử dụng
        <span class="strong"><strong>git submodule</strong></span>
        nếu bạn vẫn muốn giữ mọi thứ trong một kho chung.</p>
      </div>

      <div class="section" title="Ai Sửa và Sửa gì?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ai_s%E1%BB%ADa_v%C3%A0_s%E1%BB%ADa_g%C3%AC"></a>Ai
              Sửa và Sửa gì?</h2>
            </div>
          </div>
        </div>

        <p>Một số hệ thống quản lý mã nguồn bắt buộc bạn đánh dấu
        rõ ràng vào tệp tin theo một cách nào đó trước khi biên
        soạn. Trong khi mà điều này đặc biệt phiền toái vì nó lại
        dính líu đến việc phải liên lạc với máy chủ trung tâm, việc
        làm này có hai lợi ích:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">Thực hiện lệnh <span class=
            "emphasis"><em>diff</em></span> diễn ra nhanh bởi vì nó
            chỉ kiểm tra các tệp tin đã đánh dấu.</li>

            <li class="listitem">Một người có thể biết được khác
            đang làm việc trên một tệp tin bằng cách hỏi máy chủ
            trung tâm ai đã đánh dấu là đang sửa.</li>
          </ol>
        </div>

        <p>Với một đoạn kịch bản thích hợp, bạn có thể lưu giữ theo
        cách này với. Điều này yêu cầu sự hợp tác từ người lập
        trình, người có thể chạy các kịch bản chuyên biệt khi biên
        soạn một tệp tin.</p>
      </div>

      <div class="section" title="Lịch Sử Tệp Tin">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%E1%BB%8Bch_s%E1%BB%AD_t%E1%BB%87p_tin"></a>Lịch
              Sử Tệp Tin</h2>
            </div>
          </div>
        </div>

        <p>Sau khi Git ghi lại các thay đổi cho các dự án lớn, việc
        cấu trúc lại lịch sử của một tệp tin đơn lẻ yêu cầu phải
        làm việc nhiều hơn các chương trình quản lý mã nguồn giữ
        dấu vết theo các tệp tin riêng lẻ.</p>

        <p>Hình phạt thường là không đáng kể, và thứ đáng giá mà nó
        nhận được là các tác vụ khác hoạt động hiệu quả đến không
        ngờ. Ví dụ, <code class="literal">git checkout</code> nhanh
        hơn <code class="literal">cp -a</code>, và dữ liệu trong dự
        án lớn nén tốt hơn việc gom lại từ tệp tin cơ bản.</p>
      </div>

      <div class="section" title="Khởi tạo Bản Sao">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_kh%E1%BB%9Fi_t%E1%BA%A1o_b%E1%BA%A3n_sao"></a>Khởi
              tạo Bản Sao</h2>
            </div>
          </div>
        </div>

        <p>Việc tạo một bản sao có vẻ hơi xa xỉ hơn là việc
        <span class="emphasis"><em>checkout</em></span> trong các
        hệ thống quản lý mã nguồn khác khi phần mềm có lịch sử phát
        triển lâu dài.</p>

        <p>Cái giá phải trả ban đầu là cần nhiều thời gian để lấy
        về, nhưng nếu đã làm như thế, các tác vụ cần làm sau này sẽ
        nhanh chóng và không cần có mạng. Tuy nhiên, trong một số
        hoàn cảnh, cách làm phù hợp hơn là tạo một bản sao không
        đầy đủ bằng tùy chọn <code class="literal">--depth</code>.
        Điều này giúp ta tạo bản sao nhanh hơn, nhưng bản sao nhận
        được sẽ thiếu đi một số chức năng do đó bạn sẽ không thể
        thực thi được một số lệnh.</p>
      </div>

      <div class="section" title="Các Dự Án Hay Thay Đổi">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_c%C3%A1c_d%E1%BB%B1_%C3%A1n_hay_thay_%C4%91%E1%BB%95i">
              </a>Các Dự Án Hay Thay Đổi</h2>
            </div>
          </div>
        </div>

        <p>Git được viết ra với mục đích chú tâm đến kích thước tạo
        ra bởi các thay đổi. Con người chỉ tạo ra sự thay đổi rất
        nhỏ giữa các phiên bản. Như là bổ xung lời nhận xét là có
        sửa lỗi ở đây, có đặc tính mới ở đây, sửa lỗi chú thích,
        v.v.. Nhưng nếu các tệp tin của bạn căn bản khác nhau, thì
        trong mỗi lần commit, nó sẽ ghi lại toàn bộ các thay đổi
        vào lịch sử và làm cho dự án của bạn tất yếu sẽ tăng kích
        cỡ.</p>

        <p>Không có bất kỳ một hệ thống quản lý mã nguồn nào có thể
        làm được điều này, nhưng những người sử dụng Git theo tiêu
        chuẩn sẽ còn phải chịu tổn thất hơn khi lịch sử của nó được
        nhân bản.</p>

        <p>Đây là lý do tại sao các thay đổi quá lớn cần được xem
        xét. Định dạng các tệp tin có thể bị thay đổi. Các thay đổi
        nhỏ chỉ xảy ra phần lớn tại một số ít tệp tin.</p>

        <p>Việc xét đến việc sử dụng cơ sở dữ liệu hay các giải
        pháp sao-lưu/lưu-trữ có lẽ là thứ có vẻ thực tế hơn, không
        nên dùng hệ thống quản lý mã nguồn. Ví dụ, quản lý mã nguồn
        không thích hợp cho việc quản lý các ảnh được chụp một cách
        định kỳ từ webcam.</p>

        <p>Nếu các tệp tin thực sự thay đổi thường xuyên và chúng
        cần phải quản lý, việc xem xét khả năng sử dụng Git hoạt
        động như một hệ thống quản lý tập trung là có thể chấp nhận
        được. Một người có thể tải về một bản sao không đầy đủ, nó
        chỉ lấy về một ít hay không lấy về lịch sử của dự án. Dĩ
        nhiên, nhiều công cụ dành cho Git sẽ không thể hoạt động
        được, và sự sửa chữa phải được chuyển lên như là các miếng
        vá. Điều này chắc chắn là tốt và nó giống như là ta không
        thể hiểu nổi tại sao một số người lại muốn có được lịch sử
        của rất nhiều các tệp tin chẳng hoạt động ổn định.</p>

        <p>Một ví dụ khác là dự án phụ thuộc vào firmware, cái này
        có dạng thức là tệp tin nhị phân có kích thước rất lớn.
        Người sử dụng không quan tâm tới lịch sử của firmware, vả
        lại khả năng nén của nó lại cũng rất ít, vì vậy quản lý
        firmware có lẽ là không cần thiết vì nó làm phình to kích
        thước kho chứa.</p>

        <p>Trong trường hợp này, mã nguồn có thể lưu giữ trong kho
        Git, và tệp tin nhị phân được giữ ở nơi khác. Để cho công
        việc trở nên dễ dàng hơn, một người có thể tạo ra một đoạn
        kịch bản mà nó sử dụng Git để nhân bản mã nguồn, và dùng
        lệnh rsync hay Git lấy về firmware.</p>
      </div>

      <div class="section" title="Bộ Đếm">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_b%E1%BB%99_%C4%91%E1%BA%BFm"></a>Bộ Đếm</h2>
            </div>
          </div>
        </div>

        <p>Một số hệ quản trị mã nguồn tập trung duy trì một số
        nguyên dương tự động tăng lên khi có lần commit mới được
        chấp nhận. Git quy các thay đổi này bởi giá trị băm của
        chúng, điều này là tốt trong phần lớn hoàn cảnh.</p>

        <p>Nhưng một số người thích có nó ở dạng số nguyên. May mắn
        thay, rất dễ dàng để viết các đoạn kịch bản làm được như
        thế với mỗi lần cập nhật, kho Git trung tâm Git gia một số
        nguyên, có thể là trong một thẻ (tag), và kết hợp nó với
        giá trị băm của lần commit cuối.</p>

        <p>Mỗi bản sao có thể có một bộ đếm riêng, nhưng điều này
        chẳng ích lợi gì, chỉ có kho chứa trung tâm và bộ đếm của
        nó là có ý nghĩa với mọi người.</p>
      </div>

      <div class="section" title="Với Thư Mục Rỗng">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_v%E1%BB%9Bi_th%C6%B0_m%E1%BB%A5c_r%E1%BB%97ng"></a>Với
              Thư Mục Rỗng</h2>
            </div>
          </div>
        </div>

        <p>Các thư mục rỗng không được theo dõi. Tạo ra các thư mục
        giả để thử trục trặc này.</p>

        <p>Xét về mặt thi hành của Git, thay vì thiết kế của nó,
        điều hạn chế này này là đáng trách. Với một chút may mắn,
        một khi Git thấy có thêm lợi ích từ việc này, thêm nhiều
        người đòi hỏi tính năng này và nó sẽ được thực hiện.</p>
      </div>

      <div class="section" title="Lần Commit Khởi tạo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_l%E1%BA%A7n_commit_kh%E1%BB%9Fi_t%E1%BA%A1o"></a>Lần
              Commit Khởi tạo</h2>
            </div>
          </div>
        </div>

        <p>Hệ thống số đếm khoa học của máy tính đếm từ 0, thay vì
        1. Thật không may, có liên quan đến các lần commit, Git
        không tôn trọng quy ước này. Rất nhiều lệnh bất lợi trước
        lần commit khởi tạo. Thêm nữa, các trường hợp ngoại lệ phải
        được xử lý theo một cách đặc biệt, như là việc rebasing một
        nhánh với lần commit khởi tạo khác.</p>

        <p>Git có thể có được lợi ích từ việc định nghĩa lần commit
        zero: ngay khi kho chứa được tạo ra, HEAD được đặt cho một
        chuỗi ký tự bao gồm 20 byte rỗng. Lần commit đặc biệt này
        tương ứng với một cây (tree) rỗng, không có gốc, tại một
        thời điểm được đề lùi về trước.</p>

        <p>Sau đó chạy lệnh git log, ví dụ thế, thì Git nên báo cho
        người dùng biết chưa có lần commit nào, thay vì phát ra một
        lỗi nghiêm trọng. Điều tương tự xảy ra với các công cụ
        khác.</p>

        <p>Tất cả các bản commit đầu tiên hoàn toàn là con cháu của
        bản 0 (zero).</p>

        <p>Tuy nhiên, ở đây có một số vấn đề xảy ra trong một số
        trường hợp đặc biệt. Nếu nhiều nhánh với các lần khởi tạo
        commit khác nhau được trộn với nhau, sau đó rebase kết quả
        đòi hỏi thực chất có sự can thiệp bằng tay.</p>
      </div>

      <div class="section" title="Giao diện Lập lờ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_giao_di%E1%BB%87n_l%E1%BA%ADp_l%E1%BB%9D"></a>Giao
              diện Lập lờ</h2>
            </div>
          </div>
        </div>

        <p>Để commit A và B, nghĩa của biểu thức "A..B" và "A…B"
        tùy thuộc vào việc lệnh mong đó là hai đầu mút hay là một
        vùng. Xem <span class="strong"><strong>git help
        diff</strong></span> và <span class="strong"><strong>git
        help rev-parse</strong></span>.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Chương&nbsp;10.&nbsp;Phụ lục B: Dịch Bản Hướng Dẫn Này">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_ph%E1%BB%A5_l%E1%BB%A5c_b_d%E1%BB%8Bch_b%E1%BA%A3n_h%C6%B0%E1%BB%9Bng_d%E1%BA%ABn_n%C3%A0y">
            </a>Chương&nbsp;10.&nbsp;Phụ lục B: Dịch Bản Hướng Dẫn
            Này</h2>
          </div>
        </div>
      </div>

      <p>Tôi khuyến nghị các bạn làm theo các bước sau để thực hiện
      việc dịch thuật, làm như vậy thì các đoạn kịch bản của tôi có
      thể nhanh chóng tạo ra các bản có định dạng HTML và PDF, và
      tất cả các bản dịch có thể ở trong cùng một kho chứa.</p>

      <p>Lấy một bản sao của mã nguồn, sau đó tạo một thư mục tương
      ứng với ngôn ngữ bạn dịch <a class="ulink" href=
      "http://www.iana.org/assignments/language-subtag-registry"
      target="_top">language’s IETF tag</a>: xem tại <a class=
      "ulink" href=
      "http://www.w3.org/International/articles/language-tags/Overview.en.php"
      target="_top">the W3C article on internationalization</a>. Ví
      dụ, tiếng Anh là "en", Nhật là "ja", tiếng Trung Quốc Phồn
      thể là "zh-Hant". Trong thư mục mới đó, và dịch tệp tin
      <code class="literal">txt</code> từ thư mục con "en".</p>

      <p>Một ví dụ cụ thể là để dịch phần hướng dẫn này thành ngôn
      ngữ <a class="ulink" href=
      "http://en.wikipedia.org/wiki/Klingon_language" target=
      "_top">Klingon</a>, bạn hãy gõ vào:</p>
      <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh  # "tlh" là mã ngôn ngữ IETF dành cho Klingon.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Dịch tệp tin này.
</pre>

      <p>và cứ như thế cho những tệp tin còn lại.</p>

      <p>Chỉnh sửa lại Makefile và thêm mã ngôn ngữ cho biến
      <code class="literal">TRANSLATIONS</code>. Bạn có thể xem thử
      kết quả công việc của mình như sau:</p>
      <pre class="literallayout">
$ make tlh
$ firefox book-tlh/index.html
</pre>

      <p>Hãy commit công việc của bạn thường xuyên, và cho tôi biết
      khi nào thì chúng sẵn sàng để sử dụng. GitHub.com có giao
      diện thuận lợi như sau: tạo nhánh cho dự án "gitmagic", push
      các thay đổi của bạn lên, sau đó thông báo với tôi để tôi
      trộn.</p>
    </div>
  </div>
</body>
</html>
