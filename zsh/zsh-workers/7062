From zsh-workers-return-7062-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Jul 09 08:56:34 1999
Return-Path: <zsh-workers-return-7062-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17671 invoked from network); 9 Jul 1999 08:56:32 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Jul 1999 08:56:32 -0000
Received: (qmail 5352 invoked by alias); 9 Jul 1999 08:56:20 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7062
Received: (qmail 5340 invoked from network); 9 Jul 1999 08:56:19 -0000
Date: Fri, 9 Jul 1999 10:56:18 +0200 (MET DST)
Message-Id: <199907090856.KAA13273@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Wed, 7 Jul 1999 10:23:20 +0200 (MET
	DST)
Subject: Re: PATCH: complist


I wrote:

> This makes accept-and-infer-next-history be treated specially when in
> menu-selection. It accepts the current match and immediatly starts
> completion again. So if you have a list of files, place the mark on a
> directory and execute a-a-i-n-h, you can select files in that
> directory. Of course it would be nice to be able to go back again,
> e.g. with undo, but implementing that is a bit more complicated...

This does that. Now we have an ultra-light-weight file system
browser. Ouch.

The patch also fixes a display problem: if you were near the end of
the line and using menu-selection so that depending on the length of
the match inserted the prompt took one or two lines, the list was
moved down and up again, but the last line wasn't cleared when going
from a prompt spanning two lines to a prompt needing only one line.

The last line may now flicker again, but the rest should be ok (if
your terminal is fast enough).

Bye
 Sven

diff -u -r oos/Zle/complist.c Src/Zle/complist.c
--- oos/Zle/complist.c	Thu Jul  8 13:56:17 1999
+++ Src/Zle/complist.c	Fri Jul  9 10:40:10 1999
@@ -309,7 +309,7 @@
     Cexpl *e;
     int nlines = 0, ncols, nlist = 0, longest = 1, pnl = 0, opl = 0;
     int of = isset(LISTTYPES);
-    int mc, ml = 0, cc, hasm = 0;
+    int mc, ml = 0, cc, hasm = 0, cl;
     struct listcols col;
 
     if (minfo.asked == 2) {
@@ -448,7 +448,12 @@
 	mgtab = (Cmgroup *) zalloc(i * sizeof(Cmgroup));
 	memset(mgtab, 0, i * sizeof(Cmgroup));
 	mcols = ncols;
-	mlines = nlines;
+	mlines = cl = nlines;
+	if (cl < 2) {
+	    cl = -1;
+	    if (tccan(TCCLEAREOD))
+		tcout(TCCLEAREOD);
+	}
     }
     /* Now print the matches. */
     g = amatches;
@@ -456,14 +461,27 @@
 	char **pp = g->ylist;
 
 	if ((e = g->expls)) {
+	    int l;
+
 	    while (*e) {
 		if ((*e)->count) {
 		    if (pnl) {
 			putc('\n', shout);
 			pnl = 0;
 			ml++;
+			if (cl >= 0 && --cl <= 1) {
+			    cl = -1;
+			    if (tccan(TCCLEAREOD))
+				tcout(TCCLEAREOD);
+			}
+		    }
+		    l = printfmt((*e)->str, (*e)->count, 1);
+		    ml += l;
+		    if (cl >= 0 && (cl -= l) <= 1) {
+			cl = -1;
+			if (tccan(TCCLEAREOD))
+			    tcout(TCCLEAREOD);
 		    }
-		    ml += printfmt((*e)->str, (*e)->count, 1);
 		    pnl = 1;
 		}
 		e++;
@@ -474,6 +492,11 @@
 		putc('\n', shout);
 		pnl = 0;
 		ml++;
+		if (cl >= 0 && --cl <= 1) {
+		    cl = -1;
+		    if (tccan(TCCLEAREOD))
+			tcout(TCCLEAREOD);
+		}
 	    }
 	    if (g->flags & CGF_LINES) {
 		while (*pp) {
@@ -504,6 +527,11 @@
 		    if (n) {
 			putc('\n', shout);
 			ml++;
+			if (cl >= 0 && --cl <= 1) {
+			    cl = -1;
+			    if (tccan(TCCLEAREOD))
+				tcout(TCCLEAREOD);
+			}
 		    }
 		    pp++;
 		}
@@ -517,6 +545,11 @@
 		putc('\n', shout);
 		pnl = 0;
 		ml++;
+		if (cl >= 0 && --cl <= 1) {
+		    cl = -1;
+		    if (tccan(TCCLEAREOD))
+			tcout(TCCLEAREOD);
+		}
 	    }
 	    for (p = skipnolist(g->matches); n && nl--;) {
 		i = ncols;
@@ -607,6 +640,11 @@
 		if (n) {
 		    putc('\n', shout);
 		    ml++;
+		    if (cl >= 0 && --cl <= 1) {
+			cl = -1;
+			if (tccan(TCCLEAREOD))
+			    tcout(TCCLEAREOD);
+		    }
 		    if (n && nl)
 			p = skipnolist(p + 1);
 		}
@@ -640,6 +678,7 @@
     char *line;
     int cs;
     struct menuinfo info;
+    Cmgroup amatches, pmatches, lmatches;
 };
 
 static int
@@ -693,8 +732,20 @@
 	    acc = 1;
 	    break;
 	} else if (cmd == Th(z_acceptandinfernexthistory)) {
+	    Menustack s = (Menustack) zhalloc(sizeof(*s));
+
+	    s->prev = u;
+	    u = s;
+	    s->line = dupstring((char *) line);
+	    s->cs = cs;
+	    memcpy(&(s->info), &minfo, sizeof(struct menuinfo));
+	    s->amatches = amatches;
+	    s->pmatches = pmatches;
+	    s->lmatches = lmatches;
 	    menucmp = 0;
 	    fixsuffix();
+	    validlist = 0;
+	    pmatches = NULL;
 	    invalidatelist();
 	    menucomplete(zlenoargs);
 	    if (dat->num < 2 || !minfo.cur || !*(minfo.cur)) {
@@ -704,8 +755,6 @@
 		break;
 	    }
 	    clearlist = 1;
-	    zrefresh();
-	    clearlist = 0;
 	    mselect = (*(minfo.cur))->gnum;
 	    continue;
 	} else if (cmd == Th(z_acceptandhold) ||
@@ -717,6 +766,7 @@
 	    s->line = dupstring((char *) line);
 	    s->cs = cs;
 	    memcpy(&(s->info), &minfo, sizeof(struct menuinfo));
+	    s->amatches = s->pmatches = s->lmatches = NULL;
 	    acceptlast();
 	    do_menucmp(0);
 	    mselect = (*(minfo.cur))->gnum;
@@ -734,7 +784,15 @@
 	    cs = u->cs;
 	    memcpy(&minfo, &(u->info), sizeof(struct menuinfo));
 	    p = &(minfo.cur);
+	    if (u->pmatches && pmatches != u->pmatches) {
+		freematches();
+		amatches = u->amatches;
+		pmatches = u->pmatches;
+		lmatches = u->lmatches;
+		hasperm = 1;
+	    }
 	    u = u->prev;
+	    clearlist = 1;
 	} else if (cmd == Th(z_redisplay)) {
 	    redisplay(zlenoargs);
 	    continue;
@@ -867,6 +925,19 @@
 	}
 	do_single(**p);
 	mselect = (**p)->gnum;
+    }
+    if (u) {
+	int hp = hasperm;
+	Cmgroup m = pmatches;
+
+	for (; u; u = u->prev) {
+	    if (u->pmatches != m) {
+		pmatches = u->pmatches;
+		freematches();
+	    }
+	}
+	pmatches = m;
+	hasperm = hp;
     }
     selectlocalmap(NULL);
     mselect = -1;
diff -u -r oos/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- oos/Zle/zle_tricky.c	Thu Jul  8 11:11:38 1999
+++ Src/Zle/zle_tricky.c	Fri Jul  9 10:36:17 1999
@@ -133,7 +133,8 @@
 /* This holds the list of matches-groups. lmatches is a pointer to the  *
  * last element in this list. */
 
-static Cmgroup pmatches, amatches, lmatches;
+/**/
+Cmgroup pmatches, amatches, lmatches;
 
 /* Non-zero if we have permanently allocated matches. */
 
@@ -150,7 +151,8 @@
 
 /* !=0 if we have a valid completion list. */
 
-static int validlist;
+/**/
+int validlist;
 
 /* This flag is non-zero if we are completing a pattern (with globcomplete) */
 
@@ -7041,7 +7043,7 @@
 /* This frees the groups of matches. */
 
 /**/
-static void
+void
 freematches(void)
 {
     Cmgroup g = pmatches, n;
diff -u od/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- od/Zsh/compsys.yo	Wed Jul  7 10:24:56 1999
+++ Doc/Zsh/compsys.yo	Thu Jul  8 08:58:06 1999
@@ -579,7 +579,10 @@
 tt(_oldlist) completer).  If it is unset, or any other value, then the
 existing list of completions will be displayed if it is not already;
 otherwise, the standard completion list will be generated:  this is the
-default behaviour of tt(_oldlist).
+default behaviour of tt(_oldlist). However, if there is an old list
+and this key contains the name of the completer function that
+generated the list, then the old list will be used even if it was
+generated by a widget which does not listing.
 
 For example, suppose you type tt(^Xc) to use the tt(_correct_word)
 widget, which generates a list of corrections for the word under the
@@ -587,6 +590,14 @@
 completions for the word on the command line, and show that.  With
 tt(_oldlist), it will instead show the list of corrections already
 generated.
+
+As another example consider the tt(_match) completer: with the
+tt(match_insert) key set to tt(unambig) it inserts only an
+unambiguous prefix string if there is any. But since this may remove
+parts of the original pattern, attempting completion again may result
+in more matches than on the first attempt. But by using the
+tt(_oldlist) completer and setting this key to tt(_match), the list of 
+matches generated on the first attempt will be used again.
 )
 item(tt(oldlist_menu))(
 Controls how menu completion behaves when a completion has already been
diff -u od/Zsh/mod_complist.yo Doc/Zsh/mod_complist.yo
--- od/Zsh/mod_complist.yo	Wed Jul  7 10:24:57 1999
+++ Doc/Zsh/mod_complist.yo	Fri Jul  9 10:50:00 1999
@@ -104,12 +104,12 @@
 complete after it. Using tt(send-break) leaves menu-selection and
 continues with normal menu-completion. The functions tt(accept-and-hold) and
 tt(accept-and-menu-complete) can be used to accept the match currently
-inserted and continue inserting matches after that. Matches inserted this
-way can be removed by invoking the tt(undo) function. The function
+inserted and continue inserting matches after that. The function
 tt(accept-and-infer-next-history) accepts the current match and
 immediatly tries completion with menu-selection again. In the case of
 files this allows one to select a directory and then to directly
-continue with completing files in it. Keys bound to one of
+continue with completing files in it. Matches inserted in one of these
+ways can be removed by invoking the tt(undo) function. Keys bound to one of
 the completion functions will cycle to the next (or, in case of
 tt(reverse-menu-complete), the previous) match, and the tt(redisplay) and
 tt(clear-screen) functions work as usual without leaving

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

