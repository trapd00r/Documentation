From zsh-workers-return-28073-mason-zsh=primenet.com.au@zsh.org Tue Jul 13 20:45:57 2010
Return-Path: <zsh-workers-return-28073-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8425 invoked by alias); 13 Jul 2010 20:45:57 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28073
Received: (qmail 25458 invoked from network); 13 Jul 2010 20:45:54 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at ntlworld.com designates 81.103.221.58 as permitted sender)
Date: Tue, 13 Jul 2010 21:01:06 +0100
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: Zsh Hackers' List <zsh-workers@zsh.org>
Subject: Re: zsh portable script
Message-ID: <20100713210106.6411aba8@pws-pc>
In-Reply-To: <20100712170648.706cb975@csr.com>
References: <1007130241570.5546@smasher>
	<20100712170648.706cb975@csr.com>
X-Mailer: Claws Mail 3.7.6 (GTK+ 2.18.9; x86_64-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-Cloudmark-Analysis: v=1.1 cv=4QByPj+6Iq2k/6L54d+eVKTdgQxdscpRskJJReCfdXo= c=1 sm=0 a=zNANCjgXmV0A:10 a=DogomfpGjd0A:10 a=kj9zAlcOel0A:10 a=4UtWO5riAAAA:8 a=NLZqzBF-AAAA:8 a=_seFj15n27PmgFi70yEA:9 a=7NA8DUT2yifsXC3Kv9IA:7 a=_4x53Zq15l69IT_4av7mbpgd4rAA:4 a=CjuIK1q_8ugA:10 a=Shd8Sdw-9eQA:10 a=_dQi-Dcv4p4A:10 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117

On Mon, 12 Jul 2010 17:06:48 +0100
Peter Stephenson <Peter.Stephenson@csr.com> wrote:
> Looking at the responses, on which I can't improve, one might speculate it
> was time for someone to implement path searching down in the #! handler for
> relative paths.
>...
> This doesn't really touch zsh except that we could do it in our own
> #! handler (see zexecve() in Src/exec.c).w

Straightforward, not sure if anyone's interested since this only
addresses a fairly tiny part of the problem...

Note if zsh is in the current directory it tries that first.  That maintains compatibility
with how it used to work (whether intentionally or not).

% cat execme 
#!zsh -f
print I am running under $ZSH_VERSION
% PATH=/bin ./execme
I am running under 4.3.10
% PATH=/usr/local/bin ./execme
I am running under 4.3.10-dev-1

Index: Src/exec.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/exec.c,v
retrieving revision 1.180
diff -p -u -r1.180 exec.c
--- Src/exec.c	14 Jun 2010 11:57:08 -0000	1.180
+++ Src/exec.c	13 Jul 2010 19:54:41 -0000
@@ -461,8 +461,15 @@ zexecve(char *pth, char **argv, char **n
 			for (ptr = execvebuf + 2; *ptr && *ptr == ' '; ptr++);
 			for (ptr2 = ptr; *ptr && *ptr != ' '; ptr++);
 			if (eno == ENOENT) {
+			    char *pprog;
 			    if (*ptr)
 				*ptr = '\0';
+			    if (*ptr2 != '/' &&
+				(pprog = pathprog(ptr2, NULL))) {
+				argv[-2] = ptr2;
+				argv[-1] = ptr + 1;
+				execve(pprog, argv - 2, newenvp);
+			    }
 			    zerr("%s: bad interpreter: %s: %e", pth, ptr2,
 				 eno);
 			} else if (*ptr) {
Index: Src/init.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/init.c,v
retrieving revision 1.115
diff -p -u -r1.115 init.c
--- Src/init.c	8 Jun 2010 08:51:04 -0000	1.115
+++ Src/init.c	13 Jul 2010 19:54:41 -0000
@@ -949,25 +949,7 @@ setupshin(char *runscript)
 	     * With the PATHSCRIPT option, search the path if no
 	     * path was given in the script name.
 	     */
-	    char **pp, ppmaxlen = 0, *buf;
-	    for (pp = path; *pp; pp++)
-	    {
-		int len = strlen(*pp);
-		if (len > ppmaxlen)
-		    ppmaxlen = len;
-	    }
-	    buf = zhalloc(ppmaxlen + strlen(runscript) + 2);
-	    for (pp = path; *pp; pp++) {
-		sprintf(buf, "%s/%s", *pp, runscript);
-		/* careful, static buffer used in open() later */
-		funmeta = unmeta(buf);
-		if (access(funmeta, F_OK) == 0 &&
-		    stat(funmeta, &st) >= 0 &&
-		    !S_ISDIR(st.st_mode)) {
-		    sfname = buf;
-		    break;
-		}
-	    }
+	    funmeta = pathprog(runscript, &sfname);
 	}
 	if (!sfname ||
 	    (SHIN = movefd(open(funmeta, O_RDONLY | O_NOCTTY)))
Index: Src/utils.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/utils.c,v
retrieving revision 1.244
diff -p -u -r1.244 utils.c
--- Src/utils.c	11 Jun 2010 20:08:03 -0000	1.244
+++ Src/utils.c	13 Jul 2010 19:54:42 -0000
@@ -606,6 +606,44 @@ zwcwidth(wint_t wc)
 /**/
 #endif /* MULTIBYTE_SUPPORT */
 
+/*
+ * Search the path for prog and return the file name.
+ * The returned value is unmetafied and in the unmeta storage
+ * area (N.B. should be duplicated if not used immediately and not
+ * equal to *namep).
+ *
+ * If namep is not NULL, *namep is set to the metafied programme
+ * name, which is in heap storage.
+ */
+/**/
+char *
+pathprog(char *prog, char **namep)
+{
+    char **pp, ppmaxlen = 0, *buf, *funmeta;
+    struct stat st;
+
+    for (pp = path; *pp; pp++)
+    {
+	int len = strlen(*pp);
+	if (len > ppmaxlen)
+	    ppmaxlen = len;
+    }
+    buf = zhalloc(ppmaxlen + strlen(prog) + 2);
+    for (pp = path; *pp; pp++) {
+	sprintf(buf, "%s/%s", *pp, prog);
+	funmeta = unmeta(buf);
+	if (access(funmeta, F_OK) == 0 &&
+	    stat(funmeta, &st) >= 0 &&
+	    !S_ISDIR(st.st_mode)) {
+	    if (namep)
+		*namep = buf;
+	    return funmeta;
+	}
+    }
+
+    return NULL;
+}
+
 /* get a symlink-free pathname for s relative to PWD */
 
 /**/

-- 
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

