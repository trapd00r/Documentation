From zsh-workers-return-16259-mason-zsh=primenet.com.au@sunsite.dk Fri Nov 16 16:34:49 2001
Return-Path: <zsh-workers-return-16259-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16138 invoked from network); 16 Nov 2001 16:34:48 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 16 Nov 2001 16:34:48 -0000
Received: (qmail 13954 invoked by alias); 16 Nov 2001 16:34:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16259
Received: (qmail 13943 invoked from network); 16 Nov 2001 16:34:36 -0000
X-VirusChecked: Checked
X-Authentication-Warning: iris.logica.co.uk: Host kiddleo@rambo.logica.co.uk [158.234.33.58] claimed to be yahoo.co.uk
Sender: kiddleo@iris.logica.co.uk
Message-ID: <3BF53F5B.4242835B@yahoo.co.uk>
Date: Fri, 16 Nov 2001 16:31:23 +0000
From: Oliver Kiddle <okiddle@yahoo.co.uk>
X-Mailer: Mozilla 4.77 [en] (X11; U; Linux 2.2.15 i686)
X-Accept-Language: en
MIME-Version: 1.0
To: zsh-workers@sunsite.dk
Subject: print -z/-s with -f
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

This is a patch for printf to use -s and -z with -f. I suspect the new
part for adding a history entry may be incomplete. There is some
problem with the prototype for open_memstream. And, I've not decided
whether or not I should be working around glibc's seg fault for big
widths. Any ideas on using mmap or setbuf to keep things in memory
where there isn't an open_memstream?

This probably isn't ready to be committed but I'm posting it now in
case anyone wants to clear up those issues. I'm off on holiday for a
couple of weeks and have been fairly busy so it'd be a little while
before I get around to properly fixing and testing this. 

Oliver

Note that much of the patch is blocks being moved or reindented.

Index: zshconfig.ac
===================================================================
RCS file: /cvsroot/zsh/zsh/zshconfig.ac,v
retrieving revision 1.21
diff -u -r1.21 zshconfig.ac
--- zshconfig.ac	2001/11/15 12:10:22	1.21
+++ zshconfig.ac	2001/11/16 16:24:19
@@ -939,7 +939,7 @@
 	       pathconf sysconf \
 	       tgetent tigetflag tigetnum tigetstr setupterm \
 	       pcre_compile pcre_study pcre_exec \
-	       erand48)
+	       erand48 open_memstream)
 AC_FUNC_STRCOLL
 
 dnl  Check if tgetent accepts NULL (and will allocate its own termcap buffer)
Index: Src/builtin.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/builtin.c,v
retrieving revision 1.62
diff -u -r1.62 builtin.c
--- Src/builtin.c	2001/11/09 16:47:45	1.62
+++ Src/builtin.c	2001/11/16 16:24:20
@@ -2895,10 +2895,11 @@
     int flen, width, prec, type, argc, n, narg;
     int nnl = 0, ret = 0, maxarg = 0;
     int flags[5], *len;
-    char *start, *endptr, *c, *d, *flag, spec[11], *fmt = NULL;
+    char *start, *endptr, *c, *d, *flag, *buf, spec[11], *fmt = NULL;
     char **first, *curarg, *flagch = "0+- #", save, nullstr = '\0';
-    zlong count;
+    size_t rcount, mcount, count = 0;
     FILE *fout = stdout;
+    Histent ent;
 
     mnumber mnumval;
     double doubleval;
@@ -2970,61 +2971,6 @@
 	}
     }
 
-    /* -o and -O -- sort the arguments */
-    if (ops['o']) {
-	if (fmt && !*args) return 0;
-	if (ops['i'])
-	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);
-	else
-	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
-    } else if (ops['O']) {
-	if (fmt && !*args) return 0;
-	if (ops['i'])
-	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);
-	else
-	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
-    }
-    /* after sorting arguments, recalculate lengths */
-    if(ops['o'] || ops['O'])
-	for(n = 0; n < argc; n++)
-	    len[n] = strlen(args[n]);
-
-    /* -z option -- push the arguments onto the editing buffer stack */
-    if (ops['z']) {
-	queue_signals();
-	zpushnode(bufstack, sepjoin(args, NULL, 0));
-	unqueue_signals();
-	return 0;
-    }
-    /* -s option -- add the arguments to the history list */
-    if (ops['s']) {
-	int nwords = 0, nlen, iwords;
-	char **pargs = args;
-	Histent ent;
-
-	queue_signals();
-	ent = prepnexthistent();
-	while (*pargs++)
-	    nwords++;
-	if ((ent->nwords = nwords)) {
-	    ent->words = (short *)zalloc(nwords*2*sizeof(short));
-	    nlen = iwords = 0;
-	    for (pargs = args; *pargs; pargs++) {
-		ent->words[iwords++] = nlen;
-		nlen += strlen(*pargs);
-		ent->words[iwords++] = nlen;
-		nlen++;
-	    }
-	} else
-	    ent->words = (short *)NULL;
-	ent->text = zjoin(args, ' ', 0);
-	ent->stim = ent->ftim = time(NULL);
-	ent->flags = 0;
-	addhistnode(histtab, ent->text, ent);
-	unqueue_signals();
-	return 0;
-    }
-
     /* -u and -p -- output to other than standard output */
     if (ops['u'] || ops['p']) {
 	int fd;
@@ -3047,6 +2993,25 @@
 	}
     }
 
+    /* -o and -O -- sort the arguments */
+    if (ops['o']) {
+	if (fmt && !*args) return 0;
+	if (ops['i'])
+	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);
+	else
+	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
+    } else if (ops['O']) {
+	if (fmt && !*args) return 0;
+	if (ops['i'])
+	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);
+	else
+	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
+    }
+    /* after sorting arguments, recalculate lengths */
+    if(ops['o'] || ops['O'])
+	for(n = 0; n < argc; n++)
+	    len[n] = strlen(args[n]);
+
     /* -c -- output in columns */
     if (ops['c']) {
 	int l, nc, nr, sc, n, t, i;
@@ -3081,6 +3046,41 @@
     
     /* normal output */
     if (!fmt) {
+	/* -z option -- push the arguments onto the editing buffer stack */
+	if (ops['z']) {
+	    queue_signals();
+	    zpushnode(bufstack, sepjoin(args, NULL, 0));
+	    unqueue_signals();
+	    return 0;
+	}
+	/* -s option -- add the arguments to the history list */
+	if (ops['s']) {
+	    int nwords = 0, nlen, iwords;
+	    char **pargs = args;
+
+	    queue_signals();
+	    ent = prepnexthistent();
+	    while (*pargs++)
+		nwords++;
+	    if ((ent->nwords = nwords)) {
+		ent->words = (short *)zalloc(nwords*2*sizeof(short));
+		nlen = iwords = 0;
+		for (pargs = args; *pargs; pargs++) {
+		    ent->words[iwords++] = nlen;
+		    nlen += strlen(*pargs);
+		    ent->words[iwords++] = nlen;
+		    nlen++;
+		}
+	    } else
+		ent->words = (short *)NULL;
+	    ent->text = zjoin(args, ' ', 0);
+	    ent->stim = ent->ftim = time(NULL);
+	    ent->flags = 0;
+	    addhistnode(histtab, ent->text, ent);
+	    unqueue_signals();
+	    return 0;
+	}
+
 	for (; *args; args++, len++) {
 	    fwrite(*args, *len, 1, fout);
 	    if (args[1])
@@ -3093,10 +3093,20 @@
 	return 0;
     }
     
+    if (ops['z'] || ops['s']) {
+#ifdef HAVE_OPEN_MEMSTREAM
+    	if ((fout = open_memstream(&buf, &mcount)) == NULL)
+	    zwarnnam(name, "open_memstream failed", NULL, 0);
+#else
+    	if ((fout = tmpfile()) == NULL)
+	    zwarnnam(name, "tmpfile failed", NULL, 0);
+#endif
+    } 
+    
     /* printf style output */
     *spec='%';
     do {
-    	count = 0;
+    	rcount = count;
     	if (maxarg) {
 	    first += maxarg;
 	    argc -= maxarg;
@@ -3265,7 +3275,7 @@
 		type=3;
 		break;
 	    case 'n':
-		if (curarg) setiparam(curarg, count);
+		if (curarg) setiparam(curarg, count - rcount);
 		break;
 	    default:
 	        if (*c) {
@@ -3339,6 +3349,31 @@
     /* if there are remaining args, reuse format string */
     } while (*args && args != first && !ops['r']);
 
+    if (ops['z'] || ops['s']) {
+#ifdef HAVE_OPEN_MEMSTREAM
+    	putc(0, fout);
+    	fflush(fout);
+	count = mcount;
+#else
+    	rewind(fout);
+	buf = (char *)zalloc(count + 1);
+	fread(buf, count, 1, fout);
+	buf[count] = '\0';
+#endif
+	queue_signals();
+	if (ops['z']) {
+	    zpushnode(bufstack, buf);
+	} else {
+	    ent = prepnexthistent();
+	    ent->text = buf;
+	    ent->stim = ent->ftim = time(NULL);
+	    ent->flags = 0;
+	    ent->words = (short *)NULL;
+	    addhistnode(histtab, ent->text, ent);
+	}
+	unqueue_signals();
+    }
+    
     if (fout != stdout)
 	fclose(fout);
     return ret;

_____________________________________________________________________
This message has been checked for all known viruses by the 
MessageLabs Virus Scanning Service. For further information visit
http://www.messagelabs.com/stats.asp

