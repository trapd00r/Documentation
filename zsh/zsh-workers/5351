From zsh-workers-return-5351-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Feb 12 09:56:26 1999
Return-Path: <zsh-workers-return-5351-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3191 invoked from network); 12 Feb 1999 09:56:25 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Feb 1999 09:56:24 -0000
Received: (qmail 3744 invoked by alias); 12 Feb 1999 09:55:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5351
Received: (qmail 3716 invoked from network); 12 Feb 1999 09:54:56 -0000
Date: Fri, 12 Feb 1999 10:54:11 +0100 (MET)
Message-Id: <199902120954.KAA08624@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Thu, 11 Feb 1999 18:08:34 +0100
Subject: Re: Tar file and Re: Bad interaction between -iprefix and -string


Peter Stephenson wrote:

>  I
> vaguely thought of some extension to allow binding of multiple keys at
> once by this, either
>   #key-array \e/ \M/ history-complete
> or perhaps better
>   #key-array history-complete \e/ \M/
> but I haven't done that here.

Neither have I, but sounds good.

The patch below at least puts that key-completion stuff in a separate
function (`defkeycomp') and makes it be used.

It also fixes `__main_key_complete' to work with the widget-name-is-
function-name style and it fixes `__find'.

Bye
 Sven

diff -u om/Completion/__find Misc/Completion/__find
--- om/Completion/__find	Fri Feb 12 10:23:45 1999
+++ Misc/Completion/__find	Fri Feb 12 10:46:21 1999
@@ -6,9 +6,9 @@
   compsub
 elif [[ -iprefix - ]]; then
   complist -s 'daystart {max,min,}depth follow noleaf version xdev \
-a,c,}newer {a,c,m}{min,time} empty false {fs,x,}type gid inum links \
-i,}{l,}name {no,}{user,group} path perm regex size true uid used \
-xec {f,}print{f,0,} ok prune ls'
+{a,c,}newer {a,c,m}{min,time} empty false {fs,x,}type gid inum links \
+{i,}{l,}name {no,}{user,group} path perm regex size true uid used \
+exec {f,}print{f,0,} ok prune ls'
   compreset
 elif [[ -position 1 ]]; then
   complist -g '. ..'
diff -u om/Completion/__main_key_complete Misc/Completion/__main_key_complete
--- om/Completion/__main_key_complete	Fri Feb 12 10:23:46 1999
+++ Misc/Completion/__main_key_complete	Fri Feb 12 10:39:01 1999
@@ -3,4 +3,4 @@
 # The widget name looks like `__complete_key_<num>' where <num> can be
 # used as an index into the `keycomps' array to get at the definition.
 
-callcomplete keycomps "$WIDGET[16,-1]" "$@"
+callcomplete keycomps "$WIDGET" "$@"
diff -u om/Completion/init Misc/Completion/init
--- om/Completion/init	Fri Feb 12 10:23:47 1999
+++ Misc/Completion/init	Fri Feb 12 10:44:11 1999
@@ -56,10 +56,11 @@
 # are the names of the command, the values are names of functions or variables
 # that are to be used to generate the matches.
 # Pattern completions will be stored in an normal array named `patcomps'.
-# Completion definitions bound directly to keys are store in an assoc array
+# Completion definitions bound directly to keys are stored in an assoc array
 # named `keycomps'.
 
 typeset -A comps
+typeset -A keycomps
 
 
 # This may be used to define completion handlers. The first argument is the
@@ -106,6 +107,30 @@
 }
 
 
+# This is used to define completion handlers directly bound to keys. The
+# first argument is as for `defcomp', giving the handler. The second argument
+# is a key-sequence usable fo `bindkey'. The third argument is the name of one
+# of the built-in completion widgets. Typing the given key sequence will
+# complete the word the cursor is on according to the completion definition
+# given and will behave as if the built-in completion widget was used.
+
+defkeycomp() {
+  local name
+
+  if [[ "$1" = -a ]]; then
+    shift
+    autoload "$1"
+    name="$1"
+  elif [[ "${1[1]}" = ' ' ]]; then
+    name="${1:t}"
+  else
+    name="$1"
+  fi
+  zle -C "$name" "$3" __main_key_complete
+  bindkey "$2" "$name"
+  keycomps[$name]="$1"
+}
+
 # These can be used to easily save and restore the state of the special
 # variables used by the completion code.
 
@@ -192,16 +217,9 @@
     elif [[ $line[1] = '#pattern-array' ]]; then
       defcomp " $file" "$line[2]"
     elif [[ $line[1] = '#key-function' ]]; then
-      (( ${+keycomps} )) || typeset -A keycomps
-      zle -C ${file:t} $line[3] __main_key_complete
-      bindkey "$line[2]" ${file:t}
-      autoload ${file:t}
-      keycomps[${file:t}]=${file:t}
+      defkeycomp -a "${file:t}" "$line[2]" "$line[3]"
     elif [[ $line[1] = '#key-array' ]]; then
-      (( ${+keycomps} )) || typeset -A keycomps
-      zle -C ${file:t} $line[3] __main_key_complete
-      bindkey "$line[2]" ${file:t}
-      keycomps[${file:t}]=" $file"
+      defkeycomp " $file" "$line[2]" "$line[3]"
     elif [[ $line[1] = '#helper' ]]; then
       autoload ${file:t}
     fi

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

