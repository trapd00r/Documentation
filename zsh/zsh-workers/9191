From zsh-workers-return-9191-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jan 04 09:10:49 2000
Return-Path: <zsh-workers-return-9191-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6350 invoked from network); 4 Jan 2000 09:10:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 4 Jan 2000 09:10:47 -0000
Received: (qmail 14497 invoked by alias); 4 Jan 2000 09:10:40 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9191
Received: (qmail 14489 invoked from network); 4 Jan 2000 09:10:39 -0000
Date: Tue, 4 Jan 2000 10:10:38 +0100 (MET)
Message-Id: <200001040910.KAA27330@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: `matcher' style


Dunno if this is considered interesting enough. Also, I don't know if
this isn't too complicated again (but it really isn't *that*
complicated, I think).

This adds the `matcher' style which is used for all tags used when
generating matches. It allows to give a -M string to use for those
matches. Note that this is not used for the default tag and can not be 
used to fully replace the $compmatchers array since that is already in 
use when the completion widget is called (and it allows this xor'ing
of matcher specs which can't be replaced by -M options).

To simplify the shell code side for this the patch makes compadd use
all -M options it gets, concatenating the specs for all of them.

What do you think: useful?

Bye
 Sven

P.S.: The first hunk at least should be used -- it removes an unused
      local in _default.

diff -u -r oldcompletion/Base/_default Completion/Base/_default
--- oldcompletion/Base/_default	Fri Dec 17 21:39:19 1999
+++ Completion/Base/_default	Wed Dec 29 22:23:09 1999
@@ -1,7 +1,5 @@
 #compdef -default-
 
-local expl
-
 # You can first try the `compctl's by uncommenting the `compcall' line
 # below.
 # This is without first (-T) and default (-D) completion. If you want
@@ -22,4 +20,4 @@
 # file name expansion after the =.  In that case, it's natural to
 # allow completion to handle file names after any equals sign.
 
-[[ -o magicequalsubst ]] && compset -P 1 '*=' && _files "$expl[@]"
+[[ -o magicequalsubst ]] && compset -P 1 '*=' && _files
diff -u -r oldcompletion/Core/_description Completion/Core/_description
--- oldcompletion/Core/_description	Fri Dec 17 21:39:20 1999
+++ Completion/Core/_description	Wed Dec 29 22:07:33 1999
@@ -1,9 +1,10 @@
 #autoload
 
-local name gropt format gname hidden hide
+local name gropt format gname hidden hide match
 
 gropt=(-J)
 hide=()
+match=()
 
 if [[ "$1" = -([12]|)[VJ] ]]; then
   gropt=("$1")
@@ -26,21 +27,23 @@
 fi
 zstyle -s ":completion${curcontext}:$1" group-name gname &&
     [[ -z "$gname" ]] && gname="$1"
+zstyle -s ":completion${curcontext}:$1" matcher match &&
+    match=(-M "${(q)match}")
 
 shift 2
 [[ -n "$format" ]] && zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
 
 if [[ -n "$gname" ]]; then
   if [[ -n "$format" ]]; then
-    eval "${name}=($hide $gropt ${(q)gname} -X \"${format}\")"
+    eval "${name}=($hide $match $gropt ${(q)gname} -X \"${format}\")"
   else
-    eval "${name}=($hide $gropt ${(q)gname})"
+    eval "${name}=($hide $match $gropt ${(q)gname})"
   fi
 else
   if [[ -n "$format" ]]; then
-    eval "${name}=($hide $gropt -default- -X \"${format}\")"
+    eval "${name}=($hide $match $gropt -default- -X \"${format}\")"
   else
-    eval "${name}=($hide $gropt -default-)"
+    eval "${name}=($hide $match $gropt -default-)"
   fi
 fi
 
diff -u -r oldcompletion/Core/_path_files Completion/Core/_path_files
--- oldcompletion/Core/_path_files	Fri Dec 17 21:39:20 1999
+++ Completion/Core/_path_files	Wed Dec 29 22:08:12 1999
@@ -84,6 +84,15 @@
   else
     _description files expl file
   fi
+  tmp1=$expl[(I)-M]
+  if (( tmp1 )); then
+    match="$match $expl[1+tmp1]"
+    if (( $#matcher )); then
+      matcher[2]="$matcher[2] $expl[1+tmp1]"
+    else
+      matcher=(-M "$expl[1+tmp1]")
+    fi
+  fi
 fi
 
 [[ -n "$tmp1" && $#addsfx -ne 0 ]] && addsfx[1]=-qS
diff -u -r olddoc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- olddoc/Zsh/compsys.yo	Fri Dec 17 21:38:52 1999
+++ Doc/Zsh/compsys.yo	Wed Dec 29 22:19:29 1999
@@ -949,6 +949,14 @@
 directory name used by a user placing web pages within their home
 area.
 )
+item(tt(matcher))(
+This style is tested for tags used when generating matches. Its value
+is used as an additional match specification to use when adding the
+matches as described in
+ifzman(the section `Matching Control' in zmanref(zshcompwid))\
+ifnzman(noderef(Matching Control))\
+.
+)
 item(tt(max-errors))(
 This is used by the tt(_approximate) and tt(_correct) completer functions
 to determine the maximum number of errors to accept. The completer will try
diff -u -r olddoc/Zsh/compwid.yo Doc/Zsh/compwid.yo
--- olddoc/Zsh/compwid.yo	Fri Dec 17 21:38:53 1999
+++ Doc/Zsh/compwid.yo	Thu Dec 30 19:24:45 1999
@@ -562,7 +562,9 @@
 )
 item(tt(-M) var(match-spec))(
 This gives local match specifications as described below in
-noderef(Matching Control).
+noderef(Matching Control). This option may be given more than once. In 
+this case all var(match-spec)s given are contaneted with speces
+between them to form the specification string to use.
 Note that they will only be used if the tt(-U) option is not given.
 )
 item(tt(-n))(
diff -u -r oldsrc/Zle/complete.c Src/Zle/complete.c
--- oldsrc/Zle/complete.c	Fri Dec 17 21:38:01 1999
+++ Src/Zle/complete.c	Wed Dec 29 21:29:49 1999
@@ -435,7 +435,7 @@
 bin_compadd(char *name, char **argv, char *ops, int func)
 {
     struct cadata dat;
-    char *p, **sp, *e, *m = NULL;
+    char *p, **sp, *e, *m = NULL, *mstr = NULL;
     int dm;
     Cmatcher match = NULL;
 
@@ -590,13 +590,21 @@
 		    zerrnam(name, e, NULL, *p);
 		    return 1;
 		}
-		if (dm && (match = parse_cmatcher(name, m)) == pcm_err) {
-		    match = NULL;
-		    return 1;
+		if (dm) {
+		    if (mstr)
+			mstr = tricat(mstr, " ", m);
+		    else
+			mstr = ztrdup(m);
 		}
 	    }
 	}
     }
+    if (mstr && (match = parse_cmatcher(name, mstr)) == pcm_err) {
+	zsfree(mstr);
+	return 1;
+    }
+    zsfree(mstr);
+
  ca_args:
 
     if (!*argv && !dat.group &&

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

