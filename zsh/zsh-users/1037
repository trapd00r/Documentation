From zsh-workers-request@math.gatech.edu Fri Sep 26 20:21:31 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 5792 invoked from network); 26 Sep 1997 20:21:29 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 26 Sep 1997 20:21:29 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id PAA27314;
	Fri, 26 Sep 1997 15:46:16 -0400 (EDT)
Resent-Date: Fri, 26 Sep 1997 15:45:30 -0400 (EDT)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <970926124554.ZM29418@candle.brasslantern.com>
Date: Fri, 26 Sep 1997 12:45:53 -0700
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: zsh-users@math.gatech.edu
Subject: compctl -Tx 'w[0,...] ...' ...
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"yRvz_3.0.Uf6.P31Bq"@math>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/1037
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

What's the difference between

	compctl ... -- foo

and

	compctl -Tx 'w[0,foo]' ...

??  Aside from the obvious fact that you can use multiple `compctl ...`
commands but only one `compctl -Tx ...`.

Take a look at this:

----------

newcompctl=(compctl -Tx $(compctl -L | while read -A stuff
  do
    case $stuff[0] in
    (compctl) echo -n '
' $stuff ;;
    (*) echo -n $stuff ;;
    esac
done | while read -A compctl
  do
    [[ $#compctl -eq 1 ]] && continue
    [[ "$compctl" = *\ -x\ * ]] && continue
    shift compctl
    case $compctl[1] in
    (-[CDT]*) ;;
    (*)
      command=${compctl[$#compctl]}
      case $command in
      (-) ;;
      (*)
        compctl[$#compctl]=
        echo "'w[0,$command]'" $compctl -
       ;;
      esac
     ;;
    esac
  done) "'n[1,=]'" -f)
compctl -L | while read -A stuff
  do
    case $stuff[0] in
    (compctl) echo -n '
' $stuff ;;
    (*) echo -n $stuff ;;
    esac
done | while read -A compctl
  do
    [[ $#compctl -eq 1 ]] && continue
    [[ "$compctl" = *\ -x\ * ]] && continue
    shift compctl
    case $compctl[1] in
    (-[CDT]*) ;;
    (*)
      command=${compctl[$#compctl]}
      case $command in
      (-) ;;
      (*)
        compctl + $command
       ;;
      esac
     ;;
    esac
  done
eval $newcompctl

----------

The above turns every compctl that doesn't use -x (because -x completions
can't be nested) into a single huge compctl -T.  (It could probably be
cleaned up a lot, especially the `stuff' loop for unfolding compctls that
happen to have embedded newlines e.g. in -k '(...)' lists.)

With some finagling, it ought to be possible to rewrite all the compctls
that use -x in a similar manner, eventually reducing the entire collection
of compctls (except for -C and -D) to one `compctl -T`.

Now you may be wondering, what's the point of all this?  Well, at first it
was just a desire to have something like compctl -T but that kicked in only
after everything else failed.  (You can almost get this with -D, but only
for commands that don't already have some other completion.)  Beyond that,
though, it suggests that there may be a lot of redundant functionality in
the completion code, which could without much effort be folded together.

Also, if you convert all your compctls to one big -T like that, then you
can replace 'w[0,string]' with 'W[0,pattern]' and get an effect that a few
persistent zsh-users have been requesting for some years: pattern matching
on the command name when defining a completion.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

