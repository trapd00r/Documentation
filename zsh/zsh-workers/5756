From zsh-workers-return-5756-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 11 15:17:22 1999
Return-Path: <zsh-workers-return-5756-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22084 invoked from network); 11 Mar 1999 15:17:21 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Mar 1999 15:17:21 -0000
Received: (qmail 7668 invoked by alias); 11 Mar 1999 13:07:09 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5756
Received: (qmail 7661 invoked from network); 11 Mar 1999 13:07:06 -0000
Date: Thu, 11 Mar 1999 14:06:57 +0100 (MET)
Message-Id: <199903111306.OAA00957@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: compstate[force_list]


I just stumbled over this again... Normally the completion code will
not autolist matches if they contain only one match. This makes sense
when doing normal completion, but with all the new stuff we can do now 
there should be a way to say if the list should be shown nonetheless.

So I added the key `force_list' to `compstate'. If it is set to any
non-empty string, the list will always be shown. I decided against
using `compstate[list]=always' because then the user would first have
to test if listing was requested. Using a different key for it makes
sure that one can set it without having to bother about that.

Bye
 Sven

diff -u os/Zle/comp.h Src/Zle/comp.h
--- os/Zle/comp.h	Wed Mar 10 10:49:45 1999
+++ Src/Zle/comp.h	Thu Mar 11 13:55:32 1999
@@ -311,11 +311,12 @@
 #define CP_QUOTING    (1 << 14)
 #define CP_RESTORE    (1 << 15)
 #define CP_LIST       (1 << 16)
-#define CP_INSERT     (1 << 17)
-#define CP_EXACT      (1 << 18)
-#define CP_EXACTSTR   (1 << 19)
-#define CP_PATMATCH   (1 << 20)
+#define CP_FORCELIST  (1 << 17)
+#define CP_INSERT     (1 << 18)
+#define CP_EXACT      (1 << 19)
+#define CP_EXACTSTR   (1 << 20)
+#define CP_PATMATCH   (1 << 21)
 
-#define CP_NUM              21
+#define CP_NUM              22
 
 #define CP_ALLMASK    ((1 << CP_NUM) - 1)
diff -u os/Zle/comp1.c Src/Zle/comp1.c
--- os/Zle/comp1.c	Wed Mar 10 10:49:45 1999
+++ Src/Zle/comp1.c	Thu Mar 11 13:13:05 1999
@@ -115,6 +115,7 @@
      *compquoting,
      *comprestore,
      *complist,
+     *compforcelist,
      *compinsert,
      *compexact,
      *compexactstr,
@@ -432,7 +433,7 @@
     compprefix = compsuffix = compiprefix = compmatcherstr = 
 	compcontext = compparameter = compredirect = compquote =
 	compquoting = comprestore = complist = compinsert =
-	compexact = compexactstr = comppatmatch = NULL;
+	compexact = compexactstr = comppatmatch = compforcelist = NULL;
     makecompparamsptr = NULL;
     comp_setunsetptr = NULL;
     return 0;
@@ -473,6 +474,7 @@
     zsfree(compquoting);
     zsfree(comprestore);
     zsfree(complist);
+    zsfree(compforcelist);
     zsfree(compinsert);
     zsfree(compexact);
     zsfree(compexactstr);
diff -u os/Zle/compctl.c Src/Zle/compctl.c
--- os/Zle/compctl.c	Wed Mar 10 10:49:45 1999
+++ Src/Zle/compctl.c	Thu Mar 11 13:12:30 1999
@@ -1864,6 +1864,7 @@
     { "quoting", PM_SCALAR, VAR(compquoting) },
     { "restore", PM_SCALAR, VAR(comprestore) },
     { "list", PM_SCALAR, VAR(complist) },
+    { "force_list", PM_SCALAR, VAR(compforcelist) },
     { "insert", PM_SCALAR, VAR(compinsert) },
     { "exact", PM_SCALAR, VAR(compexact) },
     { "exact_string", PM_SCALAR, VAR(compexactstr) },
diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Wed Mar 10 10:49:47 1999
+++ Src/Zle/zle_tricky.c	Thu Mar 11 13:55:34 1999
@@ -5029,6 +5029,8 @@
 		    (isset(LISTAMBIGUOUS) ? 3 : 2) : 0) : 1);
 	zsfree(comppatmatch);
 	comppatmatch = ztrdup(useglob ? "yes" : "");
+	zsfree(compforcelist);
+	compforcelist = ztrdup("");
 	haspattern = 0;
 
 	/* Make sure we have the completion list and compctl. */
@@ -5122,7 +5124,7 @@
 	comppms = (Param *) zalloc(CP_NUM * sizeof(Param));
 
 	set = -1 & ~(CP_PARAMETER | CP_REDIRECT | CP_QUOTE | CP_QUOTING |
-		     CP_EXACTSTR | (useglob ? 0 : CP_PATMATCH));
+		     CP_EXACTSTR | CP_FORCELIST | (useglob ? 0 : CP_PATMATCH));
 	zsfree(compcontext);
 	zsfree(compparameter);
 	zsfree(compredirect);
@@ -7416,7 +7418,8 @@
      * if it is needed.                                                     */
     if (isset(LISTBEEP))
 	feep();
-    if (uselist && usemenu != 2 && !showinglist && smatches >= 2)
+    if (uselist && usemenu != 2 && !showinglist &&
+	(smatches >= 2 || (compforcelist && *compforcelist)))
 	showinglist = -2;
 }
 
diff -u od/Zsh/compwid.yo Doc/Zsh/compwid.yo
--- od/Zsh/compwid.yo	Mon Mar  8 09:04:46 1999
+++ Doc/Zsh/compwid.yo	Thu Mar 11 13:57:50 1999
@@ -176,6 +176,12 @@
 it may be set to any of these values to make the completion code as if 
 the appropriate options had been set.
 )
+item(tt(force_list))(
+If the value for the tt(list) key is tt(ambiguous), the list will
+normally be shown only if there are at least two matches in the
+list. Setting tt(force_list) to an non-empty string makes the list be
+shown even if there is only one match.
+)
 item(tt(insert))(
 This will be unset by the completon code if the contents of the
 command line will not be changed. It is set to tt(unambiguous),

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

