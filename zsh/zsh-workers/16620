From zsh-workers-return-16620-mason-zsh=primenet.com.au@sunsite.dk Wed Feb 13 16:37:00 2002
Return-Path: <zsh-workers-return-16620-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2400 invoked from network); 13 Feb 2002 16:36:59 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 13 Feb 2002 16:36:59 -0000
Received: (qmail 4509 invoked by alias); 13 Feb 2002 16:36:53 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16620
Received: (qmail 4497 invoked from network); 13 Feb 2002 16:36:52 -0000
Message-ID: <20020213163650.19763.qmail@web9305.mail.yahoo.com>
Date: Wed, 13 Feb 2002 16:36:50 +0000 (GMT)
From: =?iso-8859-1?q?Oliver=20Kiddle?= <okiddle@yahoo.co.uk>
Subject: Re: Reverse the order of an array?
To: Derek Peschel <dpeschel@eskimo.com>, zsh-workers@sunsite.dk
In-Reply-To: <20020212051541.B10430@eskimo.eskimo.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: 8bit

Derek wrote:

> Eww, I don't like the idea of using ^.

Okay, that was a bad idea.

Bart wrote:

>
> > Allowing array slices to go backwards, is a possibility though I'd
not
> > be suprised if implementing it caused other things to break.
>
> Right now, using a backwards array slice references an imaginary
"empty
> element" to the left of the left end of the slice; assigning to that
> imaginary element makes it real.  E.g.:
>
> zsh% x=(a b c d e)
> zsh% x[4,2]=(y)
> zsh% echo $x
> a b c y d e
>
> This was motivated by desiring to have a syntax for inserting
elements
> into the array; "forwards" array slices only allow for replacement.

You could now also do that with x[3]+=(y) but I made use of the
existing code for inserting elements so it would be affected by such a
change to array slices. Also, if in the future we added support for
arrays of arrays, we'd need this syntax for something else.

> We could also use a subscripting flag (though that doesn't help with
r/R).

Yes. I can't think of any advantages to that over glob qualifiers
though.

> How about if (oa) means "sort in array index order" and (Oa) means
"sort
> in reverse array index order"?  There's precedent with (oi) and (Oi)
for
> case-insensitive sorting.  Obviously (oa) is equivalent to the
default,
> but so what?

That's a good idea. Patch below implements that.

Should we perhaps also add an argument to the `o' glob qualifier to
specify no sorting (i.e. pure directory order). If so, it should
perhaps be the same letter as here in which case `a' is not available.

Oliver

--- Src/subst.c Mon Jan  7 11:31:05 2002
+++ Src/subst.c       Tue Feb 12 21:06:15 2002
@@ -773,7 +773,7 @@
     Value v = NULL;
     int flags = 0;
     int flnum = 0;
-    int sortit = 0, casind = 0;
+    int sortit = 0, casind = 0, indord = 0;
     int unique = 0;
     int casmod = 0;
     int quotemod = 0, quotetype = 0, quoteerr = 0;
@@ -881,6 +881,9 @@
                case 'i':
                    casind = 1;
                    break;
+               case 'a':
+                   indord = 1;
+                   break;

                case 'V':
                    visiblemod++;
@@ -1894,16 +1897,29 @@
                zhuniqarray(aval);
        }
        if (sortit) {
-           static CompareFn sortfn[] = {
-               strpcmp, invstrpcmp, cstrpcmp, invcstrpcmp
-           };
-
            if (!copied)
                aval = arrdup(aval);
-
-           i = arrlen(aval);
-           if (i && (*aval[i-1] || --i))
-               qsort(aval, i, sizeof(char *), sortfn[sortit-1]);
+           if (indord) {
+               if (sortit & 2) {
+                   char *copy;
+                   char **end = aval + arrlen(aval) - 1, **start =
aval;
+
+                   /* reverse the array */
+                   while (start < end) {
+                       copy = *end;
+                       *end-- = *start;
+                       *start++ = copy;
+                   }
+               }
+           } else {
+               static CompareFn sortfn[] = {
+                   strpcmp, invstrpcmp, cstrpcmp, invcstrpcmp
+               };
+
+               i = arrlen(aval);
+               if (i && (*aval[i-1] || --i))
+                   qsort(aval, i, sizeof(char *), sortfn[sortit-1]);
+           }
        }
        if (plan9) {
            LinkNode tn;


__________________________________________________
Do You Yahoo!?
Everything you'll ever need on one web page
from News and Sport to Email and Music Charts
http://uk.my.yahoo.com

