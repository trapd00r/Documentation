### vim:ft=zsh:foldmethod=marker

### salias(): smart creation of sudo aliases
### This is based on the salias() function I wrote for the grml zshrc.
### However, I changed it again to work with older versions of zsh as well.
### Added -c option. Added -C option.
### Note, that this has _nothing_ to do with suffix aliases.
function salias() {
    local only=0 multi=0 check=0 chkcom=1 sudo_host=0
    local sudo_u sudo_us sudo_h i j key val mval
    if (( ${#argv} == 0 )) ; then
        printf 'salias(): Missing argument. Try salias -h for help.\n'
        return 1
    fi
    while [[ ${1} == -* ]] ; do
        case ${1} in
            (-o) only=1  ;;
            (-C) chkcom=0 ;;
            (-c) check=1 ;;
            (-a) multi=1 ;;
            (--) shift ; break ;;
            (-h)
                printf 'usage: salias [-h|-o|-a|-c|-C] <alias-expression>\n'
                printf '  -h      shows this help text.\n'
                printf '  -a      replace '\'' ; '\'' sequences with '\'' ; sudo '\''.\n'
                printf '          be careful using this option.\n'
                printf '  -o      only sets an alias if a preceding sudo would be needed.\n'
                printf '  -c      check $sudo_hosts[] array.\n'
                printf '  -C      don'\''t check if the command in the alias exists.\n'
                printf '          Use this if the command requires a special check, that.\n'
                printf '          check_com() cannot deal with.\n'
                return 0
                ;;
            (*) printf "unkown option: '%s'\n" "${1}" ; return 1 ;;
        esac
        shift
    done
    if (( check > 0 )) ; then
        for i in ${sudo_hosts} ; do
            sudo_u=${${(s:@:)i}[1]}
            sudo_us=(${(s:,:)sudo_u})
            sudo_h=${${(s:@:)i}[2]}
            if [[ ${sudo_h} == ${HOST} ]] ; then
                for j in ${sudo_us} ; do
                    if [[ ${USER:-${LOGNAME}} == ${j} ]] ; then
                        ### user and host matches, okay.
                        sudo_host=1
                        break;
                    fi
                done
                break;
            fi
        done
        (( sudo_host == 0 )) && return 0
    fi
    if (( ${#argv} > 1 )) ; then
        printf 'Too many arguments %s\n' "${#argv}"
        return 1
    fi
    ### create the alias
    key="${1%%\=*}" ;  val="${1#*\=}"
    if (( EUID == 0 )) && (( only == 0 )); then
        if (( chkcom > 0 )) ; then
            check_com ${val} || return 0
        fi
        alias -- "${key}=${val}"
    elif (( EUID > 0 )) ; then
        if (( multi > 0 )) ; then
            mval=(${(s, ; ,)val})
            if (( chkcom > 0 )) ; then
                check_com ${mval[1]} || return 0
            fi
            val="sudo ${mval[1]}"
            shift mval
            for i in ${mval} ; do
                if (( chkcom > 0 )) ; then
                    check_com ${i} || return 0
                fi
                val="${val} ; sudo ${i}"
            done
            alias -- "${key}=${val}"
        else
            if (( chkcom > 0 )) ; then
                check_com ${val} || return 0
            fi
            alias -- "${key}=sudo ${val}"
        fi
    fi
    return 0
}

### xalias(): check for executable, then create alias
### only supposed to be used with simple aliases.
function xalias() {
    local key val com
    if (( ${#argv} == 0 )) ; then
        printf 'xalias(): Missing argument.\n'
        return 1
    fi
    if (( ${#argv} > 1 )) ; then
        printf 'xalias(): Too many arguments %s\n' "${#argv}"
        return 1
    fi

    key="${1%%\=*}" ;  val="${1#*\=}"
    check_com ${val} && alias -- "${key}=${val}"
    return 0
}

### xhashd(): check for directory, then create hash -d
function xhashd() {
    local key val com
    if (( ${#argv} == 0 )) ; then
        printf 'xhashd(): Missing argument.\n'
        return 1
    fi
    if (( ${#argv} > 1 )) ; then
        printf 'xhashd(): Too many arguments %s\n' "${#argv}"
        return 1
    fi

    key="${1%%\=*}" ;  val="${1#*\=}"
    [[ -d ${val} ]] && hash -d -- "${key}=${val}"
    return 0
}

### zrcneedcomp(): check if rc needs recompilation
function zrcneedcomp() {
    local recomp
    local rc=${1:t}
    if [[ -z ${1} ]] ; then
        zprintf 0 "usage: ${0} <rcfile>\n"
        return 0
    fi
    if ! zis_317 "atleast" ; then
        zprintf 4 "  zrcneedcomp(): rccompilation needs at least zsh v3.1.7\n"
        return 0
    fi

    if [[ ! -e ${1}.zwc ]] ; then
        zprintf 3 "  zrcneedcomp(): ${rc}.zwc does not exist,\n    - marking for compilation.\n"
        return 1
    fi
    if [[ ${1} -nt ${1}.zwc ]] ; then
        zprintf 3 "  zrcneedcomp(): ${rc} is newer than ${rc}.zwc,\n"
        recomp=1
    elif ! zcompile -t ${1}.zwc >/dev/null 2>&1 ; then
        zprintf 3 "  zrcneedcomp(): ${rc}.zwc is compiled for different zsh version,\n"
        recomp=1
    fi
    if (( recomp > 0 )) ; then
        zprintf 3 "    - marking for recompilation.\n"
        return 2
    fi
    return 0
}

function zrc_cleanup() {
}
