From zsh-users-return-14994-mason-zsh=primenet.com.au@zsh.org Fri Apr 09 12:27:18 2010
Return-Path: <zsh-users-return-14994-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11819 invoked by alias); 9 Apr 2010 12:27:18 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14994
Received: (qmail 20804 invoked from network); 9 Apr 2010 12:27:16 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.1 required=5.0 tests=BAYES_00,RCVD_IN_SORBS_WEB
	autolearn=no version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at biskalar.de does not designate permitted sender hosts)
Subject: Re: Count only visible characters?
Mime-Version: 1.0 (Apple Message framework v1078)
Content-Type: text/plain; charset=us-ascii
From: Sebastian Stark <seb-zsh@biskalar.de>
In-Reply-To: <20100409130844.67ee0d5b@news01>
Date: Fri, 9 Apr 2010 14:27:10 +0200
Cc: zsh-users@zsh.org
Content-Transfer-Encoding: quoted-printable
Message-Id: <FAD787E6-22E8-4894-9FED-7D37F6FDABEC@biskalar.de>
References: <loom.20100409T002951-342@post.gmane.org> <201004091102.55291.joke@seiken.de> <87d3y90z07.fsf@ft.bewatermyfriend.org> <D623EAB5-E787-4381-9DB8-42C6E3C3FD1D@biskalar.de> <E9EE686F-6566-4827-B6D9-36BA86FA65A4@biskalar.de> <20100409130844.67ee0d5b@news01>
To: Peter Stephenson <pws@csr.com>
X-Mailer: Apple Mail (2.1078)


Am 09.04.2010 um 14:08 schrieb Peter Stephenson:

> On Fri, 9 Apr 2010 12:56:02 +0200
> Sebastian Stark <seb-zsh@biskalar.de> wrote:
>> print "${(%)a::=3D%F{green}hello}"
>> hello}
>> % print "${(%)a::=3D%F{green}hello"
>> hello
>>=20
>> Why does the first print statement print the closing brace? How can =
the
>> second print statement not produce an error?
>=20
> ${...} doesn't attempt to balance braces internally, so the first } =
brings
> it to an end.  The final quoted "}" is then just an ordinary =
character.

ok, good to know.

> You're being a bit too clever for your own good here by trying to too =
much
> at once.  If you separate out the assignment from the use it'll work.
> If you absolutely have to do it this way, however, quoting the text =
you
> want to be treated as a string by the parameter expansion works.
>=20
> print "${(%)a::=3D"%F{green}hello"}"
>=20
> The outer double quotes are now overloaded too many times to be able =
to
> tell this is what you mean: see a recent post by Bart for a reference =
to a
> discussion on the standards mailing list about trouble with double =
quotes.

The expression works as I expect when I leave out all the double quotes. =
I didn't think those were the problem.

> I'm not sure you actually want the outer double quotes at all, but I'm =
not
> sure what you're trying to do (and it probably doesn't matter for this
> particular issue).

Sometimes I want to use expansions that are only available as prompt =
expansions. It's a bit cumbersome having to assign them to a variable =
first and then evaluate it with the %-modifier. One example would be a =
condition that checks wether a background job is running:

  if ((${(%):-%j}))
  then
    print "no reexec because background job is running"
    return $E_JOB
  fi

In this example the above is not an issue. But it could appear in other =
contexts, when using "inline prompt expansion" in print statements. I =
admit this is a bit esoteric, but still worth mentioning.=

