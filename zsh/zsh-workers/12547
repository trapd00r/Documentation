From zsh-workers-return-12547-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Aug 05 05:51:59 2000
Return-Path: <zsh-workers-return-12547-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2468 invoked from network); 5 Aug 2000 05:51:57 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 5 Aug 2000 05:51:57 -0000
Received: (qmail 13347 invoked by alias); 5 Aug 2000 05:51:48 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12547
Received: (qmail 13340 invoked from network); 5 Aug 2000 05:51:47 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000805055142.ZM11497@candle.brasslantern.com>
Date: Sat, 5 Aug 2000 05:51:42 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: Handle ENOENT/ENOTDIR in zpathmax()
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

When I commit this, I'm going to also back out 12541 and 12533.

Index: Src/compat.c
===================================================================
@@ -118,21 +118,52 @@
  * some other flag value) in order to determine that the resource is *
  * unlimited.  What use is leaving errno unchanged?  Instead, define *
  * a wrapper that resets errno to 0 and returns 0 for "the system    *
- * does not have a limit."                                           *
+ * does not have a limit," so that -1 always means a real error.     *
  *                                                                   *
- * This is replaced by a macro from system.h if not HAVE_PATHCONF.   */
+ * This is replaced by a macro from system.h if not HAVE_PATHCONF.   *
+ *
+ * Note that the length of a relative path is compared without first *
+ * prepending the current directory, if pathconf() does not return   *
+ * an error.  This is for consistency with the macro and with older  *
+ * zsh behavior; it may be problematic in the ENOENT/ENOTDIR cases.  */
 
 /**/
 mod_export long
 zpathmax(char *dir)
 {
     long pathmax;
+
+    if (!dir || !*dir)
+	dir = ".";
     errno = 0;
     if ((pathmax = pathconf(dir, _PC_PATH_MAX)) >= 0) {
+	/* This code is redundant if pathconf works correctly, but   *
+	 * some versions of glibc pathconf return a hardwired value. */
 	if (strlen(dir) < pathmax)
 	    return pathmax;
 	else
 	    errno = ENAMETOOLONG;
+    } else if (errno == ENOENT || errno == ENOTDIR) {
+	/* Work backward to find a directory, until we run out of path. */
+	char *tail = strrchr(dir, '/');
+	while (tail > dir && tail[-1] == '/')
+	    --tail;
+	if (tail > dir) {
+	    *tail = 0;
+	    pathmax = zpathmax(dir);
+	    *tail = '/';
+	    if (pathmax > 0) {
+		if (strlen(dir) < pathmax)
+		    return pathmax;
+		else
+		    errno = ENAMETOOLONG;
+	    }
+	}
+	/* else                                                          *
+	 * Either we're at the root (tail == dir) or we're on the first  *
+	 * component of a relative path (tail == NULL).  Either way we   *
+	 * have nothing to do here, the error from pathconf() is real.   *
+	 * Perhaps our current working directory has been removed?       */
     }
     if (errno)
 	return -1;

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

