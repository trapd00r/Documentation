Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Fri, 5 Feb 1999 10:51:19 +0100 (MET)
Message-Id: <199902050951.KAA19647@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Thu, 04 Feb 1999 15:12:57 +0100
Subject: Re: PATCH: zsh-3.1.5-pws-6: bash-style completion
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5270


Here is the comment on completion-matching and cursor-positioning.

Peter Stephenson wrote:

> % zsh -f
> % compctl -M 'm:{a-z}={A-Z}' 'r:|[.,_-]=* r:|=*'
> % echo z<TAB>
>        ^cursor is now over the z.

In a certain sense, this is correct. The matching code has to deal
with to possible differences between what was on the line and the
matches: character differencs and substrings that appear in the
match(es), but not on the line. The rule used is to position the
cursor preferably at a position where characters are missing and, if
there are no such places, to position the cursor on the first
character difference so that the user can type ^D, insert the wanted
character and type tab. My patch that `fixed' this places the cursor
after the first differing character (so that backspace-char-tab can be 
used, which is easy enough to type, too).

Now, some people may already have noticed that the code that inserts
this unambiguous string into the command line isn't very powerful. To
be more exact: it has problems with those parts of the matches that
differ from match to match and that don't have a corresponding part
typed by the user. Examples:

- With -M 'm:{a-z}={A-Z}' completing an empty prefix with the two 
  possible matches `Foobar' and `foobaz' the code should insert
  `fooba' with the cursor after it. With possible matches `Foobar' and
  `foobar' it should insert `foobar' with the cursor after
  (previously: on) the `f'. This could be done by checking if a match
  matches all the other matches. Doing this fast enough is already not 
  that easy.
- This also wouldn't help much. Consider the same match specification
  with the matches `Foobar' and `fooBar'. Here the code would have to
  check parts of matches against each other. Doing so with no hint
  where these parts are (i.e. chunks of characters that should be tested
  as groups), is already quite complicated.
- This gets worse if there are match specifications with different
  lengths for the line/word-patterns. With -M 'm:{a-z}={A-Z} m:ß=SS'
  and the matches `MASSE' and `Maße' we would want `Maße' to be inserted.
- All these examples were `simple' in the sense that the parts of the
  string to insert appeared in the matches, but this need not be. With
  -M 'm:{a-z}={A-Z} m:{aou}e={äöü}' and the matches `MUEHE' and `Mühe' 
  we'd like to have `Muehe' inserted where the `ue' was derived only
  from looking at the matching specification. (And in a German
  language environment a matching specification like the one given may 
  really be used - for `ä' you need to type four keys.)

Of course all this can be intermixed with partial word completion etc.

So, I'll have to think about all this some more to find out what can
be done without too much effort and without being too slow. I'll be
gratefull for every opinion, suggestion, and comment I'll get about
all this.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

