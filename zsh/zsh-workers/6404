From zsh-workers-return-6404-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jun 01 04:50:33 1999
Return-Path: <zsh-workers-return-6404-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17518 invoked from network); 1 Jun 1999 04:50:32 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 1 Jun 1999 04:50:32 -0000
Received: (qmail 25318 invoked by alias); 1 Jun 1999 04:50:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6404
Received: (qmail 25306 invoked from network); 1 Jun 1999 04:50:20 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <990601045015.ZM9744@candle.brasslantern.com>
Date: Tue, 1 Jun 1999 04:50:15 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: Singleton arrays treated as scalars (redux)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

I think I've figured out why paramsubst() converts one-element arrays into
scalars.  Consider the case where zsh needs to expand

	some${param}thing

When param is a scalar, it simply concatenates "some" and "thing" with the
value, and then performs globsubst if necessary.

When param is an array of two or more elements, it concatenates "some" with
the first element and globsubsts, does globsubst on any internal elements,
and finally concatenates the last element with "thing" and does one last
globsubst on that.

The one-element array case can't be handled like the two-or-more case; it
must be handled like the scalar case.  So zsh does the simplest thing, and
turns the array into a scalar so that it will take that code branch.  This
also prevents it from attempting plan9 (rcexpandparam) concatenation when
there is only one element.

I think mult_isarr is being assigned from isarr early enough that this is
no longer an issue in 3.1.5, and as far as I can tell it's never been an
issue in 3.0.5 (that is, new 3.1.5-pws-* code is what brought all this up;
if someone has a counter-example please tell me).

However, there's one spot where I think mult_isarr is not correctly set,
and another spot where isarr is compared to 2 even though in that branch
it can't possibly have any value other than 0.  Patch appended, someone
please check it for sanity.

Index: Src/subst.c
@@ -1484,6 +1484,10 @@
 	val = dupstring("");
 	isarr = 0;
     } else if (isarr && aval && aval[0] && !aval[1]) {
+	/* treat a one-element array as a scalar for purposes of   *
+	 * concatenation with surrounding text (some${param}thing) *
+	 * and rc_expand_param handling.  Note: mult_isarr (above) *
+	 * propagates the true array type from nested expansions.  */
 	val = aval[0];
 	isarr = 0;
     }
@@ -1500,8 +1504,8 @@
 		val = aval[0];
 	    else
 		isarr = 2;
-	    mult_isarr = isarr;
 	}
+	mult_isarr = isarr;
     }
     if (casmod) {
 	if (isarr) {
@@ -1665,7 +1669,7 @@
 	    return NULL;
 	xlen = strlen(x);
 	*str = strcatsub(&y, ostr, aptr, x, xlen, fstr, globsubst);
-	if (qt && !*y && isarr != 2)
+	if (qt && !*y)
 	    y = dupstring(nulstring);
 	setdata(n, (void *) y);
     }

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

