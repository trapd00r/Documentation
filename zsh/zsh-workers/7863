From zsh-workers-return-7863-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Sep 16 12:16:11 1999
Return-Path: <zsh-workers-return-7863-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3563 invoked from network); 16 Sep 1999 12:16:09 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Sep 1999 12:16:09 -0000
Received: (qmail 26356 invoked by alias); 16 Sep 1999 12:15:59 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7863
Received: (qmail 26349 invoked from network); 16 Sep 1999 12:15:59 -0000
Date: Thu, 16 Sep 1999 14:15:48 +0200 (MET DST)
Message-Id: <199909161215.OAA01103@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: parameter module


This adds the `dirstack' and `modules' special parameters. The first
one is a normal array containing the directory stack entries. The
latter is more interesting. It's an assoc array with the names of
modules as keys. The values are `builtin', `loaded', and
`autoloaded'. So we could use tests like `if (( $+modules[stat] )) ...'
to find out if a module is in some way usable (even if it still needs
to be loaded). I could easily change the value from the simple
`autoloaded' to a string containing descriptions of the things on
which the module would be autoloaded. I'd like to hear if you think
this is useful enough to implement (and suggestions for the syntax if
you have any).

Also I wanted to ask (before 3.1.6 was released, actually) if the
special parameters from the `parameter' module should be renamed to
`z*'. Or is it too late now?

Ok, if anyone has other ideas for what could be made accessible in the 
module, let me know (the only other thing I could think of are the
limits, but I'm not sure if that's worth it).

Oh, and none of this is used in the completion functions, yet.

Bye
 Sven

diff -u od/Zsh/mod_parameter.yo Doc/Zsh/mod_parameter.yo
--- od/Zsh/mod_parameter.yo	Thu Sep 16 07:31:12 1999
+++ Doc/Zsh/mod_parameter.yo	Thu Sep 16 10:40:15 1999
@@ -46,4 +46,19 @@
 .
 Setting or unsetting keys in this array is not possible.
 )
+vindex(modules)
+item(tt(modules))(
+An association giving information about module. The keys are the names
+of the modules builtin, loaded, or registered to be autoloaded. The
+value says which state the named module is in and is one of the
+strings tt(builtin), tt(loaded), or tt(autoloaded).
+
+Setting or unsetting keys in this array is not possible.
+)
+vindex(dirstack)
+item(tt(dirstack))(
+A normal array holding the elements of the directory stack. Note that
+the output of the tt(dirs) builtin command includes one more
+directory, the current working directory.
+)
 enditem()
diff -u -r os/Modules/parameter.c Src/Modules/parameter.c
--- os/Modules/parameter.c	Thu Sep 16 10:46:37 1999
+++ Src/Modules/parameter.c	Thu Sep 16 10:27:56 1999
@@ -596,14 +596,216 @@
 	}
 }
 
+/* Functions for the modules special parameter. */
+
+static char *modpmname;
+static int modpmfound;
+
+/**/
+static void
+modpmbuiltinscan(HashNode hn, int dummy)
+{
+    if (!(((Builtin) hn)->flags & BINF_ADDED) &&
+	!strcmp(((Builtin) hn)->optstr, modpmname))
+	modpmfound = 1;
+}
+
+/**/
+static void
+modpmparamscan(HashNode hn, int dummy)
+{
+    if ((((Param) hn)->flags & PM_AUTOLOAD) &&
+	!strcmp(((Param) hn)->u.str, modpmname))
+	modpmfound = 1;
+}
+
+/**/
+static int
+findmodnode(LinkList l, char *nam)
+{
+    LinkNode node;
+
+    for (node = firstnode(l); node; incnode(node))
+	if (!strcmp(nam, (char *) getdata(node)))
+	    return 1;
+
+    return 0;
+}
+
+/**/
+static HashNode
+getpmmodule(HashTable ht, char *name)
+{
+    Param pm = NULL;
+    char *type = NULL;
+    LinkNode node;
+
+    HEAPALLOC {
+	pm = (Param) zhalloc(sizeof(struct param));
+	pm->nam = dupstring(name);
+	pm->flags = PM_SCALAR | PM_READONLY;
+	pm->sets.cfn = NULL;
+	pm->gets.cfn = strgetfn;
+	pm->unsetfn = NULL;
+	pm->ct = 0;
+	pm->env = NULL;
+	pm->ename = NULL;
+	pm->old = NULL;
+	pm->level = 0;
+
+	for (node = firstnode(bltinmodules); node; incnode(node))
+	    if (!strcmp(name, (char *) getdata(node))) {
+		type = "builtin";
+		break;
+	    }
+#ifdef DYNAMIC
+	if (!type) {
+	    Module m;
+
+	    for (node = firstnode(modules); node; incnode(node)) {
+		m = (Module) getdata(node);
+		if (m->handle && !(m->flags & MOD_UNLOAD) &&
+		    !strcmp(name, m->nam)) {
+		    type = "loaded";
+		    break;
+		}
+	    }
+	}
+	modpmname = name;
+	modpmfound = 0;
+	if (!type) {
+	    scanhashtable(builtintab, 0, 0, 0, modpmbuiltinscan, 0);
+	    if (!modpmfound) {
+		Conddef p;
+
+		for (p = condtab; p; p = p->next)
+		    if (p->module && !strcmp(name, p->module)) {
+			modpmfound = 1;
+			break;
+		    }
+		if (!modpmfound)
+		    scanhashtable(realparamtab, 0, 0, 0, modpmparamscan, 0);
+	    }
+	    if (modpmfound)
+		type = "autoloaded";
+	}
+#endif
+	if (type)
+	    pm->u.str = type;
+	else {
+	    pm->u.str = "";
+	    pm->flags |= PM_UNSET;
+	}
+    } LASTALLOC;
+
+    return (HashNode) pm;
+}
+
+/**/
+static void
+scanpmmodules(HashTable ht, ScanFunc func, int flags)
+{
+    struct param pm;
+    int i;
+    HashNode hn;
+    LinkList done = newlinklist();
+    LinkNode node;
+    Module m;
+    Conddef p;
+
+    pm.flags = PM_SCALAR | PM_READONLY;
+    pm.sets.cfn = NULL;
+    pm.gets.cfn = strgetfn;
+    pm.unsetfn = NULL;
+    pm.ct = 0;
+    pm.env = NULL;
+    pm.ename = NULL;
+    pm.old = NULL;
+    pm.level = 0;
+
+    for (node = firstnode(bltinmodules); node; incnode(node)) {
+	pm.nam = (char *) getdata(node);
+	addlinknode(done, pm.nam);
+	pm.u.str = "builtin";
+	func((HashNode) &pm, flags);
+    }
+#ifdef DYNAMIC
+    for (node = firstnode(modules); node; incnode(node)) {
+	m = (Module) getdata(node);
+	if (m->handle && !(m->flags & MOD_UNLOAD)) {
+	    pm.nam = m->nam;
+	    addlinknode(done, pm.nam);
+	    pm.u.str = "loaded";
+	    func((HashNode) &pm, flags);
+	}
+    }
+    for (i = 0; i < builtintab->hsize; i++)
+	for (hn = builtintab->nodes[i]; hn; hn = hn->next) {
+	    if (!(((Builtin) hn)->flags & BINF_ADDED) &&
+		!findmodnode(done, ((Builtin) hn)->optstr)) {
+		pm.nam = ((Builtin) hn)->optstr;
+		addlinknode(done, pm.nam);
+		pm.u.str = "autoloaded";
+		func((HashNode) &pm, flags);
+	    }
+	}
+    for (p = condtab; p; p = p->next)
+	if (p->module && !findmodnode(done, p->module)) {
+	    pm.nam = p->module;
+	    addlinknode(done, pm.nam);
+	    pm.u.str = "autoloaded";
+	    func((HashNode) &pm, flags);
+	}
+    for (i = 0; i < realparamtab->hsize; i++)
+	for (hn = realparamtab->nodes[i]; hn; hn = hn->next) {
+	    if ((((Param) hn)->flags & PM_AUTOLOAD) &&
+		!findmodnode(done, ((Param) hn)->u.str)) {
+		pm.nam = ((Param) hn)->u.str;
+		addlinknode(done, pm.nam);
+		pm.u.str = "autoloaded";
+		func((HashNode) &pm, flags);
+	    }
+	}
+#endif
+}
+
+/* Functions for the dirstack special parameter. */
+
+static void
+dirssetfn(Param pm, char **x)
+{
+    PERMALLOC {
+	freelinklist(dirstack, freestr);
+	dirstack = newlinklist();
+	while (*x)
+	    addlinknode(dirstack, ztrdup(*x++));
+    } LASTALLOC;
+}
+
+static char **
+dirsgetfn(Param pm)
+{
+    int l = countlinknodes(dirstack);
+    char **ret = (char **) zhalloc((l + 1) * sizeof(char *)), **p;
+    LinkNode n;
+
+    for (n = firstnode(dirstack), p = ret; n; incnode(n), p++)
+	*p = dupstring((char *) getdata(n));
+    *p = NULL;
+
+    return ret;
+}
+
 /* Names and Params for the special parameters. */
 
 #define PAR_NAM "parameters"
 #define CMD_NAM "commands"
 #define FUN_NAM "functions"
 #define OPT_NAM "options"
+#define MOD_NAM "modules"
+#define DIR_NAM "dirstack"
 
-static Param parpm, cmdpm, funpm, optpm;
+static Param parpm, cmdpm, funpm, optpm, modpm, dirpm;
 
 /**/
 int
@@ -618,7 +820,7 @@
 {
     /* Create the special associative arrays.
      * As an example for autoloaded parameters, this is probably a bad
-     * example, because we the zsh core doesn't support creation of
+     * example, because the zsh core doesn't support creation of
      * special hashes, yet. */
 
     unsetparam(PAR_NAM);
@@ -641,6 +843,18 @@
 				    scanpmoptions)))
 	return 1;
     optpm->sets.hfn = setpmoptions;
+    unsetparam(MOD_NAM);
+    if (!(modpm = createspecialhash(MOD_NAM, getpmmodule,
+				    scanpmmodules)))
+	return 1;
+    modpm->flags |= PM_READONLY;
+    unsetparam(DIR_NAM);
+    if (!(dirpm = createparam(DIR_NAM,
+			      PM_ARRAY|PM_HIDE|PM_SPECIAL|PM_REMOVABLE)))
+	return 1;
+    dirpm->sets.afn = dirssetfn;
+    dirpm->gets.afn = dirsgetfn;
+    dirpm->unsetfn = stdunsetfn;
 
     return 0;
 }
@@ -664,6 +878,12 @@
     if ((pm = (Param) paramtab->getnode(paramtab, FUN_NAM)) && pm == funpm)
 	unsetparam_pm(pm, 0, 1);
     if ((pm = (Param) paramtab->getnode(paramtab, OPT_NAM)) && pm == optpm)
+	unsetparam_pm(pm, 0, 1);
+    if ((pm = (Param) paramtab->getnode(paramtab, MOD_NAM)) && pm == modpm) {
+	pm->flags &= ~PM_READONLY;
+	unsetparam_pm(pm, 0, 1);
+    }
+    if ((pm = (Param) paramtab->getnode(paramtab, DIR_NAM)) && pm == dirpm)
 	unsetparam_pm(pm, 0, 1);
     return 0;
 }
diff -u -r os/Modules/parameter.mdd Src/Modules/parameter.mdd
--- os/Modules/parameter.mdd	Thu Sep 16 10:46:42 1999
+++ Src/Modules/parameter.mdd	Thu Sep 16 10:47:02 1999
@@ -1,3 +1,3 @@
-autoparams="parameters commands functions options"
+autoparams="parameters commands functions options modules dirstack"
 
 objects="parameter.o"

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

