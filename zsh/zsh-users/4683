From zsh-users-return-4683-mason-zsh=primenet.com.au@sunsite.dk Wed Feb 20 22:13:25 2002
Return-Path: <zsh-users-return-4683-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22419 invoked from network); 20 Feb 2002 22:13:25 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 20 Feb 2002 22:13:25 -0000
Received: (qmail 5152 invoked by alias); 20 Feb 2002 22:13:06 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4683
Received: (qmail 5130 invoked from network); 20 Feb 2002 22:13:03 -0000
Date: Wed, 20 Feb 2002 15:12:56 -0700
From: Steve Talley <stephen.talley@sun.com>
To: Ian Lynagh <igloo@earth.li>
Cc: zsh-users@sunsite.dk
Subject: Re: vim-a-like vi mode status bar
Message-ID: <20020220151256.I26794@thpppt>
References: <20020216172000.GA892@stu163.keble.ox.ac.uk>
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="4bRzO86E/ozDv8r1"
Content-Disposition: inline
User-Agent: Mutt/1.2.5i
In-Reply-To: <20020216172000.GA892@stu163.keble.ox.ac.uk>; from igloo@earth.li on Sat, Feb 16, 2002 at 05:20:00PM +0000


--4bRzO86E/ozDv8r1
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

I have a mode line that appears below the command line (attached).  It
has a bug here and there, but is fairly solid and pretty simple.

Steve

Ian Lynagh wrote:

> Hi all
>
> I have thought it would be nice to have a vim-a-like indicator of
> whether or not you are insert or command mode when using the vi line
> editting mode for a long time now. In a burst of enthusiasm I have
> put something together over the last couple of days (attached).
> However it's not quite as nice as it might have been and I have run
> into a few annoyances along the way.
>
> Initially I was planning to have the indicator in the prompt.
> However AFAICT once the prompt has been displayed it is cached, so
> even if you for zsh to redraw it (I tried various things like "zle
> redisplay", "zle push-input; zle get-line", "zle -R") it just
> redraws the old one. Did I miss a way to do this?
>
> Is there a reason why it shouldn't be possible to pipe something
> into source? Or another way to do it without a temporary file?
>
> With the script attached, if I paste a command in then only the
> first character is visible until I press ^R. If I type something
> else first then it works fine (even if I first delete what I
> typed!). Perhaps this is a bug?
>
> I also couldn't find a way to set the statusbar after accepting a
> command. zsh -M complains it's not being called from a widget if I
> call it from precmd.
>
> Finally I would welcome any comments/criticisms on the code!
>
> Thanks Ian

--4bRzO86E/ozDv8r1
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename=zshmode

#
# Set vi mode status bar
#

#
# Reads until the given character has been entered.
#
readuntil () {
    typeset a
    while [ "$a" != "$1" ]
    do
        read -E -k 1 a
    done
}

#
# If the $SHOWMODE variable is set, displays the vi mode, specified by
# the $VIMODE variable, under the current command line.
# 
# Arguments:
#
#   1 (optional): Beyond normal calculations, the number of additional
#   lines to move down before printing the mode.  Defaults to zero.
#
showmode() {
    typeset movedown
    typeset row

    # Get number of lines down to print mode
    movedown=$(($(echo "$RBUFFER" | wc -l) + ${1:-0}))
    
    # Get current row position
    echo -n "\e[6n"
    row="${${$(readuntil R)#*\[}%;*}"
    
    # Are we at the bottom of the terminal?
    if [ $((row+movedown)) -gt "$LINES" ]
    then
        # Scroll terminal up one line
        echo -n "\e[1S"
        
        # Move cursor up one line
        echo -n "\e[1A"
    fi
    
    # Save cursor position
    echo -n "\e[s"
    
    # Move cursor to start of line $movedown lines down
    echo -n "\e[$movedown;E"
    
    # Change font attributes
    echo -n "\e[1m"
    
    # Has a mode been set?
    if [ -n "$VIMODE" ]
    then
        # Print mode line
        echo -n "-- $VIMODE -- "
    else
        # Clear mode line
        echo -n "\e[0K"
    fi

    # Restore font
    echo -n "\e[0m"
    
    # Restore cursor position
    echo -n "\e[u"
}

clearmode() {
    VIMODE= showmode
}

#
# Temporary function to extend built-in widgets to display mode.
#
#   1: The name of the widget.
#
#   2: The mode string.
#
#   3 (optional): Beyond normal calculations, the number of additional
#   lines to move down before printing the mode.  Defaults to zero.
#
makemodal () {
    # Create new function
    eval "$1() { zle .'$1'; ${2:+VIMODE='$2'}; showmode $3 }"

    # Create new widget
    zle -N "$1"
}

# Extend widgets
makemodal vi-add-eol           INSERT
makemodal vi-add-next          INSERT
makemodal vi-change            INSERT
makemodal vi-change-eol        INSERT
makemodal vi-change-whole-line INSERT
makemodal vi-insert            INSERT
makemodal vi-insert-bol        INSERT
makemodal vi-open-line-above   INSERT
makemodal vi-substitute        INSERT
makemodal vi-open-line-below   INSERT 1
makemodal vi-replace           REPLACE
makemodal vi-cmd-mode          NORMAL

unfunction makemodal

--4bRzO86E/ozDv8r1--

