From zsh-workers-return-10632-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Apr 11 07:55:26 2000
Return-Path: <zsh-workers-return-10632-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2530 invoked from network); 11 Apr 2000 07:55:17 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Apr 2000 07:55:17 -0000
Received: (qmail 9424 invoked by alias); 11 Apr 2000 07:54:58 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10632
Received: (qmail 9403 invoked from network); 11 Apr 2000 07:54:56 -0000
Date: Tue, 11 Apr 2000 09:54:53 +0200 (MET DST)
Message-Id: <200004110754.JAA03928@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Mon, 10 Apr 2000 15:24:56 +0200
	(MET DST)
Subject: PATCH: Re: 3.1.6-dev-22


I wrote:

> > As for my todo-list: only bug-fixing, the file-patterns stuff Peter
> > has just `suggested' (or complained about if you prefer) and the
> > function-moving-around which will happen before the final release, I
> > think. Oh, and removing compconf().
> 
> After reading a bit in the guide...
> 
> We might have to change _wanted so that it does the real tag-loop,
> too, not only the label-loop. That would make
> 
>   zstyle ':completion:*:*:foo:*' tag-order bar:baz bar
> 
> work everywhere. But it would require changing some of the completion
> functions that use `_wanted ... && ...' and the like, but the fact
> that the above sometimes isn't possible is just too confusing. I just
> hadn't though of such a tag-order value.

Here is the patch. That's it. No more stuff for the basic completion
machinery apart from bug fixes. At least for me. At least for quite
some time (as in: not before the next non-beta release).


Most of this patch does the change to _wanted, but there are two other 
things:

- The change to file-patterns suggested by Peter (I planned to send
  this in a separate patch and then accidentally overwrote it, sorry).
  I.e. it looks a bit more like tags-order, one can do:

    ... file-patterns '*.o:obj-files *(-/):dirs' ...

  Giving more than one pattern per string, with different tags. Small
  problem: one can still give more than one pattern per tag -- and has 
  to separate them with commas. I don't like that, it's different from 
  every other separation character we have. But the `(..|..)' I was
  thinking of doesn't work, of course, because of possible qualifiers
  in the patterns. No doubt all of you knew that when I was talking
  about it... Bummer. Does anyone see a better syntax?

- This has to do with tags, too: _next_tags now should work correctly
  with labels. I.e. with

    ... tag-order foo:-bar foo:-baz

  _next_tags will first use foo-bar, as usual and then switches to
  foo-baz. Before it was excluding tags, not labels.
  One thing I don't understand is why _next_tags wasn't bound by
  default again. I'm sure I changed that again when I made it work
  without being included in the completer list, but that part of the
  patch doesn't seem to have made it in. Anyway, it is now bound by
  default to ^Xn again.



Some explanation for the _wanted stuff required, I think:

As you all know, the tag-order style supports actually two things:
specifying which tags (or labels) are to be tried together and which
tags (or labels) are to be tried after another. Before this patch
_wanted only supported the first kind. I.e., _wanted always took the
first string in the tag-order that contained the tag given to it and
then looped over all labels for that tag in the string from tag-order.

With that, _wanted supported splitting one type of matches into
different groups when the groups were to be used at the same time. But 
it did not support splitting the matches in different grouops, trying
one group after another.

This patch changes that by making _wanted do both loops. With that
_wanted is almost as powerful as _alternative -- for only one tag. But 
this also means, that it cannot be called without the command to
execute (the one that generates the matches) any more, because with it 
_wanted wouldn't have a chance to do the loops, obviously.

So, the different ways to add matches are now:

For very simple cases, only one typ of matches offered (i.e. one tag):

  _wanted <tag> expl <description> <command-with-args> ...

which does everything, end of story.

For more complicated cases (but still only one tag) one has to write
the _tags-loop, this is needed when a simple <command-with-args> isn't
enough:

  _tags <tag>
  while _tags; do
    while _next_label <tag> expl <description>; do
      <cmd1> ... && ret=0
      <cmd2> ... && ret=0
    done
    (( ret )) || return 0
  done
  return 1

Note the placement of the `(( ret )) || return 0', in the outer
loop. The inner loops tests the labels in the same string from the
tag-order style. Note also that there is no call _requested, this is
only needed when offering more than one tag. The use of _all_labels
with only one tag is seldom sensible, because, with respect to the
commands it can execute, _all_labels is only as powerful as _wanted.

If you need some expensive setup before you can generate the
matches (e.g. calling external commands) and first want to make sure
that the tag is requested at all, you can call _tags (before this was
sometimes done with _wanted with one argument), both:

  _tags <tag> || return 1
  ... # setup
  _wanted <tag> expl <description> <command-with-args> ...

and

  _tags <tag> || return 1
  ... # setup
  while _tags; do
    ... # guess what
  done

work.

Next, when adding multiple different types of matches (more than one
tag), one always needs the _tags loop, as before (unless one can use
_alternative, of course). The simple case:

  _tags <tag1> <tag2>
  while _tags; do
    _requested <tag1> expl <description> <command-with-args> ... && ret=0
    _requested <tag2> expl <description> <command-with-args> ... && ret=0
    (( ret )) || return 0
  done
  return 1

The only place where the other possibilities differ are the things
around the calls to _requested. If there is some expensive setup
needed, one can use _all_labels:

  if _requested <tag>; then
    ... # setup
    _all_labels <tag> expl <description> <command-with-args> ... && ret=0
  fi

And for the most complicated case, when multiple commands are needed
to generate the matches, one needs _next_label again:

  if _requested <tag>; then
    ... # setup, maybe
    while _next_label; do
      <command1> && ret=0
      <command2> && ret=0
    done
  fi

Ok, that's it. But please remember that in most cases one uses high
level functions like _arguments, _alternative, etc or lower level
functions like _parameters, _jobs, etc. In these cases one doesn't
have to worry about the tags and labels at all, all of these functions 
do the loops needed. And in many cases the simplest form with _wanted
can be used.


Bye
 Sven

Index: Completion/Base/_brace_parameter
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_brace_parameter,v
retrieving revision 1.1.1.17
diff -u -r1.1.1.17 _brace_parameter
--- Completion/Base/_brace_parameter	2000/03/23 04:19:26	1.1.1.17
+++ Completion/Base/_brace_parameter	2000/04/11 07:11:51
@@ -1,3 +1,3 @@
 #compdef -brace-parameter-
 
-_wanted parameters && _parameters -e
+_parameters -e
Index: Completion/Base/_condition
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_condition,v
retrieving revision 1.1.1.12
diff -u -r1.1.1.12 _condition
--- Completion/Base/_condition	2000/03/23 04:19:26	1.1.1.12
+++ Completion/Base/_condition	2000/04/11 07:11:51
@@ -3,9 +3,9 @@
 local prev="$words[CURRENT-1]" ret=1
 
 if [[ "$prev" = -o ]]; then
-  _wanted -C -o options && _options
+  _tags -C -o options && _options
 elif [[ "$prev" = -([a-hkprsuwxLOGSN]|[no]t|ef) ]]; then
-  _wanted -C "$prev" files && _files
+  _tags -C "$prev" files && _files
 else
   if [[ "$PREFIX" = -* ]] ||
      ! zstyle -T ":completion:${curcontext}:options" prefix-needed; then
Index: Completion/Base/_default
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_default,v
retrieving revision 1.2
diff -u -r1.2 _default
--- Completion/Base/_default	2000/04/01 20:43:43	1.2
+++ Completion/Base/_default	2000/04/11 07:11:51
@@ -12,8 +12,6 @@
   compcall "$opt[@]" || return 0
 fi
 
-_wanted files || return 1
-
 _files && return 0
 
 # magicequalsubst allows arguments like <any-old-stuff>=~/foo to do
Index: Completion/Base/_describe
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_describe,v
retrieving revision 1.2
diff -u -r1.2 _describe
--- Completion/Base/_describe	2000/04/01 20:43:43	1.2
+++ Completion/Base/_describe	2000/04/11 07:11:51
@@ -14,8 +14,6 @@
 
 # Do the tests. `showd' is set if the descriptions should be shown.
 
-_wanted "$_type" || return 1
-
 zstyle -T ":completion:${curcontext}:$_type" verbose && _showd=yes
 
 _descr="$1"
@@ -23,31 +21,36 @@
 
 [[ "$_type" = options ]] &&
     zstyle -t ":completion:${curcontext}:options" prefix-hidden && _hide=yes
+
+_tags "$_type"
+while _tags; do
+  while _next_label "$_type" _expl "$_descr"; do
+
+    if [[ -n "$_showd" ]]; then
+      compdescribe -I ' -- ' "$@"
+    else
+      compdescribe -i "$@"
+    fi
 
-while _next_label "$_type" _expl "$_descr"; do
+    while compdescribe -g _args _tmpd _tmpmd _tmps _tmpms; do
 
-  if [[ -n "$_showd" ]]; then
-    compdescribe -I ' -- ' "$@"
-  else
-    compdescribe -i "$@"
-  fi
-
-  while compdescribe -g _args _tmpd _tmpmd _tmps _tmpms; do
-
-    # See if we should remove the option prefix characters.
-
-    if [[ -n "$_hide" ]]; then
-      if [[ "$PREFIX" = --* ]]; then
-        _tmpd=( "${(@)_tmpd#--}" )
-        _tmps=( "${(@)_tmps#--}" )
-      elif [[ "$PREFIX" = [-+]* ]]; then
-        _tmpd=( "${(@)_tmpd#[-+]}" )
-        _tmps=( "${(@)_tmps#[-+]}" )
+      # See if we should remove the option prefix characters.
+
+      if [[ -n "$_hide" ]]; then
+        if [[ "$PREFIX" = --* ]]; then
+          _tmpd=( "${(@)_tmpd#--}" )
+          _tmps=( "${(@)_tmps#--}" )
+        elif [[ "$PREFIX" = [-+]* ]]; then
+          _tmpd=( "${(@)_tmpd#[-+]}" )
+          _tmps=( "${(@)_tmps#[-+]}" )
+        fi
       fi
-    fi
 
-    compadd "$_args[@]" "$_expl[@]" -ld _tmpd - "$_tmpmd[@]" && _ret=0
-    compadd "$_args[@]" "$_expl[@]" -d _tmps  - "$_tmpms[@]" && _ret=0
+      compadd "$_args[@]" "$_expl[@]" -ld _tmpd - "$_tmpmd[@]" && _ret=0
+      compadd "$_args[@]" "$_expl[@]" -d _tmps  - "$_tmpms[@]" && _ret=0
+    done
   done
+  (( _ret )) || return 0
 done
-return _ret
+
+return 1
Index: Completion/Base/_first
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_first,v
retrieving revision 1.1.1.15
diff -u -r1.1.1.15 _first
--- Completion/Base/_first	2000/03/23 04:19:26	1.1.1.15
+++ Completion/Base/_first	2000/04/11 07:11:51
@@ -34,8 +34,8 @@
 # completion of words from the history by adding two commas at the end 
 # and hitting TAB.
 #
-#     if [[ "$PREFIX" = *,, ]] && _wanted history-words; then
-#       local max i=1 expl
+#     if [[ "$PREFIX" = *,, ]]; then
+#       local max i=1 expl opt
 #     
 #       PREFIX="$PREFIX[1,-2]"
 #       # If a numeric prefix is given, we use it as the number of
@@ -51,18 +51,19 @@
 #       # twenty words, and so on...
 #       while [[ i -le max ]]; do
 #         if zstyle -t ":completion:${curcontext}:history-words" sort; then
-#           _description history-words expl "history ($n)"
+#           opt=-J
 #         else
-#           _description -V history-words expl "history ($n)"
+#           opt=-V
 #         fi
-#         if compadd "$expl[@]" -Q - \
-#                "${(@)${(@)historywords:#[\$'\"]*}[1,i*10]}"; then
+#         if _wanted "$opt" history-words expl "history ($n)" \
+#                compadd "$expl[@]" -Q - \
+#                    "${(@)${(@)historywords:#[\$'\"]*}[1,i*10]}"; then
 #           # We have found at least one matching word, so we switch
 #           # on menu-completion and make sure that no other
 #           # completion function is called by setting _compskip.
 #           compstate[insert]=menu
 #           _compskip=all
-#           return
+#           return 0
 #         fi
 #         (( i++ ))
 #       done
Index: Completion/Base/_jobs
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_jobs,v
retrieving revision 1.2
diff -u -r1.2 _jobs
--- Completion/Base/_jobs	2000/04/01 20:43:43	1.2
+++ Completion/Base/_jobs	2000/04/11 07:11:51
@@ -2,8 +2,6 @@
 
 local expl disp jobs job jids pfx='%' desc how expls
 
-_wanted jobs || return 1
-
 if [[ "$1" = -t ]]; then
   zstyle -T ":completion:${curcontext}:jobs" prefix-needed &&
       [[ "$PREFIX" != %* && compstate[nmatches] -ne 0 ]] && return 1
@@ -79,7 +77,7 @@
 fi
 
 if [[ -n "$desc" ]]; then
-  _all_labels jobs expl "$expls" compadd "$@" -ld disp - "%$^jobs[@]"
+  _wanted jobs expl "$expls" compadd "$@" -ld disp - "%$^jobs[@]"
 else
-  _all_labels jobs expl "$expls" compadd "$@" - "%$^jobs[@]"
+  _wanted jobs expl "$expls" compadd "$@" - "%$^jobs[@]"
 fi
Index: Completion/Base/_values
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_values,v
retrieving revision 1.3
diff -u -r1.3 _values
--- Completion/Base/_values	2000/04/07 12:43:32	1.3
+++ Completion/Base/_values	2000/04/11 07:11:51
@@ -18,7 +18,7 @@
 
   if ! compvalues -D descr action; then
 
-    _wanted values || return 1
+    _tags values || return 1
 
     curcontext="${oldcontext%:*}:values"
 
Index: Completion/Builtins/_compdef
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_compdef,v
retrieving revision 1.2
diff -u -r1.2 _compdef
--- Completion/Builtins/_compdef	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_compdef	2000/04/11 07:11:51
@@ -19,15 +19,13 @@
     _wanted commands expl 'completed command' compadd - ${(k)_comps}
   ;;
   cfun)
-    if _wanted functions; then
-      list=( ${^fpath:/.}/_(|*[^~])(N:t) )
-      if zstyle -T ":completion:${curcontext}:functions" prefix-hidden; then
-        disp=( ${list[@]#_} )
-        _all_labels functions expl 'completion function' \
-            compadd -d disp - "$list[@]"
-      else
-        _all_labels functions expl 'completion function' compadd - "$list[@]"
-      fi
+    list=( ${^fpath:/.}/_(|*[^~])(N:t) )
+    if zstyle -T ":completion:${curcontext}:functions" prefix-hidden; then
+      disp=( ${list[@]#_} )
+      _wanted functions expl 'completion function' \
+          compadd -d disp - "$list[@]"
+    else
+      _wanted functions expl 'completion function' compadd - "$list[@]"
     fi
   ;;
   style)
Index: Completion/Builtins/_hash
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_hash,v
retrieving revision 1.1.1.13
diff -u -r1.1.1.13 _hash
--- Completion/Builtins/_hash	2000/03/23 04:19:27	1.1.1.13
+++ Completion/Builtins/_hash	2000/04/11 07:11:51
@@ -10,8 +10,7 @@
         compadd -q -S '=' - "${(@k)nameddirs}"
   fi
 elif compset -P 1 '*='; then
-  _wanted -C value values expl 'executable file' &&
-      _files "$expl[@]" -g '*(-*)'
+  _wanted -C value values expl 'executable file' _files "$expl[@]" -g '*(-*)'
 else
   _wanted -C name commands expl command compadd -q -S '=' - "${(@k)commands}"
 fi
Index: Completion/Builtins/_pids
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_pids,v
retrieving revision 1.2
diff -u -r1.2 _pids
--- Completion/Builtins/_pids	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_pids	2000/04/11 07:11:51
@@ -5,7 +5,7 @@
 
 local out list expl match desc listargs args
 
-_wanted processes || return 1
+_tags processes || return 1
 
 if [[ "$1" = -m ]]; then
   match="${2}*"
@@ -29,6 +29,6 @@
   desc=()
 fi
 
-_all_labels processes expl 'process ID' \
+_wanted processes expl 'process ID' \
     compadd "$@" "$desc[@]" - \
         ${${${(M)${(f)"${out}"}[2,-1]:#[ 	]#${PREFIX}[0-9]#${SUFFIX}[ 	]#*${~match}}## #}%% *}
Index: Completion/Builtins/_popd
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_popd,v
retrieving revision 1.2
diff -u -r1.2 _popd
--- Completion/Builtins/_popd	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_popd	2000/04/11 07:11:51
@@ -12,8 +12,6 @@
 ! zstyle -T ":completion:${curcontext}:directory-stack" prefix-needed ||
     [[ $PREFIX = [-+]* ]] || return 1
 
-_wanted directory-stack || return 1
-
 if zstyle -T ":completion:${curcontext}:directory-stack" verbose; then
   # get the list of directories with their canonical number
   # and turn the lines into an array, removing the current directory
@@ -39,5 +37,5 @@
   disp=()
 fi
 
-_all_labels -V directory-stack expl 'directory stack' \
+_wanted -V directory-stack expl 'directory stack' \
     compadd "$@" "$disp[@]" -Q - "$list[@]"
Index: Completion/Builtins/_sched
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_sched,v
retrieving revision 1.2
diff -u -r1.2 _sched
--- Completion/Builtins/_sched	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_sched	2000/04/11 07:11:51
@@ -4,15 +4,13 @@
 
 if [[ CURRENT -eq 2 ]]; then
   if compset -P -; then
-    _wanted -C - jobs || return 1
-
     lines=(${(f)"$(sched)"})
     if zstyle -T ":completion:${curcontext}:jobs" verbose; then
       disp=( -ld lines )
     else
       disp=()
     fi
-    [[ -z $lines ]] || _all_labels jobs expl 'scheduled jobs' \
+    [[ -z $lines ]] || _wanted jobs expl 'scheduled jobs' \
                            compadd "$disp[@]" - {1..$#lines}
     return
   else
Index: Completion/Builtins/_signals
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_signals,v
retrieving revision 1.2
diff -u -r1.2 _signals
--- Completion/Builtins/_signals	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_signals	2000/04/11 07:11:51
@@ -20,10 +20,9 @@
 
 [[ "$1" = -(|-) ]] && shift
 
-if _wanted signals &&
-       { [[ -z "$minus" ]] ||
-         ! zstyle -T ":completion:${curcontext}:signals" prefix-needed ||
-         [[ "$PREFIX" = -* ]] } ; then
+if [[ -z "$minus" ]] ||
+   ! zstyle -T ":completion:${curcontext}:signals" prefix-needed ||
+   [[ "$PREFIX" = -* ]]; then
   local disp tmp
 
   if zstyle -t ":completion:${curcontext}:signals" prefix-hidden; then
@@ -32,7 +31,7 @@
   else
     disp=()
   fi
-  _all_labels signals expl signal \
+  _wanted signals expl signal \
       compadd "$@" "$disp[@]" -M 'm:{a-z}={A-Z}' - \
               "${minus}${(@)^signals[1,last]}"
 fi
Index: Completion/Builtins/_vars
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_vars,v
retrieving revision 1.1.1.5
diff -u -r1.1.1.5 _vars
--- Completion/Builtins/_vars	2000/03/23 04:19:27	1.1.1.5
+++ Completion/Builtins/_vars	2000/04/11 07:11:51
@@ -20,5 +20,5 @@
         compadd $addclose - ${(kP)var}
   fi
 else
-  _wanted parameters && _parameters
+  _parameters
 fi
Index: Completion/Builtins/_zcompile
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zcompile,v
retrieving revision 1.1
diff -u -r1.1 _zcompile
--- Completion/Builtins/_zcompile	2000/04/01 20:43:43	1.1
+++ Completion/Builtins/_zcompile	2000/04/11 07:11:51
@@ -18,5 +18,6 @@
 if (( $+opt_args[-c] )); then
   _wanted functions expl 'function to write' compadd - ${(k)functions}
 else
-  _wanted file expl 'zsh source file' _files
+  _description files expl 'zsh source file'
+  _files "$expl[@]"
 fi
Index: Completion/Builtins/_zftp
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zftp,v
retrieving revision 1.2
diff -u -r1.2 _zftp
--- Completion/Builtins/_zftp	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_zftp	2000/04/11 07:11:51
@@ -28,35 +28,34 @@
 case $subcom in
   *(cd|ls|dir))
     # complete remote directories
-    _wanted directories && zfcd_match $PREFIX $SUFFIX
+    _tags directories && zfcd_match $PREFIX $SUFFIX
     ;;
 
   *(get(|at)|gcp|delete|remote))
     # complete remote files
-    _wanted files && zfget_match $PREFIX $SUFFIX
+    _tags files && zfget_match $PREFIX $SUFFIX
     ;;
 
   *(put(|at)|pcp))
     # complete local files
-    _wanted files && _files
+    _files
     ;;
 
   *(open|anon|params))
     # complete hosts:  should do cleverer stuff with user names
-    _wanted hosts && _hosts
+    _hosts
     ;;
 
   *(goto|mark))
     # complete bookmarks.  First decide if ncftp mode is go.
-    _wanted bookmarks || return 1
     if [[ $words[2] = -*n* ]]; then
       if [[ -f ~/.ncftp/bookmarks ]]; then
-        _all_labels bookmarks expl bookmark \
+        _wanted bookmarks expl bookmark \
             compadd - $(awk -F, 'NR > 2 { print $1 }' ~/.ncftp/bookmarks)
       fi
     else
       if [[ -f ${ZFTP_BMFILE:=${ZDOTDIR:-$HOME}/.zfbkmarks} ]]; then
-        _all_labels bookmarks expl bookmark \
+        _wanted bookmarks expl bookmark \
             compadd - $(awk '{print $1}' $ZFTP_BMFILE)
       fi
     fi
@@ -72,7 +71,7 @@
     # complete arguments like sess1:file1 sess2:file2
     if [[ $PREFIX = *:* ]]; then
       # complete file in the given session
-      _wanted files || return 1
+      _tags files || return 1
       local sess=${PREFIX%%:*} oldsess=$ZFTP_SESSION
       compset -p $(( $#sess + 1 ))
       [[ -n $sess ]] && zftp session $sess
Index: Completion/Builtins/_zpty
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zpty,v
retrieving revision 1.2
diff -u -r1.2 _zpty
--- Completion/Builtins/_zpty	2000/04/01 20:43:43	1.2
+++ Completion/Builtins/_zpty	2000/04/11 07:11:51
@@ -11,13 +11,13 @@
   '(-e -b -d -w -r)-L[list defined commands as calls]' \
   '(-r)*::args:_normal'
 
-if [[ $state = name ]] && _wanted names; then
+if [[ $state = name ]]; then
   list=( ${${(f)"$(zpty)"}#*\) } )
   names=( ${list%%:*} )
   if zstyle -T ":completion:${curcontext}" verbose; then
     zformat -a list ' --' ${${(f)"$(zpty)"}#*\) }
-    _all_labels names expl 'zpty command names' compadd -d list - "$names[@]"
+    _wanted names expl 'zpty command names' compadd -d list - "$names[@]"
   else
-    _all_labels names expl 'zpty command names' compadd - "$names[@]"
+    _wanted names expl 'zpty command names' compadd - "$names[@]"
   fi
 fi
Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.4
diff -u -r1.4 _zstyle
--- Completion/Builtins/_zstyle	2000/04/09 20:56:52	1.4
+++ Completion/Builtins/_zstyle	2000/04/11 07:11:51
@@ -96,20 +96,18 @@
 
   case "$ostate" in
     contexts)
-      if _wanted contexts; then
-        if [[ $PREFIX != :*: ]]; then
-	  _all_labels contexts expl context compadd -P : -S : completion zftp
-        elif [[ $PREFIX = :completion:* ]]; then
-          mesg=''
-          case "$PREFIX" in
-          :completion:[^:]#) mesg=function ;;
-          :completion:[^:]#:[^:]#) mesg=completer ;;
-          :completion:[^:]#:[^:]#:[^:]#) mesg='command or context' ;;
-          :completion:[^:]#:[^:]#:[^:]#:[^:]#) mesg=argument ;;
-          :completion:[^:]#:[^:]#:[^:]#:[^:]#:[^:]#) mesg=tag ;;
-	  esac
-	  [[ -n "$mesg" ]] && _message "$mesg"
-        fi
+      if [[ $PREFIX != :*: ]]; then
+	_wanted contexts expl context compadd -P : -S : completion zftp
+      elif [[ $PREFIX = :completion:* ]] && _tags contexts; then
+        mesg=''
+        case "$PREFIX" in
+        :completion:[^:]#) mesg=function ;;
+        :completion:[^:]#:[^:]#) mesg=completer ;;
+        :completion:[^:]#:[^:]#:[^:]#) mesg='command or context' ;;
+        :completion:[^:]#:[^:]#:[^:]#:[^:]#) mesg=argument ;;
+        :completion:[^:]#:[^:]#:[^:]#:[^:]#:[^:]#) mesg=tag ;;
+	esac
+	[[ -n "$mesg" ]] && _message "$mesg"
       fi
       ;;
 
Index: Completion/Commands/_next_tags
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Commands/_next_tags,v
retrieving revision 1.4
diff -u -r1.4 _next_tags
--- Completion/Commands/_next_tags	2000/04/05 08:25:00	1.4
+++ Completion/Commands/_next_tags	2000/04/11 07:11:51
@@ -3,30 +3,103 @@
 # Main widget.
 
 _next_tags() {
-  local comp ins
+  local ins ops="$PREFIX$SUFFIX"
 
-  if [[ -z $compstate[old_list] ]]; then
-    comp=()
+  unfunction _all_labels _next_label
+
+  _all_labels() {
+    local gopt=-J len tmp pre suf ret=1 descr spec
+
+    if [[ "$1" = -([12]|)[VJ] ]]; then
+      gopt="$1"
+      shift
+    fi
+
+    tmp=${argv[(ib:4:)-]}
+    len=$#
+    if [[ tmp -lt len ]]; then
+      pre=$(( tmp-1 ))
+      suf=$tmp
+    elif [[ tmp -eq $# ]]; then
+      pre=-2
+      suf=$(( len+1 ))
+    else
+      pre=4
+      suf=5
+    fi
+
+    while comptags -A "$1" curtag spec; do
+      [[ "$_next_tags_not" = *\ ${spec}\ * ]] && continue
+      _comp_tags="$_comp_tags $spec "
+      if [[ "$curtag" = *:* ]]; then
+        zformat -f descr "${curtag#*:}" "d:$3"
+        _description "$gopt" "${curtag%:*}" "$2" "$descr"
+        curtag="${curtag%:*}"
+
+        "$4" "${(P@)2}" "${(@)argv[5,-1]}"
+      else
+        _description "$gopt" "$curtag" "$2" "$3"
+
+        "${(@)argv[4,pre]}" "${(P@)2}" "${(@)argv[suf,-1]}" && ret=0
+      fi
+    done
+
+    return ret
+  }
+
+  _next_label() {
+    local gopt=-J descr spec
+
+    if [[ "$1" = -([12]|)[VJ] ]]; then
+      gopt="$1"
+      shift
+    fi
+
+    if comptags -A "$1" curtag spec; then
+      [[ "$_next_tags_not" = *\ ${spec}\ * ]] && continue
+      _comp_tags="$_comp_tags $spec "
+      if [[ "$curtag" = *:* ]]; then
+        zformat -f descr "${curtag#*:}" "d:$3"
+        _description "$gopt" "${curtag%:*}" "$2" "$descr"
+        curtag="${curtag%:*}"
+        eval "${2}=( \${(P)2} \$argv[4,-1] )"
+      else
+        _description "$gopt" "$curtag" "$2" "$3"
+        eval "${2}=( \$argv[4,-1] \${(P)2} )"
+      fi
+
+      return 0
+    fi
+
+    return 1
+  }
+
+  if [[ "${LBUFFER%${PREFIX}}" = "$_next_tags_pre" ]]; then
+    PREFIX="$_next_tags_pfx"
+    SUFFIX="$_next_tags_sfx"
   else
-    comp=(_complete)
+    _next_tags_pre="${LBUFFER%${PREFIX}}"
+    if [[ "$LASTWIDGET" = (_next_tags|list-*|*complete*) ]]; then
+      PREFIX="$_lastcomp[prefix]"
+      SUFFIX="$_lastcomp[suffix]"
+    fi
   fi
 
-  (( $+_sort_tags )) || _next_tags_not=
-
-  _sort_tags=_next_tags_sort
-  _next_tags_pre="${LBUFFER%${PREFIX}}"
   _next_tags_not="$_next_tags_not $_lastcomp[tags]"
+  _next_tags_pfx="$PREFIX"
+  _next_tags_sfx="$SUFFIX"
 
   if [[ -n "$compstate[old_insert]" ]]; then
-    PREFIX="$_lastcomp[prefix]"
-    SUFFIX="$_lastcomp[suffix]"
     ins=1
+  else
+    ins=unambiguous
   fi
 
-  _main_complete "$comp[@]"
+  _main_complete _complete _next_tags_completer
 
-  [[ $compstate[insert] = automenu ]] &&
-     compstate[insert]=automenu-unambiguous
+  [[ $compstate[insert] = automenu ]] && compstate[insert]=automenu-unambiguous
+  [[ $compstate[insert] = *unambiguous && -n "$ops" &&
+     -z "$_lastcomp[unambiguous]" ]] && compadd -Uns "$SUFFIX" - "$PREFIX"
 
   compstate[insert]="$ins"
   compstate[list]='list force'
@@ -34,11 +107,19 @@
   compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
 }
 
+# Completer, for wrap-around.
+
+_next_tags_completer() {
+  _next_tags_not=
+
+  _complete
+}
+
 # Pre-completion function.
 
 _next_tags_pre() {
 
-  # Probably `remove' our sort function. A better test would be nice, but
+  # Probably `remove' our label functions. A better test would be nice, but
   # I think one should still be able to edit the current word between
   # attempts to complete it.
 
@@ -47,65 +128,10 @@
     compstate[insert]=menu:2
     return 0
   elif [[ ${LBUFFER%${PREFIX}} != ${_next_tags_pre}* ]]; then
-    unset _sort_tags
+    unfunction _all_labels _next_label
+    autoload -U _all_labels _next_label
   else
     compprefuncs=( "$compprefuncs[@]" _next_tags_pre )
-    [[ -n "$compstate[old_list]" && -n "$_next_tags_reset" ]] &&
-        _next_tags_not= _next_tags_reset=
-  fi
-}
-
-# Helper function for sorting tags. Most of this is copied from _tags.
-
-_next_tags_sort() {
-  local order tags tag nodef tmp
-
-  zstyle -a ":completion:${curcontext}:" tag-order order ||
-      order=('arguments values' options)
-
-  # But we also remove the tags we've already tried...
-
-  tags=( "${(@)order:#(${(j:|:)~${=_next_tags_not}})(|:*)}" )
-
-  # ... unless that would remove all offered tags.
-
-  if [[ $funcstack[4] = _files ]]; then
-    if zstyle -a ":completion:${curcontext}:" file-patterns tmp; then
-      [[ "$tags" = *${${tmp[-1]##[^\\]:}%:*}* ]] &&
-          tags=( $order ) _next_tags_reset=yes
-    else
-      [[ "$tags" = *all-files* ]] && tags=( $order ) _next_tags_reset=yes
-    fi
-  else
-     [[ $#tags -ne $#order && "$tags" != *(${(j:|:)~argv})* ]] &&
-        tags=( $order ) _next_tags_reset=yes
-  fi
-  for tag in $tags; do
-    case $tag in
-    -)     nodef=yes;;
-    *\(\)) "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@";;
-    \!*)   comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}";;
-    ?*)    comptry -m "$tag";;
-    esac
-  done
-
-  if [[ -z "$nodef" ]]; then
-    if [[ $funcstack[4] = _files ]]; then
-      if zstyle -a ":completion:${curcontext}:" file-patterns tmp; then
-        [[ "$argv" = *${${tmp[-1]#*[^\\]:}%:*}* ]] && _next_tags_reset=yes
-      else
-        [[ "$argv" = *all-files* ]] && _next_tags_reset=yes
-      fi
-    fi
-    tmp=( "${(@)argv:#(${(j:|:)~${=_next_tags_not}})(|:*)}" )
-
-    # $prev is set in _tags!
-
-    if [[ -n "$prev" && ( $#tmp -ne 0 || $funcstack[4] = _files ) ]]; then
-      comptry "$tmp[@]"
-    else
-      comptry "$argv[@]"
-    fi
   fi
 }
 
Index: Completion/Core/_all_labels
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_all_labels,v
retrieving revision 1.1
diff -u -r1.1 _all_labels
--- Completion/Core/_all_labels	2000/04/01 20:43:43	1.1
+++ Completion/Core/_all_labels	2000/04/11 07:11:51
@@ -1,11 +1,7 @@
 #autoload
 
-local gopt=-J len tmp pre suf tloop ret=1 descr
+local gopt=-J len tmp pre suf ret=1 descr spec
 
-if [[ "$1" = -t ]]; then
-  tloop=yes
-  shift
-fi
 if [[ "$1" = -([12]|)[VJ] ]]; then
   gopt="$1"
   shift
@@ -24,21 +20,19 @@
   suf=5
 fi
 
-while [[ -z "$tloop" ]] || comptags -N; do
-  while comptags -A "$1" curtag; do
-    if [[ "$curtag" = *:* ]]; then
-      zformat -f descr "${curtag#*:}" "d:$3"
-      _description "$gopt" "${curtag%:*}" "$2" "$descr"
-      curtag="${curtag%:*}"
+while comptags -A "$1" curtag spec; do
+  _comp_tags="$_comp_tags $spec "
+  if [[ "$curtag" = *:* ]]; then
+    zformat -f descr "${curtag#*:}" "d:$3"
+    _description "$gopt" "${curtag%:*}" "$2" "$descr"
+    curtag="${curtag%:*}"
 
-      "$4" "${(P@)2}" "${(@)argv[5,-1]}"
-    else
-      _description "$gopt" "$curtag" "$2" "$3"
+    "$4" "${(P@)2}" "${(@)argv[5,-1]}"
+  else
+    _description "$gopt" "$curtag" "$2" "$3"
 
-      "${(@)argv[4,pre]}" "${(P@)2}" "${(@)argv[suf,-1]}" && ret=0
-    fi
-  done
-  [[ -z "$tloop" || ret -eq 0 ]] && break
+    "${(@)argv[4,pre]}" "${(P@)2}" "${(@)argv[suf,-1]}" && ret=0
+  fi
 done
 
 return ret
Index: Completion/Core/_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_files,v
retrieving revision 1.6
diff -u -r1.6 _files
--- Completion/Core/_files	2000/04/10 09:34:05	1.6
+++ Completion/Core/_files	2000/04/11 07:11:51
@@ -6,7 +6,7 @@
     '/=tmp' 'f=tmp' 'g+:-=tmp' q n 1 2 P: S: r: R: W: X+: M+: F: J+: V+:
 
 type="${(@j::M)${(@)tmp#-}#?}"
-(( $tmp[(I)-g*] )) && glob="${(j: :)${(@M)tmp:#-g*}#-g}"
+(( $tmp[(I)-g*] )) && glob="${(j:,:)${(@M)tmp:#-g*}#-g}"
 ign=$opts[(I)-F]
 if (( ign )); then
   ign=( $=opts[ign+1] )
@@ -20,56 +20,59 @@
 fi
 
 if zstyle -a ":completion:${curcontext}:" file-patterns tmp; then
-  [[ "$type" = */* ]] && glob="$glob *(-/)"
+  [[ "$type" = */* ]] && glob="$glob,*(-/)"
   pats=()
   for i in ${tmp//\\%p/ ${${glob:-\*}//:/\\:} }; do
     if [[ $i = *[^\\]:* ]]; then
-      pats=( "$pats[@]" " $i" )
+      pats=( "$pats[@]" " $i " )
     else
-      pats=( "$pats[@]" " ${i}:files" )
+      pats=( "$pats[@]" " ${i}:files " )
     fi
   done
 else
   if [[ "$type" = *g* ]]; then
     if [[ "$type" = */* ]]; then
-      pats=( " ${glob//:/\\:} *(-/):globbed-files" '*:all-files' )
+      pats=( " ${glob//:/\\:},*(-/):globbed-files " '*:all-files ' )
     else
-      pats=( " ${glob//:/\\:}:globbed-files"
-             '*(-/):directories' '*:all-files' )
+      pats=( " ${glob//:/\\:}:globbed-files "
+             '*(-/):directories ' '*:all-files ' )
     fi
   elif [[ "$type" = */* ]]; then
-    pats=( '*(-/):directories' '*:all-files' )
+    pats=( '*(-/):directories ' '*:all-files ' )
   else
-    pats=( '*:all-files' )
+    pats=( '*:all-files ' )
   fi
 fi
 
-for def in "$pats[@]"; do ###"${(@)${(@)pats#*[^\\]:}%%:*}"; do
+for def in "$pats[@]"; do
+  def="${def##[[:blank:]]#}"
+  while [[ "$def" = *[^\\][[:blank:]]* ]]; do
+    sdef="${(M)def#*[^\\][[:blank:]]}"
+    tag="${${sdef#*[^\\]:}%%:*}"
+    pat="${${${sdef%%:${tag}*}//\\\\:/:}//,/ }"
 
-  tag="${${def#*[^\\]:}%%:*}"
-  pat="${${def%%:${tag}*}//\\\\:/:}"
-
-  if [[ "$pat" != \ # ]]; then
-    if [[ "$def" = *:${tag}:* ]]; then
-      descr="${def#*:${tag}:}"
+    if [[ "$sdef" = *:${tag}:* ]]; then
+      descr="${(Q)sdef#*:${tag}:}"
     else
       descr=file
       end=yes
     fi
-  fi
 
-  if _wanted "$tag"; then
-    _comp_ignore=()
-    while _next_label "$tag" expl "$descr"; do
-      _comp_ignore=( $_comp_ignore $ign )
-      if [[ -n "$end" ]]; then
-        _path_files -g "$pat" "$opts[@]" "$expl[@]" && ret=0
-      else
-        _path_files "$expl[@]" -g "$pat" "$opts[@]" && ret=0
-      fi
+    _tags "$tag"
+    while _tags; do
+      _comp_ignore=()
+      while _next_label "$tag" expl "$descr"; do
+        _comp_ignore=( $_comp_ignore $ign )
+        if [[ -n "$end" ]]; then
+          _path_files -g "$pat" "$opts[@]" "$expl[@]" && ret=0
+        else
+          _path_files "$expl[@]" -g "$pat" "$opts[@]" && ret=0
+        fi
+      done
     done
-    (( ret )) || return 0
-  fi
+    def="${${def#${sdef}}##[[:blank:]]#}"
+  done
+  (( ret )) || return 0
 done
 
 return 1
Index: Completion/Core/_next_label
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_next_label,v
retrieving revision 1.1
diff -u -r1.1 _next_label
--- Completion/Core/_next_label	2000/04/01 20:43:43	1.1
+++ Completion/Core/_next_label	2000/04/11 07:11:51
@@ -1,13 +1,14 @@
 #autoload
 
-local gopt=-J descr
+local gopt=-J descr spec
 
 if [[ "$1" = -([12]|)[VJ] ]]; then
   gopt="$1"
   shift
 fi
 
-if comptags -A "$1" curtag; then
+if comptags -A "$1" curtag spec; then
+  _comp_tags="$_comp_tags $spec "
   if [[ "$curtag" = *:* ]]; then
     zformat -f descr "${curtag#*:}" "d:$3"
     _description "$gopt" "${curtag%:*}" "$2" "$descr"
Index: Completion/Core/_requested
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_requested,v
retrieving revision 1.2
diff -u -r1.2 _requested
--- Completion/Core/_requested	2000/04/01 20:43:43	1.2
+++ Completion/Core/_requested	2000/04/11 07:11:51
@@ -8,7 +8,6 @@
 fi
 
 if comptags -R "$1"; then
-  _comp_tags="$_comp_tags $1"
   if [[ $# -gt 3 ]]; then
     _all_labels "$gopt" "$@"
   elif [[ $# -gt 1 ]]; then
Index: Completion/Core/_wanted
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_wanted,v
retrieving revision 1.2
diff -u -r1.2 _wanted
--- Completion/Core/_wanted	2000/04/01 20:43:43	1.2
+++ Completion/Core/_wanted	2000/04/11 07:11:51
@@ -17,17 +17,10 @@
   shift
 fi
 
-if [[ $# -gt 3 ]]; then
-  if _tags "$targs[@]" "$1"; then
-    _comp_tags="$_comp_tags $1"
+_tags "$targs[@]" "$1"
 
-    _all_labels -t "$gopt" "$@"
-  else
-    return 1
-  fi
-elif [[ $# -gt 1 ]]; then
-  _tags -- "$targs[@]" "$1" && _comp_tags="$_comp_tags $1" &&
-    _description "$gopt" "$@"
-else
-  _tags -- "$targs[@]" "$1" && _comp_tags="$_comp_tags $1"
-fi
+while _tags; do
+  _all_labels "$gopt" "$@" && return 0
+done
+
+return 1
Index: Completion/Debian/_apt
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_apt,v
retrieving revision 1.2
diff -u -r1.2 _apt
--- Completion/Debian/_apt	2000/04/05 11:28:09	1.2
+++ Completion/Debian/_apt	2000/04/11 07:11:51
@@ -75,7 +75,7 @@
   nul=$'\0'
   qnul="\$'\\0'"
 
-  comp_bool='_wanted values && compadd "$expl_bool[@]" '"$bool"
+  comp_bool='_wanted values expl_bool "boolean value" compadd "$expl_bool[@]" '"$bool"
   comp_intlevel= #"_message 'intlevel'"
   comp_configfile='_files "$expl_configfile[@]"'
   comp_arbitem= #"_message 'Foo::Bar=bar'"
Index: Completion/Debian/_deb_packages
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_deb_packages,v
retrieving revision 1.1.1.10
diff -u -r1.1.1.10 _deb_packages
--- Completion/Debian/_deb_packages	2000/03/23 04:19:29	1.1.1.10
+++ Completion/Debian/_deb_packages	2000/04/11 07:11:51
@@ -51,7 +51,7 @@
 
   _deb_packages_update_$pkgset
 
-  _wanted packages && compadd "$expl[@]" - "${(@P)cachevar}"
+  _tags packages && compadd "$expl[@]" - "${(@P)cachevar}"
 }
 
 _deb_packages "$@"
Index: Completion/User/_cvs
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_cvs,v
retrieving revision 1.1.1.32
diff -u -r1.1.1.32 _cvs
--- Completion/User/_cvs	2000/03/23 04:19:29	1.1.1.32
+++ Completion/User/_cvs	2000/04/11 07:11:52
@@ -34,7 +34,7 @@
 	watchers "")
 
   if (( CURRENT == 1 )); then
-    _wanted commands && { compadd "$@" ${(k)cmds} || compadd "$@" ${(kv)=cmds} }
+    _tags commands && { compadd "$@" ${(k)cmds} || compadd "$@" ${(kv)=cmds} }
   else
     local curcontext="$curcontext"
 
@@ -427,14 +427,14 @@
     fi
   fi
 
-  _wanted files && {
+  _tags files && {
     compadd -M 'r:|[:@./]=* r:|=*' "$@" $_cvs_roots || _files "$@" -/
   }
 }
 
 (( $+functions[_cvs_tempdir] )) ||
 _cvs_tempdir () {
-  _wanted directories && compadd "$@" $TMPPREFIX:h $TMPDIR /tmp
+  _tags directories && compadd "$@" $TMPPREFIX:h $TMPDIR /tmp
 }
 
 (( $+functions[_cvs_user_variable] )) ||
@@ -450,29 +450,29 @@
 
 (( $+functions[_cvs_bindir] )) ||
 _cvs_bindir () {
-  _wanted directories && { compadd "$@" /usr/local/bin || _files "$@" -/ }
+  _tags directories && { compadd "$@" /usr/local/bin || _files "$@" -/ }
 }
 
 (( $+functions[_cvs_editor] )) ||
 _cvs_editor () {
-  _wanted commands && compadd "$@" vi
+  _tags commands && compadd "$@" vi
 }
 
 (( $+functions[_cvs_gzip_level] )) ||
 _cvs_gzip_level () {
-  _wanted values && compadd "$@" 9
+  _tags values && compadd "$@" 9
 }
 
 # define completion functions for cvs common options and arguments.
 
 (( $+functions[_cvs_D] )) ||
 _cvs_D () {
-  _wanted values && compadd "$@" today yesterday week\ ago month\ ago
+  _tags values && compadd "$@" today yesterday week\ ago month\ ago
 }
 
 (( $+functions[_cvs_k] )) ||
 _cvs_k () {
-  _wanted values && compadd "$@" kv kvl k o b v
+  _tags values && compadd "$@" kv kvl k o b v
 }
 
 (( $+functions[_cvs_m] )) ||
@@ -617,7 +617,7 @@
     local omit
     omit=(${pref}*(D:t))
     eval 'entries=(${entries:#('${(j:|:)${(@)omit:q}}')})'
-    _wanted directories && compadd "$@" -P "$qpref" - ${entries:q} ||
+    _tags directories && compadd "$@" -P "$qpref" - ${entries:q} ||
         _cvs_directories "$@"
   else
     _files "$@"
Index: Completion/User/_gdb
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_gdb,v
retrieving revision 1.3
diff -u -r1.3 _gdb
--- Completion/User/_gdb	2000/04/03 15:27:14	1.3
+++ Completion/User/_gdb	2000/04/11 07:11:52
@@ -17,7 +17,8 @@
 elif compset -P '-(symbols|core|command)='; then
   _files
 elif [[ "$PREFIX" = -* ]]; then
-  if _wanted options; then
+  _tags options
+  while _tags; do
     while _next_label options expl option; do
       compadd "$expl[@]" -QS '' - -symbols\= -exec\= -se\= -core\= -command\= \
                                   -directory\= -cd\= -tty\= && ret=0
@@ -25,7 +26,7 @@
 	    		          -batch -fullname -f -b && ret=0
     done
     (( ret )) || return 0
-  fi
+  done
 else
   prev="$words[CURRENT-1]"
 
Index: Completion/User/_gprof
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_gprof,v
retrieving revision 1.1.1.8
diff -u -r1.1.1.8 _gprof
--- Completion/User/_gprof	2000/03/23 04:19:29	1.1.1.8
+++ Completion/User/_gprof	2000/04/11 07:11:52
@@ -17,7 +17,7 @@
 if [[ -n "$state" ]]; then
   local cmd pair expl
 
-  _wanted functions || return 1
+  _tags functions || return 1
 
   [[ "$state" = pair ]] && pair=yes
 
@@ -41,14 +41,15 @@
   
     if [[ -n "$pair" ]]; then
       if compset -P '*/'; then
-        _description functions expl 'call arc to function'
+        expl='call arc to function'
       else
-        _description functions expl 'call arc from function'
+        expl='call arc from function'
       fi
     else
-      _description functions expl function
+      expl=function
     fi
-    compadd "$expl[@]" -M 'r:|_=* r:|=*' - "$_gprof_funcs[@]" && ret=0
+    _wanted functions expl "$expl" \
+        compadd "$expl[@]" -M 'r:|_=* r:|=*' - "$_gprof_funcs[@]" && ret=0
   else
     return 1
   fi
Index: Completion/User/_groups
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_groups,v
retrieving revision 1.2
diff -u -r1.2 _groups
--- Completion/User/_groups	2000/04/01 20:43:43	1.2
+++ Completion/User/_groups	2000/04/11 07:11:52
@@ -2,7 +2,7 @@
 
 local expl groups tmp
 
-_wanted groups || return 1
+_tags groups || return 1
 
 if ! zstyle -a ":completion:${curcontext}:" groups groups; then
   (( $+_cache_groups )) ||
@@ -16,4 +16,4 @@
   groups=( "$_cache_groups[@]" )
 fi
 
-_all_labels groups expl group compadd "$@" - "$groups[@]"
+_wanted groups expl group compadd "$@" - "$groups[@]"
Index: Completion/User/_lp
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_lp,v
retrieving revision 1.3
diff -u -r1.3 _lp
--- Completion/User/_lp	2000/04/05 11:28:09	1.3
+++ Completion/User/_lp	2000/04/11 07:11:52
@@ -36,28 +36,27 @@
 fi
 
 if compset -P -P || [[ "$words[CURRENT-1]" = -P ]]; then
-  if _wanted printers; then
-    if zstyle -T ":completion:${curcontext}:printers" verbose; then
-      zformat -a list ' -- ' "$_lp_cache[@]"
-      disp=(-ld list)
-    else
-      disp=()
-    fi
-    _all_labels printers expl printer \
-        compadd "$disp[@]" - "${(@)_lp_cache%%:*}" && return 0
+  if zstyle -T ":completion:${curcontext}:printers" verbose; then
+    zformat -a list ' -- ' "$_lp_cache[@]"
+    disp=(-ld list)
+  else
+    disp=()
+  fi
+  _wanted printers expl printer \
+      compadd "$disp[@]" - "${(@)_lp_cache%%:*}" && return 0
 
-    (( $+_lp_alias_cache )) || return 1
+  (( $+_lp_alias_cache )) || return 1
 
-    if zstyle -T ":completion:${curcontext}:printers" verbose; then
-      zformat -a list ' -- ' "$_lp_alias_cache[@]"
-      disp=(-ld list)
-    else
-      disp=()
-    fi
-    compadd "$expl[@]" "$disp[@]" - "${(@)_lp_alias_cache%%:*}"
+  if zstyle -T ":completion:${curcontext}:printers" verbose; then
+    zformat -a list ' -- ' "$_lp_alias_cache[@]"
+    disp=(-ld list)
   else
-    return 1
+    disp=()
   fi
+  _wanted printers expl printer \
+      compadd "$disp[@]" - "${(@)_lp_alias_cache%%:*}" && return 0
+
+  return 1
 else
   if [[ "${words[1]:t}" = (lpq|lprm) ]]; then
     if [[ "$words" = *-P* ]]; then
Index: Completion/User/_mh
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_mh,v
retrieving revision 1.3
diff -u -r1.3 _mh
--- Completion/User/_mh	2000/04/03 15:27:14	1.3
+++ Completion/User/_mh	2000/04/11 07:11:52
@@ -17,16 +17,13 @@
   # get list of options, which MH commands can generate themselves
   # awk is just too icky to use for this, sorry.  send me one if
   # you come up with it.
-  if _wanted options; then
-    _all_labels options expl option \
-        compadd - $($words[1] -help | perl -ne 'if (/^\s*-\(?(\S+)/) {
+  _wanted options expl option \
+      compadd - $($words[1] -help | perl -ne 'if (/^\s*-\(?(\S+)/) {
             $n = $1;
             $n =~ s/\)//g;
             print $n =~ s/^\[([a-z]+)\]// ? "$n\n$1$n\n" : "$n\n";
           }')
-    return
-  fi
-  return 1
+  return
 elif compset -P 1 '[+@]' || [[ "$prev" = -draftfolder ]]; then
   # Complete folder names.
   local mhpath
@@ -72,13 +69,15 @@
     # leaving foldnam empty works here
   fi
 
-  if _wanted sequences; then
+  _tags sequences
+  while _tags; do
     while _next_label sequences expl sequence; do
       compadd "$expl[@]" $(mark $foldnam 2>/dev/null | awk -F: '{ print $1 }') &&
         ret=0
       compadd "$expl[@]" reply next cur prev first last all unseen && ret=0
       _files "$expl[@]" -W folddir -g '<->' && ret=0
     done
-  fi
+    (( ret )) || return 0
+  done
   return ret
 fi
Index: Completion/User/_mount
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_mount,v
retrieving revision 1.2
diff -u -r1.2 _mount
--- Completion/User/_mount	2000/04/05 11:28:09	1.2
+++ Completion/User/_mount	2000/04/11 07:11:52
@@ -543,7 +543,7 @@
       compadd "$expl[@]" -qS, -M 'L:|no=' - "$fss[@]" && ret=0
   ;;
 fsopt)
-  _wanted options || return 1
+  _tags options || return 1
 
   eval 'tmp=(' '"$_fs_'${(s:,:)^${opt_args[$typeops]:-${deffs}}}'[@]"' ')'
   tmp=( "$_fs_any[@]" "${(@)tmp:#}" )
Index: Completion/User/_netscape
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_netscape,v
retrieving revision 1.3
diff -u -r1.3 _netscape
--- Completion/User/_netscape	2000/04/03 15:27:14	1.3
+++ Completion/User/_netscape	2000/04/11 07:11:52
@@ -56,16 +56,14 @@
       fi
     ;;
     *)
-      if _wanted commands; then
-        if [[ -z "$QIPREFIX" ]]; then
-	  _all_labels commands expl 'remote commands' \
-  	      compadd  -s'(' -S '' -M 'm:{a-zA-Z}={A-Za-z}' - \
-                      $remote_commands && ret=0
-        else
-	  _all_labels commands expl 'remote commands' \
-              compadd -qS '(' -M 'm:{a-zA-Z}={A-Za-z}' - \
-                      $remote_commands && ret=0
-	fi
+      if [[ -z "$QIPREFIX" ]]; then
+	_wanted commands expl 'remote commands' \
+  	    compadd -s'(' -S '' -M 'm:{a-zA-Z}={A-Za-z}' - \
+                    $remote_commands && ret=0
+      else
+	_wanted commands expl 'remote commands' \
+            compadd -qS '(' -M 'm:{a-zA-Z}={A-Za-z}' - \
+                    $remote_commands && ret=0
       fi
     ;;
   esac
@@ -78,12 +76,14 @@
         compadd authors blank cache document fonts global hype image-cache \
             license logo memory-cache mozilla plugins && ret=0
   else
-    if _wanted prefixes; then
+    _tags prefixes
+    while _tags; do
       while _next_label prefixes expl 'URL prefix'; do
         compadd "$expl[@]" -S '' about: mocha: javascript: && ret=0
         _urls "$@" && ret=0
       done
-    fi
+      (( ret )) || return 0
+    done
   fi
 fi
 
Index: Completion/User/_nslookup
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_nslookup,v
retrieving revision 1.1.1.11
diff -u -r1.1.1.11 _nslookup
--- Completion/User/_nslookup	2000/03/23 04:19:30	1.1.1.11
+++ Completion/User/_nslookup	2000/04/11 07:11:52
@@ -60,7 +60,7 @@
 
     _funcall ret _nslookup_redirect && return ret
 
-    _wanted -C redirection files || return 1
+    _tags -C redirection files || return 1
 
     if [[ "$words[1]" != (finger|ls) ]]; then
       _message "redirection not allowed for command \`$words[1]'"
Index: Completion/User/_rlogin
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_rlogin,v
retrieving revision 1.2
diff -u -r1.2 _rlogin
--- Completion/User/_rlogin	2000/04/05 11:28:09	1.2
+++ Completion/User/_rlogin	2000/04/11 07:11:52
@@ -28,7 +28,7 @@
     return ret
     ;;
   rcp)
-    local curcontext="$curcontext" state line ret=1
+    local curcontext="$curcontext" state line ret=1 expl
     typeset -A opt_args
 
     _arguments -C -s \
@@ -40,7 +40,7 @@
       if compset -P '*:'; then
 	_files && ret=0
       elif compset -P '*@'; then
-        _wanted hosts && _rlogin_hosts -S: -q && ret=0
+        _wanted hosts expl host _rlogin_hosts -S: -q && ret=0
       else
         _alternative \
 	    'files:: _files' \
@@ -54,11 +54,11 @@
 }
 
 _rlogin_users () {
-  _wanted users && _combination -s '[:@]' my-accounts users-hosts users "$@"
+  _tags users && _combination -s '[:@]' my-accounts users-hosts users "$@"
 }
 
 _rlogin_hosts () {
-  _wanted hosts &&
+  _tags hosts &&
       if [[ "$IPREFIX" == *@ ]]; then
         _combination -s '[:@]' my-accounts users-hosts "users=${IPREFIX/@}" hosts "$@"
       else
Index: Completion/User/_socket
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_socket,v
retrieving revision 1.1.1.13
diff -u -r1.1.1.13 _socket
--- Completion/User/_socket	2000/03/23 04:19:30	1.1.1.13
+++ Completion/User/_socket	2000/04/11 07:11:52
@@ -8,10 +8,11 @@
 local curcontext="$curcontext" state line expl
 typeset -A opt_args
 
-[[ $CURRENT -eq 2 ]] && _wanted options expl option &&
+[[ $CURRENT -eq 2 ]] &&
     { ! zstyle -T ":completion:${curcontext}:options" prefix-needed ||
       [[ "$PREFIX" = -* ]] } &&
-    compadd -M 'r:|[_-]=* r:|=*' "$expl[@]" - -version
+    _wanted options expl option \
+        compadd -M 'r:|[_-]=* r:|=*' "$expl[@]" - -version
 
 _arguments -C -s \
   '-b[background]' \
@@ -39,7 +40,7 @@
 
 arg1)
   if (( $+opt_args[-s] )); then
-    _wanted ports expl 'port to listen' _ports
+    _ports
   else
     _wanted hosts expl 'host' _combination '' hosts-ports hosts -
   fi
Index: Completion/User/_tiff
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_tiff,v
retrieving revision 1.4
diff -u -r1.4 _tiff
--- Completion/User/_tiff	2000/04/05 11:28:09	1.4
+++ Completion/User/_tiff	2000/04/11 07:11:52
@@ -195,12 +195,14 @@
       ;;
     esac
   else
-    if _wanted values; then
+    _tags values
+    while _tags; do
       while _next_label values expl 'compression scheme'; do
         compadd "$expl[@]" - none g4 packbits && ret=0
         compadd "$expl[@]" -qS: - lzw zip jpeg g3 && ret=0
       done
-    fi
+      (( ret )) || return 0
+    done
   fi
 fi
 
Index: Completion/User/_urls
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_urls,v
retrieving revision 1.3
diff -u -r1.3 _urls
--- Completion/User/_urls	2000/04/03 15:27:14	1.3
+++ Completion/User/_urls	2000/04/11 07:11:52
@@ -49,18 +49,22 @@
 
 if [[ "$1" = -f ]]; then
   shift
-  _wanted -C -f files && _files "$@" && return
+  _wanted -C -f files _files "$@" && return 0
 fi
 
 ipre="$IPREFIX"
 
-if ! compset -P '(#b)([-+.a-z0-9]#):' && _wanted -C argument prefixes; then
-  while _next_label prefixes expl 'URL prefix' "$@"; do
-    [[ -d $urls_path/bookmark ]] &&
-      compadd "$expl[@]" -S '' bookmark: && ret=0
-    compadd "$expl[@]" -S '' file: ftp:// gopher:// http:// && ret=0
+if ! compset -P '(#b)([-+.a-z0-9]#):'; then
+  _tags -C argument prefixes
+  while _tags; do
+    while _next_label prefixes expl 'URL prefix' "$@"; do
+      [[ -d $urls_path/bookmark ]] &&
+        compadd "$expl[@]" -S '' bookmark: && ret=0
+      compadd "$expl[@]" -S '' file: ftp:// gopher:// http:// && ret=0
+    done
+    (( ret )) || return 0
   done
-  return ret
+  return 1
 fi
 scheme="$match[1]"
 
@@ -73,17 +77,19 @@
   ;;
   file)
     if ! compset -P //; then
-      _wanted -C file files || return 1
-
-      while _next_label files expl 'local file' "$@"; do
-        if [[ -prefix / ]]; then
-	  _path_files "$expl[@]" -S '' -g '*(^/)' && ret=0
-	  _path_files "$expl[@]" -S/ -r '/' -/ && ret=0
-        elif [[ -z "$PREFIX" ]]; then
-	  compadd "$expl[@]" -S '/' -r '/' - "${PWD%/}" && ret=0
-        fi
+      _tags -C file files
+      while _tags; do
+        while _next_label files expl 'local file' "$@"; do
+          if [[ -prefix / ]]; then
+	    _path_files "$expl[@]" -S '' -g '*(^/)' && ret=0
+	    _path_files "$expl[@]" -S/ -r '/' -/ && ret=0
+          elif [[ -z "$PREFIX" ]]; then
+	    compadd "$expl[@]" -S '/' -r '/' - "${PWD%/}" && ret=0
+          fi
+        done
+	(( ret )) || return 0
       done
-      return ret
+      return 1
     fi
   ;;
   bookmark)
@@ -93,34 +99,40 @@
           compadd "$@" -U - \
               "$ipre$(<"$urls_path/$scheme/${(Q)PREFIX}${(Q)SUFFIX}")" && ret=0
     else
-      if _wanted -C bookmark files; then
+      _tags -C bookmark files
+      while _tags; do
         while _next_label files expl 'bookmark'; do
           _path_files -W "$urls_path/$scheme" "$expl[@]" -S '' -g '*(^/)' && 
               ret=0
           _path_files -W "$urls_path/$scheme" -S/ -r '/' -/ && ret=0
         done
-      fi
+	(( ret )) || return 0
+      done
     fi
     return ret
   ;;
 esac
 
 # Complete hosts
-if ! compset -P '(#b)([^/]#)/' && _wanted hosts; then
+if ! compset -P '(#b)([^/]#)/'; then
   uhosts=($urls_path/$scheme/$PREFIX*$SUFFIX(/:t))
 
-  while _next_label hosts expl host "$@"; do
-    (( $#uhosts )) || _hosts -S/ && ret=0
-    [[ "$scheme" = http ]] && uhosts=($uhosts $localhttp_servername)
-    compadd "$expl[@]" -S/ - $uhosts && ret=0
+  _tags hosts
+  while _tags; do
+    while _next_label hosts expl host "$@"; do
+      (( $#uhosts )) || _hosts -S/ && ret=0
+      [[ "$scheme" = http ]] && uhosts=($uhosts $localhttp_servername)
+      compadd "$expl[@]" -S/ - $uhosts && ret=0
+    done
+    (( ret )) || return 0
   done
-  return ret
+  return 1
 fi
 host="$match[1]"
 
 # Complete part after hostname
 
-_wanted -C local files || return 1
+_tags -C local files || return 1
 
 if [[ "$localhttp_servername" = "$host" ]]; then
   if compset -P \~; then
@@ -129,20 +141,29 @@
       return
     fi
     user="$match[1]"
-    while _next_label files expl 'local file'; do
-      _path_files "$expl[@]" -W ~$user/$localhttp_userdir -g '*(^/)' && ret=0
-      _path_files "$expl[@]" -W ~$user/$localhttp_userdir -S/ -r '/' -/ && ret=0
+    while _tags; do
+      while _next_label files expl 'local file'; do
+        _path_files "$expl[@]" -W ~$user/$localhttp_userdir -g '*(^/)' && ret=0
+        _path_files "$expl[@]" -W ~$user/$localhttp_userdir -S/ -r '/' -/ && ret=0
+      done
+      (( ret )) || return 0
     done
   else
-    while _next_label files expl 'local file'; do
-      _path_files "$expl[@]" -W $localhttp_documentroot -g '*(^/)' && ret=0
-      _path_files "$expl[@]" -W $localhttp_documentroot -S/ -r '/' -/ && ret=0
+    while _tags; do
+      while _next_label files expl 'local file'; do
+        _path_files "$expl[@]" -W $localhttp_documentroot -g '*(^/)' && ret=0
+        _path_files "$expl[@]" -W $localhttp_documentroot -S/ -r '/' -/ && ret=0
+      done
+      (( ret )) || return 0
     done
   fi
 else
-  while _next_label files expl 'local file'; do
-    _path_files "$expl[@]" -W $urls_path/$scheme/$host -g '*(^/)' && ret=0
-    _path_files "$expl[@]" -W $urls_path/$scheme/$host -S/ -r '/' -/ && ret=0
+  while _tags; do
+    while _next_label files expl 'local file'; do
+      _path_files "$expl[@]" -W $urls_path/$scheme/$host -g '*(^/)' && ret=0
+      _path_files "$expl[@]" -W $urls_path/$scheme/$host -S/ -r '/' -/ && ret=0
+    done
+    (( ret )) || return 0
   done
 fi
 return $ret
Index: Completion/User/_users
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_users,v
retrieving revision 1.2
diff -u -r1.2 _users
--- Completion/User/_users	2000/04/01 20:43:43	1.2
+++ Completion/User/_users	2000/04/11 07:11:52
@@ -2,9 +2,7 @@
 
 local expl users
 
-_wanted users || return 1
-
 zstyle -a ":completion:${curcontext}:" users users &&
-    _all_labels users expl user compadd "$@" - "$users[@]" && return 0
+    _wanted users expl user compadd "$@" - "$users[@]" && return 0
 
-_all_labels users expl user compadd "$@" - "${(@k)userdirs}"
+_wanted users expl user compadd "$@" - "${(@k)userdirs}"
Index: Completion/User/_users_on
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_users_on,v
retrieving revision 1.2
diff -u -r1.2 _users_on
--- Completion/User/_users_on	2000/04/01 20:43:43	1.2
+++ Completion/User/_users_on	2000/04/11 07:11:52
@@ -2,10 +2,8 @@
 
 local expl
 
-_wanted users || return 1
-
-if which users >/dev/null; then
-  _all_labels users expl 'users logged on' \
+if (( $+commands[users] )); then
+  _wanted users expl 'users logged on' \
       compadd "$@" - $(_call users users) && return 0
 else
   # Other methods of finding out users logged on should be added here
Index: Completion/User/_whois
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_whois,v
retrieving revision 1.1.1.8
diff -u -r1.1.1.8 _whois
--- Completion/User/_whois	2000/03/23 04:19:31	1.1.1.8
+++ Completion/User/_whois	2000/04/11 07:11:52
@@ -189,14 +189,14 @@
 }
 
 _whois_hosts () {
-  _wanted hosts &&
+  _tags hosts &&
     compadd "$@" \
       -M 'm:{a-zA-Z}={A-Za-z} r:|.=* r:|=*' \
       - ${_whois_servers%:?} || _hosts "$@"
 }
 
 _whois_ports () {
-  _wanted ports && compadd "$@" - whois || _ports "$@"
+  _tags ports && compadd "$@" - whois || _ports "$@"
 }
 
 (( $+functions[_whois:whois.internic.net] )) ||
Index: Completion/X/_x_colormapid
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_colormapid,v
retrieving revision 1.2
diff -u -r1.2 _x_colormapid
--- Completion/X/_x_colormapid	2000/04/01 20:43:43	1.2
+++ Completion/X/_x_colormapid	2000/04/11 07:11:52
@@ -2,7 +2,7 @@
 
 local expl list desc
 
-_wanted colormapids || return 1
+_tags colormapids || return 1
 
 list=(${(f)"$(xprop -root -f RGB_COLOR_MAP 32xcccccccxx ': $0\n'|awk -F'[ ():]' '/^[a-zA-Z_]+\(RGB_COLOR_MAP\)/ {print $5, "--", $1}')"})
 
@@ -12,5 +12,5 @@
   desc=()
 fi
 
-_all_labels colormapids expl 'colormap id' \
+_wanted colormapids expl 'colormap id' \
     compadd "$@" "$desc[@]" - "${(@)list%% *}" 
Index: Completion/X/_x_display
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_display,v
retrieving revision 1.2
diff -u -r1.2 _x_display
--- Completion/X/_x_display	2000/04/07 02:27:44	1.2
+++ Completion/X/_x_display	2000/04/11 07:11:52
@@ -1,3 +1,3 @@
 #autoload
 
-_wanted displays && _hosts -S ':0 ' -r :
+_tags displays && _hosts -S ':0 ' -r :
Index: Completion/X/_x_extension
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_extension,v
retrieving revision 1.2
diff -u -r1.2 _x_extension
--- Completion/X/_x_extension	2000/04/01 20:43:43	1.2
+++ Completion/X/_x_extension	2000/04/11 07:11:52
@@ -2,18 +2,18 @@
 
 local expl
 
-_wanted extensions || return 1
+_tags extensions || return 1
 
 (( $+_xe_cache )) || _xe_cache=( "${(@)${(@f)$(xdpyinfo)}[(r)number of extensions:*,-1][2,(r)default screen number:*][1,-2]//[      ]}" )
 
 if [[ "$1" = -a ]]; then
   shift
 
-  _all_labels extensions expl 'X extensions' \
+  _wanted extensions expl 'X extensions' \
       compadd "$@" -M 'm:{a-z}={A-Z} r:|-=* r:|=*' - all "$_xe_cache[@]"
 else
   [[ "$1" = - ]] && shift
 
-  _all_labels extensions expl 'X extensions' \
+  _wanted extensions expl 'X extensions' \
       compadd "$@" -M 'm:{a-z}={A-Z} r:|-=* r:|=*' - "$_xe_cache[@]"
 fi
Index: Completion/X/_x_font
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_font,v
retrieving revision 1.2
diff -u -r1.2 _x_font
--- Completion/X/_x_font	2000/04/01 20:43:43	1.2
+++ Completion/X/_x_font	2000/04/11 07:11:52
@@ -2,7 +2,7 @@
 
 local expl
 
-_wanted fonts || return 1
+_tags fonts || return 1
 
 # This *has* to be improved some day...
 
@@ -12,5 +12,5 @@
  _font_cache=( "${(@)^${(@f)$(_call fonts xlsfonts)}%%--*}--" )
 fi
 
-_all_labels fonts expl font \
+_wanted fonts expl font \
     compadd -M 'r:|-=* r:|=*' "$@" -S '' - "$_font_cache[@]"
Index: Completion/X/_x_keysym
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_keysym,v
retrieving revision 1.2
diff -u -r1.2 _x_keysym
--- Completion/X/_x_keysym	2000/04/01 20:43:43	1.2
+++ Completion/X/_x_keysym	2000/04/11 07:11:52
@@ -2,7 +2,7 @@
 
 local expl
 
-_wanted keysyms || return 1
+_tags keysyms || return 1
 
 if (( ! $+_keysym_cache )); then
   local file
@@ -18,5 +18,5 @@
   fi
 fi
 
-_all_labels keysyms expl 'key symbol' \
+_wanted keysyms expl 'key symbol' \
     compadd "$@" -M 'm:{a-z}={A-Z} r:|-=* r:|=*' - $_keysym_cache
Index: Completion/X/_x_window
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_x_window,v
retrieving revision 1.2
diff -u -r1.2 _x_window
--- Completion/X/_x_window	2000/04/01 20:43:43	1.2
+++ Completion/X/_x_window	2000/04/11 07:11:52
@@ -2,17 +2,17 @@
 
 local list expl
 
-_wanted windows || return 1
+_tags windows || return 1
 
 list=( "${(@)${(M@)${(@f)$(_call windows xwininfo -root -tree)}:#[ 	]#0x[0-9a-f]# \"*}##[ 	]#}" )
 
 if [[ "$1" = -n ]]; then
   shift
 
-  _all_labels windows expl 'window name' \
+  _wanted windows expl 'window name' \
       compadd "$@" -d list - "${(@)${(@)list#*\"}%%\"*}"
 else
   [[ "$1" = - ]] && shift
 
-  _all_labels windows expl 'window ID' compadd "$@" -d list - "${(@)list%% *}"
+  _wanted windows expl 'window ID' compadd "$@" -d list - "${(@)list%% *}"
 fi
Index: Completion/X/_xmodmap
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_xmodmap,v
retrieving revision 1.3
diff -u -r1.3 _xmodmap
--- Completion/X/_xmodmap	2000/04/03 15:27:14	1.3
+++ Completion/X/_xmodmap	2000/04/11 07:11:52
@@ -82,12 +82,14 @@
     [[ "$what" = *ksym* ]] && _x_keysym "$suf[@]" && ret=0
 
   else
-    if _wanted commands; then
+    _tags commands
+    while _tags; do
       while _next_label commands expl command; do
         compadd "$expl[@]" -S ' ' keycode keysym clear add remove && ret=0
         compadd "$expl[@]" -S ' = ' pointer && ret=0
       done
-    fi
+      (( ret )) || return 0
+    done
   fi
 fi
 
Index: Completion/X/_xutils
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_xutils,v
retrieving revision 1.3
diff -u -r1.3 _xutils
--- Completion/X/_xutils	2000/04/05 11:28:09	1.3
+++ Completion/X/_xutils	2000/04/11 07:11:52
@@ -55,23 +55,29 @@
     if [[ "$tmp" = *:* ]]; then
       if compset -P '(#b)(*):'; then
 	type="$match[1]"
-	_wanted displays &&
-            while _next_label displays expl 'disallow access'; do
+	_tags displays
+	while _tags; do
+          while _next_label displays expl 'disallow access'; do
 	      { compadd "$expl[@]" -M 'm:{a-z}={A-Z} r:|[:.]=* r:|=*' - \
 		        ${${(M)tmp:#(#i)$type:*}#(#i)$type:} ||
-	            _hosts "$expl[@]" } && return 0
-	    done
+	            _hosts "$expl[@]" } && ret=0
+	  done
+	  (( ret )) || return 0
+        done
       else
 	_alternative \
 	    'types:name family:compadd -S: ${(L)tmp%%:*}' \
 	    'hosts:host:compadd ${(@)tmp#*:}' && ret=0
       fi
     else
-      _wanted displays &&
-          while _next_label displays expl 'disallow access'; do
-	    { compadd "$expl[@]" -M 'm:{a-z}={A-Z} r:|[:.]=* r:|=*' - $tmp ||
-              _hosts "$expl[@]" } && return 0
-          done
+      _tags displays
+      while _tags; do
+        while _next_label displays expl 'disallow access'; do
+	  { compadd "$expl[@]" -M 'm:{a-z}={A-Z} r:|[:.]=* r:|=*' - $tmp ||
+            _hosts "$expl[@]" } && ret=0
+        done
+	(( ret )) || return 0
+      done
     fi
   else
     compset -P +
Index: Completion/X/_xwit
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_xwit,v
retrieving revision 1.2
diff -u -r1.2 _xwit
--- Completion/X/_xwit	2000/04/01 20:43:43	1.2
+++ Completion/X/_xwit	2000/04/11 07:11:52
@@ -17,7 +17,7 @@
 _xwit_compopts () {
   local expl
   _wanted options expl option compadd - ${(k)no[(R)*~0]} ||
-      _all_labels options expl option compadd - ${(k)no}
+      _wanted options expl option compadd - ${(k)no}
 }
 
 _regex_arguments _xwit_parse \
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.14
diff -u -r1.14 compsys.yo
--- Doc/Zsh/compsys.yo	2000/04/10 23:40:44	1.14
+++ Doc/Zsh/compsys.yo	2000/04/11 07:11:53
@@ -945,15 +945,19 @@
 
 If the tt(file-patterns) style is set, the default tags are not
 used. Instead, the value of the style says which tags and which
-patterns are to be offered. The strings in the value are of the form
-`var(patterns)tt(:)var(tag)'. The var(patterns) gives one or more glob 
-patterns separated by spaces that are to be used to generate
+patterns are to be offered. The strings in the value contain
+specifications of the form
+`var(patterns)tt(:)var(tag)'; each string may contain any number of
+such specifications. The var(patterns) give one or more glob 
+patterns separated by commas that are to be used to generate
 filenames. If it contains the sequence `tt(%p)', that is replaced by
 the pattern(s) given by the calling function.
 Colons in the pattern have to be preceded by a backslash to
 make them distinguishable from the colon before the var(tag). The
 var(tag)s of all strings in the value will be offered by tt(_files)
-(again, one after another) and used when looking up other styles. If
+(again, one after another) and used when looking up other styles. For
+strings containing more than one specification, the filenames for all
+specifications will be generated at the same try. If
 no `tt(:)var(tag)' is given the `tt(files)' tag will be used. The
 var(tag) may also be
 followed by an optional second colon and a description. If that is
@@ -978,7 +982,7 @@
 achieve this, one could do:
 
 example(zstyle ':completion:*' file-patterns \ 
-    '%p *(-/):globbed-files' '*:all-files')
+    '%p:globbed-files *(-/):directories' '*:all-files')
 
 Note also that during the execution of completion functions, the
 tt(EXTENDED_GLOB) option is in effect, so the characters `tt(#)',
@@ -2216,22 +2220,12 @@
 completion, if any, is always unique.
 )
 findex(_next_tags)
-item(tt(_next_tags))(
+item(tt(_next_tags) (^Xn))(
 This allows to complete types of matches that are not immediately
 offered because of the setting of the tt(tag-order) style. After a
 normal completion was tried, invoking this command makes the matches
 for the next tag (or set of tags) be used. Repeatedly invoking this
-command makes the following tags be used. To be able to complete the
-matches selected by tt(_next_tags), the tt(completer) style should
-contain tt(_next_tags) as its first string. With that, the normal key
-binding (normally tt(TAB)) can be used to complete the matches shown
-after the call to tt(_next_tags).
-
-Normally, this command is not bound to a key. To invoke it with, say
-`tt(^Xn)', one would use:
-
-example(zle -C _next_tags complete-word _next_tags
-bindkey '^Xn' _next_tags)
+command makes the following tags be used.
 )
 findex(_read_comp (^X^R))
 item(tt(_read_comp (^X^R)))(
@@ -2442,20 +2436,21 @@
 tt(_next_label).
 
 Note that this function must not be called without a previous call to
-tt(_tags), tt(_wanted) or tt(_requested) because it uses the tag label
+tt(_tags) or tt(_requested) because it uses the tag label
 for the current tag found by these functions.
 
 A normal use of this function for the tag labels for the tag tt(foo)
 looks like this:
 
 example(local expl ret=1
-...
-_wanted foo || return 1
 ...
-while _next_label foo expl '...'; do
-  compadd "$expl[@]" ... && ret=0
-done
-...
+if _requested foo; then
+  ...
+  while _next_label foo expl '...'; do
+    compadd "$expl[@]" ... && ret=0
+  done
+  ...
+fi
 return ret
 )
 )
@@ -2476,10 +2471,11 @@
 For example:
 
 example(local expl
-...
-_wanted foo || return 1
 ...
-_all_labels foo expl '...' compadd ... - $matches)
+if _requested foo; then
+  ...
+  _all_labels foo expl '...' compadd ... - $matches
+fi)
 
 Will complete the strings from the tt(matches) parameter, using
 tt(compadd) with additional options which will take precedence over
@@ -2525,7 +2521,7 @@
 done)
 )
 findex(_wanted)
-item(tt(_wanted) [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(specs) ... ])(
+item(tt(_wanted) [ tt(-12VJ) ] var(tag) var(name) var(descr) var(command) var(args) ...)(
 In many contexts only one type of matches can be generated but even
 then it should be tested if the tag representing those matches is
 requested by the user. This function makes that easier.
@@ -2538,6 +2534,10 @@
 
 example(_wanted tag expl 'description' \ 
     compadd matches...)
+
+Unlike tt(_requested), however, tt(_wanted) can not be called without
+the var(command). That's because tt(_wanted) also implements the loop
+over the tags, not only the one for the labels.
 )
 findex(_alternative)
 item(tt(_alternative) [ tt(-C) var(name) ] var(specs) ...)(
Index: Etc/completion-style-guide
===================================================================
RCS file: /cvsroot/zsh/zsh/Etc/completion-style-guide,v
retrieving revision 1.2
diff -u -r1.2 completion-style-guide
--- Etc/completion-style-guide	2000/04/01 20:43:44	1.2
+++ Etc/completion-style-guide	2000/04/11 07:11:53
@@ -63,12 +63,12 @@
 Then, before adding the matches, see if matches of that type are
 requested by the user in the current context. If you will add only one 
 type of matches, this is very simple. You can use the function
-`_wanted' for this. Its return value is zero only if the type of
-matches is requested by the user, so you can just do:
+`_wanted' for this. Well, you can often use it, that is. Use it as in:
 
-  _wanted names || return 1
+  _wanted names expl 'name' compadd - alice bob
 
-  _all_labels names expl 'name' compadd - alice bob
+This is like testing if the tag `names' is requested by the user and
+then calling `_all_labels' with the same arguments.
 
 The `_all_labels' function implements the loop over the tag aliases and
 handles the user-defined description, using (in the example) the
@@ -88,13 +88,6 @@
 And the `-' will be replaced by the options that are to be given to
 `compadd'.
 
-Since the above sequence of command is used so often, the `_wanted'
-function can also accept the same arguments as `_all_labels'. In this
-case it will do the test for the requested tag and then just call
-`_all_labels', so:
-
-  _wanted names expl 'name' compadd - alice bob
-
 Note that you can also give the `-J' and `-V' options with the
 optional `1' or `2' preceding them supported by `_description':
 
@@ -332,11 +325,11 @@
 explanation to the same function that is used to test if the tags are
 requested (again: see above). Just as a reminder:
 
-  _wanted [ -[1,2]V | -[1,2]J ] <tag> expl <descr>
+  _wanted [ -[1,2]V | -[1,2]J ] <tag> expl <descr> <cmd> ...
 
 and
 
-  _requested [ -[1,2]V | -[1,2]J ] <tag> expl <descr>
+  _requested [ -[1,2]V | -[1,2]J ] <tag> expl <descr> [ <cmd> ... ]
 
 is all you need to make your function work correctly with both tags
 and description at the same time.
Index: Functions/Zftp/zfcd_match
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zftp/zfcd_match,v
retrieving revision 1.3
diff -u -r1.3 zfcd_match
--- Functions/Zftp/zfcd_match	2000/04/04 19:34:51	1.3
+++ Functions/Zftp/zfcd_match	2000/04/11 07:11:53
@@ -30,7 +30,7 @@
   rm -f $tmpf
   [[ -n $dir && $dir != */ ]] && dir="$dir/"
   if [[ -n $WIDGET ]]; then
-    _all_labels directories expl 'remote directory'
+    _wanted directories expl 'remote directory'
         compadd -S/ -q -P "$dir" - $reply
   elif [[ -n $dir ]]; then
     reply=(${dir}$reply)
Index: Functions/Zftp/zfget_match
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zftp/zfget_match,v
retrieving revision 1.2
diff -u -r1.2 zfget_match
--- Functions/Zftp/zfget_match	2000/04/01 20:49:47	1.2
+++ Functions/Zftp/zfget_match	2000/04/11 07:11:53
@@ -17,7 +17,7 @@
     local reply
     reply=(${${${(f)"$(<$tmpf)"}##$dir}%\*})
     rm -f $tmpf
-    _all_labels files expl 'remote file' compadd -P $dir - $reply
+    _wanted files expl 'remote file' compadd -P $dir - $reply
   else
     # On the first argument to ls, we usually get away with a glob.
     zftp ls "$1*$2" >$tmpf
@@ -28,7 +28,7 @@
   local fcache_name
   zffcache
   if [[ -n $WIDGET ]]; then
-    _all_labels files expl 'remote file' compadd -F fignore - ${(P)fcache_name}
+    _wanted files expl 'remote file' compadd -F fignore - ${(P)fcache_name}
   else
     reply=(${(P)fcache_name});
   fi
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.4
diff -u -r1.4 computil.c
--- Src/Zle/computil.c	2000/04/04 12:56:40	1.4
+++ Src/Zle/computil.c	2000/04/11 07:11:54
@@ -2291,7 +2291,7 @@
     case 'N': min = 0; max =  0; break;
     case 'R': min = 1; max =  1; break;
     case 'S': min = 1; max =  1; break;
-    case 'A': min = 2; max =  2; break;
+    case 'A': min = 2; max =  3; break;
     default:
 	zwarnnam(nam, "invalid option: %s", args[0], 0);
 	return 1;
@@ -2365,6 +2365,14 @@
 		}
 		s->ptr = q + 1;
 		setsparam(args[2], ztrdup(*v == '-' ? dyncat(args[1], v) : v));
+		if (args[3]) {
+		    char *r = dupstring(*q), *p;
+
+		    for (p = r + (v - *q); *p && *p != ':'; p++);
+		    *p = '\0';
+
+		    setsparam(args[3], ztrdup(r));
+		}
 		return 0;
 	    }
 	    return 1;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

