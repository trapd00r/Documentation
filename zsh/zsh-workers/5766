From zsh-workers-return-5766-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Mar 12 08:35:45 1999
Return-Path: <zsh-workers-return-5766-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1153 invoked from network); 12 Mar 1999 08:35:42 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Mar 1999 08:35:42 -0000
Received: (qmail 4864 invoked by alias); 12 Mar 1999 08:35:11 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5766
Received: (qmail 4844 invoked from network); 12 Mar 1999 08:35:10 -0000
Date: Fri, 12 Mar 1999 09:35:07 +0100 (MET)
Message-Id: <199903120835.JAA02533@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Thu, 11 Mar 1999 20:51:39 +0300
Subject: RE: _path_files and completeinword


Andrej Borsenkow wrote:

> > `_path_files' does the matching itself -- and sometimes things get too
> > hard for it.
> > To allow `-g ...' patterns, it has to append these patterns to the
> > string from the line and then use that to generate filenames.
> 
> Sorry? I don't understand it. The meaning of `-g'  is: "take as possible
> matches the files that match given glob pattern(s)". The matches are only
> *possible* - that is, they still have to match comand line to be included in
> completion list.
> If _path_files does something else, that means
> 
>  - it implements different completion as was always used in zsh
>  - this is a bug
> 
> If we return to example (/t/s/z/D/z<CURSOR>i - implying
> /tools/src/zsh-xxx/Doc/zsh.texi), then it means, that _path_files should
> take a list of files in /tools/src/zsh-xxx/Doc that match given glob pattern
> (let it be *.texi) and then match them against z*i.

Well I never said that `_path_files' behaves exactly like
`comp{ctl,gen}', but maybe it should try harder...
I wanted to do everything in one step, making it fast, but after
trying it, I realised that supporting this doesn't make things too
slow.

Bye
 Sven

diff -u oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Thu Mar 11 14:58:36 1999
+++ Completion/Core/_path_files	Fri Mar 12 09:32:32 1999
@@ -22,7 +22,7 @@
 
 local nm prepaths str linepath realpath donepath patstr prepath testpath rest
 local tmp1 collect tmp2 suffixes i ignore matchflags opt group sopt pats gopt
-local addpfx addsfx expl orig ostr nm=$compstate[nmatches] menu remsfx
+local addpfx addsfx expl orig ostr nm=$compstate[nmatches] menu remsfx patlast
 
 setopt localoptions nullglob rcexpandparam extendedglob
 unsetopt markdirs globsubst shwordsplit nounset
@@ -200,6 +200,25 @@
 
 patstr="$patstr:gs-/-*/-:gs/*.*./../:gs-/*.-/.-:gs/**/*/:gs-.*/-./-"
 
+# We take the last pathname component from the pattern and store it in
+# `patlast', replacing `*'s in it with patterns that match any character
+# but not slashes. Later we will generate matches using `patstr' with the
+# patterns we were given (like `*.c') appended to it, producing all matching
+# files. These filenames are then compared to `patlast' and all names not
+# matching that will be removed. All this is needed to be able to correctly
+# support `completeinword' as otherwise we would have something like `a*x'
+# from the line (the `*' was inserted above) and appending the `-g' pattern
+# `*.tex' would yield `a*x*.tex' which is not what we want.
+
+if [[ "$patstr" = */* ]]; then
+  patlast="*/${${patstr##*/}//\*/[^/]#}"
+  patstr="${patstr%/*}/"
+else
+  patlast="${patstr//\*/[^/]#}"
+  patstr=""
+fi
+
+
 # First we skip over all pathname components in `str' which really exist in
 # the file-system, so that `/usr/lib/l<TAB>' doesn't offer you `lib' and
 # `lib5'. Pathname components skipped this way are taken from `orig' and added
@@ -207,6 +226,7 @@
 
 while [[ "$orig" = */* ]] do
   tmp1=( ${~matchflags}$realpath$donepath${orig%%/*}/${~patstr#*/}$^pats )
+  tmp1=("${(@M)tmp1:#$~patlast}")
   [[ $#tmp1 -gt 0 && -e "$realpath$donepath${orig%%/*}" ]] || break
   donepath="$donepath${orig%%/*}/"
   orig="${orig#*/}"
@@ -261,6 +281,7 @@
 
       for i in "$tmp1[@]" ; do
         tmp2=( ${~i}/${~matchflags}${~suffixes} )
+        tmp2=("${(@M)tmp2:#$~patlast}")
         [[ $#tmp2 -ne 0 ]] && collect=( $collect $i )
       done
 
@@ -282,6 +303,7 @@
 	# Now produce all matching pathnames in `collect'.
 
         collect=( ${~collect}/${~matchflags}${~suffixes} )
+	collect=("${(@M)collect:#$~patlast}")
 
 	# And then remove the common path prefix from all these matches.
 
@@ -296,14 +318,14 @@
 
 	if [[ -n "$menu" ]]; then
           compadd -QU "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
-                  -i "$IPREFIX" -p "${linepath:q}${testpath:q}" \
+                  -i "$IPREFIX" -p "$linepath${testpath:q}" \
 		  -S "/${ostr#*/}" \
 		  -W "$tmp1" -f "$ignore[@]" - "${(@)${(@)collect%%/*}:q}"
 	else
           for i in $collect; do
-            compadd -U "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
-	            -i "$IPREFIX" -p "$linepath$testpath" -s "/${i#*/}" \
-		    -M 'r:|/=*' -W "$tmp1" -f "$ignore[@]" - "${i%%/*}"
+            compadd -QU "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
+	            -i "$IPREFIX" -p "$linepath${testpath:q}" -s "/${${i#*/}:q}" \
+		    -M 'r:|/=*' -W "$tmp1" -f "$ignore[@]" - "${${i%%/*}:q}"
           done
 	fi
 
@@ -337,6 +359,8 @@
   suffixes=( $str$^pats )
   suffixes=( "${(@)suffixes:gs.**.*.}" )
   tmp2=( ${~tmp1}${~matchflags}${~suffixes} )
+  tmp2=("${(@M)tmp2:#$~patlast}")
+
   if [[ $#tmp2 -eq 0 ]]; then
     # No match, insert the expanded path and add the original tail.
 
@@ -347,11 +371,11 @@
     [[ "$linepath$testpath$ostr" = "$PREFIX$SUFFIX" ]] && return 1
 
     compadd -QU -S '' "$group[@]" "$expl[@]" \
-            -i "$IPREFIX" -f - "${linepath:q}${testpath:q}$ostr"
+            -i "$IPREFIX" -f - "$linepath${testpath:q}$ostr"
   else
-    compadd -U "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" "$group[@]" "$expl[@]" \
-            -i "$IPREFIX" -p "$linepath$testpath" -f "$ignore[@]" \
-	    -W "$prepath$realpath$testpath" - "${(@)tmp2#$tmp1}"
+    compadd -QU "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" "$group[@]" "$expl[@]" \
+            -i "$IPREFIX" -p "$linepath${testpath:q}" -f "$ignore[@]" \
+	    -W "$prepath$realpath$testpath" - "${(@)${(@)tmp2#$tmp1}:q}"
   fi
 done
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

