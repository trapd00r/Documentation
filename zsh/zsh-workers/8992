From zsh-workers-return-8992-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Dec 10 14:20:36 1999
Return-Path: <zsh-workers-return-8992-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24663 invoked from network); 10 Dec 1999 14:20:29 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Dec 1999 14:20:29 -0000
Received: (qmail 23078 invoked by alias); 10 Dec 1999 14:20:21 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8992
Received: (qmail 23070 invoked from network); 10 Dec 1999 14:20:19 -0000
Date: Fri, 10 Dec 1999 15:20:17 +0100 (MET)
Message-Id: <199912101420.PAA06240@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: zstyle


As discussed, this adds the zutil module with currently only two
builtins: zformat and zstyle.

zformat is just the replacement for compdisplay and compfmt. The
latter has been enhanced to allow field widths between the % and the
char and since it is used everywhere in the completion system, you can 
now do things like:

  zstyle ':completion:*:descriptions' format '%-20.30d'

This also shows the new way to define styles -- using
zstyle. compstyle is still there, but, like compconf, will be removed
some day. For now compstyle does the same as zstyle, but prepends the
`:completion' to the pattern.


To convert your stuff to the zstyle form you can just start a shell as 
always and then use `zstyle -L' to get the equivalent forms with calls 
to zstyle.


Ok, in the completion functions, only zstyle is used now (this is what 
makes the patch so big). See there or the style guide for how to use
zstyle (or the doc for the zutil module, of course).


This means that Completion/Core/_style should be removed now.


Bye
 Sven

P.S.: Now I'm curious if zstyle gets used elsewhere... or even zformat.

diff -ru ../z.old/Completion/Base/_arguments Completion/Base/_arguments
--- ../z.old/Completion/Base/_arguments	Thu Dec  9 15:56:03 1999
+++ Completion/Base/_arguments	Fri Dec 10 11:30:07 1999
@@ -162,7 +162,7 @@
   esac
 done
 
-_style -s options auto-description autod
+zstyle -s ":completion${curcontext}:options" auto-description autod
 
 if (( $# )) && comparguments -i "$autod" "$@"; then
   local nm="$compstate[nmatches]" action noargs aret expl local
@@ -258,7 +258,7 @@
       fi
 
       if [[ -z "$matched" ]] && _requested options &&
-          { ! _style options prefix-needed ||
+          { ! zstyle -t ":completion${curcontext}:options" prefix-needed ||
             [[ "$origpre" = [-+]* ]] } ; then
 	local prevpre="$PREFIX" previpre="$IPREFIX"
 
diff -ru ../z.old/Completion/Base/_combination Completion/Base/_combination
--- ../z.old/Completion/Base/_combination	Thu Dec  9 15:56:03 1999
+++ Completion/Base/_combination	Fri Dec 10 14:34:39 1999
@@ -78,7 +78,7 @@
 num="${${1##*:}:-1}"
 shift
 
-if _style -a "$tag" "$style" tmp; then
+if zstyle -a ":completion${curcontext}:$tag" "$style" tmp; then
   eval "tmp=( \"\${(@M)tmp:#\${(j($sep))~pats}}\" )"
   if (( keys[(in:num:)$key] != 1 )); then
     eval "tmp=( \${tmp#\${(j(${sep}))~\${(@)\${(@)keys[2,(rn:num:)\$key]}/*/*}}$sep} )"
diff -ru ../z.old/Completion/Base/_describe Completion/Base/_describe
--- ../z.old/Completion/Base/_describe	Thu Dec  9 15:56:03 1999
+++ Completion/Base/_describe	Fri Dec 10 11:30:08 1999
@@ -16,7 +16,7 @@
 
 _tags "$_type" || return 1
 
-_style "$_type" verbose && _showd=yes
+zstyle -t ":completion${curcontext}:$_type" verbose && _showd=yes
 
 _description "$_type" _expl "$1"
 shift
@@ -27,7 +27,8 @@
   compdescribe -i "$@"
 fi
 
-[[ "$_type" = options ]] && _style options prefix-hidden && _hide=yes
+[[ "$_type" = options ]] &&
+    zstyle -t ":completion${curcontext}:options" prefix-hidden && _hide=yes
 
 while compdescribe -g _args _tmpd _tmpmd _tmps _tmpms; do
 
diff -ru ../z.old/Completion/Base/_first Completion/Base/_first
--- ../z.old/Completion/Base/_first	Thu Dec  9 15:56:03 1999
+++ Completion/Base/_first	Fri Dec 10 11:30:08 1999
@@ -50,7 +50,7 @@
 #       # We first search in the last ten words, then in the last
 #       # twenty words, and so on...
 #       while [[ i -le max ]]; do
-#         if _style history-words sort; then
+#         if zstyle -t ":completion${curcontext}:history-words" sort; then
 #           _description history-words expl "history ($n)"
 #         else
 #           _description -V history-words expl "history ($n)"
diff -ru ../z.old/Completion/Base/_jobs Completion/Base/_jobs
--- ../z.old/Completion/Base/_jobs	Thu Dec  9 15:56:03 1999
+++ Completion/Base/_jobs	Fri Dec 10 11:30:08 1999
@@ -4,9 +4,10 @@
 
 _tags jobs || return 1
 
-_style jobs prefix-needed && [[ "$PREFIX" != %* ]] && return 1
-_style jobs prefix-hidden && pfx=''
-_style jobs verbose       && desc=yes
+zstyle -t ":completion${curcontext}:jobs" prefix-needed &&
+    [[ "$PREFIX" != %* ]] && return 1
+zstyle -t ":completion${curcontext}:jobs" prefix-hidden && pfx=''
+zstyle -t ":completion${curcontext}:jobs" verbose       && desc=yes
 
 if [[ "$1" = -r ]]; then
   jids=( "${(@k)jobstates[(R)running*]}" )
@@ -30,7 +31,7 @@
   done
 fi
 
-if _style jobs strings; then
+if zstyle -t ":completion${curcontext}:jobs" strings; then
   local texts i text str tmp
 
   # Find shortest unambiguous strings.
diff -ru ../z.old/Completion/Base/_regex_arguments Completion/Base/_regex_arguments
--- ../z.old/Completion/Base/_regex_arguments	Thu Dec  9 15:56:04 1999
+++ Completion/Base/_regex_arguments	Fri Dec 10 11:30:08 1999
@@ -330,7 +330,7 @@
   local i state next
 
   local cache_dir
-  _style -s regex cache-path cache_dir
+  zstyle -s ":completion${curcontext}:regex" cache-path cache_dir
   [[ -z "$cache_dir" ]] && cache_dir="$HOME/.zsh/regex_arguments"
   local cache_file="$cache_dir/$1"
   local cache_test
diff -ru ../z.old/Completion/Base/_subscript Completion/Base/_subscript
--- ../z.old/Completion/Base/_subscript	Thu Dec  9 15:56:04 1999
+++ Completion/Base/_subscript	Fri Dec 10 11:30:09 1999
@@ -21,14 +21,14 @@
   while _tags; do
     if _requested -V indexes expl 'array index'; then
       ind=( {1..${#${(P)${compstate[parameter]}}}} )
-      if _style indexes verbose; then
+      if zstyle -t ":completion${curcontext}:indexes" verbose; then
         list=()
         for i in "$ind[@]"; do
           [[ "$i" = ${PREFIX}*${SUFFIX} ]] &&
               list=( "$list[@]" 
 	             "${i}:$(print -D ${(P)${compstate[parameter]}[$i]})" )
         done
-        compdisplay list ' -- ' "$list[@]"
+        zformat -a list ' -- ' "$list[@]"
 	disp=( -d list)
       else
         disp=()
diff -ru ../z.old/Completion/Base/_tilde Completion/Base/_tilde
--- ../z.old/Completion/Base/_tilde	Thu Dec  9 15:56:04 1999
+++ Completion/Base/_tilde	Fri Dec 10 11:30:09 1999
@@ -22,9 +22,9 @@
       compadd "$suf[@]" "$expl[@]" "$@" - "${(@k)nameddirs}"
 
   if _requested -V directory-stack expl 'directory stack' &&
-     { ! _style directory-stack prefix-needed ||
+     { ! zstyle -t ":completion${curcontext}:directory-stack" prefix-needed ||
        [[ "$PREFIX" = [-+]* ]] }; then
-    if _style directory-stack verbose; then
+    if zstyle -t ":completion${curcontext}:directory-stack" verbose; then
       integer i
 
       lines=("${PWD}" "${dirstack[@]}")
diff -ru ../z.old/Completion/Builtins/_pids Completion/Builtins/_pids
--- ../z.old/Completion/Builtins/_pids	Thu Dec  9 15:56:06 1999
+++ Completion/Builtins/_pids	Fri Dec 10 11:30:09 1999
@@ -12,11 +12,11 @@
   shift 2
 fi
 
-_style -a ps list-arguments listargs
-_style -a ps arguments args
+zstyle -a ":completion${curcontext}:ps" list-arguments listargs
+zstyle -a ":completion${curcontext}:ps" arguments args
 (( $#listargs )) || listargs=( "$args[@]" )
 
-if _style processes verbose; then
+if zstyle -t ":completion${curcontext}:processes" verbose; then
   list=("${(@Mr:COLUMNS-1:)${(f@)$(command ps $listargs 2>/dev/null)}[2,-1]:#[ 	]#${PREFIX}[0-9]#${SUFFIX}[ 	]*${~match}}")
   desc=(-ld list)
 else
diff -ru ../z.old/Completion/Builtins/_popd Completion/Builtins/_popd
--- ../z.old/Completion/Builtins/_popd	Thu Dec  9 15:56:07 1999
+++ Completion/Builtins/_popd	Fri Dec 10 11:30:09 1999
@@ -11,9 +11,10 @@
 
 _wanted -V directory-stack expl 'directory stack' || return 1
 
-! _style directory-stack prefix-needed || [[ $PREFIX = [-+]* ]] || return 1
+! zstyle -t ":completion${curcontext}:directory-stack" prefix-needed ||
+    [[ $PREFIX = [-+]* ]] || return 1
 
-if _style directory-stack verbose; then
+if zstyle -t ":completion${curcontext}:directory-stack" verbose; then
   # get the list of directories with their canonical number
   # and turn the lines into an array, removing the current directory
   lines=("${PWD}" "${dirstack[@]}")
diff -ru ../z.old/Completion/Builtins/_sched Completion/Builtins/_sched
--- ../z.old/Completion/Builtins/_sched	Thu Dec  9 15:56:07 1999
+++ Completion/Builtins/_sched	Fri Dec 10 11:30:09 1999
@@ -7,7 +7,7 @@
     _wanted -C - jobs expl 'scheduled jobs' || return 1
 
     lines=(${(f)"$(sched)"})
-    if _style jobs verbose; then
+    if zstyle -t ":completion${curcontext}:jobs" verbose; then
       disp=( -ld lines )
     else
       disp=()
diff -ru ../z.old/Completion/Builtins/_signals Completion/Builtins/_signals
--- ../z.old/Completion/Builtins/_signals	Thu Dec  9 15:56:09 1999
+++ Completion/Builtins/_signals	Fri Dec 10 11:30:10 1999
@@ -21,11 +21,12 @@
 [[ "$1" = -(|-) ]] && shift
 
 if _wanted signals expl signal &&
-       { [[ -z "$minus" ]] || ! _style signals prefix-needed ||
+       { [[ -z "$minus" ]] ||
+         ! zstyle -t ":completion${curcontext}:signals" prefix-needed ||
          [[ "$PREFIX" = -* ]] } ; then
   local disp tmp
 
-  if _style signals prefix-hidden; then
+  if zstyle -t ":completion${curcontext}:signals" prefix-hidden; then
     tmp=( "${(@)signals[1,last]}" )
     disp=(-d tmp)
   else
diff -ru ../z.old/Completion/Builtins/_stat Completion/Builtins/_stat
--- ../z.old/Completion/Builtins/_stat	Thu Dec  9 15:56:08 1999
+++ Completion/Builtins/_stat	Fri Dec 10 11:30:10 1999
@@ -9,7 +9,8 @@
 
   while _tags; do
     _requested options expl 'inode element' &&
-        { ! _style options prefix-needed || [[ "$PREFIX[1]" = + ]] } &&
+        { ! zstyle -t ":completion${curcontext}:options" prefix-needed ||
+          [[ "$PREFIX[1]" = + ]] } &&
         compadd "$expl[@]" - +device +inode +mode +nlink +uid +gid +rdev \
                              +size +atime +mtime +ctime +blksize +block +link
     fi
diff -ru ../z.old/Completion/Commands/_history_complete_word Completion/Commands/_history_complete_word
--- ../z.old/Completion/Commands/_history_complete_word	Thu Dec  9 15:56:10 1999
+++ Completion/Commands/_history_complete_word	Fri Dec 10 11:30:10 1999
@@ -25,9 +25,9 @@
     direction=older
   fi
 
-  _style -s history-words stop stop
+  zstyle -s ":completion${curcontext}:history-words" stop stop
 
-  _style history-words list || compstate[list]=''
+  zstyle -t ":completion${curcontext}:history-words" list || compstate[list]=''
 
   if [[ -n "$compstate[old_list]" &&
         ( -n "$stop" || "$compstate[insert]" = menu ) ]] ; then
@@ -67,14 +67,14 @@
 }
 
 _history_complete_word_gen_matches () {
-  if _style history-words list; then
-    if _style history-words sort; then
+  if zstyle -t ":completion${curcontext}:history-words" list; then
+    if zstyle -t ":completion${curcontext}:history-words" sort; then
       _description history-words expl 'history word'
     else
       _description -V history-words expl 'history word'
     fi
   else
-    if _style history-words sort; then
+    if zstyle -t ":completion${curcontext}:history-words" sort; then
       expl=()
     else
       expl=('-V' '')
@@ -84,7 +84,7 @@
   [[ -n "$_hist_stop" ]] && PREFIX="$_hist_old_prefix"
 
   local rem_dups
-  if _style history-words remove-all-dups; then
+  if zstyle -t ":completion${curcontext}:history-words" remove-all-dups; then
     rem_dups=''
   else
     rem_dups='-1'
diff -ru ../z.old/Completion/Core/_approximate Completion/Core/_approximate
--- ../z.old/Completion/Core/_approximate	Thu Dec  9 15:56:11 1999
+++ Completion/Core/_approximate	Fri Dec 10 14:35:16 1999
@@ -20,7 +20,7 @@
 
 oldcontext="$curcontext"
 
-_style -s '' max-errors cfgacc
+zstyle -s ":completion${curcontext}:" max-errors cfgacc
 
 # Get the number of errors to accept.
 
@@ -79,11 +79,12 @@
                "e:$_comp_correct" "o:$PREFIX$SUFFIX"
 
   if _complete; then
-    if _style '' insert-unambiguous &&
+    if zstyle -t ":completion${curcontext}:" insert-unambiguous &&
        [[ "${#compstate[unambiguous]}" -ge "${#:-$PREFIX$SUFFIX}" ]]; then
       compstate[pattern_insert]=unambiguous
     elif _requested original &&
-         ( [[ compstate[nmatches] -gt 1 ]] || _style '' original ); then
+         ( [[ compstate[nmatches] -gt 1 ]] ||
+           zstyle -t ":completion${curcontext}:" original ); then
       local expl
 
       _description -V original expl original
diff -ru ../z.old/Completion/Core/_description Completion/Core/_description
--- ../z.old/Completion/Core/_description	Thu Dec  9 15:56:11 1999
+++ Completion/Core/_description	Fri Dec 10 11:30:10 1999
@@ -16,17 +16,19 @@
 
 name="$2"
 
-_style -s "$1" format format || _style -s descriptions format format
+zstyle -s ":completion${curcontext}:$1" format format ||
+    zstyle -s ":completion${curcontext}:descriptions" format format
 
-_style -s "$1" hidden hidden
+zstyle -s ":completion${curcontext}:$1" hidden hidden
 if [[ "$hidden" = (all|yes|true|1|on) ]]; then
   [[ "$hidden" = all ]] && format=''
   hide=(-n)
 fi
-_style -s "$1" group-name gname && [[ -z "$gname" ]] && gname="$1"
+zstyle -s ":completion${curcontext}:$1" group-name gname &&
+    [[ -z "$gname" ]] && gname="$1"
 
 shift 2
-[[ -n "$format" ]] && compfmt format "$format" "d:$1" "${(@)argv[2,-1]}"
+[[ -n "$format" ]] && zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
 
 if [[ -n "$gname" ]]; then
   if [[ -n "$format" ]]; then
diff -ru ../z.old/Completion/Core/_expand Completion/Core/_expand
--- ../z.old/Completion/Core/_expand	Thu Dec  9 15:56:11 1999
+++ Completion/Core/_expand	Fri Dec 10 14:35:48 1999
@@ -13,7 +13,8 @@
 
 # First, see if we should insert all *completions*.
 
-if _style -s '' completions expr && [[ "${(e):-\$[$expr]}" -eq 1 ]]; then
+if zstyle -s ":completion${curcontext}:" completions expr &&
+   [[ "${(e):-\$[$expr]}" -eq 1 ]]; then
   compstate[insert]=all
   return 1
 fi
@@ -29,7 +30,8 @@
 # First try substitution. That weird thing spanning multiple lines
 # changes quoted spaces, tabs, and newlines into spaces.
 
-_style -s '' substitute expr && [[ "${(e):-\$[$expr]}" -eq 1 ]] &&
+zstyle -s ":completion${curcontext}:" substitute expr &&
+    [[ "${(e):-\$[$expr]}" -eq 1 ]] &&
     exp=( "${(e)exp//\\[ 	
 ]/ }" )
 
@@ -39,7 +41,8 @@
 
 # Now try globbing.
 
-_style -s '' glob expr && [[ "${(e):-\$[$expr]}" -eq 1 ]] &&
+zstyle -s ":completion${curcontext}:" glob expr &&
+    [[ "${(e):-\$[$expr]}" -eq 1 ]] &&
     exp=( ${~exp}(N) )
 
 # If we don't have any expansions or only one and that is the same
@@ -50,7 +53,7 @@
 
 # Now add as matches whatever the user requested.
 
-_style -s '' sort sort
+zstyle -s ":completion${curcontext}:" sort sort
 
 [[ "$sort" = (yes|true|1|on) ]] && exp=( "${(@o)exp}" )
 
diff -ru ../z.old/Completion/Core/_list Completion/Core/_list
--- ../z.old/Completion/Core/_list	Thu Dec  9 15:56:11 1999
+++ Completion/Core/_list	Fri Dec 10 14:36:06 1999
@@ -8,7 +8,7 @@
 
 # Get the strings to compare.
 
-if _style '' word; then
+if zstyle -t ":completion${curcontext}:" word; then
   pre="$HISTNO$LBUFFER"
   suf="$RBUFFER"
 else
@@ -18,7 +18,7 @@
 
 # Should we only show a list now?
 
-_style -s '' condition expr
+zstyle -s ":completion${curcontext}:" condition expr
 if [[ ( -z "$expr" || "${(e):-\$[$expr]}" -eq 1 ) &&
       ( "$pre" != "$_list_prefix" || "$suf" != "$_list_suffix" ) ]]; then
 
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_main_complete	Fri Dec 10 14:36:24 1999
@@ -17,7 +17,7 @@
 # state than the global one for which you are completing.
 
 
-local comp post ret=1 _compskip _prio_num=1 _cur_context format \
+local comp post ret=1 _compskip _prio_num=1 format \
       context state line opt_args val_args curcontext="$curcontext" \
       _last_nmatches=-1 _last_menu_style _def_menu_style _menu_style sel \
       _saved_exact="$compstate[exact]" \
@@ -56,7 +56,7 @@
 if (( ! $# )); then
   local tmp
 
-  _style -a '' completer tmp
+  zstyle -a ":completion${curcontext}:" completer tmp
   set -- "$tmp[@]"
 fi
 
@@ -139,7 +139,7 @@
 if [[ compstate[nmatches] -eq 0 &&
       compstate[matcher] -eq compstate[total_matchers] &&
       $#_lastdescr -ne 0 ]] &&
-   _style -s warnings format format; then
+   zstyle -s ":completion${curcontext}:warnings" format format; then
   local str
 
   compstate[list]='list force'
@@ -151,7 +151,8 @@
   *) str="${(j:, :)_lastdescr[1,-2]}, or $_lastdescr[-1]";;
   esac
 
-  compadd -UX "${format//\\%d/$str}" -n ''
+  zformat -f format "$format" "d:$str"
+  compadd -UX "$format" -n ''
 fi
 
 _lastcomp=( "${(@kv)compstate}" )
diff -ru ../z.old/Completion/Core/_match Completion/Core/_match
--- ../z.old/Completion/Core/_match	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_match	Fri Dec 10 14:36:44 1999
@@ -19,8 +19,8 @@
 [[ "$tmp:q" = "$tmp" ||
    compstate[matcher] -ne compstate[total_matchers] ]] && return 1
 
-_style -s '' original orig
-_style -b '' insert-unambiguous ins
+zstyle -s ":completion${curcontext}:" original orig
+zstyle -b ":completion${curcontext}:" insert-unambiguous ins
 
 # Try completion without inserting a `*'?
 
diff -ru ../z.old/Completion/Core/_message Completion/Core/_message
--- ../z.old/Completion/Core/_message	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_message	Fri Dec 10 11:30:11 1999
@@ -4,10 +4,11 @@
 
 _tags messages || return 1
 
-_style -s messages format format || _style -s descriptions format format
+zstyle -s ":completion${curcontext}:messages" format format ||
+    zstyle -s ":completion${curcontext}:descriptions" format format
 
 if [[ -n "$format" ]]; then
-  compfmt format "$format" "d:$1" "${(@)argv[2,-1]}"
+  zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
   if [[ $compstate[nmatches] -eq 0 ]]; then
     compstate[list]='list force'
     compstate[insert]=''
diff -ru ../z.old/Completion/Core/_oldlist Completion/Core/_oldlist
--- ../z.old/Completion/Core/_oldlist	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_oldlist	Fri Dec 10 14:37:07 1999
@@ -2,7 +2,7 @@
 
 local curcontext="${curcontext}:oldlist" list
 
-_style -s '' list list
+zstyle -s ":completion${curcontext}:" list list
 
 # If this is a listing widget and there is already an old list,
 # and either the style :oldlist:list is `always', or it is not `never'
@@ -33,7 +33,8 @@
 
 if [[ -z $compstate[old_insert] && -n $compstate[old_list] ]]; then
   compstate[old_list]=keep
-elif [[ $WIDGET = *complete(|-prefix|-word) ]] && _style '' menu; then
+elif [[ $WIDGET = *complete(|-prefix|-word) ]] &&
+     zstyle -t ":completion${curcontext}:" menu; then
   if [[ -n $compstate[old_insert] ]]; then
     compstate[old_list]=keep
     if [[ $WIDGET = *reverse* ]]; then
diff -ru ../z.old/Completion/Core/_path_files Completion/Core/_path_files
--- ../z.old/Completion/Core/_path_files	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_path_files	Fri Dec 10 13:35:31 1999
@@ -116,7 +116,7 @@
 # If given no `-F' option, we want to use the `ignored-suffixes'-style.
 
 if (( ! $#ignore )); then
-  if _style -a files ignored-suffixes ignore; then
+  if zstyle -a ":completion${curcontext}:files" ignored-suffixes ignore; then
     ignore=(-F "( $ignore )")
   else
 
@@ -347,8 +347,10 @@
       tmp4="$testpath"
       compquote tmp1 tmp4
 
-      if [[ -n $menu ]] || ! _style paths expand '*suffix*'; then
-        _style paths cursor && compstate[to_end]=''
+      if [[ -n $menu ]] ||
+         ! zstyle -t ":completion${curcontext}:paths" expand suffix; then
+        zstyle -t ":completion${curcontext}:paths" cursor &&
+            compstate[to_end]=''
         if [[ "$tmp3" = */* ]]; then
 	  compadd -Qf "$mopts[@]" -p "$linepath$tmp4" -s "/${tmp3#*/}" \
 	          -W "$prepath$realpath$testpath" "$ignore[@]" \
@@ -436,7 +438,7 @@
 
 exppaths=( "${(@)exppaths:#$orig}" )
 
-if _style paths expand '*prefix*' &&
+if zstyle -t ":completion${curcontext}:paths" expand prefix &&
    [[ $#exppaths -gt 0 && nm -eq compstate[nmatches] ]]; then
   PREFIX="${opre}"
   SUFFIX="${osuf}"
diff -ru ../z.old/Completion/Core/_requested Completion/Core/_requested
--- ../z.old/Completion/Core/_requested	Thu Dec  9 15:56:13 1999
+++ Completion/Core/_requested	Fri Dec 10 13:43:56 1999
@@ -8,8 +8,6 @@
   tag="$1"
 fi
 
-comptags -C _cur_context
-
 comptags -R "$tag" &&
     if [[ $# -gt 1 ]]; then
       _description "$@"
diff -ru ../z.old/Completion/Core/_setup Completion/Core/_setup
--- ../z.old/Completion/Core/_setup	Thu Dec  9 15:56:13 1999
+++ Completion/Core/_setup	Fri Dec 10 11:30:12 1999
@@ -2,7 +2,7 @@
 
 local val nm="$compstate[nmatches]"
 
-if _style -a "$1" list-colors val; then
+if zstyle -a ":completion${curcontext}:$1" list-colors val; then
   if [[ "$1" = default ]]; then
     ZLS_COLORS="${(j.:.)${(@)val:gs/:/\\\:}}"
   else
@@ -10,7 +10,7 @@
   fi
 fi
 
-if _style -s "$1" list-packed val; then
+if zstyle -s ":completion${curcontext}:$1" list-packed val; then
   if [[ "$val" = (yes|true|1|on) ]]; then
     compstate[list]="${compstate[list]} packed"
   else
@@ -20,7 +20,7 @@
   compstate[list]="$_saved_list"
 fi
 
-if _style -s "$1" list-rows-first val; then
+if zstyle -s ":completion${curcontext}:$1" list-rows-first val; then
   if [[ "$val" = (yes|true|1|on) ]]; then
     compstate[list]="${compstate[list]} rows"
   else
@@ -30,7 +30,7 @@
   compstate[list]="$_saved_list"
 fi
 
-if _style -s "$1" last-prompt val; then
+if zstyle -s ":completion${curcontext}:$1" last-prompt val; then
   if [[ "$val" = (yes|true|1|on) ]]; then
     compstate[last_prompt]=yes
   else
@@ -40,7 +40,7 @@
   compstate[last_prompt]="$_saved_lastprompt"
 fi
 
-if _style -s "$1" accept-exact val; then
+if zstyle -s ":completion${curcontext}:$1" accept-exact val; then
   if [[ "$val" = (yes|true|1|on) ]]; then
     compstate[exact]=accept
   else
@@ -53,7 +53,7 @@
 [[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] &&
     _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
-if _style -a "$1" menu val; then
+if zstyle -a ":completion${curcontext}:$1" menu val; then
   _last_nmatches="$nm"
   _last_menu_style=( "$val[@]" )
 else
diff -ru ../z.old/Completion/Core/_tags Completion/Core/_tags
--- ../z.old/Completion/Core/_tags	Thu Dec  9 15:56:12 1999
+++ Completion/Core/_tags	Fri Dec 10 13:45:15 1999
@@ -18,7 +18,7 @@
 
   [[ "$1" = -(|-) ]] && shift
 
-  if _style -a '' group-order order; then
+  if zstyle -a ":completion${curcontext}" group-order order; then
     local name
 
     for name in "$order[@]"; do
@@ -42,10 +42,6 @@
 
   "${_sort_tags:-_sort_tags}" "$@"
 
-  # Also store the context (used below and in _requested).
-
-  _cur_context="$curcontext"
-
   # Return non-zero if at least one set of tags should be used.
 
   comptags -T
@@ -56,10 +52,6 @@
 # The other mode: switch to the next set of tags.
 
 local tags
-
-# Reset the current context.
-
-comptags -C _cur_context
 
 _failed_tags=( "$_failed_tags[@]" "$_last_tags[@]" )
 
diff -ru ../z.old/Completion/Core/compinit Completion/Core/compinit
--- ../z.old/Completion/Core/compinit	Thu Dec  9 15:56:13 1999
+++ Completion/Core/compinit	Fri Dec 10 11:30:13 1999
@@ -440,19 +440,19 @@
   if (( ! $# )); then
     local pats styles vals pat style pre eq
 
-    compstyles -G pats
+    zstyle -g pats
 
-    for pat in "$pats[@]"; do
+    for pat in "${(@M)pats:#:completion*}"; do
       if [[ -n "$long" ]]; then
-        pre="compstyle ${(qq)pat} "
+        pre="compstyle ${(qq)pat#:completion} "
       else
-        print "$pat"
+        print "${pat#:completion}"
 	pre='    '
 	eq=' ='
       fi
-      compstyles -G styles "$pat"
+      zstyle -g styles "$pat"
       for style in "$styles[@]"; do
-        compstyles -G vals "$pat" "$style"
+        zstyle -g vals "$pat" "$style"
         print "${pre}${style}${eq}" "${(@qq)vals}"
       done
     done
@@ -461,26 +461,24 @@
   fi
 
   if [[ "$1" = -d ]]; then
-    case "$#" in
-    1) compstyles -d ;;
-    2) compstyles -d "$2" ;;
-    *) 
-      local pat="$2" style
+    if [[ $# -gt 1 ]]; then
+      zstyle -d ":completion$2" "${(@)argv[3,-1]}"
+    else
+      local pats
 
-      shift
+      zstyle -g pats
 
-      for style; do
-        compstyles -d "$pat" "$style"
+      for pat in "${(@M)pats:#:completion}"; do
+        zstyle -d "$pat"
       done
-      ;;
-    esac
+    fi
 
     return 0
   fi
 
   [[ "$1" = -(|-) ]] && shift
 
-  compstyles -a "$@"
+  zstyle - ":completion$1" "${(@)argv[2,-1]}"
 
   return 0
 }
diff -ru ../z.old/Completion/Debian/_apt Completion/Debian/_apt
--- ../z.old/Completion/Debian/_apt	Thu Dec  9 15:56:14 1999
+++ Completion/Debian/_apt	Fri Dec 10 11:30:13 1999
@@ -106,7 +106,7 @@
 tmp3=("$tmp3[@]" $_ra_left${(M)^short_hasarg:#$~tmp1} $_ra_left${(M)^short_configfile:#$~tmp1} $_ra_left${(M)^short_arbitem:#$~tmp1})
 _describe -o option tmp2 -- tmp3 -S='
 
-  comp_opt='{ ! _style options prefix-needed || [[ "$PREFIX" = -* ]] }'" && { $comp_short; $comp_long }"
+  comp_opt='{ ! zstyle -t ":completion${curcontext}:options" prefix-needed || [[ "$PREFIX" = -* ]] }'" && { $comp_short; $comp_long }"
 
   regex_short=()
   regex_long=()
diff -ru ../z.old/Completion/User/_cvs Completion/User/_cvs
--- ../z.old/Completion/User/_cvs	Thu Dec  9 15:56:17 1999
+++ Completion/User/_cvs	Fri Dec 10 11:30:13 1999
@@ -488,7 +488,8 @@
 
 (( $+functions[_cvs_extract_modifiedfile_entries] )) ||
 _cvs_extract_modifiedfile_entries () {
-  if _style cvs disable-stat || ! { zmodload -e stat || zmodload stat }; then
+  if zstyle -t ":completion${curcontext}:cvs" disable-stat ||
+     ! { zmodload -e stat || zmodload stat }; then
     _cvs_extract_file_entries
     return
   fi
diff -ru ../z.old/Completion/User/_groups Completion/User/_groups
--- ../z.old/Completion/User/_groups	Thu Dec  9 15:56:18 1999
+++ Completion/User/_groups	Fri Dec 10 11:30:13 1999
@@ -4,7 +4,7 @@
 
 _wanted groups expl group || return 1
 
-if ! _style -a groups groups groups; then
+if ! zstyle -a ":completion${curcontext}:groups" groups groups; then
   (( $+_cache_groups )) ||
       if (( ${+commands[ypcat]} )); then
         : ${(A)_cache_groups:=${${(s: :)$(ypcat group.byname)}%%:*}} # If you use YP
diff -ru ../z.old/Completion/User/_hosts Completion/User/_hosts
--- ../z.old/Completion/User/_hosts	Thu Dec  9 15:56:18 1999
+++ Completion/User/_hosts	Fri Dec 10 11:30:14 1999
@@ -2,7 +2,7 @@
 
 local expl hosts
 
-if ! _style -a hosts hosts hosts; then
+if ! zstyle -a ":completion${curcontext}:hosts" hosts hosts; then
   (( $+_cache_hosts )) ||
       : ${(A)_cache_hosts:=${(s: :)${(ps:\t:)${${(f)"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}}
 
diff -ru ../z.old/Completion/User/_ports Completion/User/_ports
--- ../z.old/Completion/User/_ports	Fri Dec 10 13:52:51 1999
+++ Completion/User/_ports	Fri Dec 10 11:31:11 1999
@@ -2,7 +2,7 @@
 
 local expl ports
 
-if ! _style -a ports ports ports; then
+if ! zstyle -a ":completion${curcontext}:ports" ports ports; then
   (( $+_cache_ports )) ||
       : ${(A)_cache_ports:=${${(M)${${(f)"$(</etc/services)"}:#\#*}#*/tcp}%%[ 	]*}}
 
diff -ru ../z.old/Completion/User/_socket Completion/User/_socket
--- ../z.old/Completion/User/_socket	Fri Dec 10 13:52:51 1999
+++ Completion/User/_socket	Fri Dec 10 11:30:14 1999
@@ -9,7 +9,8 @@
 typeset -A opt_args
 
 [[ $CURRENT -eq 2 ]] && _wanted options expl option &&
-    { ! _style options prefix-needed || [[ "$PREFIX" = -* ]] } &&
+    { ! zstyle -t ":completion${curcontext}:options" prefix-needed ||
+      [[ "$PREFIX" = -* ]] } &&
     compadd -M 'r:|[_-]=* r:|=*' "$expl[@]" - -version
 
 _arguments -C -s \
diff -ru ../z.old/Completion/User/_urls Completion/User/_urls
--- ../z.old/Completion/User/_urls	Thu Dec  9 15:56:21 1999
+++ Completion/User/_urls	Fri Dec 10 11:30:14 1999
@@ -40,8 +40,9 @@
 
 local ipre scheme host user uhosts ret=1 expl
 local urls_path localhttp
-_style -s urls path urls_path || urls_path="${ZDOTDIR:-$HOME}/.zsh/urls"
-_style -a urls local localhttp
+zstyle -s ":completion${curcontext}:urls" path urls_path ||
+    urls_path="${ZDOTDIR:-$HOME}/.zsh/urls"
+zstyle -a ":completion${curcontext}:urls" local localhttp
 local localhttp_servername="$localhttp[1]"
 local localhttp_documentroot="$localhttp[2]"
 local localhttp_userdir="$localhttp[3]"
diff -ru ../z.old/Completion/User/_users Completion/User/_users
--- ../z.old/Completion/User/_users	Thu Dec  9 15:56:21 1999
+++ Completion/User/_users	Fri Dec 10 11:30:15 1999
@@ -7,7 +7,7 @@
 
 _wanted users expl user || return 1
 
-_style -a users users users &&
+zstyle -a ":completion${curcontext}:users" users users &&
     compadd "$expl[@]" "$@" - "$users[@]" && return 0
 
 compadd "$@" "$expl[@]" - "${(@k)userdirs}"
diff -ru ../z.old/Completion/X/_x_color Completion/X/_x_color
--- ../z.old/Completion/X/_x_color	Thu Dec  9 15:56:23 1999
+++ Completion/X/_x_color	Fri Dec 10 11:30:15 1999
@@ -15,7 +15,7 @@
 
   # Cache of color names doesn't exist yet, create it.
 
-  _style -s colors path file
+  zstyle -s ":completion${curcontext}:colors" path file
   if [[ -n "$file" ]]; then
     _color_cache=( "${(@)${(@f)$(< $file)}[2,-1]##*		}" )
   else
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Thu Dec  9 15:55:50 1999
+++ Doc/Zsh/compsys.yo	Fri Dec 10 14:49:01 1999
@@ -258,37 +258,6 @@
 var(function) autoloadable (exactly equivalent to
 tt(autoload -U )var(function)).
 )
-findex(compstyle)
-cindex(completion system, configuring)
-xitem(tt(compstyle) var(pattern) var(style) var(strings ...))
-xitem(tt(compstyle -d) [ var(pattern) [ var(styles ...) ] ])
-item(tt(compstyle) [ tt(-L) ] )(
-Several aspects of the completion system can be configured by the
-user. This function allows to define so-called styles that are used by 
-various completion functions. These styles are associated with
-patterns that are compared to context names used by the completion
-system. The possible ways to configure the completion system are
-explained in detail in
-ifzman(the section `Completion System Configuration' below)\
-ifnzman(noderef(Completion System Configuration))\
-.
-
-In the first form a new var(style) is defined for a certain
-var(pattern), setting it to the value given by the var(strings). If there 
-was already a definition for the same var(pattern)/var(style) pair,
-only the value is changed.
-
-The second form with the tt(-d) option can be used to delete
-definitions made by previous calls with the first form. Without any
-arguments all definitions are removed. If a var(pattern) is given, all 
-styles defined for it are removed and if a var(pattern) and any number 
-of var(styles) are given, only those styles are removed for the
-pattern.
-
-In the last form (without arguments) all definitions are listed. If
-the tt(-L) option is given this is done in the form of calls to
-tt(compstyle).
-)
 enditem()
 
 texinode(Completion System Configuration)(Control Functions)(Initialization)(Completion System)
@@ -452,16 +421,17 @@
 wants to change the way matches are generated for that context.
 
 But the completion system can not only be configured by supplying a
-specialized tt(_sort_tags) function. There are also the
-`styles' defined with the tt(compstyle) function mentioned in
-ifzman(the section `Initialization' above)\
-ifnzman(noderef(Initialization))\
-.
+specialized tt(_sort_tags) function. It also uses `styles' defined
+with the tt(zstyle) builtin command (see
+ifzman(zmanref(zshmodules))\
+ifnzman(noderef(The zutil Module))\
+) using the prefix `tt(:completion)' and the context name when testing 
+and retrieving values.
 
 For some tags the completion functions look up the definition of
 certain styles set for the current context. These styles can have any
 number of strings as their values and specify, for example, how the
-matches are generated. The tt(compstyle) function defines mappings
+matches are generated. The tt(zstyle) builtin command defines mappings
 between patterns and style names with their values. Whenever a
 completion function looks up the value of a style it uses the name of
 the current context followed by a colon and the name of a tag. This
@@ -473,11 +443,11 @@
 which form should be used. To make all such functions always use the
 verbose form one can simply call
 
-example(compstyle '*' verbose yes)
+example(zstyle ':completion:*' verbose yes)
 
-in one of the startup files like tt(.zshrc) (after the call to the
-tt(compinit) function). This definition simply means that the
-tt(verbose) style has tt(yes) as its value in every context.
+in one of the startup files like tt(.zshrc). This definition simply
+means that the tt(verbose) style has tt(yes) as its value in every
+context.
 
 The completion function for the tt(kill) builtin command uses this
 style to decide if jobs and processes are listed only as job numbers
@@ -486,7 +456,7 @@
 calling the tt(ps) command). To make this builtin list the matches
 only as numbers one could call:
 
-example(compstyle '*::kill:*' verbose no)
+example(zstyle ':completion:*::kill:*' verbose no)
 
 And if one wants to see the command lines for processes but not the
 job texts one could use the fact that the tag name is appended to the
@@ -494,21 +464,12 @@
 call use (remember that the function for the tt(kill) builtin command
 uses the tags tt(jobs) and tt(processes)): 
 
-example(compstyle '*::kill:*:jobs' verbose no)
+example(zstyle ':completion:*::kill:*:jobs' verbose no)
 
-As said above, the patterns given to the tt(compstyle) function are
-tested in the order in which they were given. But that isn't
-completely true. In fact, this function roughly sorts the patterns so
-that more specialized patterns are compared before more general
-patterns. Due to this, the last two examples could be defined after
-the first one because both `tt(*::kill:*)' and `tt(*::kill:*:jobs)' are
-considered to be more specific then the pattern `tt(*)' from the first
-example. To decide how specific a pattern is, the function looks at 
-the number of colons (corresponding to the number of components) used
-in the pattern, and if these components are actual patterns (like the
-`tt(*)') or simple strings (like the `tt(jobs)' in the last
-example). Patterns with fewer colons and fewer simple strings are
-considered to be less specific.
+Due to the ordering tt(zstyle) does with the patterns defined, the
+last two examples could be defined after the first one because both
+`tt(*::kill:*)' and `tt(*::kill:*:jobs)' are considered to be more
+specific then the pattern `tt(*)' from the first example.
 
 As for tags, completion functions can use any number of styles, so
 there can't be a complete list. However, the following two sections
@@ -807,9 +768,9 @@
 completion, completion and correction for incremental completion and
 only completion for prediction one could use:
 
-example(compstyle '*' completer _complete _correct _approximate
-compstyle ':incremental' completer _complete _correct
-compstyle ':predict' completer _complete)
+example(zstyle ':completion:*' completer _complete _correct _approximate
+zstyle ':completion:incremental' completer _complete _correct
+zstyle ':completion:predict' completer _complete)
 )
 item(tt(completions))(
 This style is used by the tt(_expand) completer function.
@@ -830,7 +791,7 @@
 arithmetical expression. In this case, delaying will be done if the
 expression evaluates to `tt(1)'. For example, with
 
-example(compstyle ':list' condition 'NUMERIC != 1')
+example(zstyle ':completion:list' condition 'NUMERIC != 1')
 
 delaying will be done only if given an explicit numeric argument
 other than `tt(1)'.
@@ -882,6 +843,14 @@
 Finally, for the tt(warnings) tag, it is printed when no matches could 
 be generated at all. In this case the `tt(%d)' is replaced with the
 descriptions for the matches that were expected.
+
+Here and in all other cases where the completion system uses `tt(%)'
+sequences, the `tt(%)' may be followed by field with specifications as 
+described for the tt(zformat) builtin command from the tt(zutil)
+module, see
+ifzman(zmanref(zshmodules))\
+ifnzman(noderef(The zutil Module))\
+.
 )
 item(tt(glob))(
 Like tt(complete), this is used by the tt(_expand) completer.
@@ -901,8 +870,8 @@
 completions. To have the external commands and shell functions listed
 separately, one can set:
 
-example(compstyle '*:-command-:commands' group-name commands
-compstyle '*:-command-:functions' group-name functions)
+example(zstyle ':completion:*:-command-:commands' group-name commands
+zstyle ':completion:*:-command-:functions' group-name functions)
 
 This also means that if the same name is used for different types of
 matches, then those matches will be displayed together in the same
@@ -912,7 +881,7 @@
 the matches will be used as the name of the group. So, to have all
 different types of matches displayed separately, one can just set:
 
-example(compstyle '*' group-name '')
+example(zstyle ':completion:*' group-name '')
 
 All matches for which no group name is defined will be put in a group
 named tt(-default-).
@@ -931,7 +900,7 @@
 external commands appear in this order when completing in command
 position one would set:
 
-example(compstyle '*:-command-' group-order builtins functions commands)
+example(zstyle ':completion:*:-command-' group-order builtins functions commands)
 )
 item(tt(groups))(
 A style holding the names of the groups that should be completed. If
@@ -1046,7 +1015,7 @@
 To be able to share the same specifications one has set up for the GNU
 version of the tt(ls) command one can use:
 
-example(compstyle '*:default' list-colors ${(s.:.)LS_COLORS})
+example(zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS})
 
 And to get the default colors (which are the same as for the GNU
 tt(ls) command) one should set the style to an empty value.
@@ -1082,7 +1051,7 @@
 completer function will take any numeric argument as the
 maximum number of errors allowed. For example, with
 
-example(compstyle ':approximate' accept 2 numeric)
+example(zstyle ':completion:approximate' accept 2 numeric)
 
 two errors will be allowed if no numeric argument is given. However,
 with a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
@@ -1241,7 +1210,7 @@
 arithmetical expression. In this case, expansion of substitutions will
 be done if the expression evaluates to `tt(1)'. For example, with
 
-example(compstyle ':expand' substitute '${NUMERIC:-1} != 1')
+example(zstyle ':completion:expand' substitute '${NUMERIC:-1} != 1')
 
 substitution will be performed only if given an explicit numeric
 argument other than `tt(1)', as by typing `tt(ESC 2 TAB)'.
@@ -1295,7 +1264,7 @@
 tt(completer) style. For example, to use normal completion and
 correction if that doesn't generate any matches:
 
-example(compstyle '*' completer _complete _correct)
+example(zstyle ':completion:*' completer _complete _correct)
 
 after calling tt(compinit). The default value for this style set up
 in tt(compinit) is `tt(_complete)', i.e. normally only ordinary
@@ -1407,7 +1376,7 @@
 presented to the user. The intended use of this completer function is to
 try after the normal tt(_complete) completer by setting:
 
-example(compstyle '*' completer _complete _approximate)
+example(zstyle ':completion:*' completer _complete _approximate)
 
 This will give correcting completion if and only if
 normal completion doesn't yield any possible completions. When
@@ -1436,9 +1405,9 @@
 
 For example, with:
 
-example(compstyle '*' completer _complete _correct _approximate
-compstyle ':correct' accept 2 not-numeric
-compstyle ':approximate' accept 3 numeric)
+example(zstyle ':completion:*' completer _complete _correct _approximate
+zstyle ':completion:correct' accept 2 not-numeric
+zstyle ':completion:approximate' accept 3 numeric)
 
 correction will accept up to two errors. If a numeric argument is
 given, correction will not be performed, but correcting completion
@@ -1836,48 +1805,6 @@
 
 Like tt(_tags) this function supports the tt(-C) option to give an
 additional context name component.
-)
-findex(_style)
-item(tt(_style))(
-This function is used to look up the values of styles defined by the
-user. In its simplest form, it is called with two arguments: a tag and 
-a style-name. The tag (if non-empty) is temporarily appended to the
-current context name (preceded by a colon) and the patterns defined by 
-the user with the tt(compstyle) function will be compared to that
-combined name. If any of those patterns match the name and the given
-style is defined for it and its boolean value is `true' (i.e. its
-value is one of `tt(true)', `tt(on)', `tt(yes)', and `tt(1)'), tt(_style)
-returns zero and non-zero otherwise. If you want to test the style not 
-only for a boolean value, you can give a third argument which is then
-used as a pattern and tt(_style) returns zero if the pattern matches
-the value defined for the style.
-
-If you want to retrieve the value defined for the style, you can use
-one of the options tt(-b) (to retrieve it as a boolean value, i.e. one 
-of tt(yes) or tt(no)), tt(-s) (to get it as a scalar, i.e. a string
-concatenated from the value strings defined by the user, separated by
-spaces), tt(-a) (to get it as an array), and tt(-h) (to get it as an
-associative array; in this case the first, third, etc. strings from the 
-value are used as the keys and the others as their values). In each of
-these cases the arguments after the option are the tag, the style-name
-and the name of the parameter into which the result will be stored.
-
-For example, to test if the tt(description) style is set to `true' for 
-the current context and the tag tt(foo):
-
-example(if _style foo description; then
-  ... # style is true
-fi)
-
-And to get the value of the tt(path) style for the tag tt(foo) as an
-array into the parameter tt(tmp):
-
-example(local tmp
-_style -a foo path tmp)
-
-In any case, the return value of this function is zero if a
-definition for the style was found and non-zero if no definition was
-found.
 )
 findex(_describe)
 item(tt(_describe) var(descr) var(name1) [ var(name2) ] var(opts) ... tt(-)tt(-) ...)(
diff -ru ../z.old/Doc/Zsh/mod_clone.yo Doc/Zsh/mod_clone.yo
--- ../z.old/Doc/Zsh/mod_clone.yo	Thu Dec  9 15:55:52 1999
+++ Doc/Zsh/mod_clone.yo	Fri Dec 10 11:30:15 1999
@@ -1,4 +1,4 @@
-texinode(The clone Module)(The complete Module)(The cap Module)(Zsh Modules)
+texinode(The clone Module)(The zutil Module)(The cap Module)(Zsh Modules)
 sect(The clone Module)
 The tt(clone) module makes available one builtin command:
 
diff -ru ../z.old/Doc/Zsh/mod_complete.yo Doc/Zsh/mod_complete.yo
--- ../z.old/Doc/Zsh/mod_complete.yo	Thu Dec  9 15:55:52 1999
+++ Doc/Zsh/mod_complete.yo	Fri Dec 10 11:30:15 1999
@@ -1,4 +1,4 @@
-texinode(The complete Module)(The compctl Module)(The clone Module)(Zsh Modules)
+texinode(The complete Module)(The compctl Module)(The zutil Module)(Zsh Modules)
 sect(The complete Module)
 The tt(complete) module makes available several builtin commands which
 can be used in user-defined completion widgets, see
diff -ru ../z.old/Doc/Zsh/mod_computil.yo Doc/Zsh/mod_computil.yo
--- ../z.old/Doc/Zsh/mod_computil.yo	Thu Dec  9 15:55:52 1999
+++ Doc/Zsh/mod_computil.yo	Fri Dec 10 15:12:27 1999
@@ -6,8 +6,7 @@
 completions system (see
 ifzman(zmanref(zshcompsys))\
 ifnzman(noderef(Completion System))
-). Except for tt(compquote) and tt(compdisplay) these builtin
-commands are very
+). Except for tt(compquote) these builtin commands are very
 specialised and thus not very interesting when writing your own
 completion functions. In short, these builtin commands are:
 
@@ -24,22 +23,6 @@
 
 The return value is non-zero in case of an error and zero otherwise.
 )
-item(tt(compfmt) var(name) var(string) var(defs) ...)(
-The var(defs) ar of the form `var(char)tt(;)var(string)' and
-tt(compfmt) will replace every occurance of the sequence
-`tt(%)var(char)' for each of the var(char)s with the corresponding
-var(string). The resulting string will be placed in the parameter
-var(name).
-)
-item(tt(compdisplay) var(name) var(string) var(defs) ...)(
-The var(defs) are strings which should be of the form
-`var(str)tt(:)var(descr)' (the intended use is that the var(descr)
-describes the var(str)) and tt(compdisplay) will convert them to
-strings in which the colon is replaced by the var(string) given as the 
-second argument and spaces are inserted before that so that they are
-aligned over all strings. These resultings strings are then assigned
-to an array with the var(name) given as the first argument.
-)
 item(tt(compdescribe))(
 This is used by the tt(_describe) function to build the displays for
 the matches and to get the strings to add as matches with their
@@ -67,9 +50,6 @@
 )
 item(tt(compvalues))(
 Like tt(comparguments), but for the tt(_values) function.
-)
-item(tt(compstyle))(
-This builtin implements the internals of the style mechanism.
 )
 item(tt(comptags), tt(comptry))(
 This implements the internals of the tags mechanism.
diff -ru ../z.old/Doc/Zsh/mod_zutil.yo Doc/Zsh/mod_zutil.yo
--- ../z.old/Doc/Zsh/mod_zutil.yo	Fri Dec 10 13:50:19 1999
+++ Doc/Zsh/mod_zutil.yo	Fri Dec 10 14:40:54 1999
@@ -0,0 +1,109 @@
+texinode(The zutil Module)(The complete Module)(The clone Module)(Zsh Modules)
+sect(The zutil Module)
+cindex(builtins, utility)
+The tt(zutil) module only adds some builtins:
+
+startitem()
+xitem(tt(zstyle) [ tt(-L) ])
+xitem(tt(zstyle) [ tt(-) | tt(-)tt(-) ] var(pattern) var(style) var(strings) ...)
+xitem(tt(zstyle -d) [ var(pattern) [ var(styles) ... ] ])
+xitem(tt(zstyle -g) var(name) [ var(pattern) [ var(style) ] ])
+xitem(tt(zstyle -s) var(context) var(style) var(name) [ var(sep) ])
+xitem(tt(zstyle -b) var(context) var(style) var(name))
+xitem(tt(zstyle -a) var(context) var(style) var(name))
+xitem(tt(zstyle -h) var(context) var(style) var(name))
+xitem(tt(zstyle -t) var(context) var(style) [ var(strings) ...])
+item(tt(zstyle -m) var(context) var(style) var(pattern))(
+This builtin command is used to define and lookup styles. Styles are
+pairs of names and values, where the values consist of any number of
+strings. They are stored together with patterns and lookup is done by
+giving a string, called the `context', which is compared to the
+patterns. The definition stored for the first matching pattern will be 
+returned. For this, the patterns are ordered from most specific to
+less specific and patterns that are equally specific keep the order in 
+which they were defined. A pattern is considered to be more specific
+than another if it contains more components (substrings separated by
+colons) or if the patterns for the components are more specific, where 
+simple strings are considered to be more specific than patterns and
+complex patterns are considered to be more specific than the pattern
+`tt(*)'.
+
+The first form (without arguments) lists the definitions in the order
+tt(zstyle) will test them. If the tt(-L) option is given, listing is
+done in the form of calls to tt(zstyle).
+
+In the second form this defines the given var(style) for the
+var(pattern) with the var(strings) as the value.
+
+The third form can be used to delete such definitions. Without
+arguments all definitions are deleted, with a var(pattern) all
+definitions for that pattern are deleted and if any var(styles) are
+given, then only those styles are deleted for the var(pattern).
+
+The fourth form allows to retrieve definitions. The var(name) will be
+used as the name of an array in which the results are stored. Without
+any further arguments, all var(patterns) defined are returned. With a
+var(pattern) the styles defined for that pattern are returned and with 
+both a var(pattern) and a var(style), the value strings of that
+combination is returned.
+
+The other forms can be used to look up or test patterns. With the
+tt(-s) option, the value of the style is returned as a string in the
+parameter var(name). For this, the strings from the value are
+concatenated with spaces (or the var(sep) string if that is given)
+between them. The tt(-b) option makes the value be returned as a
+boolean, i.e. as the string tt(yes) if the value has only one string
+and that is equal to one of tt(yes), tt(true), tt(on), or tt(1). If
+the value has more than one string or only one but that is different
+from the strings mentioned, the parameter will be set to tt(no). The
+tt(-a) option makes the value be returned as an array and the tt(-h)
+makes it be returned as an associative array (with the first, third,
+etc. string being used as the keys and the other strings being used as 
+the values).
+
+The tt(-t) option can be used to test the value of a style, i.e. it
+only sets the return value. Without any var(strings) arguments it is
+zero if the style is defined for at least one matching pattern, has
+only one string in its value and that is equal to one of tt(true),
+tt(yes), tt(on) or tt(1). If any var(strings) are given the return
+zero if and only if at least one of the var(strings) is equal to at
+least one of the strings in the value.
+
+The tt(-m) option can be used to match a value. It returns zero if the 
+var(pattern) matches at least one of the strings in the value.
+)
+xitem(tt(zformat -f) var(param) var(format) var(specs) ...)
+item(tt(zformat -a) var(array) var(sep) var(specs) ...)(
+This builtin provides to different forms of formatting. The first form 
+is selected with the tt(-f) option. If this is given, the var(format)
+string will be modified by replacing sequences starting with a percent 
+sign in it with strings from the var(specs). Each var(spec) has to be
+of the form `var(char)tt(:)var(string)' and this will make every
+appearence of the sequence `tt(%)var(char)' in var(format) be replaced 
+with the var(string). The `tt(%)' sequence may also contain optional
+minimum and maximum field width specifications between the `tt(%)' and 
+the `var(char)' in the form `tt(%)var(min)tt(.)var(max)tt(c)',
+i.e. the minimum field width is given first and if the maximum field
+width is used, it has to be preceded by a dot. Giving a minimum field
+width makes the result be padded with spaces to the right if the
+var(string) is shorter than the requested width. Padding to the left
+can be achieved by giving a negative minimum field width. If a maximum 
+field width is given, the var(string) will be truncated after that
+many characters. After all `tt(%)' sequences for the given var(specs)
+have been processed, the resulting string is stored in the parameter
+var(param).
+
+The second form, using the tt(-a) option, can be used to get aligned
+strings. Here, the var(specs) are of the form
+`var(left)tt(:)var(right)' where `var(left)' and `var(right)' are
+arbitrary strings. These strings are modified by replacing the colons
+with the var(sep) string and padding the var(left) strings with spaces 
+to the right so that the var(sep) strings in the result (and hence the 
+var(right) strings after them) are all aligned if the strings are
+printed below each other. All strings without a colon are left
+unchanged and all strings with a empty var(right) string have the
+trailing colon removed. In both cases the lengths of the strings
+are not used to determine how the other strings have to be aligned.
+The resulting strings are stored in the var(array).
+)
+enditem()
diff -ru ../z.old/Doc/Zsh/modules.yo Doc/Zsh/modules.yo
--- ../z.old/Doc/Zsh/modules.yo	Thu Dec  9 15:55:54 1999
+++ Doc/Zsh/modules.yo	Fri Dec 10 11:30:16 1999
@@ -15,6 +15,10 @@
 item(tt(clone))(
 A builtin that can clone a running shell onto another terminal.
 )
+item(tt(zutil))(
+Some utility builtins, e.g. the one for supporting configuration via 
+styles.
+)
 item(tt(complete))(
 The basic completion code.
 )
@@ -66,6 +70,7 @@
 startmenu()
 menu(The cap Module)
 menu(The clone Module)
+menu(The zutil Module)
 menu(The complete Module)
 menu(The compctl Module)
 menu(The complist Module)
@@ -84,6 +89,7 @@
 endmenu()
 includefile(Zsh/mod_cap.yo)
 includefile(Zsh/mod_clone.yo)
+includefile(Zsh/mod_zutil.yo)
 includefile(Zsh/mod_complete.yo)
 includefile(Zsh/mod_compctl.yo)
 includefile(Zsh/mod_complist.yo)
diff -ru ../z.old/Etc/completion-style-guide Etc/completion-style-guide
--- ../z.old/Etc/completion-style-guide	Thu Dec  9 15:55:55 1999
+++ Etc/completion-style-guide	Fri Dec 10 13:42:50 1999
@@ -187,40 +187,48 @@
 Users can associate patterns for hierarchical context names with
 certain styles using the `compstyle' function. The completion code
 should then use these styles to decide how matches should be added and 
-to get user-configured values. This is done using the function
-`_style'.
+to get user-configured values. This is done using the builtin `zstyle'.
 
 Basically styles map names to a bunch of strings (the `value'). In
 many cases you want to treat the value as a boolean, so let's start
 with that. To test if, for example, the style `verbose' is set for 
 the tag `options' in the context you are currently in, you can just do:
 
-  if _style options verbose; then
+  if zstyle -t ":completion${curcontext}:options" verbose; then
     # yes, it is set...
   fi
 
-I.e. with two arguments `_style' takes the first one as a tag and the
-second one as a style name and returns zero if that style has the
-boolean value `true'. Internally it checks if the style is set to one
-of `yes', `true', `on', or `1' and interprets that as `true' and every 
-other value as `false'.
+I.e. with the -t option and two arguments `zstyle' takes the first one
+as a tag and the second one as a style name and returns zero if that
+style has the boolean value `true'. Internally it checks if the style
+is set to one of `yes', `true', `on', or `1' and interprets that as
+`true' and every other value as `false'.
 
 For more complicated style for which you want to test if the value
-matches a certain pattern, you can use `_style' with three arguments:
+matches a certain pattern, you can use `zstyle' with the -m option and
+three arguments:
 
-  if _style foo bar '*baz*'; then
+  if zstyle -m ":completion${curcontext}:foo" bar '*baz*'; then
     ...
   fi
 
 This tests if the value of the style `bar' for the tag `foo' matches
 the pattern `*baz*' and returns zero if it does.
 
+If you just want to see if one of the strings in the value is exactly
+equal to any of a number of a strings, you can use the -t option and
+give the strings after the style name:
+
+  if zstyle -t ":completion${curcontext}:foo" bar str1 str2; then
+    ...
+  fi
+
 But sometimes you want to actually get the value stored for a certain
-style instead of just testing it. For this `_style' supports four
+style instead of just testing it. For this `zstyle' supports four
 options: `-b', `-s', `-a', and `-h'. After these options, three
-arguments are expected, namely the tag, the style, and a parameter
-name. The parameter will then be set to the value of the style and the 
-option says how the strings stored as a value will be stored in the
+arguments are expected, the tag, the style, and a parameter name. The
+parameter will then be set to the value of the style and the option
+says how the strings stored as a value will be stored in the
 parameter:
 
   - `-b': the parameter will be set to a either `yes' or `no'
@@ -232,13 +240,6 @@
           from the value being interpreted alternatingly as keys and
 	  values
 
-Note that if you want to test or get styles for a certain context
-name which you have to build yourself, you have to call `_style' after 
-the call to `_tags', `_wanted', or whatever. When you are using
-utility functions like `_alternate' or `_arguments' the context will
-automatically be set up appropriately at the time when you have a
-chance to call `_style'.
-
 Some random comments about style names. Use the ones already in use if 
 possible. Especially, use the `verbose' style if you can add
 matches in a simple and a verbose way. Use the verbose form only if
@@ -249,15 +250,11 @@
 matches be added and the second one says if the prefix should be
 visible in the list.
 
-But, I think, using any number of new style names is ok -- different
-from tag-names where I would like to keep the number of names used
-small.
-
 And finally, if you need a style whose value can sensibly be
 interpreted as a list of words, use array or association styles with
-the `-a' or `-h' options to `_style'. Otherwise you should only make
+the `-a' or `-h' options to `zstyle'. Otherwise you should only make
 sure that an empty value for a style is treated in the same way as if
-the style wasn't set at all (this is use elsewhere and we want to
+the style wasn't set at all (this is used elsewhere and we want to
 keep things consistent).
 
 
diff -ru ../z.old/Functions/Zle/incremental-complete-word Functions/Zle/incremental-complete-word
--- ../z.old/Functions/Zle/incremental-complete-word	Thu Dec  9 15:56:38 1999
+++ Functions/Zle/incremental-complete-word	Fri Dec 10 11:30:16 1999
@@ -51,8 +51,8 @@
     word="${_lastcomp[unambiguous]}"
     state=''
   fi
-  compfmt pstr "$pmpt" "u:${word}" "s:$state" "n:$num" "a:$alt" \
-                       "l:$toolong" "c:${_lastcomp[completer][2,-1]}"
+  zformat -f pstr "$pmpt" "u:${word}" "s:$state" "n:$num" "a:$alt" \
+                          "l:$toolong" "c:${_lastcomp[completer][2,-1]}"
   zle -R "$pstr"
   read -k key
 
@@ -99,8 +99,8 @@
       word="${_lastcomp[unambiguous]}"
       state=''
     fi
-    compfmt pstr "$pmpt" "u:${word}" "s:$state" "n:$num" "a:$alt" \
-                       "l:$toolong" "c:${_lastcomp[completer][2,-1]}"
+    zformat -f pstr "$pmpt" "u:${word}" "s:$state" "n:$num" "a:$alt" \
+                            "l:$toolong" "c:${_lastcomp[completer][2,-1]}"
     zle -R "$pstr"
     read -k key
   done
diff -ru ../z.old/Src/Modules/zutil.c Src/Modules/zutil.c
--- ../z.old/Src/Modules/zutil.c	Fri Dec 10 13:50:40 1999
+++ Src/Modules/zutil.c	Fri Dec 10 13:59:07 1999
@@ -0,0 +1,761 @@
+/*
+ * zutil.c - misc utilities
+ *
+ * This file is part of zsh, the Z shell.
+ *
+ * Copyright (c) 1999 Sven Wischnowsky
+ * All rights reserved.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and to distribute modified versions of this software for any
+ * purpose, provided that the above copyright notice and the following
+ * two paragraphs appear in all copies of this software.
+ *
+ * In no event shall Sven Wischnowsky or the Zsh Development Group be liable
+ * to any party for direct, indirect, special, incidental, or consequential
+ * damages arising out of the use of this software and its documentation,
+ * even if Sven Wischnowsky and the Zsh Development Group have been advised of
+ * the possibility of such damage.
+ *
+ * Sven Wischnowsky and the Zsh Development Group specifically disclaim any
+ * warranties, including, but not limited to, the implied warranties of
+ * merchantability and fitness for a particular purpose.  The software
+ * provided hereunder is on an "as is" basis, and Sven Wischnowsky and the
+ * Zsh Development Group have no obligation to provide maintenance,
+ * support, updates, enhancements, or modifications.
+ *
+ */
+
+#include "zutil.mdh"
+#include "zutil.pro"
+
+/* Style stuff. */
+
+typedef struct stypat *Stypat;
+typedef struct style *Style;
+
+/* A pattern and the styles for it. */
+
+struct stypat {
+    Stypat next;
+    char *pat;			/* pattern string */
+    Patprog prog;		/* compiled pattern */
+    int weight;			/* how specific is the pattern? */
+    Style styles, lstyles;	/* first/last style */
+};
+    
+struct style {
+    Style next;
+    char *name;
+    char **vals;
+};
+
+/* List of styles. */
+
+static Stypat zstyles, lzstyles;
+
+/* Memory stuff. */
+
+static void
+freestyle(Style s)
+{
+    Style n;
+
+    while (s) {
+	n = s->next;
+
+	zsfree(s->name);
+	if (s->vals)
+	    freearray(s->vals);
+	zfree(s, sizeof(*s));
+
+	s = n;
+    }
+}
+
+static void
+freestypat(Stypat p)
+{
+    Stypat n;
+
+    while (p) {
+	n = p->next;
+
+	zsfree(p->pat);
+	freepatprog(p->prog);
+	zfree(p, sizeof(*p));
+
+	p = n;
+    }
+}
+
+/* Get the struct for a pattern, if any. */
+
+static Stypat
+getstypat(char *pat)
+{
+    Stypat p;
+
+    for (p = zstyles; p; p = p->next)
+	if (!strcmp(pat, p->pat))
+	    return p;
+
+    return NULL;
+}
+
+/* Get the style stuff for a name. */
+
+static Style
+getstyle(Stypat p, char *name)
+{
+    Style s;
+
+    for (s = p->styles; s; s=  s->next)
+	if (!strcmp(name, s->name))
+	    return s;
+
+    return NULL;
+}
+
+/* Store a value for a style. */
+
+static void
+setstyle(Stypat p, char *name, char **vals)
+{
+    Style s;
+
+    for (s = p->styles; s; s = s->next)
+	if (!strcmp(name, s->name)) {
+
+	    /* Exists -> replace. */
+
+	    if (s->vals)
+		freearray(s->vals);
+	    PERMALLOC {
+		s->vals = arrdup(vals);
+	    } LASTALLOC;
+
+	    return;
+	}
+
+    /* New style. */
+
+    s = (Style) zalloc(sizeof(*s));
+
+    s->name = ztrdup(name);
+    PERMALLOC {
+	s->vals = arrdup(vals);
+    } LASTALLOC;
+    s->next = NULL;
+
+    if (p->lstyles)
+	p->lstyles->next = s;
+    else
+	p->styles = s;
+    p->lstyles = s;
+}
+
+/* Add a new pattern. */
+
+static Stypat
+addstypat(char *pat, Patprog prog)
+{
+    Stypat p, q, qq;
+    int weight, tmp, first;
+    char *s;
+
+    /* Calculate the weight. */
+
+    for (weight = 0, tmp = 2, first = 1, s = pat; *s; s++) {
+	if (first && *s == '*' && (!s[1] || s[1] == ':')) {
+	    /* Only `*' in this component. */
+	    tmp = 0;
+	    continue;
+	}
+	first = 0;
+
+	if (*s == '(' || *s == '|' || *s == '*' || *s == '[' || *s == '<' ||
+	    *s == '?' || *s == '#' || *s == '^')
+	    /* Is pattern. */
+	    tmp = 1;
+
+	if (*s == ':') {
+	    /* Yet another component. */
+
+	    first = 1;
+	    weight += tmp;
+	    tmp = 2;
+	}
+    }
+    weight += tmp;
+
+    p = (Stypat) zalloc(sizeof(*p));
+
+    p->pat = ztrdup(pat);
+    p->weight = weight;
+    p->prog = prog;
+    p->styles = p->lstyles = NULL;
+
+    for (qq = NULL, q = zstyles; q && q->weight >= weight;
+	 qq = q, q = q->next);
+
+    p->next = q;
+    if (qq)
+	qq->next = p;
+    else
+	zstyles = p;
+    if (!q)
+	lzstyles = p;
+
+    return p;
+}
+
+/* Delete a style. */
+
+static void
+deletestyle(Stypat p, char *name)
+{
+    Style ps, s;
+
+    for (ps = NULL, s = p->styles; s; ps = s, s = s->next)
+	if (!strcmp(name, s->name)) {
+	    if (ps)
+		ps->next = s->next;
+	    else
+		p->styles = s->next;
+	    if (s == p->lstyles)
+		p->lstyles = ps;
+
+	    s->next = NULL;
+	    freestyle(s);
+
+	    return;
+	}
+}
+
+/* Delete a whole pattern with all its styles. */
+
+static void
+deletestypat(Stypat pat)
+{
+    Stypat pp, p;
+
+    for (pp = NULL, p = zstyles; p; pp = p, p = p->next)
+	if (p == pat) {
+	    if (pp)
+		pp->next = p->next;
+	    else
+		zstyles = p->next;
+	    if (p == lzstyles)
+		lzstyles = pp;
+
+	    p->next = NULL;
+	    zsfree(p->pat);
+	    freepatprog(p->prog);
+	    freestyle(p->styles);
+	    zfree(p, sizeof(*p));
+
+	    return;
+	}
+}
+
+/* Look up a style for a context pattern. This does the matching. */
+
+static Style
+lookupstyle(char *ctxt, char *style)
+{
+    Stypat p;
+    Style s;
+
+    for (p = zstyles; p; p = p->next)
+	if (pattry(p->prog, ctxt))
+	    for (s = p->styles; s; s = s->next)
+		if (!strcmp(style, s->name))
+		    return s;
+
+    return NULL;
+}
+
+static int
+bin_zstyle(char *nam, char **args, char *ops, int func)
+{
+    int min, max, n, add = 0, list = 0;
+
+    if (!args[0])
+	list = 1;
+    else if (args[0][0] == '-') {
+	char oc;
+
+	if ((oc = args[0][1]) && oc != '-') {
+	    if (args[0][2]) {
+		zerrnam(nam, "invalid argument: %s", args[0], 0);
+		return 1;
+	    }
+	    if (oc == 'L')
+		list = 2;
+	} else {
+	    add = 1;
+	    args++;
+	}
+    } else
+	add = 1;
+
+    if (add) {
+	Stypat p;
+
+	if (arrlen(args) < 2) {
+	    zerrnam(nam, "not enough arguments", NULL, 0);
+	    return 1;
+	}
+	if (!(p = getstypat(args[0]))) {
+	    Patprog prog;
+	    char *pat = dupstring(args[0]);
+
+	    tokenize(pat);
+
+	    if (!(prog = patcompile(pat, PAT_ZDUP, NULL))) {
+		zerrnam(nam, "invalid pattern: %s", args[0], 0);
+		return 1;
+	    }
+	    p = addstypat(args[0], prog);
+	}
+	setstyle(p, args[1], args + 2);
+
+	return 0;
+    }
+    if (list) {
+	Stypat p;
+	Style s;
+	char **v;
+
+	for (p = zstyles; p; p = p->next) {
+	    if (list == 1) {
+		quotedzputs(p->pat, stdout);
+		putchar('\n');
+	    }
+	    for (s = p->styles; s; s = s->next) {
+		if (list == 1)
+		    printf("    %s", s->name);
+		else {
+		    printf("zstyle ");
+		    quotedzputs(p->pat, stdout);
+		    printf(" %s", s->name);
+		}
+		for (v = s->vals; *v; v++) {
+		    putchar(' ');
+		    quotedzputs(*v, stdout);
+		}
+		putchar('\n');
+	    }
+	}
+	return 0;
+    }
+    switch (args[0][1]) {
+    case 'd': min = 0; max = -1; break;
+    case 's': min = 3; max =  4; break;
+    case 'b': min = 3; max =  3; break;
+    case 'a': min = 3; max =  3; break;
+    case 'h': min = 3; max =  3; break;
+    case 't': min = 2; max = -1; break;
+    case 'm': min = 3; max =  3; break;
+    case 'g': min = 1; max =  3; break;
+    default:
+	zerrnam(nam, "invalid option: %s", args[0], 0);
+	return 1;
+    }
+    n = arrlen(args) - 1;
+    if (n < min) {
+	zerrnam(nam, "not enough arguments", NULL, 0);
+	return 1;
+    } else if (max >= 0 && n > max) {
+	zerrnam(nam, "too many arguments", NULL, 0);
+	return 1;
+    }
+    switch (args[0][1]) {
+    case 'd':
+	{
+	    Stypat p;
+
+	    if (args[1]) {
+		if ((p = getstypat(args[1]))) {
+		    if (args[2]) {
+			char **ap = args + 2;
+
+			while (*ap)
+			    deletestyle(p, *ap++);
+
+			if (!p->styles)
+			    deletestypat(p);
+		    } else
+			deletestypat(p);
+		}
+	    } else {
+		freestypat(zstyles);
+		zstyles = lzstyles = NULL;
+	    }
+	}
+	break;
+    case 's':
+	{
+	    Style s;
+	    char *ret;
+	    int val;
+
+	    if ((s = lookupstyle(args[1], args[2])) && s->vals[0]) {
+		PERMALLOC {
+		    ret = sepjoin(s->vals, (args[4] ? args[4] : " "));
+		} LASTALLOC;
+		val = 0;
+	    } else {
+		ret = ztrdup("");
+		val = 1;
+	    }
+	    setsparam(args[3], ret);
+
+	    return val;
+	}
+	break;
+    case 'b':
+	{
+	    Style s;
+	    char *ret;
+	    int val;
+
+	    if ((s = lookupstyle(args[1], args[2])) &&
+		s->vals[0] && !s->vals[1] &&
+		(!strcmp(s->vals[0], "yes") ||
+		 !strcmp(s->vals[0], "true") ||
+		 !strcmp(s->vals[0], "on") ||
+		 !strcmp(s->vals[0], "1"))) {
+		ret = "yes";
+		val = 0;
+	    } else {
+		ret = "no";
+		val = 1;
+	    }
+	    setsparam(args[3], ztrdup(ret));
+
+	    return val;
+	}
+	break;
+    case 'a':
+    case 'h':
+	{
+	    Style s;
+	    char **ret;
+	    int val;
+
+	    if ((s = lookupstyle(args[1], args[2]))) {
+		PERMALLOC {
+		    ret = arrdup(s->vals);
+		} LASTALLOC;
+		val = 0;
+	    } else {
+		char *dummy = NULL;
+
+		PERMALLOC {
+		    ret = arrdup(&dummy);
+		} LASTALLOC;
+		val = 1;
+	    }
+	    if (args[0][1] == 'a')
+		setaparam(args[3], ret);
+	    else
+		sethparam(args[3], ret);
+
+	    return val;
+	}
+	break;
+    case 't':
+	{
+	    Style s;
+
+	    if ((s = lookupstyle(args[1], args[2])) && s->vals[0]) {
+		if (args[3]) {
+		    char **ap = args + 3, **p;
+
+		    while (*ap) {
+			p = s->vals;
+			while (*p)
+			    if (!strcmp(*ap, *p++))
+				return 0;
+			ap++;
+		    }
+		    return 1;
+		} else
+		    return !(!strcmp(s->vals[0], "true") ||
+			     !strcmp(s->vals[0], "yes") ||
+			     !strcmp(s->vals[0], "on") ||
+			     !strcmp(s->vals[0], "1"));
+	    }
+	    return 1;
+	}
+	break;
+    case 'm':
+	{
+	    Style s;
+	    Patprog prog;
+
+	    tokenize(args[3]);
+
+	    if ((s = lookupstyle(args[1], args[2])) &&
+		(prog = patcompile(args[3], PAT_STATIC, NULL))) {
+		char **p = s->vals;
+
+		while (*p)
+		    if (pattry(prog, *p++))
+			return 0;
+	    }
+	    return 1;
+	}
+	break;
+    case 'g':
+	{
+	    LinkList l = newlinklist();
+	    int ret = 1;
+	    Stypat p;
+
+	    if (args[2]) {
+		if ((p = getstypat(args[2]))) {
+		    Style s;
+
+		    if (args[3]) {
+			if ((s = getstyle(p, args[3]))) {
+			    char **v = s->vals;
+
+			    while (*v)
+				addlinknode(l, *v++);
+
+			    ret = 0;
+			}
+		    } else {
+			for (s = p->styles; s; s = s->next)
+			    addlinknode(l, s->name);
+
+			ret = 0;
+		    }
+		}
+	    } else {
+		for (p = zstyles; p; p = p->next)
+		    addlinknode(l, p->pat);
+
+		ret = 0;
+	    }
+	    set_list_array(args[1], l);
+
+	    return ret;
+	}
+    }
+    return 0;
+}
+
+/* Format stuff. */
+
+static int
+bin_zformat(char *nam, char **args, char *ops, int func)
+{
+    char opt;
+
+    if (args[0][0] != '-' || !(opt = args[0][1]) || args[0][2]) {
+	zerrnam(nam, "invalid argument: %s", args[0], 0);
+	return 1;
+    }
+    args++;
+
+    switch (opt) {
+    case 'f':
+	{
+	    char **ap, *specs[256], *out, *s;
+	    int olen, oused = 0;
+
+	    memset(specs, 0, 256 * sizeof(char *));
+
+	    for (ap = args + 2; *ap; ap++) {
+		if (!ap[0][0] || ap[0][0] == '-' || ap[0][0] == '.' ||
+		    (ap[0][0] >= '0' && ap[0][0] <= '9') ||
+		    ap[0][1] != ':') {
+		    zerrnam(nam, "invalid argument: %s", *ap, 0);
+		    return 1;
+		}
+		specs[STOUC(ap[0][0])] = ap[0] + 2;
+	    }
+	    out = (char *) zhalloc(olen = 128);
+
+	    for (s = args[1]; *s; s++) {
+		if (*s == '%') {
+		    int right, min = -1, max = -1, outl;
+		    char *spec, *start = s;
+
+		    if ((right = (*++s == '-')))
+			s++;
+
+		    if (*s >= '0' && *s <= '9') {
+			for (min = 0; *s >= '0' && *s <= '9'; s++)
+			    min = (min * 10) + (int) STOUC(*s) - '0';
+		    }
+		    if (*s == '.' && s[1] >= '0' && s[1] <= '9') {
+			for (max = 0, s++; *s >= '0' && *s <= '9'; s++)
+			    max = (max * 10) + (int) STOUC(*s) - '0';
+		    }
+		    if ((spec = specs[STOUC(*s)])) {
+			int len;
+
+			if ((len = strlen(spec)) > max && max >= 0)
+			    len = max;
+			outl = (min >= 0 ? (min > len ? min : len) : len);
+
+			if (oused + outl >= olen) {
+			    int nlen = olen + outl + 128;
+			    char *tmp = (char *) zhalloc(nlen);
+
+			    memcpy(tmp, out, olen);
+			    olen = nlen;
+			    out = tmp;
+			}
+			if (len >= outl) {
+			    memcpy(out + oused, spec, outl);
+			    oused += outl;
+			} else {
+			    int diff = outl - len;
+
+			    if (right) {
+				while (diff--)
+				    out[oused++] = ' ';
+				memcpy(out + oused, spec, len);
+				oused += len;
+			    } else {
+				memcpy(out + oused, spec, len);
+				oused += len;
+				while (diff--)
+				    out[oused++] = ' ';
+			    }				
+			}
+		    } else {
+			int len = s - start + 1;
+
+			if (oused + len >= olen) {
+			    int nlen = olen + len + 128;
+			    char *tmp = (char *) zhalloc(nlen);
+
+			    memcpy(tmp, out, olen);
+			    olen = nlen;
+			    out = tmp;
+			}
+			memcpy(out + oused, start, len);
+			oused += len;
+		    }
+		} else {
+		    if (oused + 1 >= olen) {
+			char *tmp = (char *) zhalloc(olen << 1);
+
+			memcpy(tmp, out, olen);
+			olen <<= 1;
+			out = tmp;
+		    }
+		    out[oused++] = *s;
+		}
+	    }
+	    out[oused] = '\0';
+
+	    setsparam(args[0], ztrdup(out));
+	    return 0;
+	}
+	break;
+    case 'a':
+	{
+	    char **ap, *cp;
+	    int nbc = 0, colon = 0, pre = 0, suf = 0;
+
+	    for (ap = args + 2; *ap; ap++) {
+		for (nbc = 0, cp = *ap; *cp && *cp != ':'; cp++)
+		    if (*cp == '\\' && cp[1])
+			cp++, nbc++;
+		if (*cp == ':' && cp[1]) {
+		    int d;
+
+		    colon++;
+		    if ((d = cp - *ap - nbc) > pre)
+			pre = d;
+		    if ((d = strlen(cp + 1)) > suf)
+			suf = d;
+		}
+	    }
+	    {
+		int sl = strlen(args[1]);
+		VARARR(char, buf, pre + suf + sl + 1);
+		char **ret, **rp, *copy, *cpp, oldc;
+
+		ret = (char **) zalloc((arrlen(args + 2) + 1) *
+				       sizeof(char *));
+
+		memcpy(buf + pre, args[1], sl);
+		suf = pre + sl;
+
+		for (rp = ret, ap = args + 2; *ap; ap++) {
+		    copy = dupstring(*ap);
+		    for (cp = cpp = copy; *cp && *cp != ':'; cp++) {
+			if (*cp == '\\' && cp[1])
+			    cp++;
+			*cpp++ = *cp;
+		    }
+		    oldc = *cpp;
+		    *cpp = '\0';
+		    if (((cpp == cp && oldc == ':') || *cp == ':') && cp[1]) {
+			memset(buf, ' ', pre);
+			memcpy(buf, copy, (cpp - copy));
+			strcpy(buf + suf, cp + 1);
+			*rp++ = ztrdup(buf);
+		    } else
+			*rp++ = ztrdup(copy);
+		}
+		*rp = NULL;
+
+		setaparam(args[0], ret);
+		return 0;
+	    }
+	}
+	break;
+    }
+    zerrnam(nam, "invalid option: -%c", 0, opt);
+    return 1;
+}
+
+static struct builtin bintab[] = {
+    BUILTIN("zstyle", 0, bin_zstyle, 0, -1, 0, NULL, NULL),
+    BUILTIN("zformat", 0, bin_zformat, 3, -1, 0, NULL, NULL),
+};
+
+
+/**/
+int
+setup_zutil(Module m)
+{
+    zstyles = NULL;
+
+    return 0;
+}
+
+/**/
+int
+boot_zutil(Module m)
+{
+    return !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
+}
+
+/**/
+int
+cleanup_zutil(Module m)
+{
+    deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
+    return 0;
+}
+
+/**/
+int
+finish_zutil(Module m)
+{
+    freestypat(zstyles);
+
+    return 0;
+}
diff -ru ../z.old/Src/Modules/zutil.mdd Src/Modules/zutil.mdd
--- ../z.old/Src/Modules/zutil.mdd	Fri Dec 10 13:50:40 1999
+++ Src/Modules/zutil.mdd	Fri Dec 10 11:30:06 1999
@@ -0,0 +1,3 @@
+objects="zutil.o"
+
+autobins="zformat zstyle"
diff -ru ../z.old/Src/Zle/complist.c Src/Zle/complist.c
--- ../z.old/Src/Zle/complist.c	Thu Dec  9 15:55:43 1999
+++ Src/Zle/complist.c	Fri Dec 10 09:04:43 1999
@@ -916,7 +916,7 @@
 		s->nbrbeg = nbrbeg;
 		s->nbrend = nbrend;
 		s->nmatches = nmatches;
-		menucmp = menuacc = 0;
+		menucmp = menuacc = hasoldlist = 0;
 		fixsuffix();
 		validlist = 0;
 		amatches = pmatches = lastmatches = NULL;
diff -ru ../z.old/Src/Zle/computil.c Src/Zle/computil.c
--- ../z.old/Src/Zle/computil.c	Thu Dec  9 15:55:44 1999
+++ Src/Zle/computil.c	Fri Dec 10 11:30:07 1999
@@ -102,24 +102,6 @@
     return ret;
 }
 
-/**/
-static int
-bin_compdisplay(char *nam, char **args, char *ops, int func)
-{
-    struct cdisp disp;
-
-    if (incompfunc != 1) {
-	zerrnam(nam, "can only be called from completion function", NULL, 0);
-	return 1;
-    }
-    disp.pre = disp.suf = disp.colon = 0;
-
-    cdisp_calc(&disp, args + 2);
-    setaparam(args[0], cdisp_build(&disp, args[1], args + 2));
-
-    return !disp.colon;
-}
-
 /* Help fuer `_describe'. */
 
 typedef struct cdset *Cdset;
@@ -2179,411 +2161,6 @@
     return 0;
 }
 
-/* Style stuff. */
-
-typedef struct cspat *Cspat;
-typedef struct cstyle *Cstyle;
-
-/* A pattern and the styles for it. */
-
-struct cspat {
-    Cspat next;
-    char *pat;			/* pattern string */
-    Patprog prog;		/* compiled pattern */
-    int weight;			/* how specific is the pattern? */
-    Cstyle styles, lstyles;	/* first/last style */
-};
-    
-struct cstyle {
-    Cstyle next;
-    char *name;
-    char **vals;
-};
-
-/* List of styles. */
-
-static Cspat compstyles, lcompstyles;
-
-/* Memory stuff. */
-
-static void
-freecstyle(Cstyle s)
-{
-    Cstyle n;
-
-    while (s) {
-	n = s->next;
-
-	zsfree(s->name);
-	if (s->vals)
-	    freearray(s->vals);
-	zfree(s, sizeof(*s));
-
-	s = n;
-    }
-}
-
-static void
-freecspat(Cspat p)
-{
-    Cspat n;
-
-    while (p) {
-	n = p->next;
-
-	zsfree(p->pat);
-	freepatprog(p->prog);
-	zfree(p, sizeof(*p));
-
-	p = n;
-    }
-}
-
-/* Get the struct for a pattern, if any. */
-
-static Cspat
-getcspat(char *pat)
-{
-    Cspat p;
-
-    for (p = compstyles; p; p = p->next)
-	if (!strcmp(pat, p->pat))
-	    return p;
-
-    return NULL;
-}
-
-/* Get the style stuff for a name. */
-
-static Cstyle
-getcstyle(Cspat p, char *name)
-{
-    Cstyle s;
-
-    for (s = p->styles; s; s=  s->next)
-	if (!strcmp(name, s->name))
-	    return s;
-
-    return NULL;
-}
-
-/* Store a value for a style. */
-
-static void
-setcstyle(Cspat p, char *name, char **vals)
-{
-    Cstyle s;
-
-    for (s = p->styles; s; s = s->next)
-	if (!strcmp(name, s->name)) {
-
-	    /* Exists -> replace. */
-
-	    if (s->vals)
-		freearray(s->vals);
-	    PERMALLOC {
-		s->vals = arrdup(vals);
-	    } LASTALLOC;
-
-	    return;
-	}
-
-    /* New style. */
-
-    s = (Cstyle) zalloc(sizeof(*s));
-
-    s->name = ztrdup(name);
-    PERMALLOC {
-	s->vals = arrdup(vals);
-    } LASTALLOC;
-    s->next = NULL;
-
-    if (p->lstyles)
-	p->lstyles->next = s;
-    else
-	p->styles = s;
-    p->lstyles = s;
-}
-
-/* Add a new pattern. */
-
-static Cspat
-addcspat(char *pat, Patprog prog)
-{
-    Cspat p, q, qq;
-    int weight, tmp, first;
-    char *s;
-
-    /* Calculate the weight. */
-
-    for (weight = 0, tmp = 2, first = 1, s = pat; *s; s++) {
-	if (first && *s == '*' && (!s[1] || s[1] == ':')) {
-	    /* Only `*' in this component. */
-	    tmp = 0;
-	    continue;
-	}
-	first = 0;
-
-	if (*s == '(' || *s == '|' || *s == '*' || *s == '[' || *s == '<' ||
-	    *s == '?' || *s == '#' || *s == '^')
-	    /* Is pattern. */
-	    tmp = 1;
-
-	if (*s == ':') {
-	    /* Yet another component. */
-
-	    first = 1;
-	    weight += tmp;
-	    tmp = 2;
-	}
-    }
-    weight += tmp;
-
-    p = (Cspat) zalloc(sizeof(*p));
-
-    p->pat = ztrdup(pat);
-    p->weight = weight;
-    p->prog = prog;
-    p->styles = p->lstyles = NULL;
-
-    for (qq = NULL, q = compstyles; q && q->weight >= weight;
-	 qq = q, q = q->next);
-
-    p->next = q;
-    if (qq)
-	qq->next = p;
-    else
-	compstyles = p;
-    if (!q)
-	lcompstyles = p;
-
-    return p;
-}
-
-/* Delete a style. */
-
-static void
-deletecstyle(Cspat p, char *name)
-{
-    Cstyle ps, s;
-
-    for (ps = NULL, s = p->styles; s; ps = s, s = s->next)
-	if (!strcmp(name, s->name)) {
-	    if (ps)
-		ps->next = s->next;
-	    else
-		p->styles = s->next;
-	    if (s == p->lstyles)
-		p->lstyles = ps;
-
-	    s->next = NULL;
-	    freecstyle(s);
-
-	    return;
-	}
-}
-
-/* Delete a whole pattern with all its styles. */
-
-static void
-deletecspat(Cspat pat)
-{
-    Cspat pp, p;
-
-    for (pp = NULL, p = compstyles; p; pp = p, p = p->next)
-	if (p == pat) {
-	    if (pp)
-		pp->next = p->next;
-	    else
-		compstyles = p->next;
-	    if (p == lcompstyles)
-		lcompstyles = pp;
-
-	    p->next = NULL;
-	    zsfree(p->pat);
-	    freepatprog(p->prog);
-	    freecstyle(p->styles);
-	    zfree(p, sizeof(*p));
-
-	    return;
-	}
-}
-
-/* Look up a style for a context pattern. This does the matching. */
-
-static Cstyle
-lookupcstyle(char *ctxt, char *style)
-{
-    Cspat p;
-    Cstyle s;
-
-    for (p = compstyles; p; p = p->next)
-	if (pattry(p->prog, ctxt))
-	    for (s = p->styles; s; s = s->next)
-		if (!strcmp(style, s->name))
-		    return s;
-
-    return NULL;
-}
-
-static int
-bin_compstyles(char *nam, char **args, char *ops, int func)
-{
-    int min, max, n;
-
-    if (args[0][0] != '-' || !args[0][1] || args[0][2]) {
-	zerrnam(nam, "invalid argument: %s", args[0], 0);
-	return 1;
-    }
-    switch (args[0][1]) {
-    case 'a': min = 2; max = -1; break;
-    case 'd': min = 0; max =  2; break;
-    case 'S': min = 3; max =  3; break;
-    case 'A': min = 3; max =  3; break;
-    case 'H': min = 3; max =  3; break;
-    case 'T': min = 2; max =  2; break;
-    case 'G': min = 1; max =  3; break;
-    default:
-	zerrnam(nam, "invalid option: %s", args[0], 0);
-	return 1;
-    }
-    n = arrlen(args) - 1;
-    if (n < min) {
-	zerrnam(nam, "not enough arguments", NULL, 0);
-	return 1;
-    } else if (max >= 0 && n > max) {
-	zerrnam(nam, "too many arguments", NULL, 0);
-	return 1;
-    }
-    switch (args[0][1]) {
-    case 'a':
-	{
-	    Cspat p;
-
-	    if (!(p = getcspat(args[1]))) {
-		Patprog prog;
-		char *pat = dupstring(args[1]);
-
-		tokenize(pat);
-
-		if (!(prog = patcompile(pat, PAT_ZDUP, NULL))) {
-		    zerrnam(nam, "invalid pattern: %s", args[1], 0);
-		    return 1;
-		}
-		p = addcspat(args[1], prog);
-	    }
-	    setcstyle(p, args[2], args + 3);
-	}
-	break;
-    case 'd':
-	{
-	    Cspat p;
-
-	    if (args[1]) {
-		if ((p = getcspat(args[1]))) {
-		    if (args[2]) {
-			deletecstyle(p, args[2]);
-			if (!p->styles)
-			    deletecspat(p);
-		    } else
-			deletecspat(p);
-		}
-	    } else {
-		freecspat(compstyles);
-		compstyles = lcompstyles = NULL;
-	    }
-	}
-	break;
-    case 'S':
-	{
-	    Cstyle s;
-	    char *ret;
-	    int val;
-
-	    if ((s = lookupcstyle(args[1], args[2])) && s->vals[0]) {
-		PERMALLOC {
-		    ret = sepjoin(s->vals, NULL);
-		} LASTALLOC;
-		val = 0;
-	    } else {
-		ret = ztrdup("");
-		val = 1;
-	    }
-	    setsparam(args[3], ret);
-
-	    return val;
-	}
-	break;
-    case 'A':
-    case 'H':
-	{
-	    Cstyle s;
-	    char **ret;
-	    int val;
-
-	    if ((s = lookupcstyle(args[1], args[2]))) {
-		PERMALLOC {
-		    ret = arrdup(s->vals);
-		} LASTALLOC;
-		val = 0;
-	    } else {
-		char *dummy = NULL;
-
-		PERMALLOC {
-		    ret = arrdup(&dummy);
-		} LASTALLOC;
-		val = 1;
-	    }
-	    if (args[0][1] == 'A')
-		setaparam(args[3], ret);
-	    else
-		sethparam(args[3], ret);
-
-	    return val;
-	}
-	break;
-    case 'T':
-	return !lookupcstyle(args[1], args[2]);
-    case 'G':
-	{
-	    LinkList l = newlinklist();
-	    int ret = 1;
-	    Cspat p;
-
-	    if (args[2]) {
-		if ((p = getcspat(args[2]))) {
-		    Cstyle s;
-
-		    if (args[3]) {
-			if ((s = getcstyle(p, args[3]))) {
-			    char **v = s->vals;
-
-			    while (*v)
-				addlinknode(l, *v++);
-
-			    ret = 0;
-			}
-		    } else {
-			for (s = p->styles; s; s = s->next)
-			    addlinknode(l, s->name);
-
-			ret = 0;
-		    }
-		}
-	    } else {
-		for (p = compstyles; p; p = p->next)
-		    addlinknode(l, p->pat);
-
-		ret = 0;
-	    }
-	    set_list_array(args[1], l);
-
-	    return ret;
-	}
-    }
-    return 0;
-}
-
 /* Tags stuff. */
 
 typedef struct ctags *Ctags;
@@ -2855,12 +2432,10 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("compdisplay", 0, bin_compdisplay, 2, -1, 0, NULL, NULL),
     BUILTIN("compdescribe", 0, bin_compdescribe, 3, -1, 0, NULL, NULL),
     BUILTIN("comparguments", 0, bin_comparguments, 1, -1, 0, NULL, NULL),
     BUILTIN("compvalues", 0, bin_compvalues, 1, -1, 0, NULL, NULL),
     BUILTIN("compquote", 0, bin_compquote, 1, -1, 0, NULL, NULL),
-    BUILTIN("compstyles", 0, bin_compstyles, 1, -1, 0, NULL, NULL),
     BUILTIN("comptags", 0, bin_comptags, 1, -1, 0, NULL, NULL),
     BUILTIN("comptry", 0, bin_comptry, 0, -1, 0, NULL, NULL),
     BUILTIN("compfmt", 0, bin_compfmt, 2, -1, 0, NULL, NULL),
@@ -2874,8 +2449,6 @@
     memset(cadef_cache, 0, sizeof(cadef_cache));
     memset(cvdef_cache, 0, sizeof(cvdef_cache));
 
-    compstyles = NULL;
-
     memset(comptags, 0, sizeof(comptags));
 
     lasttaglevel = 0;
@@ -2908,8 +2481,6 @@
 	freecadef(cadef_cache[i]);
     for (i = 0; i < MAX_CVCACHE; i++)
 	freecvdef(cvdef_cache[i]);
-
-    freecspat(compstyles);
 
     for (i = 0; i < MAX_TAGS; i++)
 	freectags(comptags[i]);
diff -ru ../z.old/Src/Zle/computil.mdd Src/Zle/computil.mdd
--- ../z.old/Src/Zle/computil.mdd	Thu Dec  9 15:55:44 1999
+++ Src/Zle/computil.mdd	Fri Dec 10 11:30:07 1999
@@ -2,4 +2,4 @@
 
 objects="computil.o"
 
-autobins="compdisplay compdescribe comparguments compvalues compquote compstyles comptags comptry"
+autobins="compdescribe comparguments compvalues compquote comptags comptry"
diff -ru ../z.old/Src/xmods.conf Src/xmods.conf
--- ../z.old/Src/xmods.conf	Fri Dec 10 13:51:01 1999
+++ Src/xmods.conf	Fri Dec 10 11:30:07 1999
@@ -4,6 +4,7 @@
 compctl
 sched
 complist
+zutil
 computil
 parameter
 zleparameter

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

