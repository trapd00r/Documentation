From zsh-workers-return-5659-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Mar 05 13:07:56 1999
Return-Path: <zsh-workers-return-5659-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18015 invoked from network); 5 Mar 1999 13:07:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 5 Mar 1999 13:07:54 -0000
Received: (qmail 21284 invoked by alias); 5 Mar 1999 13:07:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5659
Received: (qmail 21276 invoked from network); 5 Mar 1999 13:07:16 -0000
Date: Fri, 5 Mar 1999 14:06:28 +0100 (MET)
Message-Id: <199903051306.OAA04169@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Fri, 5 Mar 1999 14:40:27 +0300
Subject: RE: PATCH: Re: Shuld it be so? and Re: _tar


Andrej Borsenkow wrote:

> >
> > > bor@itsrm2:~%> l /u/l/m<TAB>
> > > bor@itsrm2:~%> l /u1/lager-db/minileit.dbs/
> > > u1/   usr/
> > > ^^^^^^^^^^ Somewhat strange. We really have /usr/lib/macros
> > (and more), but
> > > this list is a bit unexpected (well, at least I would expect
> > then to first
> > > menu complete ``/u1'' and ``/usr'' and then go on respectively)
> >
> > It now keeps the original suffix if menucompletion is used. With
> > normal completion it still tries to build as long a suffix as
> > possible.
> 
> Well, now it cycles through /u1 and /usr, leaving the tail unmodified. And?
> I have no way to say "go ahead, and complete the next path component". And
> inserted string is unusable as is.

<Cursor-Left><Cursor-Right><TAB> or just <Cursor-Left><TAB> or
<x><BackSpace><TAB> or ...

How do you folks using menucompletion complete consecutive path
components (normal, existing paths, without _path_files), btw?

> I'd expect, that in case of menucompletion the whole list (after common
> prefix) would simply be spit out. Yes, it is ugly if no common prefix
> exists. But then you get what you asked for.

Really? I could do that but would like to hear opinions of others
using menucompletion before I...

> > Anyway, if you try it, you will notice, that the cursor is left at the
> > end of the whole string, even though only the beginning is cycled
> > through. Since I don't like menucompletion I have to ask: would you
> > like to have the cursor after the changed/listed component? (I'm not
> > sure if I can manage to implement that, though.)
> >
> 
> Me not. See above. Until we come to a clean solution how to implement
> partial, incremental completion (I had some weird idea today morning) - give
> a user the whole list. We do it in most cases anyway.

In which cases do we this? We are talking about paths here. And no, I
certainly don't want to see some hundred possible completions when the 
code sets me in a position where I have to choose between two or three 
directories. This is without menucompletion, though... (But I would
think that with menucompletion keeping the list small is even more
important, isn't it?)

> >
> > This is now allowed if `globcomplete' is set. Otherwise the pattern
> > characters will still be quoted (which is a good thing, I think).
> >
> 
> Not sure. It is now O.K. with globcomplete set. But without globcomplete I
> get ``/home/bor/s\*'' - what is it good for? Better would be to leave meta
> as is. Cf
> 
> grep xxx /u/i/s/*.h<TAB>
> 
> I'd expect it to complete path and leave star in place.

Hm. Ok. (Especially since I saw -- looking at compctl like you -- that 
compctl made it this way.)

Unfortunately I had to change the C-code for this since it was
tricky.c that added the backslashes (I had played with `globcomplete' a
bit when implementing the code and at that time inserting them looked
like a good idea). Implementors of completion functions that do the
matching themselves have to make a mental note that they now have to
detect if the string they are given should be treated as a pattern or
not -- and probably they have to use `:q', based on the setting of
`globcomplete'.


Bye
 Sven

diff -u oc/Core/_comp_parts Completion/Core/_comp_parts
--- oc/Core/_comp_parts	Fri Mar  5 12:49:15 1999
+++ Completion/Core/_comp_parts	Fri Mar  5 13:56:04 1999
@@ -42,6 +42,7 @@
 # Get the string from the line.
 
 str="$PREFIX$SUFFIX"
+[[ -o globcomplete ]] && str="$str:q"
 prefix=""
 
 # Walk through the arguments to find the longest unambiguous prefix.
diff -u oc/Core/_multi_parts Completion/Core/_multi_parts
--- oc/Core/_multi_parts	Fri Mar  5 12:49:16 1999
+++ Completion/Core/_multi_parts	Fri Mar  5 13:56:43 1999
@@ -45,7 +45,11 @@
 # the original string in `orig'. The `eval' is used to replace our
 # separator character by `*<sep>'.
 
-patstr="${PREFIX}*${SUFFIX}*"
+if [[ -o globcomplete ]]; then
+  patstr="${PREFIX}*${SUFFIX}*"
+else
+  patstr="${PREFIX:q}*${SUFFIX:q}*"
+fi
 orig="${PREFIX}${SUFFIX}"
 
 matchflags=""
diff -u oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Fri Mar  5 12:49:16 1999
+++ Completion/Core/_path_files	Fri Mar  5 13:52:42 1999
@@ -91,12 +91,12 @@
 # str holds the whole string from the command line with a `*' between
 # the prefix and the suffix.
 
-str="${PREFIX}*${SUFFIX}"
-
-# If the string began with a `~', the quoting turned this into `\~',
-# remove the slash.
-
-[[ "$str" = \\\~* ]] && str="$str[2,-1]"
+if [[ -o globcomplete ]]; then
+  str="${PREFIX}*${SUFFIX}"
+else
+  str="${PREFIX:q}*${SUFFIX:q}"
+fi
+orig="${PREFIX}${SUFFIX}"
 
 # We will first try normal completion called with `compgen', but only if we
 # weren't given a `-F' option.
@@ -144,6 +144,7 @@
   eval realpath\=$linepath
   [[ "$realpath" = "$linepath" ]] && return
   str="${str#*/}"
+  orig="${orig#*/}"
   donepath=''
   prepaths=( '' )
 else
@@ -159,6 +160,7 @@
     # Also, we don't use the paths from `-W'.
 
     str="$str[2,-1]"
+    orig="$orig[2,-1]"
     donepath='/'
     prepaths=( '' )
   else
@@ -170,9 +172,6 @@
   fi
 fi
 
-# Save the original string.
-orig="${str:s/*//}"
-
 # Now build the glob pattern by calling `_match_pattern'.
 patstr="$str"
 matchflags=""
@@ -184,7 +183,7 @@
 # have special meaning for globbing, we remove them. But before that, we
 # add the pattern for matching any characters before a slash.
 
-patstr="$patstr:gs-/-*/-:gs/*.*.//:gs-/*.-/.-:gs/**/*/:gs-.*/-./-"
+patstr="$patstr:gs-/-*/-:gs/*.*./../:gs-/*.-/.-:gs/**/*/:gs-.*/-./-"
 
 # First we skip over all pathname components in `str' which really exist in
 # the file-system, so that `/usr/lib/l<TAB>' doesn't offer you `lib' and
@@ -256,9 +255,9 @@
       # next `-W' path.
 
       if [[ $#collect -eq 0 ]]; then
-        compadd -U "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
-                -i "$IPREFIX" -p "$linepath$testpath" -S "/${ostr#*/}" \
-		-W "$tmp1" -f "$ignore[@]" - "$tmp1[@]"
+        compadd -QU "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
+                -i "$IPREFIX" -p "${linepath:q}${testpath:q}" -S "/${ostr#*/}" \
+		-W "$tmp1" -f "$ignore[@]" - "${(@)tmp1:q}"
         continue 2
       elif [[ $#collect -ne 1 ]]; then
         # If we have more than one possible match, this means that the
@@ -284,9 +283,9 @@
 	# (the `-f' and `-F' options).
 
 	if [[ $compstate[insert] = *menu ]]; then
-          compadd -U "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
-                  -i "$IPREFIX" -p "$linepath$testpath" -S "/${ostr#*/}" \
-		  -W "$tmp1" -f "$ignore[@]" - "${(@)collect%%/*}"
+          compadd -QU "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
+                  -i "$IPREFIX" -p "${linepath:q}${testpath:q}" -S "/${ostr#*/}" \
+		  -W "$tmp1" -f "$ignore[@]" - "${(@)${(@)collect%%/*}:q}"
 	else
           for i in $collect; do
             compadd -U "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
@@ -335,7 +334,7 @@
     [[ "$linepath$testpath$ostr" = "$PREFIX$SUFFIX" ]] && return
 
     compadd -QU -S '' "$group[@]" "$expl[@]" \
-            -i "$IPREFIX" -f - "$linepath$testpath$ostr"
+            -i "$IPREFIX" -f - "${linepath:q}${testpath:q}$ostr"
   else
     compadd -U "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
             -i "$IPREFIX" -p "$linepath$testpath" -f "$ignore[@]" \
diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Fri Mar  5 12:50:05 1999
+++ Src/Zle/zle_tricky.c	Fri Mar  5 14:01:06 1999
@@ -5200,23 +5200,19 @@
 	    compquote = ztrdup("");
 	    compquoting = ztrdup("");
 	}
+	untokenize(s = dupstring(s));
 	zsfree(compprefix);
 	zsfree(compsuffix);
 	if (unset(COMPLETEINWORD)) {
-	    tmp = quotename(s, NULL, NULL, NULL);
-	    untokenize(tmp);
-	    compprefix = ztrdup(tmp);
+	    compprefix = ztrdup(s);
 	    compsuffix = ztrdup("");
 	} else {
 	    char *ss = s + offs, sav;
-	    
-	    tmp = quotename(s, &ss, NULL, NULL);
+
 	    sav = *ss;
 	    *ss = '\0';
-	    untokenize(tmp);
-	    compprefix = ztrdup(tmp);
+	    compprefix = ztrdup(s);
 	    *ss = sav;
-	    untokenize(ss);
 	    compsuffix = ztrdup(ss);
 	}
 	zsfree(compiprefix);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

