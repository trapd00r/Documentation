From zsh-workers-return-7002-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jul 07 10:32:08 1999
Return-Path: <zsh-workers-return-7002-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10071 invoked from network); 7 Jul 1999 10:32:06 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Jul 1999 10:32:06 -0000
Received: (qmail 9495 invoked by alias); 7 Jul 1999 10:31:56 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7002
Received: (qmail 9487 invoked from network); 7 Jul 1999 10:31:53 -0000
Message-Id: <9907071003.AA22985@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: pws-25: _read_comp, again
Date: Wed, 07 Jul 1999 12:03:11 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

This modifies _read_comp to use Sven's zle -R rewrite to provide a
completion listing for the completion functions that can be completed to
run to get a completion.  (Alles klar?)  With autolist set and
alwayslastprompt set, it will list the possible functions after the first
character is typed.

There were some small problems: beeping added a newline, it was still
possible to get a completion on global matchers after the first if you
aborted, and I had to trap SIGINT to return from the function because for
some reason `read -k' wasn't returning the right status, just a 0 (which
you can't tell from C-SPC):  strange, since it seems to work perfectly well
in ordinary widgets.  I've left the commented-out debugging code in
deliberately.  Sigh.

--- Completion/Commands/_read_comp.c6	Mon Jul  5 16:21:32 1999
+++ Completion/Commands/_read_comp	Wed Jul  7 11:50:26 1999
@@ -23,7 +23,10 @@
 #  _read_comp         Last completion string read from user
 
 emulate -L zsh
-setopt extendedglob nobadpattern
+setopt extendedglob nobadpattern # xtrace promptsubst
+# local PS4='%N:%i:$((#key))> '
+
+trap 'zle -cR ""; return 1' INT
 
 # Took me ages to work this out.  If we're not on the first global
 # matcher specification, we mustn't do any I/O.
@@ -41,7 +44,9 @@
   return
 fi
 
-local key search str str2 newch funcs funcs2 exact msg
+_read_comp=
+
+local key search str str2 newch funcs funcs2 exact msg list
 integer pos
 
 msg="Completion: "
@@ -49,37 +54,48 @@
 zle -R $msg
 
 if ! read -k key; then
-  zle -R ''
+  zle -cR ''
   return 1
 fi
 
 while [[ '#key' -ne 10 && '#key' -ne 13 ]]; do
-  if [[ '#key' -eq 3 || '#key' -eq 7 ]]; then
-    zle -R ''
+  if [[ '#key' -eq 0 && '#key' -eq 3 || '#key' -eq 7 ]]; then
+    zle -cR ''
     return 1
   fi
   if [[ ( '#key' -eq 8 || '#key' -eq 127 ) && -n $str ]]; then
     # delete character
     str="$str[1,-2]"
     exact=
+    list=()
   elif [[ '#key' -eq 21 ]]; then
     # ^U: delete line
     str=
     exact=
+    list=()
+  elif [[ '#key' -eq 4 && $str = _[^\ ]# && $str != *' '* ]]; then
+    # ^D: list completions
+    list=(${$(whence -m "$str*" 2>/dev/null)%: function})
   elif [[ ( -n $exact && $key != ' ' ) || '#key & 127' -lt 32 ]]; then
     # If we've got an exact function, only allow a space after it.
     # Don't try to insert non-printing characters.
     if [[ -n $ZBEEP ]]; then
       print -nb $ZBEEP
     elif [[ -o beep ]]; then
-      print "\a"
+      print -n "\a"
     fi
+    list=()
   else
     str="$str$key"
     if [[ $str = _[^\ ]# ]]; then
       # Rudimentary completion for function names.
       # Allow arguments, i.e. don't do this after we've got a space.
       funcs=(${$(whence -m "$str*" 2>/dev/null)%: function})
+      if [[ -o autolist && $#str -gt 1 ]]; then
+	list=($funcs)
+      else
+	list=()
+      fi
       if (( $#funcs == 1 )); then
 	# Exact match; prompt the user for a newline to confirm
 	str=$funcs[1]
@@ -89,9 +105,10 @@
 	if [[ -n $ZBEEP ]]; then
 	  print -nb $ZBEEP
 	elif [[ -o beep ]]; then
-	  print "\a"
+	  print -n "\a"
 	fi
 	str="$str[1,-2]"
+	list=()
       else
 	# Add characters to the string until a name doesn't
 	# match any more, then backtrack one character to get
@@ -112,9 +129,13 @@
       exact=
     fi
   fi
-  zle -R "$msg$str$exact"
+  if (( $#list )); then
+    zle -R "$msg$str$exact" $list
+  else
+    zle -cR "$msg$str$exact"
+  fi
   if ! read -k key; then
-    zle -R ''
+    zle -cR ''
     return 1
   fi
 done
@@ -130,7 +151,7 @@
   _read_comp=$str
 fi
 
-zle -R ''
+zle -cR ''
 
 if [[ $str = _* ]]; then
   eval $str

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

