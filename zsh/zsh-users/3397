From zsh-users-return-3397-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Aug 26 17:51:39 2000
Return-Path: <zsh-users-return-3397-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10982 invoked from network); 26 Aug 2000 17:51:38 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Aug 2000 17:51:38 -0000
Received: (qmail 22843 invoked by alias); 26 Aug 2000 17:50:50 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 3397
Received: (qmail 22836 invoked from network); 26 Aug 2000 17:50:48 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000826175034.ZM13455@candle.brasslantern.com>
Date: Sat, 26 Aug 2000 17:50:34 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.auc.dk
Subject: A different approach to PROMPT_CR
Cc: "Mark G. Sobell" <mark@sobell.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

There have previously been two suggested solutions to the promblem of zsh's
prompt overwriting command output when that output does not end with a
newline: Either `setopt nopromptcr', which leaves the prompt in the middle
of the line and may mess up ZLE editing; or include a newline in PS1, which
means seeing a blank line after the output of most commands.  (These are
both discussed in the FAQ, section 3.)

Here's a different solution, which unfortunately works only on VT100/ANSI
compatible terminals.  Place the following in a file in your fpath, named
`promptnl'; add `autoload promptnl' to your .zshrc; and include a call to
promptnl near the end of your precmd function.

When promptnl runs, it asks the terminal to send back the current position
of the cursor.  If the cursor is in column 1, it does nothing; otherwise it
prints a newline.  Thus you get a newline exactly when one is needed.

Of course this can make it appear that `print -n' and friends have failed
to suppress the final newline; so promptnl outputs the value of the EOLMARK
parameter before the newline, with prompt sequences expanded.  So you can
for example use EOLMARK='%B!%b' to put a bold exclamation point at the end
of the actual output.

This could be coded in C and added to ZLE ... `setopt PROMPT_NL', anyone?

---- 8< ---- cut here ---- 8< ----
#autoload
emulate -L zsh

# VT100 and ANSI terminals will report the cursor position when sent
# the sequence ESC [ 6 n -- it comes back as ESC [ column ; line R
# with of course no trailing newline.  Column and line are 1-based.

local RECV SEND='\e[6n' REPLY=X

# If you are on a very slow tty, you may need to increase WAIT here.
integer WAIT=1

# This is annoying, but zsh immediately resets it properly, so ...
stty -echo

# Output the SEND sequence and read back into RECV.  In case this is
# not a terminal that understands SEND, do a non-blocking read and
# retry for at most WAIT seconds before giving up.  Requires 3.1.9.
# For 3.0.x, remove "-t" but don't call this on the wrong terminal!

print -nP $SEND

integer N=$SECONDS
while [[ $REPLY != R ]] && ((SECONDS - N <= WAIT))
do
    read -t -k 1 && ((N=SECONDS))
    RECV=$RECV$REPLY
done

# If the cursor is not in the first column, emit EOLMARK and newline.

(( ${${RECV#*\;}%R} > 1 )) && print -P $EOLMARK

return 0
---- 8< ---- cut here ---- 8< ----

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

