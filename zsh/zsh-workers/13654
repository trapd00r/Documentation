From zsh-workers-return-13654-mason-zsh=primenet.com.au@sunsite.dk Fri Mar 16 18:23:49 2001
Return-Path: <zsh-workers-return-13654-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24253 invoked from network); 16 Mar 2001 18:23:48 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Mar 2001 18:23:48 -0000
Received: (qmail 18785 invoked by alias); 16 Mar 2001 18:23:42 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13654
Received: (qmail 18732 invoked from network); 16 Mar 2001 18:23:40 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010316182317.ZM5902@candle.brasslantern.com>
Date: Fri, 16 Mar 2001 18:23:17 +0000
In-Reply-To: <874rwtzteq.fsf@home.delysid.org>
Comments: In reply to Mario Lang <mlang@home.delysid.org>
        "ZSpeak! Only Zsh can do this!" (Mar 16,  3:21pm)
References: <874rwtzteq.fsf@home.delysid.org>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Mario Lang <mlang@home.delysid.org>, zsh-workers@sunsite.dk
Subject: Re: ZSpeak! Only Zsh can do this!
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Mar 16,  3:21pm, Mario Lang wrote:
} Subject: ZSpeak! Only Zsh can do this!
} 
} OK, here we go. Please mail me with every (minor|major) suggestion.
} I can use everything. Especially to learn nice Zsh techniques.
} 
} # * Find a nice way to add/remove keybindings in speech-(on|off)

Finding a nice way to remove keybindings is sort of a general topic of
discussion right now.

For the rebindings of forward-char and backward-char, look at the way
it's done in Functions/Zle/predict-on (in the predict-off function).

} # * Find a way to make the prefix key-sequence configurable (^[v)

That should be as easy as stashing it in a parameter.  Or you could use
the zstyle mechanism.

} # * Modify the completion system so that menu-completion inserted
} #   text gets spoken.

Hrm, that one probably requires C source code changes.

} # * Find a way to read stdout/stderr of commands too! is exec my friend?

Yes, of course!

Let me jump ahead a bit, though:

} speak-string () {
}     # Here goes the compatibility code. All synth specific
}     # decissions when outputting text should be done here.
}     case $ZSPEAK_SYNTH in
} 	festival)
} 	    [[ -x `which festival` ]] && print "$@"|festival --tts
} 	    ;;
}         speechd)
} 	    [[ -e "/dev/speech" ]] && print "$@">/dev/speech
} 	    ;;
} 	*)
}     esac
} }

I'm not familiar with how "festival" works, but if it can accept a series
of lines and speak each one as it sees the newline, you can use a feature
of zsh's coproc mechanism to emulate /dev/speech.

Rather than test for the existence of festival every time speak-string is
called, you set it up in advance like this:

    if [[ $ZSPEAK_SYNTH == festival && -x `which festival` ]]
    then
      coproc festival --tts
      speak-string () {
        print -p "$@"
      }
    elif [[ [[ $ZSPEAK_SYNTH == speechd && -e /dev/speech ]]
      speak-string () {
        print "$@" > /dev/speech
      }
    else
      speak-string () { }
    fi

Now "print -p" sends its output to the speech synthesizer, as does any
command whose output is redirected with ">&p".  Unlike ksh coprocesses,
zsh holds open the coproc descriptors even when redirection has been
done, so as long as festival doesn't exit, you can redirect the output
of every command through it.

Of course this may have unwanted side-effects if festival holds open a
sound device, thereby preventing other sound processes from using it.
However, I'll proceed on the assumption that's not the case.  Also, it
means you can't use "coproc" for anything else, but in my experience
hardly anyone ever uses zsh coprocesses in the first place.

With the coproc in place, if you want to, you can take advantage of
"multios" like so:

    setopt multios
    exec 2>&1 2>&p	# Send stderr to both stdout and synthesizer
    exec >&2		# Send stdout to the two places stderr goes

Now everything output by any command that isn't explicitly redirected
somewhere else, will be both written to the terminal (or wherever fd 1
was originally pointing) and spoken.

Replace >&p with >/dev/speech in the first exec if using speechd, but
again the caveat about holding the device open may apply.

Note that some commands, such as "less", may attempt to use fd 2 for
interactive input when their standard input is a pipe.  In that case
the above trick of multi-redirecting stderr works very badly.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

