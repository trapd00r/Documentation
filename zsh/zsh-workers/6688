From zsh-workers-return-6688-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 17 08:46:31 1999
Return-Path: <zsh-workers-return-6688-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16901 invoked from network); 17 Jun 1999 08:46:28 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Jun 1999 08:46:28 -0000
Received: (qmail 28773 invoked by alias); 17 Jun 1999 08:45:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6688
Received: (qmail 28737 invoked from network); 17 Jun 1999 08:45:21 -0000
Message-ID: <4FBF540FF16FD1119D9600A0C94B2B51F29E8F@napier.logica.co.uk>
From: "Kiddle, Oliver" <KiddleO@logica.com>
To: "'zsh-workers@sunsite.auc.dk'" <zsh-workers@sunsite.auc.dk>
Subject: Doc fixes - US vs. British spelling
Date: Thu, 17 Jun 1999 09:45:16 +0100
X-Mailer: Internet Mail Service (5.5.2448.0)

Following is a small patch to the documentation. Mostly it is changing
'initialise' to 'initialize'. If British spelling is generally prefered
then I can create a patch to do the change the other way. I just think
that we should be consistent. I did a grep for 'ise' and the only other
words this found were 'bitwise', 'otherwise' and 'recognise'. I haven't
got a US dictionary so can't confirm it but I'd guess that only the
latter would be spelt with a z in America. There are also some other
British spellings like behaviour and favour in there. 

Note that there are a couple of fixes in here which have nothing
to do with British vs. American spelling.

Oliver Kiddle

diff -u -r old/compsys.yo Zsh/compsys.yo
--- old/compsys.yo	Mon Jun 14 17:14:28 1999
+++ Zsh/compsys.yo	Wed Jun 16 23:06:44 1999
@@ -41,13 +41,13 @@
 tt($fpath) variable so that the functions can be autoloaded.
 
 startmenu()
-menu(Initialisation)
+menu(Initialization)
 menu(Control Functions)
 menu(Completion Functions)
 endmenu()
 
-texinode(Initialisation)(Control Functions)()(Completion System)
-sect(Initialisation)
+texinode(Initialization)(Control Functions)()(Completion System)
+sect(Initialization)
 
 The script tt(compinstall) can be run by a user to set up the completion
 system for use.  It will usually insert code into tt(.zshrc), although if
@@ -65,7 +65,7 @@
 completion functions are stored.  It will ask you various questions about
 how you would like completion set up.  It is in two parts; the basic part
 locates the completion files and decides where to put your personal
-dumpfile, used to speed up initialisation after the first time.  After
+dumpfile, used to speed up initialization after the first time.  After
 that, you will be asked if you wish to go on to the advanced set-up; if you
 answer tt(n), you can rerun tt(compinstall) later without having to
 re-enter any of the basic settings.
@@ -79,7 +79,7 @@
 the current session when run directly by the user; if you have run
 tt(compinstall) it will be called automatically from your tt(.zshrc).
 
-To initialise the system, the script tt(compinit) should be sourced with
+To initialize the system, the script tt(compinit) should be sourced with
 `tt(source )var(<path>)tt(/compinit)' or
 `tt(. )var(<path>)tt(/compinit)'. This will define a few utility functions,
 arrange for all the necessary shell functions to be autoloaded, and will
@@ -238,10 +238,10 @@
 )
 enditem()
 
-texinode(Control Functions)(Completion
Functions)(Initialisation)(Completion System)
+texinode(Control Functions)(Completion
Functions)(Initialization)(Completion System)
 sect(Control Functions)
 
-The initialisation script tt(compinit) re-binds all the keys which perform
+The initialization script tt(compinit) re-binds all the keys which perform
 completion to newly created widgets that all call the supplied widget
 function tt(_main_complete). This function acts as a wrapper calling
 the so-called `completer' functions that generate matches. If
@@ -382,7 +382,7 @@
 errors are accepted.  Hence with a value of `tt(0n)', no correcting
 completion will be attempted unless a numeric argument is given.
 
-If the value contains `tt(n)' or `tt(N)' and a exclamation mark
+If the value contains `tt(n)' or `tt(N)' and an exclamation mark
 (`tt(!)'), tt(_approximate) will var(not) try to generate corrected
 completions when given a numeric argument, so in this case the number given
 should be greater than zero.  For example, `tt(2n!)' specifies that
@@ -652,7 +652,7 @@
 from being tried simply by setting this parameter to any value.
 )
 item(tt(_multi_parts))(
-This functions gets two arguments: a separator character and an
+This function gets two arguments: a separator character and an
 array.  As usual, the array may be either the
 name of an array parameter or a literal array in the form
 `tt(LPAR()foo bar)tt(RPAR())' (i.e. a list of words separated by white 
diff -u -r old/func.yo Zsh/func.yo
--- old/func.yo	Mon Jun 14 17:14:29 1999
+++ Zsh/func.yo	Wed Jun 16 23:07:08 1999
@@ -41,7 +41,7 @@
 If the tt(KSH_AUTOLOAD) option is set, or the file contains only a simple
 definition of the function, the file's contents will be
 executed.  It would normally define the function in question, but may
-also perform initialisation.
+also perform initialization.
 It is executed in the context of the function
 execution, and may therefore define local parameters.
 
@@ -48,9 +48,9 @@
 Otherwise, the function is defined such that its body is the
 complete contents of the file.  This form allows the file to be
 used directly as an executable shell script.
-Initialisation code can be executed, but only as part of the first
+Initialization code can be executed, but only as part of the first
 function execution, so the function would have to redefine itself to
-avoid reinitialising on the next execution.
+avoid reinitializing on the next execution.
 
 If this processing of the file results in the function being
 fully defined, the function itself is then executed.
diff -u -r old/mod_zle.yo Zsh/mod_zle.yo
--- old/mod_zle.yo	Mon Jun 14 17:14:29 1999
+++ Zsh/mod_zle.yo	Wed Jun 16 22:54:22 1999
@@ -67,7 +67,7 @@
 item(tt(-N) var(new-keymap) [ var(old-keymap) ])(
 Create a new keymap, named var(new-keymap).  If a keymap already has that
 name, it is deleted.  If an var(old-keymap) name is given, the new keymap
-is initialised to be a duplicate of it, otherwise the new keymap will
+is initialized to be a duplicate of it, otherwise the new keymap will
 be empty.
 )
 enditem()
diff -u -r old/params.yo Zsh/params.yo
--- old/params.yo	Mon Jun 14 17:14:29 1999
+++ Zsh/params.yo	Wed Jun 16 22:55:52 1999
@@ -26,7 +26,7 @@
 parameter is special.
 Special parameters cannot have their type changed, and they stay special
even
 if unset.  `<Z>' indicates that the parameter does not exist when the shell
-initialises in tt(sh) or tt(ksh) emulation mode.
+initializes in tt(sh) or tt(ksh) emulation mode.
 startmenu()
 menu(Array Parameters)
 menu(Positional Parameters)
@@ -316,7 +316,7 @@
 )
 vindex(OLDPWD)
 item(tt(OLDPWD))(
-The previous working directory.  This is set when the shell initialises
+The previous working directory.  This is set when the shell initializes
 and whenever the directory changes.
 )
 vindex(OPTARG)
@@ -339,7 +339,7 @@
 )
 vindex(PWD)
 item(tt(PWD))(
-The present working directory.  This is set when the shell initialises
+The present working directory.  This is set when the shell initializes
 and whenever the directory changes.
 )
 vindex(RANDOM)
@@ -592,7 +592,7 @@
 An array (colon-separated list)
 of directories that tt(zmodload)
 searches for dynamically loadable modules.
-This is initialised to a standard pathname,
+This is initialized to a standard pathname,
 usually `tt(/usr/local/lib/zsh/$ZSH_VERSION)'.
 (The `tt(/usr/local/lib)' part varies from installation to installation.)
 For security reasons, any value set in the environment when the shell
diff -u -r old/zftpsys.yo Zsh/zftpsys.yo
--- old/zftpsys.yo	Mon Jun 14 17:14:29 1999
+++ Zsh/zftpsys.yo	Wed Jun 16 22:55:32 1999
@@ -47,7 +47,7 @@
 otherwise, you will need to find them and copy them.  The directory should
 appear as one of the elements of the tt($fpath) array (this should already
 be the case if they were installed), and at least the function tt(zfinit)
-should be autoloaded; it will autoload the rest.  Finally, to initialise
+should be autoloaded; it will autoload the rest.  Finally, to initialize
 the use of the system you need to call the tt(zfinit) function.  The
 following code in your tt(.zshrc) will arrange for this; assume the
 functions are stored in the directory tt(~/myfns):
@@ -59,7 +59,7 @@
 Note that tt(zfinit) assumes you are using the tt(zmodload) method to
 load the tt(zftp) command.  If it is already built into the shell, change
 tt(zfinit) to tt(zfinit -n).  It is helpful (though not essential) if the
-call to tt(zfinit) appears after any code to initialise the new completion
+call to tt(zfinit) appears after any code to initialize the new completion
 system, else unnecessary tt(compctl) commands will be given.
 
 texinode(Zftp Functions)(Miscellaneous Features)(Installation)(Zftp
Function System)
@@ -324,7 +324,7 @@
 
 startitem()
 item(tt(zfinit [ -n ]))(
-As described above, this is used to initialise the zftp function system.
+As described above, this is used to initialize the zftp function system.
 The tt(-n) option should be used if the zftp command is already built into
 the shell.
 )

