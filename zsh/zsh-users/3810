From zsh-users-return-3810-mason-zsh=primenet.com.au@sunsite.dk Sat Apr 07 18:26:58 2001
Return-Path: <zsh-users-return-3810-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27993 invoked from network); 7 Apr 2001 18:26:56 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Apr 2001 18:26:56 -0000
Received: (qmail 26486 invoked by alias); 7 Apr 2001 18:26:47 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3810
Received: (qmail 26474 invoked from network); 7 Apr 2001 18:26:46 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010407182602.ZM15804@candle.brasslantern.com>
Date: Sat, 7 Apr 2001 18:26:01 +0000
In-Reply-To: <20010407163348.A619@gmx.de>
Comments: In reply to Dominik Vogt <dominik.vogt@gmx.de>
        "displaying top cpu using process" (Apr  7,  4:33pm)
References: <20010407163348.A619@gmx.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: dominik.vogt@gmx.de, zsh-users@sunsite.auc.dk
Subject: Re: displaying top cpu using process
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Apr 7,  4:33pm, Dominik Vogt wrote:
} Subject: displaying top cpu using process
}
}   ps gives me complete control over the output format, but I can't
}   make it give me the CPU percentage.  Although the 'C' output
}   modifier is documented as 
} 
}     "use raw CPU time for %CPU instead of decaying average"
} 
}   I always get the decaying average.

I can't even get my "ps" to accept the C modifier.  It keeps interpreting
it as the "selection by command name" option, and telling me that only
root is allowed to do that.

}     top -b -n 1 | sed '<script>'
} 
}   But then, this only works if the terminal window from which top
}   was started has enough lines. [...]  To get the full output I
}   have to detach top from the terminal.  

That's odd; on RH6.2, for me, "top -b -n 1" produces a lot more lines
of output than the height of the terminal.  (procps-2.0.6-5)  However,
try fooling it by stuffing the LINES and COLUMNS environment variables.

}   In other words, I need one process that generates the data and one
}   that writes it into the terminal window. There are several ways to
}   do this, but the best solution seems to be a coprocess (because the
}   coprocess is killed if the terminal window that runs the script is
}   closed).

A coprocess is overkill.  Just use the parameter assignment and a pipe:

topcpu {
  local p=0 pid user pri ni size rss share stat lib cpu mem time command
  LINES=10 COLUMNS=200 top d 2 c b n 43200 |
  while read pid user pri ni size rss share stat lib cpu mem time command
  do
    [[ $pid == PID ]] && { p=1; continue }
    (( p )) && { print $pid $cpu% $command; p=0 }
  done
}

43200 iterations of 2 sec is 24 hours.

} Can anybody think of a better solution (that does not include
} writing any C code)?

Presumably it's possible to compute the CPU percentages by reading from
/proc/<->/stat plus the cpu line from /proc/stat, but I don't know the
algorithm top uses.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

