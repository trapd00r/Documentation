From zsh-workers-return-5417-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 18 11:08:14 1999
Return-Path: <zsh-workers-return-5417-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2468 invoked from network); 18 Feb 1999 11:08:12 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Feb 1999 11:08:12 -0000
Received: (qmail 24784 invoked by alias); 18 Feb 1999 11:08:00 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5417
Received: (qmail 24776 invoked from network); 18 Feb 1999 11:07:56 -0000
Date: Thu, 18 Feb 1999 12:05:59 +0100 (MET)
Message-Id: <199902181105.MAA07404@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Fri, 12 Feb 1999 23:05:07 -0800
Subject: Re: PATCH: Re: PATCH: zsh-3.1.5-pws-7: "$a[@]" with $a unset


Bart Schaefer wrote:

> On Feb 12,  9:33am, Bart Schaefer wrote:
> } Subject: Re: PATCH: zsh-3.1.5-pws-7: "$a[@]" with $a unset
> } 
> } zagzig% foo() { echo $# "$@" }
> } zagzig% foo "$unset[@]"
> } zsh: segmentation fault (core dumped)  Src/zsh -f
> 
> Here's a fix.  I don't think this can possibly cause anything else to go
> wrong, but ...

...it broke multiple subscripts. The patch below fixes this in a way
that hopefully will not cause anything else to go wrong, but...

Seriously, the problem was that for multiple subscripts a temporary
pm-struct was created with a NULL nam. The patch makes such a
temporary get a nam equal to nulstring. Since such a temporary is
created only in one place this should not affect other uses (of
createparam() and getarrvalue()).

I found this while trying to `fix' the problem I mentioned in 7328:

Given an array `a=(a b b c d e f g)' an expression like this

  ${${a[1,4]}[(I)b]}

gives `3' (the offset of the last `b' in the first four
elements). But if the expression is used inside a subscript:

  ${a[${${a[1,4]}[(I)b]},-1]}

this returns the whole string because the first expression expands to
`0' (zero). This is caused by the call to parsestr() in getarg() which
makes the subscript be tokenized as if it where in double quotes. With
that the code in paramsubst() and friends turns ${a[1,4]} into one
string, making the [(I)b] fail. To get this to work one will have to
use ${a[${${(@)a[1,4]}[(I)b]},-1]}.

I don't want to change this now because I think that there are reasons
to use parsestr() instead of parse_subst_string() (which solves the
problem), but I think that this difference between using the same
expression outside of an subscript and inside one is quite irritating.
So, does anyone know of a case where we need the behavior parsestr()
gives?


Bye
 Sven

--- os/params.c	Mon Feb 15 12:51:43 1999
+++ Src/params.c	Thu Feb 18 11:20:15 1999
@@ -568,8 +568,10 @@
 
 	if (isset(ALLEXPORT) && !oldpm)
 	    flags |= PM_EXPORTED;
-    } else
+    } else {
 	pm = (Param) alloc(sizeof *pm);
+	pm->nam = nulstring;
+    }
     pm->flags = flags;
 
     if(!(pm->flags & PM_SPECIAL))

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

