From zsh-workers-request@math.gatech.edu Sun Jun 14 20:14:05 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2381 invoked from network); 14 Jun 1998 20:14:03 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 14 Jun 1998 20:14:03 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id QAA01349;
	Sun, 14 Jun 1998 16:10:21 -0400 (EDT)
Resent-Date: Sun, 14 Jun 1998 16:06:20 -0400 (EDT)
Date: Sun, 14 Jun 1998 16:05:53 -0400
Message-Id: <9806142005.AA00932@ezdzit.zko.dec.com>
From: Paul Lew <lew@ezdzit.zko.dec.com>
To: zsh-users@math.gatech.edu
Subject: Re: help with 'rename' function 
In-Reply-To: <199806120909.LAA21384@hydra.ifh.de>
References: <199806120816.EAA22173@luomat.peak.org>
	<199806120909.LAA21384@hydra.ifh.de>
X-Mailer: VM 6.37 under Emacs 20.2.1
Mime-Version: 1.0 (generated by tm-edit 7.106)
Content-Type: text/plain; charset=US-ASCII
Resent-Message-ID: <"hFSh01.0.ZI.gq2Xr"@math>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/1616
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

>>>>> "Peter" == Peter Stephenson <pws@ifh.de> writes:

    Peter> Timothy J Luoma wrote:
    >> I used to have a binary that did this, but I've lost it.
    >> 
    >> What it did was simple: it changed extensions of filenames.

    Peter> It's perennially annoying UNIX doesn't have this.  On the
    Peter> other hand, if it did it would probably be so inscrutable
    Peter> as to be almost useless.

I have been using the DOS style rename under Unix for years, i.e.,

(1)ezdzit lew x>> touch {a,b,c,d,e}.c
(1)ezdzit lew x>> ls
a.c   b.c   c.c   d.c   e.c
(1)ezdzit lew x>> ren *.c *.d
(1)ezdzit lew x>> ls
a.d   b.d   c.d   d.d   e.d

Yes, this can be done under Unix with some tweak.  The following alias
and function definition actually called a csh script to do the real
work which can be converted to zsh.  As you can see I have been using
this before the birth of zsh.

     alias ren='set -F; rena'
     function rena () {
        set -F
        renam $*
        set +F
	}

#! /bin/csh -f
#
#-	rename - VMS style rename used for wildcard renaming
#-
#-	This is to facilitate some desirable VMS feature on Unix. For
#-	example:
#-		$ mv *.c *.c00
#-		$ mv abc.* def.*
#-
#-	Another tool 'move' which use sed to change file  name is more
#-	general purpose  than  'rename' or the 'rename.net' written by
#-	Juergen Wagner <gandalf@csli.stanford.edu>.
#-
#	Author:		Paul Lew, General Systems Group, Inc.
#	Created at:	03/02/88  01:48 PM
#	Last update:	07/29/88  06:01 PM  (Edition: 23)
#
#-	Usage:		rename old new
#-	where: there must be one '*' in both old and new
#-
#---------------------------------------------------------------#
#	      Display help if requested by user			#
#---------------------------------------------------------------#
switch ( "$1" )
	case -H[xX]:
		set echo; set verbose; shift
		breaksw
	case -H*:
		show_help `which $0` $1
		goto end
	default:
	endsw
#---------------------------------------------------------------#
#			Process Arguments			#
#---------------------------------------------------------------#
if ( $#argv != 2 ) then
	show_help `which $0`
	goto end
	endif
#---------------------------------------------------------------#
#	    Process each item in the argument list		#
#---------------------------------------------------------------#
set src = "$1"
set dest = "$2"
set cmd
set noglob
if ( ( "$1:r" != '*' && "$1:e" != '*' ) || \
     ( "$2:r" != '*' && "$2:e" != '*' ) ) then
	echo "wildcard characters required on both src and dest"
	goto end
	endif
if ( "$src:r" == "$dest:r" && "$src:r" == '*' ) then
	set same_root
else if ( "$src:e" == "$dest:e" && "$src:e" == '*' ) then
	set same_ext
else if ( "$src:r" == "$dest:e" && "$src:r" == '*' ) then
	set r_to_e
else if ( "$src:e" == "$dest:r" && "$src:e" == '*' ) then
	set e_to_r
	endif
unset noglob
set nonomatch
foreach file ($src)
	if ( "$file" == "$src" ) then
		echo "...File: $file not found, aborted..."
		goto end
		endif
	if ( $?same_root ) $cmd mv $file ${file:r}.${dest:e}
	if ( $?same_ext  ) $cmd mv $file ${dest:r}.${file:e}
	if ( $?r_to_e    ) $cmd mv $file ${dest:r}.${file:r}
	if ( $?e_to_r    ) $cmd mv $file ${file:e}.${dest:e}
	end
#---------------------------------------------------------------#
#		Clean up and exit here...			#
#---------------------------------------------------------------#
end:
unset src dest file

