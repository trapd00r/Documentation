From zsh-workers-return-9936-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Feb 29 15:50:52 2000
Return-Path: <zsh-workers-return-9936-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10776 invoked from network); 29 Feb 2000 15:50:50 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Feb 2000 15:50:50 -0000
Received: (qmail 11303 invoked by alias); 29 Feb 2000 15:50:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9936
Received: (qmail 11288 invoked from network); 29 Feb 2000 15:50:37 -0000
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: completion tests
MIME-Version: 1.0 (generated by AKEMI 1.13.2 - =?ISO-2022-JP?B?Ig==?=
 =?ISO-2022-JP?B?GyRCQTA0Y0s8GyhCIg==?=)
Content-Type: text/plain; charset=US-ASCII
From: Tanaka Akira <akr@jaist.ac.jp>
Date: 01 Mar 2000 00:50:26 +0900
Message-ID: <rsqbt506m9p.fsf@crane.jaist.ac.jp>
Lines: 264
User-Agent: Chao-gnus/6.12.5 AKEMI/1.13.2 (=?ISO-2022-JP?B?GyRCQTAbKEI=?=
 =?ISO-2022-JP?B?GyRCNGNLPBsoQg==?=) FLAM-DOODLE/1.12.6
 (=?ISO-2022-JP?B?GyRCM3cbKEI=?= 10R4.0/5.0) Emacs/20.4
 (sparc-sun-solaris2.6) MULE/4.0 (HANANOEN)

This is completion tests using zpty.

This is bit slow because this runs zsh for each test.  Probabily it
should be rewritten to run only one zsh under pty to test.

Also, I couldn't extract display strings specified by compadd -d.  Is
there a simple way to extract?

Of course, it should have more tests.

Index: Src/Zle/complist.c
===================================================================
RCS file: /projects/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.1.1.42
diff -u -r1.1.1.42 complist.c
--- Src/Zle/complist.c	2000/02/23 15:18:49	1.1.1.42
+++ Src/Zle/complist.c	2000/02/29 15:33:59
@@ -745,7 +745,7 @@
 	}
 	zcoff();
 	if (!lastc) {
-	    zcputs(&mcolors, g->name, COL_NO);
+	    zcputs(&mcolors, g->name, COL_SP);
 	    fputs("  ", shout);
 	    zcoff();
 	}
--- /dev/null	Wed Mar  1 00:32:29 2000
+++ Test/comptest	Wed Mar  1 00:47:02 2000
@@ -0,0 +1,94 @@
+#!/usr/local/bin/zsh -f
+
+zmodload zsh/zpty
+setopt extendedglob
+
+debug=
+dump=(-D)
+code=
+zsh=${ZSH:-zsh}
+
+while getopts Dd:c:z: opt; do
+  case $opt in
+    D) debug=yes;;
+    d) dump=(-d "$OPTARG");;
+    c) code="$OPTARG";;
+    z) zsh="$OPTARG";;
+  esac
+done
+(( OPTIND > 1 )) && shift $(( OPTIND - 1 ))
+
+input="$*"
+
+init=\
+'stty columns 80 rows 24
+LISTMAX=10000000
+'"ZLS_COLORS='no=<NO>:fi=<FI>:di=<DI>:ln=<LN>:pi=<PI>:so=<SO>:bd=<BD>:cd=<CD>:ex=<EX>:mi=<MI>:tc=<TC>:sp=<SP>:lc=<LC>:ec=<EC>\n:rc=<RC>'
+bindkey -e
+autoload -U compinit
+compinit $dump
+"'zstyle ":completion:*" group-name ""
+zstyle ":completion*:messages" format "<MESSAGE>%d</MESSAGE>
+"
+zstyle ":completion*:descriptions" format "<DESCRIPTION>%d</DESCRIPTION>
+"
+zstyle ":completion*:options" verbose yes
+zstyle ":completion*:values" verbose yes
+setopt noalwayslastprompt listrowsfirst completeinword
+zmodload zsh/complist
+expand-or-complete-with-report () {
+  print -lr "<WIDGET><expand-or-complete>"
+  zle expand-or-complete
+  print -lr - "<LBUFFER>$LBUFFER</LBUFFER>" "<RBUFFER>$RBUFFER</RBUFFER>"
+  zle clear-screen
+  zle -R
+}
+list-choices-with-report () {
+  print -lr "<WIDGET><list-choices>"
+  zle list-choices
+  zle clear-screen
+  zle -R
+}
+finish () {
+  print "<WIDGET><finish>"
+  exit 0
+}
+zle -N expand-or-complete-with-report
+zle -N list-choices-with-report
+zle -N finish
+bindkey "^I" expand-or-complete-with-report
+bindkey "^D" list-choices-with-report
+bindkey "^Z" finish
+'"$code"
+
+export PS1="<PROMPT>"
+zpty zsh "$zsh" -f
+
+zpty -r zsh log "*<PROMPT>*"
+
+zpty -w zsh "eval ${init:q}"
+zpty -r zsh log "*<PROMPT>*"
+
+zpty -w zsh "$input"$'\C-Z'
+zpty -r zsh log "*<WIDGET><finish>*"
+
+logs=(${(s:<WIDGET>:)log})
+shift logs
+
+for log in "$logs[@]"; do
+  if [[ "$log" = (#b)*$'<LBUFFER>'(*)$'</LBUFFER>\r\n<RBUFFER>'(*)$'</RBUFFER>'* ]]; then
+    print -lr "line: {$match[1]}{$match[2]}"
+  fi
+  while (( ${(N)log#*(#b)(<LC><(??)><RC>(*)<EC>|<DESCRIPTION>(*)</DESCRIPTION>|<MESSAGE>(*)</MESSAGE>)} )); do
+    log="${log[$mend[1]+1,-1]}"
+    if (( 0 <= $mbegin[2] )); then
+      if [[ $match[2] != TC && $match[3] != \ # ]]; then
+	print "$match[2]:{$match[3]}"
+      fi
+    elif (( 0 <= $mbegin[4] )); then
+      print "DESCRIPTION:{$match[4]}"
+    elif (( 0 <= $mbegin[5] )); then
+      print "MESSAGE:{$match[5]}"
+    fi
+  done
+done
--- /dev/null	Wed Mar  1 00:32:29 2000
+++ Test/53completion.ztst	Wed Mar  1 00:47:18 2000
@@ -0,0 +1,136 @@
+# Tests for completion system.
+
+%prep
+
+  comptest () { $ZTST_testdir/../Src/zsh -f $ZTST_srcdir/comptest -z $ZTST_testdir/../Src/zsh -d $ZTST_testdir/compdump.tmp "$@" }
+
+  mkdir comp.tmp
+  cd comp.tmp
+
+  mkdir dir1
+  mkdir dir2
+  touch file1
+  touch file2
+
+%test
+
+  comptest $': \t\t\t\t\t\t\t'
+0:directories and files
+>line: {: }{}
+>DESCRIPTION:{file}
+>DI:{dir1}
+>DI:{dir2}
+>FI:{file1}
+>FI:{file2}
+>line: {: dir1/}{}
+>line: {: dir2/}{}
+>line: {: file1}{}
+>line: {: file2}{}
+>line: {: dir1/}{}
+>line: {: dir2/}{}
+
+  comptest -c '_users () { compadd user1 user2 }' $': ~\t\t\t\t\t'
+0:tilde
+>line: {: ~user}{}
+>line: {: ~user}{}
+>NO:{user1}
+>NO:{user2}
+>line: {: ~user1}{}
+>line: {: ~user2}{}
+>line: {: ~user1}{}
+
+ code='compdef _tst tst; _tst () { _arguments ":desc1:(arg1)" }'
+ comptest -c "$code" $'tst \t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst a\t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst ar\t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst arg\t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst arg1\t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst r\t'
+0:_arguments
+>line: {tst r}{}
+
+ comptest -c "$code" $'tst x\t'
+0:_arguments
+>line: {tst x}{}
+
+ comptest -c "$code" $'tst a \t'
+0:_arguments
+>line: {tst a }{}
+>MESSAGE:{no more arguments}
+
+ comptest -c "$code" $'tst a b \t'
+0:_arguments
+>line: {tst a b }{}
+>MESSAGE:{no more arguments}
+
+ code='compdef _tst tst; _tst () { _arguments ":desc1:(a b)" }'
+ comptest -c "$code" $'tst \t'
+0:_arguments
+>line: {tst }{}
+>DESCRIPTION:{desc1}
+>NO:{a}
+>NO:{b}
+
+ code='compdef _tst tst; _tst () { _arguments ":desc1:(arg1)" ":desc2:(arg2)" ":desc3:(arg3)" }'
+ comptest -c "$code" $'tst \t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ comptest -c "$code" $'tst arg1 \t'
+0:_arguments
+>line: {tst arg1 arg2 }{}
+
+ comptest -c "$code" $'tst arg1 arg2 \t'
+0:_arguments
+>line: {tst arg1 arg2 arg3 }{}
+
+ comptest -c "$code" $'tst \C-D'
+0:_arguments
+>DESCRIPTION:{desc1}
+>NO:{arg1}
+
+# code='compdef _tst tst; _tst () { _arguments "-\+[opt]" }'
+# comptest -c "$code" $'tst -\C-D'
+#0:_arguments
+#>DESCRIPTION:{option}
+#>NO:{-+ -- opt}
+
+ code='compdef _tst tst; _tst () { _arguments "1:desc1:(arg1)" }'
+ comptest -c "$code" $'tst \t'
+0:_arguments
+>line: {tst arg1 }{}
+
+ code='compdef _tst tst; _tst () { _arguments "-x" ":arg:" }'
+ comptest -c "$code" $'tst -\t'
+0:_arguments
+>line: {tst -x }{}
+
+ code='compdef _tst tst; _tst () { _arguments "-x:arg:" }'
+ comptest -c "$code" $'tst -x\t'
+0:_arguments
+>line: {tst -x }{}
+
+ code='
+   compdef _tst tst
+   _tst () { _arguments "-a" "*::rest:_tst2" }
+   _tst2 () { compadd - -b }
+ '
+ comptest -c "$code" $'tst arg -\t'
+0:_arguments
+>line: {tst arg -b }{}
+
-- 
Tanaka Akira

