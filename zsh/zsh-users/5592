From zsh-users-return-5592-mason-zsh=primenet.com.au@sunsite.dk Thu Dec 19 02:53:36 2002
Return-Path: <zsh-users-return-5592-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2917 invoked from network); 19 Dec 2002 02:53:35 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 19 Dec 2002 02:53:35 -0000
Received: (qmail 29223 invoked by alias); 19 Dec 2002 02:53:21 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5592
Received: (qmail 29215 invoked from network); 19 Dec 2002 02:53:20 -0000
To: zsh-users@sunsite.dk
Subject: Useful query-replace zle widget
From: Philippe Troin <phil@fifi.org>
Date: 18 Dec 2002 18:53:16 -0800
Message-ID: <87heda1zz7.fsf@ceramic.fifi.org>
Lines: 25
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.2
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="=-=-="
Sender: Philippe Troin <phil@fifi.org>

--=-=-=

Hi,

I've been using these for a while and it's time for me to share
them... It involves `creative' use of zle... It's zsh's answer to
emacs's query-replace.

How to use:
 1. You need the read-within-zle function.
 2. Drop read-within-zle and query-replace along your fpath
 3. Add the following to your .zshrc:
        autoload -zU query-replace read-within-zle
        zle -N query-replace
        bindkey "^[%" query-replace
        bindkey "\M-%" query-replace # only if using bindkey -m
 4. Use M-x query-replace or M-% to start query-replace'ing.

Enclose these in the zsh distribution if you find them useful. Both
functions are GPL'ed but I'm willing to change the license if needed
for inclusion into zsh.

Phil.

--=-=-=
Content-Type: application/x-sh
Content-Disposition: attachment; filename=query-replace

# query-replace - replace all or some occurrences of a string by another
# Copyright (C) 2001,2002 Philippe Troin <phil@fifi.org>
#
# $Id: query-replace,v 1.4 2002/12/19 02:46:43 phil Exp $
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# How to use:
#  1. You need the read-within-zle function (available separately)
#  2. Drop read-within-zle and query-replace along your fpath
#  3. Add the following to your .zshrc:
#         autoload -zU query-replace read-within-zle
#         zle -N query-replace
#         bindkey "^[%" query-replace
#	  bindkey "\M-%" query-replace # only if using bindkey -m
#  4. Use M-x query-replace or M-% to start query-replace'ing.


emulate -L zsh

local input=''
read-within-zle 'Query-replace: ' || return 0
local from=$input 
[[ $#from -eq 0 ]] && return 0
read-within-zle 'With: ' || return 0
local to=$input 
local nfound=0 
local replacethis=0
local replaceall=0 
while :
do
  local postmatch=${RBUFFER#*$from} 
  if [[ $#postmatch = $#RBUFFER ]]
  then
    if [[ $nfound -eq 0 ]]
    then
      zle -M "no matches"
    fi
    return
  fi
  ((nfound++))
  local prematch=$RBUFFER[1,-$(($#postmatch+$#from+1))] 
  LBUFFER="$LBUFFER$prematch" 
  RBUFFER="$from$postmatch" 
  if [[ $replaceall -eq 0 ]]
  then
    zle -R "Replace \"$from\" with \"$to\" (y/n/a/!/q)?"
    while :
    do
      local key=''
      read -k key || return
      case $key in
        ([yY])   replacethis=1; break ;;
        ([nN])   replacethis=0; break ;;
        ([aA!])  replacethis=1; replaceall=1; break ;;
        ([qQ]) return ;;
	(*)      zle beep ;;
      esac
    done
  fi
  RBUFFER=$RBUFFER[$#from+1,-1] 
  if [[ $replacethis -eq 1 ]]
  then
    LBUFFER="$LBUFFER$to" 
  else
    LBUFFER="$LBUFFER$from" 
  fi
done

--=-=-=
Content-Type: application/x-sh
Content-Disposition: attachment; filename=read-within-zle
Content-Transfer-Encoding: base64

IyByZWFkLXdpdGhpbi16bGUgLSByZWFkIGEgbGluZSB3aXRoaW4gYSB6bGUgd2lkZ2V0CiMgQ29w
eXJpZ2h0IChDKSAyMDAxLDIwMDIgUGhpbGlwcGUgVHJvaW4gPHBoaWxAZmlmaS5vcmc+CiMKIyAk
SWQ6IHJlYWQtd2l0aGluLXpsZSx2IDEuMyAyMDAyLzEyLzE5IDAyOjQ2OjQzIHBoaWwgRXhwICQK
IwojIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBp
dCBhbmQvb3IgbW9kaWZ5CiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQ
dWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkKIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0
aW9uOyBlaXRoZXIgdmVyc2lvbiAyIG9mIHRoZSBMaWNlbnNlLCBvcgojIChhdCB5b3VyIG9wdGlv
bikgYW55IGxhdGVyIHZlcnNpb24uCiMKIyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4g
dGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwKIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFO
VFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgojIE1FUkNIQU5UQUJJTElU
WSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUKIyBHTlUgR2Vu
ZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLgojCiMgWW91IHNob3VsZCBoYXZl
IHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UKIyBhbG9u
ZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZQoj
IEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSwgU3VpdGUgMzMwLCBCb3N0b24sIE1B
ICAwMjExMS0xMzA3ICBVU0EKCmVtdWxhdGUgLUwgenNoCgpsb2NhbCBwcm9tcHQ9JDEgCmxvY2Fs
IGxhc3RrZXk9JycgCiMgaW5wdXQgaXMgdGhlIHJldHVybmVkIHN0cmluZwppbnB1dD0nJyAKd2hp
bGUgOgpkbwogIHpsZSAtUiAiJHByb21wdCRpbnB1dCIKICByZWFkIC1rIGxhc3RrZXkgfHwgcmV0
dXJuIDEKICBjYXNlICRsYXN0a2V5IGluCiAgICAoDSkgcmV0dXJuIDAgOzsKICAgICgHKSByZXR1
cm4gMSA7OwogICAgKBUpIGlucHV0PSIiIDs7CiAgICAofykgaW5wdXQ9JGlucHV0WzEsJCgoJCNp
bnB1dC0xKSldIDs7CiAgICAoKikgIGlucHV0PSIkaW5wdXQkbGFzdGtleSIgOzsKICBlc2FjCmRv
bmUK
--=-=-=--

