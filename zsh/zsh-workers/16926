From zsh-workers-return-16926-mason-zsh=primenet.com.au@sunsite.dk Fri Mar 29 01:13:01 2002
Return-Path: <zsh-workers-return-16926-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17946 invoked from network); 29 Mar 2002 01:13:00 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 29 Mar 2002 01:13:00 -0000
Received: (qmail 5312 invoked by alias); 29 Mar 2002 01:12:54 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16926
Received: (qmail 5300 invoked from network); 29 Mar 2002 01:12:52 -0000
Date: Thu, 28 Mar 2002 17:12:24 -0800 (PST)
From: Wayne Davison <wayned@users.sourceforge.net>
X-X-Sender:  <wayne@phong.blorf.net>
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: Zsh Workers <zsh-workers@sunsite.dk>
Subject: PATCH: -W option for zmv (updated)
In-Reply-To: <1020328155914.ZM1111@candle.brasslantern.com>
Message-ID: <Pine.LNX.4.33L2.0203281524340.16964-100000@phong.blorf.net>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

On Thu, 28 Mar 2002, Bart Schaefer wrote:
> My only concern is that it should complain if the number of wildcards in
> the destination is less than the number of wildcards in the source.

Good point.  I've made it complain and exit if the counts don't match.

> integer N=0
> x=(x x x x x x)
> print ${(e)x//x/\$[++N]}

Thanks!  That's the nudge I needed to make things more efficient.

The only weird thing I ran into was when I put the find pattern into a
variable so I could reuse it in 3 spots.  To get things working I had to
change the "\/" into "[/]" or the "\*\*#\/" pattern wouldn't match.
Strange.

Here's my latest patch.  I'll probably commit this after a little more
testing (unless someone has an objection).

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: zsh/Functions/Misc/zmv
--- zsh/Functions/Misc/zmv	28 Aug 2001 20:28:18 -0000	1.9
+++ zsh/Functions/Misc/zmv	29 Mar 2002 01:04:32 -0000
@@ -13,9 +13,14 @@
 # path.  Note that you need to write it like this; you can't get away with
 # '(**/*).txt'.
 #   zmv -w '**/*.txt' '$1$2.lis'
-# This is the lazy version of the one above; zsh picks out the patterns
-# for you.  The catch here is that you don't need the / in the replacement
-# pattern.  (It's not really a catch, since $1 can be empty.)
+#   noglob zmv -W **/*.txt **/*.lis
+# These are the lazy version of the one above; with -w, zsh inserts the
+# parentheses for you in the search pattern, and with -W it also inserts
+# the numbered variables for you in the replacement pattern.  The catch
+# in the first version is that you don't need the / in the replacement
+# pattern.  (It's not really a catch, since $1 can be empty.)  Note that
+# -W actually inserts ${1}, ${2}, etc., so it works even if you put a
+# number after a wildcard (such as zmv -W '*1.txt' '*2.txt').
 #   zmv -C '**/(*).txt' ~/save/'$1'.lis
 # Copy, instead of move, all .txt files in subdirectories to .lis files
 # in the single directory `~/save'.  Note that the ~ was not quoted.
@@ -91,6 +96,8 @@
 #      where <oldname> and <newname> are filenames generated.
 #  -w  Pick out wildcard parts of the pattern, as described above, and
 #      implicitly add parentheses for referring to them.
+#  -W  Just like -w, with the addition of turning wildcards in the
+#      replacement pattern into sequential ${1} .. ${N} references.
 #  -C
 #  -L
 #  -M  Force cp, ln or mv, respectively, regardless of the name of the
@@ -116,12 +123,12 @@

 local f g args match mbegin mend files action myname tmpf opt exec
 local opt_f opt_i opt_n opt_q opt_Q opt_s opt_M opt_C opt_L
-local opt_o opt_p opt_v opt_w MATCH MBEGIN MEND
+local opt_o opt_p opt_v opt_w opt_W MATCH MBEGIN MEND
 local pat repl errstr fpat hasglobqual opat
 typeset -A from to
 integer stat

-while getopts ":o:p:MCLfinqQsvw" opt; do
+while getopts ":o:p:MCLfinqQsvwW" opt; do
   if [[ $opt = "?" ]]; then
     print -P "%N: unrecognized option: -$OPTARG" >&2
     return 1
@@ -173,19 +180,32 @@
   return 1
 fi

-if [[ -n $opt_w ]]; then
+if [[ -n $opt_w || -n $opt_W ]]; then
   # Parenthesise all wildcards.
-  local newpat
+  local tmp find
+  integer cnt=0
   # Well, this seems to work.
   # The tricky bit is getting all forms of [...] correct, but as long
   # as we require inactive bits to be backslashed its not so bad.
-  newpat="${pat//\
-(#m)(\*\*#\/|[*?]|\<[0-9]#-[0-9]#\>|\[(\[:[a-z]##:\]|\\\[|\\\]|[^\[\]]##)##\])\##\
-/($MATCH)}"
-  if [[ $newpat = $pat ]]; then
-    print -P "%N: warning: no wildcards were found" >&2
+  find='(#m)(\*\*#[/]|[*?]|\<[0-9]#-[0-9]#\>|\[(\[:[a-z]##:\]|\\\[|\\\]|[^\[\]]##)##\])\##'
+  tmp="${pat//${~find}/$[++cnt]}"
+  if [[ $cnt = 0 ]]; then
+    print -P "%N: warning: no wildcards were found in search pattern" >&2
   else
-    pat=$newpat
+    pat="${pat//${~find}/($MATCH)}"
+  fi
+  if [[ -n $opt_W ]]; then
+    # Turn wildcards into ${1} .. ${N} references.
+    local open='${' close='}'
+    integer N=0
+    repl="${repl//${~find}/$open$[++N]$close}"
+    if [[ $N != $cnt ]]; then
+      print -P "%N: error: number of wildcards in each pattern must match" >&2
+      return 1
+    fi
+    if [[ $N = 0 ]]; then
+      print -P "%N: warning: no wildcards were found in replacement pattern" >&2
+    fi
   fi
 fi

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

