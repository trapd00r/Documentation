From zsh-users-return-15408-mason-zsh=primenet.com.au@zsh.org Sat Sep 18 19:42:15 2010
Return-Path: <zsh-users-return-15408-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10287 invoked by alias); 18 Sep 2010 19:42:15 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15408
Received: (qmail 7067 invoked from network); 18 Sep 2010 19:42:12 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100918124147.ZM31152@torch.brasslantern.com>
Date: Sat, 18 Sep 2010 12:41:47 -0700
In-reply-to: <4C950347.9060109@gmail.com>
Comments: In reply to Anonymous bin Ich <ichbinanon@gmail.com>
 "Re: Waiting for a process without using pid" (Sep 18, 11:51pm)
References: <AANLkTinyDC-OoGBzuisMKUg+OqeeqG=HKZrNDuJZL+sD@mail.gmail.com>
	<100916072654.ZM29712@torch.brasslantern.com>	<4C950347.9060109@gmail.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Waiting for a process without using pid
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 18, 11:51pm, Anonymous bin Ich wrote:
} Subject: Re: Waiting for a process without using pid
}
} On 09/16/2010 07:56 PM, Bart Schaefer wrote:
} > On Sep 16,  4:09pm, Anonymous bin ich wrote:
} > }
} > } I am trying to write a 'timeout' script, which will take 2 commands
} > } and exit after whichever one exits first. Is there a way to do it
} > } without using pid or polling?
} >
} But I see that job2 is still running at the end, just the script having 
} this code forks at then kills both its instances.

If I understand that correctly, what you want is for the control script
AND both of its children to exit all at the same time, whenever at least
one of the children has exited?

That wasn't clear before.

Also after a bit of thought it's really not necessary to kill the
coprocess, you can do all the synchronization with I/O; and it's a
better solution to start the coprocess and set up the trap first,
rather than starting the background jobs first.

cat <<-\ENDOFA >a.sh
	#!/usr/bin/zsh

	coproc read -E
	trap "print Waking coprocess; print -p Woken" CHLD

	setopt HUP
	./b.sh 10 &
	echo $!
	./b.sh 20 &
	echo $!

	read -p -E
	print "Finished"
	kill -HUP -$$

	# Never get here
	exit 0
ENDOFA
cat <<-\ENDOFB >b.sh
	#!/usr/bin/zsh
	trap "print HUP $1 in $$; exit 0" HUP
	print start $1 in $$
	sleep $1
	print stop $1 in $$
ENDOFB

The trap in b.sh is just so you can see what's going on.

If the parent doesn't need to do anything after the first child exits,
you can avoid the coprocess entirely by having both children kill the
parent:

cat <<-\ENDOFA >a.sh
	#!/bin/zsh

	setopt HUP

	repeat 2 {
		: $RANDOM to prime the number generator
		{ ./b.sh $((RANDOM%10+10)); kill -HUP -$$ } &
	}

	wait
ENDOFA

