From zsh-workers-return-6812-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jun 23 10:31:48 1999
Return-Path: <zsh-workers-return-6812-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16010 invoked from network); 23 Jun 1999 10:31:46 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Jun 1999 10:31:46 -0000
Received: (qmail 5751 invoked by alias); 23 Jun 1999 10:31:35 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6812
Received: (qmail 5744 invoked from network); 23 Jun 1999 10:31:33 -0000
Message-Id: <9906231002.AA17151@ibmth.df.unipi.it>
To: "ZSH workers mailing list" <zsh-workers@sunsite.auc.dk>
Subject: Re: Possible bug with ${(A)foo=} and ${(AA)foo=} 
In-Reply-To: ""Bart Schaefer""'s message of "Tue, 22 Jun 1999 17:36:28 DFT."
             <990622173628.ZM30363@candle.brasslantern.com> 
Date: Wed, 23 Jun 1999 12:02:56 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

"Bart Schaefer" wrote:
> On Jun 22,  8:13pm, Andrej Borsenkow wrote:
> } Subject: Possible bug with ${(A)foo=} and ${(AA)foo=}
> }
> } While playing with something else I discovered, that it is impossible to
> } create empty array with this form and it is impossible to create hash in
> } this way without error message:
> 
> The first problem is what causes the second, though creating an empty AA
> this way would create an empty hash table (normally the hash table is not
> created until the AA has at least one value).

Without fixing the general array-splitting problem, which is difficult, I
don't see there's any problem deciding what to do in the case of an
associative array, since the intention in such a case can only be to create
an empty one because there is no key/value pair, even with ${(AA)foo=''}
since wordsplitting can't change that fact.  So until somebody gets around
to doing array splitting in this case properly, I suggest we just assume it
should create an empty associative array.  The other problems are far less
pressing because if the associative array already exists there are always
other ways of setting it, which in practice aret the ones we always use.

I was thinking about `typeset -g foo' to stop foo becoming local if it
doesn't exist, but there is always the problem with what to do when foo
already exists but has been unset.  The easiest thing is always to use that
value at the level at which was set.  This means, for example,

fn2() { typset -g foo; }
fn1() { typeset foo; unset foo; fn2(); foo=bar; }

that foo remains throughout local to fn1.  I think this version could be
implemented quite easily.  Any other version is going to be messy.

--- Src/subst.c.aa	Tue Jun 15 17:06:48 1999
+++ Src/subst.c	Wed Jun 23 11:51:00 1999
@@ -1328,10 +1328,15 @@
 			else
 			    t = aval;
 		    } else if (!isarr) {
-			arr[0] = val;
-			arr[1] = NULL;
+			if (!*val && arrasg > 1) {
+			    arr[0] = NULL;
+			    l = 0;
+			} else {
+			    arr[0] = val;
+			    arr[1] = NULL;
+			    l = 1;
+			}
 			t = aval = arr;
-			l = 1;
 		    } else
 			l = arrlen(aval), t = aval;
 		    p = a = zalloc(sizeof(char *) * (l + 1));

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

