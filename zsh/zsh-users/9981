From zsh-users-return-9981-mason-zsh=primenet.com.au@sunsite.dk Thu Mar 02 18:34:49 2006
Return-Path: <zsh-users-return-9981-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7044 invoked from network); 2 Mar 2006 18:34:47 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.0 (2005-09-13) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=BAYES_00,FORGED_RCVD_HELO 
	autolearn=ham version=3.1.0
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 2 Mar 2006 18:34:47 -0000
Received: (qmail 10537 invoked from network); 2 Mar 2006 18:34:39 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 2 Mar 2006 18:34:39 -0000
Received: (qmail 5592 invoked by alias); 2 Mar 2006 18:34:32 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 9981
Received: (qmail 5582 invoked from network); 2 Mar 2006 18:34:31 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 2 Mar 2006 18:34:31 -0000
Received: (qmail 9487 invoked from network); 2 Mar 2006 18:34:31 -0000
Received: from mx2.magma.ca (206.191.0.250)
  by a.mx.sunsite.dk with SMTP; 2 Mar 2006 18:34:29 -0000
Received: from mail1.magma.ca (mail1.magma.ca [206.191.0.252])
	by mx2.magma.ca (8.13.0/8.13.0) with ESMTP id k22IYRkg006368
	for <zsh-users@sunsite.dk>; Thu, 2 Mar 2006 13:34:28 -0500
Received: from princo.homelinux.org (ottawa-hs-209-217-75-29.d-ip.magma.ca [209.217.75.29])
	by mail1.magma.ca (Magma's Mail Server) with ESMTP id k22IYQLT017628
	for <zsh-users@sunsite.dk>; Thu, 2 Mar 2006 13:34:27 -0500
Received: from jrdavid by princo.homelinux.org with local (Exim 3.36 #1 (Debian))
	id 1FEsd7-00057m-00
	for <zsh-users@sunsite.dk>; Thu, 02 Mar 2006 13:34:25 -0500
Date: Thu, 2 Mar 2006 13:34:25 -0500
From: Jean-Rene David <jrdavid@magma.ca>
To: Zsh User <zsh-users@sunsite.dk>
Subject: Two directory navigation facilities
Message-ID: <20060302183425.GD11769@princo>
Mail-Followup-To: Zsh User <zsh-users@sunsite.dk>
Mime-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
User-Agent: Mutt/1.5.9i

I made up two little facilities to navigate
directories:

1. directory marks. These are similar to named
   directories but are dynamically defined, have
   one letter mnemonics and are automatically
   saved to a file. 

2. directory jump-list. Go back to previous
   directories in cd-history and go forward again.

I'm sure I've duplicated some existing
functionality but it works just as I like and I
learned a lot in the process of doing it.

Just thought I'd share that. Hope someone finds it
useful. Improvements welcome...

**********************************************
 Directory marks
 i.e. This is similar to vi's marks functionality.
      In vicmd mode, type 'ma' to assign marks 'a'
      to the current directory. Then from
      anywhere, in vicmd mode, type ;a to go back
      to the marked directory.
      Type 'marks' to see all marks currently
      defined.
      Marks are saved in a file so persist between
      shell sessions.
**********************************************
ZSH_CONFIG_DIR=~/.zsh
MARKS_FILE=$ZSH_CONFIG_DIR/marks
typeset -A dir_marks
# load marks
if [ -r $MARKS_FILE ] ; then
   while read key value ; do
      dir_marks[$key]=$value
   done < $MARKS_FILE
fi

usage() {
}

marks() { 
   if [ $# -eq 0 ] ; then
      for k in ${(k)dir_marks}; do
         print -r "$k ${(vq)dir_marks[$k]}"
      done
   fi

   while getopts "hld:gs" arg
   do
      case "$arg" in
         l) # Load marks file 
            if [ -r $MARKS_FILE ] ; then
               while read key value ; do
                  dir_marks[$key]=$value
               done < $MARKS_FILE
               return 0
            else
               print -u2 "$MARKS_FILE doesn\'t exist."
               return 1
            fi
            ;;
         d) # Delete marks
            if [ $OPTARG = "ALL" ] ; then
               set -A dir_marks
               rm -f $MARKS_FILE
            elif [ $dir_marks[$OPTARG] ] ; then
               unset "dir_marks[$OPTARG]"
            else
               print -u2 "$0: No such mark \'$OPTARG\'"
            fi
            return 0
            ;;
         g) # Go to mark, let cd handle errors
            builtin cd $dir_marks[$2]
            return 0
            ;;
         s) # Set mark
            if [ $2 -a -z $3 ] ; then
               dir_marks[$2]=${PWD}
            elif [ $2 -a $3 ]  ; then
               dir_marks[$2]=$3
            else
               print -u2 "which mark?"
               return 1
            fi
            for k in ${(k)dir_marks}; do
               print -r "$k ${(vq)dir_marks[$k]}"
            done >| $MARKS_FILE
            ;;

         : ) ;;
      esac
   done
}

zle -N set-dir-mark
zle -N goto-dir-mark
bindkey -M vicmd 'm'   set-dir-mark
bindkey -M vicmd \;    goto-dir-mark

********************
set-dir-mark widget:
********************
read -k mark
if [ $mark = '?' ] ; then
   cat $MARKS_FILE
else
   [ ${mark%} ] || { print -u2 "$0: Empty mark is illegal."; return 1; }
   dir_marks[$mark]=${PWD}
   print "$mark -> $dir_marks[$mark]"
   marks >| $MARKS_FILE
fi
zle accept-line

********************
goto-dir-mark widget:
********************
read -k mark
builtin cd $dir_marks[$mark]
zle accept-line

*************************************************
 Directory jumplist
 i.e. this is similar to vim's jump functionality.
      typing "ju" or "jumps" will show you all the
      places you've 'cd' to, preceded by a count.
      Type that count and ^o (in vicmd mode) and
      you are back to that directory.

      The difference with directory stacks is that
      when you go back in the 'cd history' (if I
      may call it that), nothing gets popped off
      the stack so you can go forward again to
      where you came from, also using a count.

      Uses a separate directory stack (called
      'jumplist') so all the normal stack
      manipulation functions work normally.
*************************************************
JUMPS_FILE=$ZSH_CONFIG_DIR/jumps
JUMPLIST_SIZE=50
set -A jumplist
integer jumppos=1

_pushd() {
   integer i;
   integer len;

   len=${#jumplist}
   if [ $len -eq $JUMPLIST_SIZE ] ; 
   then 
      len=$JUMPLIST_SIZE-1
   fi

   if [ $len -eq 0 ]
   then
      jumplist[1]=${PWD}
   else
      for ((i=$len; i>0; i--))
      do
         jumplist[(($i+1))]=$jumplist[$i]
      done
      jumplist[1]=${PWD}
   fi
}

_popd() {
   local i;

   [ ${#jumplist} -eq 0 ]        && return 1;
   for ((i=1; i<${#jumplist}; i++))
   do
      jumplist[$i]=$jumplist[(($i+1))]
   done
   jumplist[$i]=()
   return 0;
}

jump_to() {
   local i;

   builtin cd $1
   [ $? -eq 0 ] || return 1;
   if [ $jumppos -gt 1 ] ; then
      for ((i=$jumppos; i>1; i--))
      do
         _popd;
      done
      jumppos=1
   fi
   _pushd
}

jumps() {
   integer i

   # With no argument, print jump list
   if [ $# -eq 0 ] ; then
      for ((i=${#jumplist}; i>0; i--))
      do
         if [ $i -eq $jumppos ] 
         then
            print "$(($i-1)) > $jumplist[$i]"
         else
            print "$(($i-1))   $jumplist[$i]"
         fi
      done
      return 0
   fi

   while getopts "d" arg
   do
      case "$arg" in
         d ) set -A jumplist
             return 0
             ;;
         ? ) ;;
      esac
   done
}

zle -N jump_back
zle -N jump_forward
bindkey -M vicmd '\Co' jump_back
bindkey -M viins '\Co' jump_back
# Can't bind c-i in viins because it's too useful for completion
# (i.e. 'tab') but it works in vicmd mode.
bindkey -M vicmd '\Ci' jump_forward
alias cd=jump_to
alias ju=jumps

********************
jump_back widget:
********************
[ ${#jumplist} -eq 0 ]        && return 1;
if [ ! $NUMERIC ] ; then
   count=1;
else
   count=$NUMERIC
fi

# make sure we don't jump beyond end if list
if [ $(($jumppos+$count)) -gt ${#jumplist} ] ; then
   jumppos=$((${#jumplist}));
else
   jumppos=$(($jumppos+$count));
fi
builtin cd $jumplist[$jumppos]
zle accept-line

********************
jump_forward widget:
********************
[ ${#jumplist} -eq 0 ] && return 1;
if [ ! $NUMERIC ] ; then
   count=1;
else
   count=$NUMERIC
fi

if [ $(($jumppos-$count)) -lt 1 ] ; then
   jumppos=1
else
   jumppos=$(($jumppos-$count));
fi
builtin cd $jumplist[$jumppos]
zle accept-line

-- 
JR

