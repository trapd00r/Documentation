18:23:55 ▏       mst dhoss: a list only exists, if ever, as a series of SV entries on the perl stack
18:24:13 ▏       mst dhoss: an array is an actual AV with indices and stuff
18:26:25 ▏   Altreus eval: sub foo() { my @arr = qw(a b); @arr }  [ foo(), scalar foo ]
18:26:27 ▏   perlbot Altreus: ["a","b",2]
18:26:34 ▏       mst anyway, &
18:26:41 ▏   Altreus dhoss: the function returns an /array/, so in scalar context you get its length
18:26:57 ▏   Altreus eval: sub foo() { return qw(a b) }  [ foo(), scalar foo ]

04:32:22 ▏  woldrich \bmike\b, something like perl -e '@_ = qw(foo bar foobarbaz); $max = length($_[2]); printf("%${max}s\n", $_) for @_'  
                     , just compute the len of the longst string you have
04:34:19 ▏     Somni assuming you know all of the strings you will ever have
04:34:56 ▏     Somni printf "%-*s\n", $max, $_;
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
04:35:57 ▏     mauke >> woldrich: your casual overwriting of @_ and use of dynamic format strings saddens me
04:36:33 ▏  woldrich mauke, what's wrong with dynamic format strings?
04:36:42 ▏     Somni $max = '%s'
04:36:59 ▏     Somni woops, you've now caused erroneous output; if this were C, a potential exploit
04:37:10 ▏  woldrich sigh
04:37:17 ▏     mauke >> woldrich: red flag
04:37:41 ▏  woldrich point taken, but not very likely scenario for what I've used it for :p
04:37:45 ▏  woldrich what do you use instead?
04:37:49 ▏     mauke they're unnecessary in many cases and can be security issues in extreme cases
04:37:57 ▏     Somni depends on the situation; here, it is entirely unnecessary
04:38:00 ▏     Somni thus, %-*s
04:38:33 ▏     Somni or printf "%*s", -$max, $_
04:38:51 ▏  woldrich oh, I didn't know of that. yes, now I can agree
04:39:00 ▏     Somni or printf "%*s", $max, $_ if you really did want want left padding



=for double-not

A double "not" operator is used for converting scalar to boolean value
  use constant TRUE => !! 1;
  use constant FALSE => !! '';

=cut

=for zero-width

# zero-width, match _before_ 'foo':
split(/(?=foo)/, 'foobarfoobazfooqux');

=cut

=for unimport()

# unimport()
# 11:33:22 ▏      anno >> woldrich: it runs unimport(). what unimport() does is
# up to the module

use Data::Dumper;
no Data::Dumper qw(Dumper);

=cut

=for arithmetic

* siginfies multiplication, but two asterisks in a row are a shorthand for
exponentiation (this derives from FORTRAN). Thus, one might write 2 ** 8 = 256.

=cut

=for Mechanize

$mech->add_handler("request_send", sub { shift->dump; return });
$mech->add_handler("response_done", sub { shift->dump; return });

This will cause all HTTP requests and responses to be output, so you can see exactly whats happening.

=cut

=for research

my $str = "Hello"; pos($str) = 0; [ scalar $str =~ m/\G[\s\n]*/gc ]

=cut

# vim: ft=perl tw=0 nowrap:
