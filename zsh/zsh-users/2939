From zsh-users-return-2939-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Mar 04 05:40:41 2000
Return-Path: <zsh-users-return-2939-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10396 invoked from network); 4 Mar 2000 05:40:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 4 Mar 2000 05:40:39 -0000
Received: (qmail 14587 invoked by alias); 4 Mar 2000 05:40:26 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 2939
Received: (qmail 14567 invoked from network); 4 Mar 2000 05:40:24 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000304054014.ZM21187@candle.brasslantern.com>
Date: Sat, 4 Mar 2000 05:40:13 +0000
In-Reply-To: =?iso-8859-1?Q?=3C20000303123932=2EA11036=40picard=2Efranken?=
 =?iso-8859-1?Q?=2Ede=3E?=
 =?iso-8859-1?Q?Comments=3A_In_reply_to_Thomas_K=F6hler_=3Cjean-luc=40pica?=
 =?iso-8859-1?Q?rd=2Efranken=2Ede=3E?=
 =?iso-8859-1?Q?________=22Re=3A_zsh_tips_for_=22UNIX_Power_Tools=22=22_?=
 =?iso-8859-1?Q?=28Mar__3=2C_12=3A39pm=29?=
References: <28174.952013581@jpeek.com> 
	<20000303123932.A11036@picard.franken.de> 
	<87k8jjwt6h.fsf@cenderis.demon.co.uk>
In-Reply-To: <87k8jjwt6h.fsf@cenderis.demon.co.uk>
Comments: In reply to Bruce Stephens <bruce+zsh@cenderis.demon.co.uk>
        "Re: zsh tips for "UNIX Power Tools"" (Mar  3, 11:05pm)
X-Mailer: Z-Mail (5.0.0 30July97)
To: Jerry Peek <jpeek@jpeek.com>, zsh-users@sunsite.auc.dk
Subject: Re: zsh tips for "UNIX Power Tools"
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: quoted-printable

On Mar 3, 12:39pm, Thomas K=F6hler wrote:
} Subject: Re: zsh tips for "UNIX Power Tools"
}
} My favorite zsh tricks (some of which are not too tricky, but perhaps
} worth to be mentioned anyways):
} - I like the globbing features of zsh, especially this one:
}   for i in **/*.gif ; do convert $i ${i:r}.png ; done

It's even easier than that:

    for i in **/*.gif; convert $i $i:r.png

You don't need the "do ... done" for a one-liner.  (The no_short_loops
option can be used to require do ... done for ksh script compatibility.)
You don't need the { } for $i:r either (though you would if there were
not a "." between the "r" and the "png").

Skipping ahead just a bit:

} This is my last trick for now (and it contains some escape characters,
} so be sure to copy them as such if you want to try this)

Avoid literal escape characters in 3.1.6 and later by using $'...'.
The result of $'...' is that the stuff in between the single quotes is
treated as if you did $(print '...') instead.  So now \e is escape:

	RPROMPT=3D$'%{\e[0;33m%}%1v%{\e[0m%}'

}   function precmd {
}      # OK, I set the prompt here in my original precmd, but that's not =
the
}      # issue here :)
}      if jobs % >& /dev/null; then
}         psvar=3D("There are jobs.")
}      else
}         psvar=3D("")
}      fi
}   }

Two things:  First, you can assign directly to individual elements of an
array, thusly:

	psvar[1]=3D"There are jobs."

That way you can use other positions in $psvar for other things, without
reassigning the whole thing every time.

Second, in 3.1.6-dev-19, you've got the parameter module available, so
you can avoid running the jobs command and even do some fancier stuff:

	# requires zmodload zsh/parameter
	case "$jobstates" in
	(*suspended*)
	  psvar[1]=3D"There are stopped jobs.";;
	(*running*)
	  psvar[1]=3D"There are running jobs.";;
	(*)
	  psvar[1]=3D"";;
	esac

Note that if instead you'd said

	psvar[1]=3D()

then that's equivalent to

	shift psvar

which is probably not what you want in this case.

}   The last line in my precmd (marked "SEE THERE" above") reads like
}   this:
}      (sleep 1 ; show_mode "INSERT") &!
}   [I need the sleep because I have a multiline prompt, so the show_mode=

}   would set the indication to the wrong place otherwise]

There's a better way to do this:

	# requires setopt prompt_subst
	PROMPT=3D"$PROMPT"'%{$(show_mode INSERT >/dev/tty)%}'

Now the prompt itself runs the initial show_mode, and you don't need any
background jobs run from precmd.  Note that I wrapped it in %{...%} to
indicate that it shouldn't be counted when computing the prompt width.
The redirection to /dev/tty is so that the output of show_mode won't
really become part of the prompt.

}   ###       vi-add-eol (unbound) (A) (unbound)
}   ###              Move  to the end of the line and enter insert mode.
}   vi-add-eol() {
}      show_mode "INSERT"
}      builtin zle .vi-add-eol
}   }
}   zle -N vi-add-eol
}   bindkey -M vicmd "A" vi-add-eol

Note that "A" is already bound to vi-add-eol in the vicmd keymap, so you
don't need that bindkey command.  It's enough to replace the existing
widget of that name with "zle -N vi-add-eol".  Same goes for the rest
of these widgets, as far as I noticed.

On Mar 3, 11:05pm, Bruce Stephens wrote:
} Subject: Re: zsh tips for "UNIX Power Tools"
}
} >   chmod 755 **/*(/)
} >   chmod 644 **/*(.)
} =

} What's wrong with
} =

}         chmod -R go+rX .

It changes the group and other execute permissions of plain files if the
user execute permission was already set.  That's obviously not what 644
accomplishes on plain files in Thomas's example.

Besides, not everyone has GNU chmod.

-- =

Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

