From zsh-workers-return-10129-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Mar 14 10:19:36 2000
Return-Path: <zsh-workers-return-10129-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2931 invoked from network); 14 Mar 2000 10:19:30 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Mar 2000 10:19:30 -0000
Received: (qmail 932 invoked by alias); 14 Mar 2000 10:19:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10129
Received: (qmail 919 invoked from network); 14 Mar 2000 10:19:08 -0000
Date: Tue, 14 Mar 2000 11:19:07 +0100 (MET)
Message-Id: <200003141019.LAA07320@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Sat, 11 Mar 2000 23:46:01 +0000
Subject: Re: Default fpath


Bart Schaefer wrote:

> ...
> 
> This gives me an idea ... it ought to be possible to point autoload (or
> some new builtin) at a zcompiled digest file and have it mark all the
> functions therein for autoloading.  That way, you could (once) select
> the functions to compile into the digest, then simply add the digest to
> your $fpath and issue a single autoload command.  (Note 1)
> 
> The digest-file equivalent of `autoload $dir/*(.)`, you see.  I suppose
> you can do `autoload ${$(zcompile -t file.zwc):t}` but that requires an
> extra process, and it doesn't cover cases where one component file of
> the .zwc contained multiple function definitions.

The patch below adds the `-w' option to autoload (and only to that,
like `[-+]X'). If it is given, the arguments are taken as names of
wordcode files and all functions in them are marked for autoloading.


[ in another message: ]

> ...
> 
> Perhaps not.  Actually, what would suit me fine is a way to dump out a
> .zwc of (a subset of the) functions defined in a running zsh.

That's easy. Would you prefer it as an option to `zcompile' or one for
`functions'? E.g. `zcompile -c foo' would put the definitons of all
currently defined function in the wordcode file foo.zwc,
`zcompile -c foo bar baz' would put the functions `bar' and `baz', as
currently defined in foo.zwc, and `zcompile -cm foo "_*"' would put
all functions whose name matches `_*' in foo.zwc.

Or the same with, say `functions -w ...'? We have the code for `-m'
there already, although that isn't that much.

> } > (2) an option to say whether each function should be autoloaded zsh-style
> } >     or ksh-style, so that the right thing happens regardless of the run-
> } >     time setting of kshautoload.)
> } 
> } But currently it is the same as for loading from a normal file,
> } wouldn't it probably be confusing if the wordcode file said how to
> } load it?
> 
> Actually I'd like it if the text file could "say how to load it" as well,
> but that wouldn't be portable -- the whole point of kshautoload is to be
> able to write functions that can load into both zsh and ksh.  So if I set
> kshautoload, I'm probably in a situation where I load ksh functions.  It
> would be possible to require that zsh function text files include some
> token that specifies NOT using kshautoload, but that would put the burden
> on the ordinary zsh writer, which feels wrong.
> 
> There's no such problem with .zwc files -- only zsh will load them, and
> the how-to token is invisible to the user.
> 
> Consider the current problem of initializing the completion system with
> kshautoload set.  (I.e., you can't.)  The kshautoload user could solve
> this problem by precompiling the completion system for zsh loading.

Ah, stupid me. Good idea...

> The one thing I can't decide is whether the default should be initialized
> from the setting of kshautoload, or if it should always default to zsh.

Hm, defaulting to the current setting of kshautoload is probably less
surprising, I think (but then, I've never used kshautoload...).

> } But don't get me wrong: I never use kshautoload, so I
> } wouldn't be against allowing it. Per-function or per-wordcode file?
> 
> Per source file used to build the wordcode file would be the correct
> granularity, which I guess means per-function?

Yep. Suggested syntax: two options `-k' and `-z' which mean: all
following files are loaded like ksh/zsh does it normally. this allows
us to say:

  zcompile -z comp.zwc .../Completion/*/_*

to have them all loaded zsh-like.

  zcompile foo.zwc -z bar -k baz

would load bar zsh-like and baz ksh-like.

Ok? But maybe this is a case where adding functions to a wordcode file
would be handy:

  zcompile foo.zwc -z bar1 baz1
  zcompile -a foo.zwc -k bar2 baz2

would create a wordcode file with bar1/baz1 loaded zsh-like and then
add bar2/baz2 loaded ksh-like to it.


Bye
 Sven

diff -ru ../z.old/Doc/Zsh/builtins.yo Doc/Zsh/builtins.yo
--- ../z.old/Doc/Zsh/builtins.yo	Tue Mar 14 10:55:29 2000
+++ Doc/Zsh/builtins.yo	Tue Mar 14 10:56:20 2000
@@ -76,8 +76,9 @@
 findex(autoload)
 cindex(functions, autoloading)
 cindex(autoloading functions)
-item(tt(autoload) [ {tt(PLUS())|tt(-)}tt(UXmt) ] [ var(name) ... ])(
-Equivalent to tt(functions -u), with the exception of tt(-X)/tt(+X).
+item(tt(autoload) [ {tt(PLUS())|tt(-)}tt(UXmt) ] [ tt(-w) ] [ var(name) ... ])(
+Equivalent to tt(functions -u), with the exception of tt(-X)/tt(+X)
+and tt(-w).
 
 The flag tt(-X) may be used only inside a shell function, and may not be
 followed by a var(name).  It causes the calling function to be marked for
@@ -93,6 +94,9 @@
 exit status is nonzero (failure) if the function was already defined or
 when no definition was found.  In the latter case the function remains
 undefined and marked for autoloading.
+
+With the tt(-w) flag, the var(name)s are taken as names of wordcode
+files and all functions defined in them are marked for autoloading.
 )
 findex(bg)
 cindex(jobs, backgrounding)
diff -ru ../z.old/Src/builtin.c Src/builtin.c
--- ../z.old/Src/builtin.c	Tue Mar 14 10:55:18 2000
+++ Src/builtin.c	Tue Mar 14 10:56:21 2000
@@ -43,7 +43,7 @@
     BUILTIN(".", BINF_PSPECIAL, bin_dot, 1, -1, 0, NULL, NULL),
     BUILTIN(":", BINF_PSPECIAL, bin_true, 0, -1, 0, NULL, NULL),
     BUILTIN("alias", BINF_MAGICEQUALS | BINF_PLUSOPTS, bin_alias, 0, -1, 0, "Lgmr", NULL),
-    BUILTIN("autoload", BINF_TYPEOPTS, bin_functions, 0, -1, 0, "tUX", "u"),
+    BUILTIN("autoload", BINF_TYPEOPTS, bin_functions, 0, -1, 0, "tUXw", "u"),
     BUILTIN("bg", 0, bin_fg, 0, -1, BIN_BG, NULL, NULL),
     BUILTIN("break", BINF_PSPECIAL, bin_break, 0, 1, BIN_BREAK, NULL, NULL),
     BUILTIN("bye", 0, bin_break, 0, 1, BIN_EXIT, NULL, NULL),
@@ -1996,7 +1996,8 @@
 
 /* Helper for bin_functions() when run as "autoload -X" */
 
-static int
+/**/
+int
 eval_autoload(Shfunc shf, char *name, char *ops, int func)
 {
     if (!(shf->flags & PM_UNDEFINED))
@@ -2114,7 +2115,12 @@
 
     /* Take the arguments literally -- do not glob */
     for (; *argv; argv++) {
-	if ((shf = (Shfunc) shfunctab->getnode(shfunctab, *argv))) {
+	if (ops['w']) {
+	    if (dump_autoload(*argv, on, ops, func)) {
+		zwarnnam(name, "invalid wordcode file: %s", *argv, 0);
+		returnval = 1;
+	    }
+	} else if ((shf = (Shfunc) shfunctab->getnode(shfunctab, *argv))) {
 	    /* if any flag was given */
 	    if (on|off) {
 		/* turn on/off the given flags */
@@ -2140,7 +2146,7 @@
 }
 
 /**/
-static Eprog
+Eprog
 mkautofn(Shfunc shf)
 {
     Eprog p;
diff -ru ../z.old/Src/parse.c Src/parse.c
--- ../z.old/Src/parse.c	Tue Mar 14 10:55:21 2000
+++ Src/parse.c	Tue Mar 14 10:56:21 2000
@@ -2801,3 +2801,30 @@
 }
 
 #endif
+
+/**/
+int
+dump_autoload(char *file, int on, char *ops, int func)
+{
+    Wordcode h;
+    FDHead n, e;
+    Shfunc shf;
+    int ret = 0;
+
+    if (!strsfx(FD_EXT, file))
+	file = dyncat(file, FD_EXT);
+
+    if (!(h = load_dump_header(file)))
+	return 1;
+
+    for (n = firstfdhead(h), e = (FDHead) (h + fdheaderlen(h)); n < e;
+	 n = nextfdhead(n)) {
+	shf = (Shfunc) zcalloc(sizeof *shf);
+	shf->flags = on;
+	shf->funcdef = mkautofn(shf);
+	shfunctab->addnode(shfunctab, ztrdup(fdname(n) + n->tail), shf);
+	if (ops['X'] && eval_autoload(shf, shf->nam, ops, func))
+	    ret = 1;
+    }
+    return ret;
+}

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

