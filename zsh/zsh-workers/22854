From zsh-workers-return-22854-mason-zsh=primenet.com.au@sunsite.dk Tue Oct 10 11:17:35 2006
Return-Path: <zsh-workers-return-22854-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6996 invoked from network); 10 Oct 2006 11:17:32 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.6 (2006-10-03) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.4 required=5.0 tests=AWL,BAYES_00,
	FORGED_RCVD_HELO autolearn=ham version=3.1.6
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 10 Oct 2006 11:17:32 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 67863 invoked from network); 10 Oct 2006 11:17:25 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 10 Oct 2006 11:17:25 -0000
Received: (qmail 322 invoked by alias); 10 Oct 2006 11:17:22 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 22854
Received: (qmail 313 invoked from network); 10 Oct 2006 11:17:21 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 10 Oct 2006 11:17:21 -0000
Received: (qmail 67558 invoked from network); 10 Oct 2006 11:17:21 -0000
Received: from cluster-d.mailcontrol.com (217.69.20.190)
  by a.mx.sunsite.dk with SMTP; 10 Oct 2006 11:17:19 -0000
Received: from cameurexb01.EUROPE.ROOT.PRI ([62.189.241.200])
	by rly23d.srv.mailcontrol.com (MailControl) with ESMTP id k9ABDafB028090
	for <zsh-workers@sunsite.dk>; Tue, 10 Oct 2006 12:17:11 +0100
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.1830);
	 Tue, 10 Oct 2006 12:15:58 +0100
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.7/8.13.4) with ESMTP id k9ABFvLl032414
	for <zsh-workers@sunsite.dk>; Tue, 10 Oct 2006 12:15:58 +0100
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.7/8.13.7/Submit) with ESMTP id k9ABFunr032411
	for <zsh-workers@sunsite.dk>; Tue, 10 Oct 2006 12:15:57 +0100
Message-Id: <200610101115.k9ABFunr032411@news01.csr.com>
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: replace-string-again
Date: Tue, 10 Oct 2006 12:15:56 +0100
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 10 Oct 2006 11:15:58.0353 (UTC) FILETIME=[76104810:01C6EC5D]
Content-Type: text/plain
MIME-Version: 1.0
X-Scanned-By: MailControl A-07-04-02 (www.mailcontrol.com) on 10.68.0.133

I've separated out the back end of replace-string to make it easy to
repeat the last replacement operation.

Index: Doc/Zsh/contrib.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/contrib.yo,v
retrieving revision 1.63
diff -u -r1.63 contrib.yo
--- Doc/Zsh/contrib.yo	14 Aug 2006 16:58:47 -0000	1.63
+++ Doc/Zsh/contrib.yo	10 Oct 2006 11:13:56 -0000
@@ -1055,8 +1055,10 @@
 similar functions while reading a value.
 )
 tindex(replace-string)
+tindex(replace-string-again)
 tindex(replace-pattern)
-item(tt(replace-string), tt(replace-pattern))(
+xitem(tt(replace-string), tt(replace-pattern))
+item(tt(replace-string-again), tt(replace-pattern-again))(
 The function tt(replace-string) implements two widgets.
 If defined under the same name as the function, it prompts for two
 strings; the first (source) string will be replaced by the second
@@ -1082,6 +1084,13 @@
 numeric argument forces the previous values to be offered, a negative or
 zero argument forces them not to be.
 
+The function tt(replace-string-again) can be used to repeat the
+previous replacement; no prompting is done.  As with tt(replace-string), if
+the name of the widget contains the word `tt(pattern)', pattern matching
+is performed, else a literal string replacement.  Note that the
+previous source and replacement text are the same whether pattern or string
+matching is used.
+
 For example, starting from the line:
 
 example(print This line contains fan and fond)
Index: Functions/Zle/replace-string
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/replace-string,v
retrieving revision 1.2
diff -u -r1.2 replace-string
--- Functions/Zle/replace-string	13 Jan 2005 15:31:53 -0000	1.2
+++ Functions/Zle/replace-string	10 Oct 2006 11:13:56 -0000
@@ -1,11 +1,11 @@
 emulate -L zsh
 setopt extendedglob
 
-autoload read-from-minibuffer
+autoload -U read-from-minibuffer replace-string-again
 
 local p1="Replace: " p2="   with: "
-local REPLY MATCH MBEGIN MEND curwidget=$WIDGET previous
-local -a match mbegin mend
+# Saving curwidget is necessary to avoid the widget name being overwritten.
+local REPLY previous curwidget=$WIDGET
 
 if (( ${+NUMERIC} )); then
   (( $NUMERIC > 0 )) && previous=1
@@ -20,34 +20,4 @@
   ${previous:+$_replace_string_rep} || return 1
 _replace_string_rep=$REPLY
 
-if [[ $curwidget = *pattern* ]]; then
-    local rep2
-    # The following horror is so that an & preceded by an even
-    # number of backslashes is active, without stripping backslashes,
-    # while preceded by an odd number of backslashes is inactive,
-    # with one backslash being stripped.  A similar logic applies
-    # to \digit.
-    local rep=$_replace_string_rep
-    while [[ $rep = (#b)([^\\]#)(\\\\)#(\\|)(\&|\\<->|\\\{<->\})(*) ]]; do
-	if [[ -n $match[3] ]]; then
-	    # Expression is quoted, strip quotes
-	    rep2="${match[1]}${match[2]}${match[4]}"
-	else
-	    rep2+="${match[1]}${match[2]}"
-	    if [[ $match[4] = \& ]]; then
-		rep2+='${MATCH}'
-	    elif [[ $match[4] = \\\{* ]]; then
-		rep2+='${match['${match[4][3,-2]}']}'
-	    else
-		rep2+='${match['${match[4][2,-1]}']}'
-	    fi
-	fi
-	rep=${match[5]}
-    done
-    rep2+=$rep
-    LBUFFER=${LBUFFER//(#bm)$~_replace_string_src/${(e)rep2}}
-    RBUFFER=${RBUFFER//(#bm)$~_replace_string_src/${(e)rep2}}
-else
-    LBUFFER=${LBUFFER//$_replace_string_src/$_replace_string_rep}
-    RBUFFER=${RBUFFER//$_replace_string_src/$_replace_string_rep}
-fi
+replace-string-again $curwidget
Index: Functions/Zle/replace-string-again
===================================================================
RCS file: Functions/Zle/replace-string-again
diff -N Functions/Zle/replace-string-again
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ Functions/Zle/replace-string-again	10 Oct 2006 11:13:56 -0000
@@ -0,0 +1,45 @@
+# Back end for replace-string; can be called as a widget to repeat
+# the previous replacement.  _replace_string_src and _replace_string_rep
+# are global.
+
+# When called from replace-string, we need to use the widget
+# name passed to decide whether to do pattern matching: the widget
+# may since have been overwritten.
+local MATCH MBEGIN MEND curwidget=${1:-$WIDGET}
+local -a match mbegin mend
+
+if [[ -z $_replace_string_src ]]; then
+  zle -M No string to replace.
+fi
+
+if [[ $curwidget = *pattern* ]]; then
+    local rep2
+    # The following horror is so that an & preceded by an even
+    # number of backslashes is active, without stripping backslashes,
+    # while preceded by an odd number of backslashes is inactive,
+    # with one backslash being stripped.  A similar logic applies
+    # to \digit.
+    local rep=$_replace_string_rep
+    while [[ $rep = (#b)([^\\]#)(\\\\)#(\\|)(\&|\\<->|\\\{<->\})(*) ]]; do
+	if [[ -n $match[3] ]]; then
+	    # Expression is quoted, strip quotes
+	    rep2="${match[1]}${match[2]}${match[4]}"
+	else
+	    rep2+="${match[1]}${match[2]}"
+	    if [[ $match[4] = \& ]]; then
+		rep2+='${MATCH}'
+	    elif [[ $match[4] = \\\{* ]]; then
+		rep2+='${match['${match[4][3,-2]}']}'
+	    else
+		rep2+='${match['${match[4][2,-1]}']}'
+	    fi
+	fi
+	rep=${match[5]}
+    done
+    rep2+=$rep
+    LBUFFER=${LBUFFER//(#bm)$~_replace_string_src/${(e)rep2}}
+    RBUFFER=${RBUFFER//(#bm)$~_replace_string_src/${(e)rep2}}
+else
+    LBUFFER=${LBUFFER//$_replace_string_src/$_replace_string_rep}
+    RBUFFER=${RBUFFER//$_replace_string_src/$_replace_string_rep}
+fi

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


To access the latest news from CSR copy this link into a web browser:  http://www.csr.com/email_sig.php

