From zsh-workers-return-5675-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 08 09:23:38 1999
Return-Path: <zsh-workers-return-5675-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28816 invoked from network); 8 Mar 1999 09:23:36 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Mar 1999 09:23:36 -0000
Received: (qmail 24794 invoked by alias); 8 Mar 1999 09:23:23 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5675
Received: (qmail 24787 invoked from network); 8 Mar 1999 09:23:22 -0000
Date: Mon, 8 Mar 1999 10:22:38 +0100 (MET)
Message-Id: <199903080922.KAA11610@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: zle_tricky cleanup


Ok, another part of my homework...

A bit of cosmetic cleanup in zle_tricky.c (putting `else's on the
lines of preceding `}'s which seems to be normal style in zsh code and 
which I have trouble getting used to), two fixes in `join_new_[ps]fx()',
some security tests in `do_ambiguous()' (probably not needed, but not
wrong, so...), and a couple of `DPUTS's just to make sure...

This is *not* the promised patch to improve joining cline lists. I
played with the code a bit and decided to turn this into a bit more
work for me. Just to give you a hint as to what this is about:

The completion code uses lists of cline-structs to describe what
should be put on the line (for non-menucompletion). After each match
the list for the match has to be joined with the list for all previous 
lists, producing a new list that `matches' all matches generated. Some 
of the code still comes from the time where we didn't have new style
completion and thus can only cope with one typ of change in the
command-line-string-information: putting a prefix from what is now
called PREFIX int IPREFIX. But since we now can give arbitrary strings 
(and prefixes and suffixes and...) to the completion code it is
relatively easy to completely irritate some of the completion code
just by playing with different settings of PREFIX, IPREFIX and using
compadd with the `-p' and `-s' options. I now decided to change the
matching code (internally) in a way that will allow to simplify many
of the functions and still be able to produce better common strings
(simplifying the way these cline lists are build and stored). This
will still take some time, though.

Bye
 Sven

diff -u oos/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- oos/Zle/zle_tricky.c	Mon Mar  8 09:17:59 1999
+++ Src/Zle/zle_tricky.c	Mon Mar  8 10:05:21 1999
@@ -442,8 +442,7 @@
 		    menugrp = lmatches;
 	    } while (!menugrp->mcount);
 	    menucur = menugrp->matches + menugrp->mcount - 1;
-	}
-	else
+	} else
 	    menucur--;
 	metafy_line();
 	do_single(*menucur);
@@ -1599,8 +1598,7 @@
 	    memcpy(np, rw, rwlen);
 	    nw += np - rw;
 	    zfree(rw, rwlen);
-	}
-	else
+	} else
 	    nw = np;
 	*rwp = rw = np;
 	rwlen = nl;
@@ -1609,8 +1607,7 @@
     if (prep) {
 	memmove(rw + al, rw, rwlen - al);
 	memcpy(rw, as, al);
-    }
-    else
+    } else
 	memcpy(nw, as, al);
 
     return nw + al;
@@ -2348,7 +2345,7 @@
 	    /* The cline doesn't have a string built by reverse matching,
 	     * so we have to work on the original substring in the cline
 	     * and the new string. */
-	    if (line->wlen == len && strncmp(line->word, word, len)) {
+	    if (line->wlen == len && !strncmp(line->word, word, len)) {
 		/* They are equal, accept and return. If there was
 		 * another element in the list, shorten the list. */
 		if (next)
@@ -2793,7 +2790,7 @@
 		    ret = line;
 	    }
 	} else {
-	    if (line->wlen == len && strncmp(line->word, word - len, len)) {
+	    if (line->wlen == len && !strncmp(line->word, word - len, len)) {
 		if (next)
 		    miss = 1;
 		line->next = NULL;
@@ -2909,7 +2906,7 @@
     Cline oo = o;
 
     if (!o)
-	/* This is the first time this was called, so just return the
+	/* This is the first time we are being called, so just return
 	 * the second list. In future calls we will get this list as
 	 * the first argument. */
 	return n;
@@ -3026,13 +3023,11 @@
 			o->word = NULL;
 			o->flags |= CLF_DIFF;
 		    }
-		}
-		else {
+		} else {
 		    o->word = NULL;
 		    o->flags |= CLF_DIFF;
 		}
-	    }
-	    else if (n->word)
+	    } else if (n->word)
 		o->flags |= CLF_DIFF;
 
 	    q = n->next;
@@ -3152,8 +3147,7 @@
 	    pll -= sl - psl;
 	}
 	sll = strlen(s) - sl;
-    }
-    else
+    } else
 	sll = 0;
 
     pll -= pl;
@@ -3503,11 +3497,9 @@
 				    }
 				    lm = mp;
 				    break;
-				}
-				else
+				} else
 				    t = 0;
-			    }
-			    else
+			    } else
 				t = 0;
 			}
 		    } else {
@@ -3718,8 +3710,7 @@
 				    }
 				    lm = mp;
 				    break;
-				}
-				else
+				} else
 				    t = 0;
 			    }
 			}
@@ -3865,8 +3856,7 @@
 
 		return NULL;
 	    }
-	}
-	else
+	} else
 	    return NULL;
     } else if (!(r = match_pfx(pfx, w, &pli, &pl, NULL, bpl)))
 	/* We had only the prefix to match and that didn't match. */
@@ -4211,6 +4201,9 @@
 		    Cline *clp = &lc, tlc;
 		    char *ss = dupstring(s), *ee = me + (ss - s);
 
+		    DPUTS(me < s || me > s + sl,
+			  "BUG: invalid end-pointer (me)");
+
 		    if (ppre && *ppre) {
 			*clp = tlc = getcline(NULL, 0, ppre, lpl, CLF_VAR);
 			clp = &(tlc->next);
@@ -4245,9 +4238,13 @@
 			lc = tlc;
 		    }
 		    if (psuf && *psuf) {
-			for (tlc = lc; tlc->next; tlc = tlc->next);
-			tlc->next = getcline(NULL, 0, psuf, lsl,
-					     CLF_END | CLF_VAR);
+			if (lc) {
+			    for (tlc = lc; tlc->next; tlc = tlc->next);
+			    tlc->next = getcline(NULL, 0, psuf, lsl,
+						 CLF_END | CLF_VAR);
+			} else
+			    lc = getcline(NULL, 0, psuf, lsl,
+					  CLF_END | CLF_VAR);
 		    }
 		}
 		if (ipre && *ipre) {
@@ -4559,6 +4556,8 @@
 	Cline *clp = &lc, tlc;
 	char *ss = dupstring(s), *ee = e + (ss - s);
 
+	DPUTS(e < s || e > s + sl, "BUG: invalid end-pointer (e)");
+
 	if (lppre && *lppre) {
 	    *clp = str_cline(lppre, strlen(lppre), &tlc);
 	    clp = &(tlc->next);
@@ -4628,19 +4627,16 @@
 	if (lpsuf && *lpsuf && strsfx(lpsuf, s)) {
 	    s[sl - lpsl] = '\0';
 	    cm->psuf = lpsuf;
-	}
-	else
+	} else
 	    cm->psuf = NULL;
 
 	if (lppre && *lppre && strpfx(lppre, s)) {
 	    s += lppl;
 	    cm->ppre = lppre;
 	    cm->prpre = (isf && prpre && *prpre ? prpre : NULL);
-	}
-	else
+	} else
 	    cm->ppre = cm->prpre = NULL;
-    }
-    else {
+    } else {
 	cm->ppre = (lppre && *lppre ? lppre : NULL);
 	cm->psuf = (lpsuf && *lpsuf ? lpsuf : NULL);
 	cm->prpre = (isf && prpre && *prpre ? prpre : NULL);
@@ -5964,8 +5960,7 @@
     if (cc->explain) {
 	expl = (Cexpl) zhalloc(sizeof(struct cexpl));
 	expl->count = expl->fcount = 0;
-    }
-    else
+    } else
 	expl = NULL;
     /* compadd is the number of characters we have to ignore at the  *
      * beginning of the word.                                        */
@@ -5980,8 +5975,7 @@
 	    uremnode(ccstack, firstnode(ccstack));
 	    return;
 	}
-    }
-    else
+    } else
 	ipre = NULL;
 
     if (cc->matcher) {
@@ -6163,8 +6157,7 @@
 		lppre = NULL;
 		lppl = 0;
 	    }
-	}
-	else {
+	} else {
 	    lppre = NULL;
 	    lppl = 0;
 	}
@@ -6181,8 +6174,7 @@
 	    }
 	    lpsuf = strchr(lpsuf, '/');
 	    lpsl = (lpsuf ? strlen(lpsuf) : 0);
-	}
-	else {
+	} else {
 	    lpsuf = NULL;
 	    lpsl = 0;
 	}
@@ -6696,8 +6688,7 @@
 
 		    sprintf(p, "%s%s%s", m->ppre, m->str, m->psuf);
 		    addlinknode(args, dupstring(p));
-		}
-		else
+		} else
 		    addlinknode(args, dupstring(m->str));
 	    }
 
@@ -6725,8 +6716,7 @@
 	else
 	    endcmgroup(NULL);
 	begcmgroup("default", 0);
-    }
-    else if ((tt = cc->explain)) {
+    } else if ((tt = cc->explain)) {
 	tt = dupstring(tt);
 	if ((cc->mask & CC_EXPANDEXPL) && !parsestr(tt)) {
 	    singsub(&tt);
@@ -6949,8 +6939,7 @@
 	    ap = bp;
 	}
 	*cp = NULL;
-    }
-    else if (s) {
+    } else if (s) {
 	/* Now sort the array (it contains matches). */
 	qsort((void *) rp, n, sizeof(Cmatch),
 	      (int (*) _((const void *, const void *)))matchcmp);
@@ -7153,8 +7142,7 @@
 		e->str = ztrdup(o->str);
 	    }
 	    *ep = NULL;
-	}
-	else
+	} else
 	    n->expls = NULL;
 
 	if ((n->ccount = g->ccount)) {
@@ -7163,8 +7151,7 @@
 	    for (cq = g->ccs; *cq; cq++, cp++)
 		*cp = *cq;
 	    *cp = NULL;
-	}
-	else
+	} else
 	    n->ccs = NULL;
 	g = g->next;
     }
@@ -7306,8 +7293,11 @@
 	    ls = ainfo->csl;
 	}
 	if (lc) {
+	    if (!ps)
+		ps = "";
 	    if (lp) {
 		if (ls) {
+		    DPUTS(!ainfo->firstm, "BUG: merge without firtsm");
 		    if (ainfo->firstm->psuf)
 			merge_cline(lc, ps, lp,
 				    dyncat(ainfo->firstm->str,
@@ -7329,11 +7319,13 @@
 		ocs += l;
 		cs = ocs;
 	    }
-	    if(ainfo->suflen && !atend)
+	    if(ainfo->suflen && !atend) {
+		DPUTS(!ainfo->firstm, "BUG: suffix without firstm");
 		inststrlen(ainfo->firstm->str +
 			   strlen(ainfo->firstm->str) - ainfo->suflen, 1,
 			   ainfo->suflen);
-	    if (ainfo->firstm->psuf)
+	    }
+	    if (ainfo->firstm && ainfo->firstm->psuf)
 		inststrlen(ainfo->firstm->psuf, 0, -1);
 	    if (brend && *brend) {
 		cs -= brsl;
@@ -7484,13 +7476,11 @@
 		    sprintf(p, "%s%s%s", m->ripre, str, psuf);
 		    if (pl && p[pl-1] == Inbrace)
 			strcpy(p+pl-1, p+pl);
-		}
-		else if (ic) {
+		} else if (ic) {
 		    p = (char *) ncalloc(strlen(ppre) + strlen(str) +
 					 strlen(psuf) + 2);
 		    sprintf(p, "%c%s%s%s", ic, ppre, str, psuf);
-		}
-		else {
+		} else {
 		    p = (char *) ncalloc(strlen(ppre) + strlen(str) +
 					 strlen(psuf) + 1);
 		    sprintf(p, "%s%s%s", ppre, str, psuf);
@@ -7744,8 +7734,7 @@
 		    pp++;
 		}
 		nlines--;
-	    }
-	    else {
+	    } else {
 		while (*pp) {
 		    if ((l = strlen(*pp)) > longest)
 			longest = l;
@@ -7753,8 +7742,7 @@
 		    pp++;
 		}
 	    }
-	}
-	else {
+	} else {
 	    for (p = g->matches; (m = *p); p++) {
 		if (!(m->flags & CMF_NOLIST)) {
 		    if ((l = niceztrlen(m->str)) > longest)
@@ -7851,8 +7839,7 @@
 		    if (*++pp)
 			putc('\n', shout);
 		}
-	    }
-	    else {
+	    } else {
 		int n = g->lcount, nl = (n + ncols - 1) / ncols, nc = nl, i, a;
 		char **pq;
 
@@ -7876,8 +7863,7 @@
 		    pp++;
 		}
 	    }
-	}
-	else if (g->lcount) {
+	} else if (g->lcount) {
 	    int n = g->lcount, nl = (n + ncols - 1) / ncols, nc = nl, i, j, a = 0;
 	    Cmatch *q;
 
@@ -7938,8 +7924,7 @@
 	    showinglist = -1;
 	} else
 	    clearflag = 0, putc('\n', shout);
-    }
-    else
+    } else
 	putc('\n', shout);
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

