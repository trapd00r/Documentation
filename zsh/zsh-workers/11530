From zsh-workers-return-11530-mason-zsh=primenet.com.au@sunsite.auc.dk Tue May 23 13:17:16 2000
Return-Path: <zsh-workers-return-11530-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16428 invoked from network); 23 May 2000 13:17:14 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 May 2000 13:17:14 -0000
Received: (qmail 16135 invoked by alias); 23 May 2000 13:17:05 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11530
Received: (qmail 16090 invoked from network); 23 May 2000 13:17:04 -0000
Date: Tue, 23 May 2000 15:15:13 +0200 (MET DST)
Message-Id: <200005231315.PAA24546@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Mon, 22 May 2000 10:37:00 +0200
	(MET DST)
Subject: Re: PATCH: Re: _netscape


I wrote:

> Oliver Kiddle wrote:
> 
> > ...
> > 
> > Basically, what a helper function needs to do is
> > take the suffix passed to it and when it is completing a final component
> > of itself, it should pass any suffix it wants with the one passed to it
> > appended. Pulling out -S options from "$@" is going to look messy
> > without some special handling at a lower level somewhere.
> 
> It's mostly a bit of [(i)...] stuff, but yes, it's probably common
> enough... One idea would be to add an option to zparseopts to allow it 
> to extract options. Actually, I've been wishing for something like
> that, too.

This is so simple to write that I think it's worth adding. So, this
adds the -E option to zparseopts that can be used to extract options
from the positional parameters. When combined with -D, the options
described are actually removed from $*.

Bye
 Sven

Index: Doc/Zsh/mod_zutil.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_zutil.yo,v
retrieving revision 1.6
diff -u -r1.6 mod_zutil.yo
--- Doc/Zsh/mod_zutil.yo	2000/05/22 09:32:33	1.6
+++ Doc/Zsh/mod_zutil.yo	2000/05/23 13:14:08
@@ -131,7 +131,7 @@
 This implements the internals of the `tt(_regex_arguments)'.
 )
 findex(zparseopts)
-item(tt(zparseopts) [ tt(-D) ] [ tt(-a) var(array) ] [ tt(-A) var(assoc) ] var(specs))(
+item(tt(zparseopts) [ tt(-D) ] [ tt(-E) ] [ tt(-a) var(array) ] [ tt(-A) var(assoc) ] var(specs))(
 This builtin simplifies the parsing of options in positional
 parameters, i.e. the set of arguments given by tt($*).  Each var(spec)
 describes one option and should be of the form
@@ -166,6 +166,9 @@
 positional parameters, up to but not including any not described by the
 var(specs).  This means that any options processed by tt(zparseopts) are
 removed from the positional parameters.
+
+The tt(-E) option allows to extract the options described by the
+var(specs) from the positional parameters, ignoring all other strings.
 
 For example,
 
Index: Src/Modules/zutil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/zutil.c,v
retrieving revision 1.4
diff -u -r1.4 zutil.c
--- Src/Modules/zutil.c	2000/05/22 09:32:33	1.4
+++ Src/Modules/zutil.c	2000/05/23 13:14:09
@@ -1261,8 +1261,8 @@
 static int
 bin_zparseopts(char *nam, char **args, char *ops, int func)
 {
-    char *o, *p, *n, **pp, **aval, **ap, *assoc = NULL;
-    int del = 0, f;
+    char *o, *p, *n, **pp, **aval, **ap, *assoc = NULL, **cp, **np;
+    int del = 0, f, extract = 0;
     Zoptdesc sopts[256], d;
     Zoptarr a, defarr = NULL;
     Zoptval v;
@@ -1290,6 +1290,14 @@
 		}
 		del = 1;
 		break;
+	    case 'E':
+		if (o[2]) {
+		    args--;
+		    o = NULL;
+		    break;
+		}
+		extract = 1;
+		break;
 	    case 'a':
 		if (defarr) {
 		    zwarnnam(nam, "default array given more than once", NULL, 0);
@@ -1400,10 +1408,19 @@
 	if (!o[1])
 	    sopts[STOUC(*o)] = d;
     }
-    for (pp = pparams; (o = *pp); pp++) {
-	if (*o != '-')
-	    break;
+    np = cp = pp = ((extract && del) ? arrdup(pparams) : pparams);
+    for (; (o = *pp); pp++) {
+	if (*o != '-') {
+	    if (extract) {
+		if (del)
+		    *cp++ = o;
+		continue;
+	    } else
+		break;
+	}
 	if (!o[1] || (o[1] == '-' && !o[2])) {
+	    if (del && extract)
+		*cp++ = o;
 	    pp++;
 	    break;
 	}
@@ -1429,8 +1446,14 @@
 		} else
 		    add_opt_val(d, NULL);
 	    }
-	    if (!o)
-		break;
+	    if (!o) {
+		if (extract) {
+		    if (del)
+			*cp++ = *pp;
+		    continue;
+		} else
+		    break;
+	    }
 	} else {
 	    if (d->flags & ZOF_ARG) {
 		char *e = o + strlen(d->name) + 1;
@@ -1450,6 +1473,10 @@
 		add_opt_val(d, NULL);
 	}
     }
+    if (extract && del)
+	while (*pp)
+	    *cp++ = *pp++;
+
     for (a = opt_arrs; a; a = a->next) {
 	aval = (char **) zalloc((a->num + 1) * sizeof(char *));
 	for (ap = aval, v = a->vals; v; ap++, v = v->next) {
@@ -1498,9 +1525,15 @@
 	sethparam(assoc, aval);
     }
     if (del) {
-	pp = zarrdup(pp);
-	freearray(pparams);
-	pparams = pp;
+	if (extract) {
+	    *cp = NULL;
+	    freearray(pparams);
+	    pparams = zarrdup(np);
+	} else {
+	    pp = zarrdup(pp);
+	    freearray(pparams);
+	    pparams = pp;
+	}
     }
     return 0;
 }

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

