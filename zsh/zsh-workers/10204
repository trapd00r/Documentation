From zsh-workers-return-10204-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 23 08:14:24 2000
Return-Path: <zsh-workers-return-10204-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9765 invoked from network); 23 Mar 2000 08:14:19 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Mar 2000 08:14:19 -0000
Received: (qmail 23530 invoked by alias); 23 Mar 2000 08:13:54 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10204
Received: (qmail 23517 invoked from network); 23 Mar 2000 08:13:53 -0000
Date: Thu, 23 Mar 2000 09:13:52 +0100 (MET)
Message-Id: <200003230813.JAA23072@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Wed, 22 Mar 2000 15:36:57 +0100
	(MET)
Subject: Re: PATCH: tag aliases


Two more fixes...

- The execution of action in _arguments and friends wasn't completely
  correct. I used _loop in places where I shouldn't, so that the $expl
  got inserted, irritating at least one of the functions called.
- comptags has to be able to keep track of more than one set of tags
  currently being handled. For that it uses locallevel (function
  nesting level), which means that calls to comptags that belong
  together have to be at the same level in the function call chain.
  This was messed up in the case of _wanted.

And then there is a bit of optimisation in _loop (avoiding to copy
arrays).


Bye
 Sven

diff -ru ../z.old/Completion/Base/_arguments Completion/Base/_arguments
--- ../z.old/Completion/Base/_arguments	Wed Mar 22 15:36:33 2000
+++ Completion/Base/_arguments	Thu Mar 23 09:07:10 2000
@@ -236,14 +236,17 @@
 
             # A string in braces is evaluated.
 
-            _loop arguments expl "$descr" eval "$action[2,-2]"
-
+            while _try arguments expl "$descr"; do
+              eval "$action[2,-2]"
+            done
           elif [[ "$action" = \ * ]]; then
 
             # If the action starts with a space, we just call it.
 
 	    eval "action=( $action )"
-            _loop arguments expl "$descr" "$action[@]"
+            while _try arguments expl "$descr"; do
+              "$action[@]"
+            done
           else
 
             # Otherwise we call it with the description-arguments.
diff -ru ../z.old/Completion/Base/_values Completion/Base/_values
--- ../z.old/Completion/Base/_values	Wed Mar 22 15:36:34 2000
+++ Completion/Base/_values	Thu Mar 23 09:07:11 2000
@@ -124,14 +124,17 @@
 
       # A string in braces is evaluated.
 
-      _loop arguments expl "$descr" eval "$action[2,-2]"
-
+      while _try arguments expl "$descr"; do
+        eval "$action[2,-2]"
+      done
     elif [[ "$action" = \ * ]]; then
 
       # If the action starts with a space, we just call it.
 
       eval "action=( $action )"
-      _loop arguments expl "$descr" "$action[@]"
+      while _try arguments expl "$descr"; do
+        "$action[@]"
+      done
     else
 
       # Otherwise we call it with the description-arguments built above.
diff -ru ../z.old/Completion/Core/_alternative Completion/Core/_alternative
--- ../z.old/Completion/Core/_alternative	Wed Mar 22 15:36:40 2000
+++ Completion/Core/_alternative	Thu Mar 23 09:07:11 2000
@@ -50,13 +50,17 @@
 
         # A string in braces is evaluated.
 
-        _loop "${def%%:*}" expl "$descr" eval "$action[2,-2]"
+        while _try "${def%%:*}" expl "$descr"; do
+          eval "$action[2,-2]"
+        done
       elif [[ "$action" = \ * ]]; then
 
         # If the action starts with a space, we just call it.
 
         eval "action=( $action )"
-        _loop "${def%%:*}" expl "$descr" "$action[@]"
+        while _try "${def%%:*}" expl "$descr"; do
+          "$action[@]"
+        done
       else
 
         # Otherwise we call it with the description-arguments built above.
diff -ru ../z.old/Completion/Core/_loop Completion/Core/_loop
--- ../z.old/Completion/Core/_loop	Wed Mar 22 15:36:42 2000
+++ Completion/Core/_loop	Thu Mar 23 09:07:11 2000
@@ -1,6 +1,6 @@
 #autoload
 
-local gopt=-J tmp pre suf tloop ret=1 descr
+local gopt=-J len tmp pre suf tloop ret=1 descr
 
 if [[ "$1" = -t ]]; then
   tloop=yes
@@ -12,15 +12,16 @@
 fi
 
 tmp=${argv[(ib:4:)-]}
-if [[ tmp -lt $# ]]; then
-  pre=( "${(@)argv[4,tmp-1]}" )
-  suf=( "${(@)argv[tmp,-1]}" )
+len=$#
+if [[ tmp -lt len ]]; then
+  pre=$(( tmp-1 ))
+  suf=$tmp
 elif [[ tmp -eq $# ]]; then
-  pre=( "${(@)argv[4,-2]}" )
-  suf=()
+  pre=-2
+  suf=$(( len+1 ))
 else
-  pre=( "$4" )
-  suf=( "${(@)argv[5,-1]}" )
+  pre=4
+  suf=5
 fi
 
 while [[ -z "$tloop" ]] || comptags -N; do
@@ -34,7 +35,7 @@
     else
       _description "$gopt" "$curtag" "$2" "$3"
 
-      "$pre[@]" "${(P@)2}" "$suf[@]" && ret=0
+      "${(@)argv[4,pre]}" "${(P@)2}" "${(@)argv[suf,-1]}" && ret=0
     fi
   done
   [[ -z "$tloop" || ret -eq 0 ]] && break
diff -ru ../z.old/Completion/Core/_tags Completion/Core/_tags
--- ../z.old/Completion/Core/_tags	Wed Mar 22 15:36:41 2000
+++ Completion/Core/_tags	Thu Mar 23 09:07:11 2000
@@ -1,5 +1,17 @@
 #autoload
 
+local prev
+
+# A `--' as the first argument says that we should tell comptags to use
+# the preceding function nesting level. This is only documented here because
+# if everythings goes well, users won't have to worry about it and should
+# not mess with it.
+
+if [[ "$1" = -- ]]; then
+  prev=-
+  shift
+fi
+
 if (( $# )); then
 
   # We have arguments: the tags supported in this context.
@@ -33,7 +45,7 @@
 
   # Set and remember offered tags.
 
-  comptags -i "$curcontext" "$@"
+  comptags "-i$prev" "$curcontext" "$@"
 
   # Sort the tags.
 
@@ -80,11 +92,11 @@
 
   # Return non-zero if at least one set of tags should be used.
 
-  comptags -T
+  comptags "-T$prev"
 
   return
 fi
 
 # The other mode: switch to the next set of tags.
 
-comptags -N
+comptags "-N$prev"
diff -ru ../z.old/Completion/Core/_wanted Completion/Core/_wanted
--- ../z.old/Completion/Core/_wanted	Wed Mar 22 15:36:42 2000
+++ Completion/Core/_wanted	Thu Mar 23 09:07:11 2000
@@ -26,8 +26,8 @@
     return 1
   fi
 elif [[ $# -gt 1 ]]; then
-  _tags "$targs[@]" "$1" && _comp_tags="$_comp_tags $1" &&
+  _tags -- "$targs[@]" "$1" && _comp_tags="$_comp_tags $1" &&
     _description "$gopt" "$@"
 else
-  _tags "$targs[@]" "$1" && _comp_tags="$_comp_tags $1"
+  _tags -- "$targs[@]" "$1" && _comp_tags="$_comp_tags $1"
 fi
diff -ru ../z.old/Src/Zle/computil.c Src/Zle/computil.c
--- ../z.old/Src/Zle/computil.c	Wed Mar 22 15:36:15 2000
+++ Src/Zle/computil.c	Thu Mar 23 09:07:12 2000
@@ -2225,14 +2225,14 @@
 /* Set the tags for the current local level. */
 
 static void
-settags(char **tags)
+settags(int level, char **tags)
 {
     Ctags t;
 
-    if (comptags[locallevel])
-	freectags(comptags[locallevel]);
+    if (comptags[level])
+	freectags(comptags[level]);
 
-    comptags[locallevel] = t = (Ctags) zalloc(sizeof(*t));
+    comptags[level] = t = (Ctags) zalloc(sizeof(*t));
 
     t->all = zarrdup(tags + 1);
     t->context = ztrdup(*tags);
@@ -2263,22 +2263,23 @@
 static int
 bin_comptags(char *nam, char **args, char *ops, int func)
 {
-    int min, max, n;
+    int min, max, n, level;
 
     if (incompfunc != 1) {
 	zwarnnam(nam, "can only be called from completion function", NULL, 0);
 	return 1;
     }
-    if (args[0][0] != '-' || !args[0][1] || args[0][2]) {
+    if (args[0][0] != '-' || !args[0][1] ||
+	(args[0][2] && (args[0][2] != '-' || args[0][3]))) {
 	zwarnnam(nam, "invalid argument: %s", args[0], 0);
 	return 1;
     }
-    if (locallevel >= MAX_TAGS) {
+    level = locallevel - (args[0][2] ? 1 : 0);
+    if (level >= MAX_TAGS) {
 	zwarnnam(nam, "nesting level too deep", NULL, 0);
 	return 1;
     }
-    if ((args[0][1] != 'i' && args[0][1] != 'A' && !comptags[locallevel]) ||
-	(args[0][1] == 'A' && !comptags[lasttaglevel])) {
+    if (args[0][1] != 'i' && args[0][1] != 'I' && !comptags[level]) {
 	zwarnnam(nam, "no tags registered", NULL, 0);
 	return 1;
     }
@@ -2304,39 +2305,39 @@
     }
     switch (args[0][1]) {
     case 'i':
-	settags(args + 1);
-	lasttaglevel = locallevel;
+	settags(level, args + 1);
+	lasttaglevel = level;
 	break;
     case 'C':
-	setsparam(args[1], ztrdup(comptags[locallevel]->context));
+	setsparam(args[1], ztrdup(comptags[level]->context));
 	break;
     case 'T':
-	return !comptags[locallevel]->sets;
+	return !comptags[level]->sets;
     case 'N':
 	{
 	    Ctset s;
 
-	    if (comptags[locallevel]->init)
-		comptags[locallevel]->init = 0;
-	    else if ((s = comptags[locallevel]->sets)) {
-		comptags[locallevel]->sets = s->next;
+	    if (comptags[level]->init)
+		comptags[level]->init = 0;
+	    else if ((s = comptags[level]->sets)) {
+		comptags[level]->sets = s->next;
 		s->next = NULL;
 		freectset(s);
 	    }
-	    return !comptags[locallevel]->sets;
+	    return !comptags[level]->sets;
 	}
     case 'R':
 	{
 	    Ctset s;
 
-	    return !((s = comptags[locallevel]->sets) &&
+	    return !((s = comptags[level]->sets) &&
 		     arrcontains(s->tags, args[1], 1));
 	}
     case 'A':
 	{
 	    Ctset s;
 
-	    if (comptags[lasttaglevel] && (s = comptags[lasttaglevel]->sets)) {
+	    if (comptags[level] && (s = comptags[level]->sets)) {
 		char **q, *v = NULL;
 		int l = strlen(args[1]);
 
@@ -2368,10 +2369,10 @@
 	    return 1;
 	}
     case 'S':
-	if (comptags[locallevel]->sets) {
+	if (comptags[level]->sets) {
 	    char **ret;
 
-	    ret = zarrdup(comptags[locallevel]->sets->tags);
+	    ret = zarrdup(comptags[level]->sets->tags);
 	    setaparam(args[1], ret);
 	} else
 	    return 1;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

