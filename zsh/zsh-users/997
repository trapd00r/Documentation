From zsh-workers-request@math.gatech.edu Wed Sep 03 04:45:48 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 20888 invoked from network); 3 Sep 1997 04:45:45 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 3 Sep 1997 04:45:45 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id AAA26429;
	Wed, 3 Sep 1997 00:40:44 -0400 (EDT)
Resent-Date: Wed, 3 Sep 1997 00:40:18 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@frontiernet.net>
Message-Id: <199709030440.AAA01426@hzoli.home>
Subject: Re: zsh always resets LINES to 24.
In-Reply-To: <19970902225543.21124@supernova.math.lsa.umich.edu> from Jahwan Kim at "Sep 2, 97 10:55:43 pm"
To: jahwan@math.lsa.umich.edu (Jahwan Kim)
Date: Wed, 3 Sep 1997 00:40:18 -0400 (EDT)
Cc: zsh-users@math.gatech.edu
X-Mailer: ELM [version 2.4ME+ PL31 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"P1K0M1.0.JS6.neE3q"@math>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/997
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

> Hi all,
>     Maybe my post didn't propagated well...

Well, that's the first time I read it.

>     
>     My environment is 31x80 vt-100 (pseudo-)emulator, OSTYPE=solaris2.5.1, and
> TERM=vt100.  Of course, the terminfo entry of vt100 specifies that it
> has 24 lines.  So in my .zshrc, I detect where I login from, and reset LINES
> if I login from home:  export LINES=31.
>     Then at the very first prompt, echo $LINES gives me 24.

Zsh sets LINES and columns to the value obtained from the TIOCGWINSZ
ioctl.  This way, when you resize you xterm, the LINES parameter will
change too.  Normally, when you resize your window, xterm sends SIGWINCH
to the process group of its terminal.  Zsh catches this signal, and
adjusts the window size.  So far so good, you do not resize you terminal,
so zsh does not get SIGWINCH, LINES should not change.  Unfortunately,
it's not that simple.  When zsh runs interactively, the MONITOR option is
enabled to allow you to use fg, bg, ^Z etc.  But this means that when you
start a foreground process, it will run in a separate process group from
zsh, and the terminal's process group is set to the foreground job's
process group.  As a consequence, zsh cannot handle the SIGWINCH signals
xterm sends when you resize the window, so when a foreground process
terminates, zsh goes and asks the terminal for its size.  If the terminal
says that it has 24 lines, zsh just assumes that it was resized, and
sets LINES to 24 even if you had set it to 31 before.

This really means that assigning LINES does not make too much sense.  It
is usefull only on systems which do not have TIOCGWINSZ.

The patch below is an attempt to cure this.  When you manually set
LINES or COLUMNS to something which is different from the last value
returned by TIOCGWINSZ, zsh will not touch it unless it receives a real
SIGWINCH signal.  I hope this helps.  If anyone has a better solution,
please tell me.

Zoltan


*** Src/init.c	1997/07/13 05:24:42	3.1.3.1
--- Src/init.c	1997/09/03 04:28:04
***************
*** 523,533 ****
      createparamtable();     /* create paramater hash table             */
  
  #ifdef TIOCGWINSZ
!     adjustwinsize();
  #else
!     /* Using zero below sets the defaults from termcap */
!     setiparam("COLUMNS", 0);
!     setiparam("LINES", 0);
  #endif
  
  #ifdef HAVE_GETRLIMIT
--- 523,535 ----
      createparamtable();     /* create paramater hash table             */
  
  #ifdef TIOCGWINSZ
!     adjustwinsize(0);
  #else
!     /* columns and lines are normally zero, unless something different *
!      * was inhereted from the environment.  If either of them are zero *
!      * the setiparam calls below set them to the defaults from termcap */
!     setiparam("COLUMNS", columns);
!     setiparam("LINES", lines);
  #endif
  
  #ifdef HAVE_GETRLIMIT
*** Src/jobs.c	1997/06/30 04:48:17	3.1.3.6
--- Src/jobs.c	1997/09/03 03:58:04
***************
*** 167,173 ****
  	if (mypgrp != pgrp && inforeground &&
  	    (jn->gleader == pgrp || (pgrp > 1 && kill(-pgrp, 0) == -1))) {
  	    attachtty(mypgrp);
! 	    adjustwinsize();   /* check window size and adjust if necessary */
  	}
      }
  
--- 167,173 ----
  	if (mypgrp != pgrp && inforeground &&
  	    (jn->gleader == pgrp || (pgrp > 1 && kill(-pgrp, 0) == -1))) {
  	    attachtty(mypgrp);
! 	    adjustwinsize(0);   /* check window size and adjust if necessary */
  	}
      }
  
*** Src/signals.c	1997/06/05 04:44:57	3.1.3.0
--- Src/signals.c	1997/09/03 03:58:10
***************
*** 489,495 ****
  
  #ifdef SIGWINCH
      case SIGWINCH:
!         adjustwinsize();  /* check window size and adjust */
  	if (sigtrapped[SIGWINCH])
  	    dotrap(SIGWINCH);
          break;
--- 489,495 ----
  
  #ifdef SIGWINCH
      case SIGWINCH:
!         adjustwinsize(1);  /* check window size and adjust */
  	if (sigtrapped[SIGWINCH])
  	    dotrap(SIGWINCH);
          break;
*** Src/utils.c	1997/08/02 20:00:18	3.1.3.3
--- Src/utils.c	1997/09/03 04:33:09
***************
*** 790,810 ****
  
  /**/
  void
! adjustwinsize(void)
  {
  #ifdef TIOCGWINSZ
!     int oldcols = columns, oldrows = lines;
  
!     if (SHTTY == -1)
  	return;
  
      ioctl(SHTTY, TIOCGWINSZ, (char *)&shttyinfo.winsize);
      setiparam("COLUMNS", shttyinfo.winsize.ws_col);
      setiparam("LINES", shttyinfo.winsize.ws_row);
!     if (zleactive && (oldcols != columns || oldrows != lines)) {
  	resetneeded = winchanged = 1;
  	refresh();
      }
  #endif   /* TIOCGWINSZ */
  }
  
--- 790,812 ----
  
  /**/
  void
! adjustwinsize(int fromsig)
  {
  #ifdef TIOCGWINSZ
!     static int oldcols, oldrows;
  
!     if (SHTTY == -1 || (!fromsig && (columns != oldcols || lines != oldrows)))
  	return;
  
      ioctl(SHTTY, TIOCGWINSZ, (char *)&shttyinfo.winsize);
      setiparam("COLUMNS", shttyinfo.winsize.ws_col);
      setiparam("LINES", shttyinfo.winsize.ws_row);
!     if (zleactive && (fromsig || oldcols != columns || oldrows != lines)) {
  	resetneeded = winchanged = 1;
  	refresh();
      }
+     oldcols = columns;
+     oldrows = lines;
  #endif   /* TIOCGWINSZ */
  }
  

