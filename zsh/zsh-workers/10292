From zsh-workers-return-10292-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Mar 28 08:08:37 2000
Return-Path: <zsh-workers-return-10292-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27037 invoked from network); 28 Mar 2000 08:08:30 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 28 Mar 2000 08:08:30 -0000
Received: (qmail 5354 invoked by alias); 28 Mar 2000 08:08:22 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10292
Received: (qmail 5341 invoked from network); 28 Mar 2000 08:08:21 -0000
Date: Tue, 28 Mar 2000 10:08:14 +0200 (MET DST)
Message-Id: <200003280808.KAA09896@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Fri, 24 Mar 2000 17:48:11 +0000
Subject: PATCH: completer style (was: Re: PATCH: tag aliases)


Bart Schaefer wrote:

> ...
> 
> } And finally: Bart and I had this bit of discussion about changing the
> } completer field to always contain the `-<num>' suffix. And we didn't
> } like it. [...] We could make the completer style allow an alias-syntax
> } like the one from tag-order, too.
> } 
> }   zstyle ':completion:*' completer complete ... complete:foo
> } 
> } The first invocation of _complete would use the usual
> } `...:complete:...' in the context name but the second one would use
> } `...:foo:...' in the completer field.
> 
> This would best be combined with the change you posted in 10231 so
> that it became
> 
>     zstyle ':completion:*' completer complete ... complete:-foo
> 
> so the second call to _complete would use "...:complete-foo:...".

Here's the patch for it.

This means that it was possible to remove the special casing in the
completer field of the context for the matcher-list style and the
_prefix and _ignored completers. So, one may now do things like:

  zstyle ':completion:*' completer _complete _correct _complete:-foo
  zstyle ':completion:*:*:complete-foo:*' matcher-list 'm:{a-z}={A-Z}'

to get first normal completion without a match spec, then correction
and then case insensitive completion. Probably a silly example, but I
hope you get my meaning.


For writers of completers (the real, top-level completers), this patch 
also means that they don't have to set up the completer field of
$curcontext. This is done automatically in _main_complete before the
completer is called. Removing that from the existing completers is
responsible for the greatest part of the patch, the stuff in
_main_complete is quite small (and simple).

The patch also contains a little patch for _path_files when used with
expand=prefix and it removes two unused arrays from _main_complete.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_approximate Completion/Core/_approximate
--- ../z.old/Completion/Core/_approximate	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_approximate	Tue Mar 28 09:59:38 2000
@@ -11,12 +11,7 @@
 [[ _matcher_num -gt 1 || "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1
 
 local _comp_correct _correct_expl comax cfgacc
-local curcontext="${curcontext}" oldcontext opm="$compstate[pattern_match]"
-
-[[ "$curcontext" != [^:]#:correct:* ]] &&
-    curcontext="${curcontext/:[^:]#:/:approximate:}"
-
-oldcontext="$curcontext"
+local oldcontext="${curcontext}" opm="$compstate[pattern_match]"
 
 zstyle -s ":completion:${curcontext}:" max-errors cfgacc || cfgacc='2 numeric'
 
diff -ru ../z.old/Completion/Core/_complete Completion/Core/_complete
--- ../z.old/Completion/Core/_complete	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_complete	Tue Mar 28 09:59:38 2000
@@ -7,8 +7,6 @@
 local comp name oldcontext
 typeset -T curcontext="$curcontext" ccarray
 
-ccarray[2]=complete
-
 oldcontext="$curcontext"
 
 # If we have a user-supplied context name, use only that.
diff -ru ../z.old/Completion/Core/_correct Completion/Core/_correct
--- ../z.old/Completion/Core/_correct	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_correct	Tue Mar 28 09:59:39 2000
@@ -9,7 +9,6 @@
 # starting with `correct'.
 
 local ret=1 opm="$compstate[pattern_match]"
-local curcontext="${curcontext/:[^:]#:/:correct:}"
 
 compstate[pattern_match]='-'
 
diff -ru ../z.old/Completion/Core/_expand Completion/Core/_expand
--- ../z.old/Completion/Core/_expand	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_expand	Tue Mar 28 09:59:39 2000
@@ -12,7 +12,6 @@
 [[ _matcher_num -gt 1 ]] && return 1
 
 local exp word="$PREFIX$SUFFIX" sort expr expl subd suf=" "
-local curcontext="${curcontext/:[^:]#:/:expand:}"
 
 # First, see if we should insert all *completions*.
 
diff -ru ../z.old/Completion/Core/_ignored Completion/Core/_ignored
--- ../z.old/Completion/Core/_ignored	Mon Mar 27 16:35:06 2000
+++ Completion/Core/_ignored	Tue Mar 28 09:59:39 2000
@@ -4,11 +4,10 @@
 
 (( $compstate[ignored] )) || return 1
 
-local curcontext="${curcontext/:[^:]#:/:ignored-${(M)#_completers[1,_completer_num]:#_ignored}:}"
 local comp i _comp_no_ignore=yes tmp expl
 
 zstyle -a ":completion:${curcontext}:" completer comp ||
-  comp=( "${(@)_completers[1,_completer_num-1][(R)_ignored,-1]}" )
+  comp=( "${(@)_completers[1,_completer_num-1][(R)_ignored(|:*),-1]}" )
 
 for i in "$comp[@]"; do
   if [[ "$i" != _ignored ]] && "$i"; then
diff -ru ../z.old/Completion/Core/_list Completion/Core/_list
--- ../z.old/Completion/Core/_list	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_list	Tue Mar 28 09:59:39 2000
@@ -6,7 +6,7 @@
 
 [[ _matcher_num -gt 1 ]] && return 1
 
-local pre suf expr curcontext="${curcontext/:[^:]#:/:list:}"
+local pre suf expr
 
 # Get the strings to compare.
 
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_main_complete	Tue Mar 28 09:59:39 2000
@@ -31,9 +31,6 @@
 
 typeset -U _lastdescr
 
-_comp_opts=()
-_comp_tries=()
-
 [[ -z "$curcontext" ]] && curcontext=:::
 
 # Special completion contexts after `~' and `='.
@@ -77,14 +74,25 @@
   "$func"
 done
 
-for _completer; do
+for tmp; do
+
+  if [[ "$tmp" = *:-* ]]; then
+    _completer="${${tmp%:*}[2,-1]//_/-}${tmp#*:}"
+    tmp="${tmp%:*}"
+  elif [[ $tmp = *:* ]]; then
+    _completer="${tmp#*:}"
+    tmp="${tmp%:*}"
+  else
+    _completer="${tmp[2,-1]//_/-}"
+  fi
+  curcontext="${curcontext/:[^:]#:/:${_completer}:}"
 
-  zstyle -a ":completion:${curcontext/::/:${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}:}:" matcher-list _matchers ||
+  zstyle -a ":completion:${curcontext}:" matcher-list _matchers ||
       _matchers=( '' )
 
   _matcher_num=1
   for _matcher in "$_matchers[@]"; do
-    if "$_completer"; then
+    if "$tmp"; then
       ret=0
       break 2
     fi
@@ -93,8 +101,7 @@
   (( _completer_num++ ))
 done
 
-if [[ -n "$tmp" || $compstate[old_list] = keep ||
-      $compstate[nmatches] -gt 1 ]]; then
+if [[ $compstate[old_list] = keep || $compstate[nmatches] -gt 1 ]]; then
   [[ _last_nmatches -ge 0 && _last_nmatches -ne $compstate[nmatches] ]] &&
       _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
diff -ru ../z.old/Completion/Core/_match Completion/Core/_match
--- ../z.old/Completion/Core/_match	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_match	Tue Mar 28 09:59:39 2000
@@ -12,7 +12,6 @@
 [[ _matcher_num -gt 1 ]] && return 1
 
 local tmp opm="$compstate[pattern_match]" ret=0 orig ins
-local curcontext="${curcontext/:[^:]#:/:match:}"
 
 # Do nothing if we don't have a pattern.
 
diff -ru ../z.old/Completion/Core/_menu Completion/Core/_menu
--- ../z.old/Completion/Core/_menu	Mon Mar 27 16:35:04 2000
+++ Completion/Core/_menu	Tue Mar 28 09:59:40 2000
@@ -2,8 +2,6 @@
 
 [[ _matcher_num -gt 1 ]] && return 1
 
-local curcontext="${curcontext/:[^:]#:/:menu:}"
-
 # This completer is an example showing how menucompletion can be
 # implemented with the new completion system.
 # Use this one before the normal _complete completer, as in:
diff -ru ../z.old/Completion/Core/_oldlist Completion/Core/_oldlist
--- ../z.old/Completion/Core/_oldlist	Mon Mar 27 16:35:05 2000
+++ Completion/Core/_oldlist	Tue Mar 28 09:59:40 2000
@@ -2,7 +2,7 @@
 
 [[ _matcher_num -gt 1 ]] && return 1
 
-local curcontext="${curcontext/:[^:]#:/:oldlist:}" list
+local list
 
 zstyle -s ":completion:${curcontext}:" old-list list
 
diff -ru ../z.old/Completion/Core/_path_files Completion/Core/_path_files
--- ../z.old/Completion/Core/_path_files	Mon Mar 27 16:35:05 2000
+++ Completion/Core/_path_files	Tue Mar 28 09:59:40 2000
@@ -530,8 +530,6 @@
 if zstyle -t ":completion:${curcontext}:paths" expand prefix &&
    [[ nm -eq compstate[nmatches] ]]; then
 
-  exppaths=( "${(@)exppaths:#$eorig}" )
-
   if (( $#exppaths )); then
     PREFIX="${opre}"
     SUFFIX="${osuf}"
diff -ru ../z.old/Completion/Core/_prefix Completion/Core/_prefix
--- ../z.old/Completion/Core/_prefix	Mon Mar 27 16:35:06 2000
+++ Completion/Core/_prefix	Tue Mar 28 09:59:40 2000
@@ -4,10 +4,10 @@
 
 [[ -n "$SUFFIX" ]] || return 1
 
-local curcontext="${curcontext/:[^:]#:/:prefix-${(M)#_completers[1,_completer_num]:#_prefix}:}" comp i
+local comp i
 
 zstyle -a ":completion:${curcontext}:" completer comp ||
-  comp=( "${(@)_completers[1,_completer_num-1][(R)_prefix,-1]}" )
+  comp=( "${(@)_completers[1,_completer_num-1][(R)_prefix(|:*),-1]}" )
 
 if zstyle -t ":completion:${curcontext}:" add-space; then
   ISUFFIX=" $SUFFIX"
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Mon Mar 27 16:34:42 2000
+++ Doc/Zsh/compsys.yo	Tue Mar 28 09:59:43 2000
@@ -806,6 +806,28 @@
 ifnzman(noderef(Control Functions))\
 .
 
+Each string may be the name of a completer function or a string of the 
+form `var(function)tt(:)var(name)'. In the first case the
+var(completer) field of the context will contain the name of the
+completer without the leading underscore and with all other
+underscores replaced with hyphens. In the second case the
+var(function) is the name of the completer to call, but the context
+will contain the var(name) in the var(completer) field of the
+context. If the var(name) starts with a hyphen, the string for the
+context will be build from the name of the completer function as in
+the first case with the var(name) will be appended to it. For example: 
+
+example(zstyle ':completion:*' completer _complete _complete:-foo)
+
+Here, completion will call the tt(_complete) completer twice, once
+using `tt(complete)' and once using `tt(complete-foo)' in the
+var(completer) field of the context. Normally, using the same
+completer more than once makes only sense when used with the
+`var(functions)tt(:)var(name)' form, because otherwise the context
+name will be the same in all calls to the completer (possible
+exception to this rule are the tt(_ignored) and tt(_prefix)
+completers).
+
 Note that the widget functions from the distribution that call the
 completion code (namely, the tt(incremental-complete-word) and the
 tt(predict-on) widgets) set up their top-level context name before
@@ -1235,12 +1257,11 @@
 completer, one would do:
 
 example(zstyle ':completion:*' completer _complete _prefix
-zstyle ':completion:*:complete*:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')
+zstyle ':completion:*:complete:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}')
 
-Note that there is no colon directly after the `tt(complete)'. That's
-because the completion system really uses the name of the completer
-followed by a minus sign and a number in the var(completer) field of
-the context name. This is useful if, for example, one wants to try
+Note that the tt(completer) style allows to give user-defined names to 
+use in the context instead of the name of the completer.
+This is useful if, for example, one wants to try
 normal completion without a match specification and with
 case-insensitive matching first, correction if that doesn't generate
 any matches and partial-word completion if that doesn't yield any
@@ -1248,10 +1269,10 @@
 completer more than once in the tt(completer) style and define different
 match specifications for them, as in:
 
-example(zstyle ':completion:*' completer _complete _correct _complete
-zstyle ':completion:*:complete-1:*' matcher-list \ 
+example(zstyle ':completion:*' completer _complete _correct _complete:foo
+zstyle ':completion:*:complete:*' matcher-list \ 
     '' 'm:{a-zA-Z}={A-Za-z}'
-zstyle ':completion:*:complete-2:*' matcher-list \ 
+zstyle ':completion:*:foo:*' matcher-list \ 
     'm:{a-zA-Z}={A-Za-z} r:|[-_./]=* r:|=*')
 
 Note that in any case an unset style makes the completion code use no
@@ -2017,13 +2038,12 @@
 the tt(_prefix) completer itself. Also, if this completer appears more
 than once in the list of completers only those completers not
 already tried by the last invocation of tt(_prefix) will be
-called. The completer field used to look up styles contains the string 
-`tt(prefix-)var(n)', where `var(n)' is the number of the call to
-tt(_prefix).
+called.
 
 For example, consider this global tt(completer) style:
 
-example(zstyle ':completion:*' completer _complete _prefix _correct _prefix)
+example(zstyle ':completion:*' completer \
+    _complete _prefix _correct _prefix:foo)
 
 This makes the tt(_prefix) completer try normal completion with the
 suffix ignored. If that doesn't generate any matches and neither does
@@ -2033,7 +2053,7 @@
 want it to try only normal completion, you need to call:
 
 example(zstyle ':completion:*' completer _complete ... _prefix
-zstyle ':completion::prefix-1:*' completer _complete)
+zstyle ':completion::prefix:*' completer _complete)
 
 The tt(add-space) style is used, too. If it is set to `true' then
 tt(_prefix) will insert a space between the matches generated (if any) 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

