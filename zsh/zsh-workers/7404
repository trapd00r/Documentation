From zsh-workers-return-7404-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Aug 09 08:43:03 1999
Return-Path: <zsh-workers-return-7404-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18869 invoked from network); 9 Aug 1999 08:43:02 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Aug 1999 08:43:02 -0000
Received: (qmail 15789 invoked by alias); 9 Aug 1999 08:42:52 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7404
Received: (qmail 15782 invoked from network); 9 Aug 1999 08:42:51 -0000
Date: Mon, 9 Aug 1999 10:42:49 +0200 (MET DST)
Message-Id: <199908090842.KAA25290@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Mon, 9 Aug 1999 12:10:14 +0400
Subject: Re: Bug? RE: Un-patch: new pattern matching code


Andrej Borsenkow wrote:

> > Anyone who knows any computer science will probably notice that, while it's
> > pretty much a finite state machine, some states are more finite than
> > others.  In particularly, backtracking on excluded matches, where in
> > (foo~bar)rod the `bar' only has to match the `foo' and the `rod' is
> > irrelevant, need some extra state recording, and I have retained the old
> > trick that eliminates infinite loops and prevents exponential behaviour
> > when failing to match against things like `(f#o#)#' (the version of perl
> > here goes into an infinite loop when given `(f*o*)*', so it isn't trivial).
> > This has meant leaving holes for pointers in the compiled expression, which
> > ought to work (I've tried to make sure everything is aligned to pointer
> > size anyway) but is probably the most dubious part of the proceedings.
> > 
> 
> bor@itsrm2:~%> foo=ab12xy
> bor@itsrm2:~%> print ${foo/[[:digit:]]#}
> abxy
> bor@itsrm2:~%> print ${(S)foo/[[:digit:]]#}
> ab12xy
> bor@itsrm2:~%> print ${foo//[[:digit:]]#}  
> abxy
> bor@itsrm2:~%> print ${(S)foo//[[:digit:]]#}
> here zsh hangs completely.

It was repeatedly matching the empty string, of course. This makes
that be handled as a special case, stepping one character forward even 
if zero characters were matched.
Maybe Peter will have to decide if this is the right thing to do here.

Bye
 Sven

P.S.: At least simple things like ${a#*/}, ${a%/*}, ${a##*/}, and
      ${a%%/*} seem to be circa three times slower than before for me.

--- os/glob.c	Mon Aug  9 10:40:41 1999
+++ Src/glob.c	Mon Aug  9 10:33:49 1999
@@ -1971,8 +1971,11 @@
 				*ptr = sav;
 			    }
 			}
-			if (!--n || (n <= 0 && (fl & SUB_GLOBAL)))
+			if (!--n || (n <= 0 && (fl & SUB_GLOBAL))) {
 			    *sp = get_match_ret(*sp, t-s, mpos-s, fl, replstr);
+			    if (mpos == start)
+				mpos++;
+			}
 			if (!(fl & SUB_GLOBAL)) {
 			    if (n) {
 				/*

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

