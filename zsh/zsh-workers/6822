From zsh-workers-return-6822-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 24 09:55:40 1999
Return-Path: <zsh-workers-return-6822-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16855 invoked from network); 24 Jun 1999 09:55:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Jun 1999 09:55:39 -0000
Received: (qmail 25712 invoked by alias); 24 Jun 1999 09:55:19 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6822
Received: (qmail 25705 invoked from network); 24 Jun 1999 09:55:18 -0000
Date: Thu, 24 Jun 1999 11:55:16 +0200 (MET DST)
Message-Id: <199906240955.LAA31432@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Thu, 24 Jun 1999 10:41:34 +0200
Subject: Re: PATCH: complist doc, and some small problems


Peter Stephenson wrote:

> I still have some problems, which by now are rather minor.
> 
> 1.  Actually, this one isn't minor, but I just discovered it trying to get
>     the others to show up with zsh -f.  Any completion (!) with zsh -f
>     gives a core dump at the top of printfmt() in zle_tricky.c.  It seems
>     the fmt passed is invalid.  Looking back, it seems ilistmatches is
>     calling printfmt with `e' which points to a null string.

Forgot to change the second argument of ilistmatches().

> 2.  I finally tracked down my problems with spaces appearing after a
>     menu item when selection was used.  It happens if you
>     - load new completion
>     - setopt menucomplete
>     - use menu-select, highlight a directory
>     - abort with ^G
>     - hit <TAB> again
>     - the key point is I'm using _oldlist, so that this sets
>       compstate[old_list]=keep to use the existing list.
>     - The list items which aren't directories all have a space after them.

That's the compstate[insert] behaviour I described when I implemented
it. I'm pretty sure I asked if this space should be there or not at
the time, and here seems to be the answer to that question.
So the patch makes the space not be inserted in this case.
Btw. I was thinking about cases where one selects one match from those 
generated and wants to insert only that -- leaving completion. In such 
a case the space is the right thing, so I may enhance the use of the
insert key some day to be able to select both.

>       Also with zsh -g it seems to be beeping all the time.  This seems to
>       be tied to old_list, too, presumably with LISTBEEP taking effect
>       too often.  I've tried this with an old version, and it doesn't
>       seem to be related to my feeping changes, nor the other bug I've
>       just mentioned.

That test at the end of do_ambiguous() is one of the things I started
to dislike long ago...

> 3.  Also, the documentation advertises that undo works to remove a
>     completion.  If this means it's supposed to work invoking undo
>     to remove a completion while menu-select is still active, it doesn't.
>     It works after you've aborted, of course.

Hm, works for me (note: only completions inserted with
accept-and-{menu-complete,hold}).

Bye
 Sven

diff -u os/Zle/complist.c Src/Zle/complist.c
--- os/Zle/complist.c	Thu Jun 24 11:08:17 1999
+++ Src/Zle/complist.c	Thu Jun 24 11:22:47 1999
@@ -623,14 +623,14 @@
 domenuselect(Hookdef dummy, Chdata dat)
 {
     Cmatch **p;
-    Cmgroup amatches = dat->matches, *pg;
+    Cmgroup *pg;
     Thingy cmd;
     Menustack u = NULL;
     int i = 0;
     char *s;
 
     if (getcols(NULL) || (dummy && (!(s = getsparam("SELECTMIN")) ||
-				    dat->num < atoi(s))))
+				    (dat && dat->num < atoi(s)))))
 	return 1;
 
     selectlocalmap(mskeymap);
diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Thu Jun 24 11:08:19 1999
+++ Src/Zle/zle_tricky.c	Thu Jun 24 11:45:09 1999
@@ -7477,7 +7477,8 @@
     if (isset(LISTBEEP))
 	ret = 1;
     if (uselist && (usemenu != 2 || (!showinglist && !oldlist)) &&
-	(!showinglist || (usemenu == 3 && !oldlist)) &&
+	((!showinglist && (!listshown || !oldlist)) ||
+	 (usemenu == 3 && !oldlist)) &&
 	(smatches >= 2 || (compforcelist && *compforcelist)))
 	showinglist = -2;
     return ret;
@@ -7652,7 +7653,7 @@
 	    inststrlen(&(m->autoq), 1, 1);
 	    minfo.insc++;
 	}
-	if (!menucmp) {
+	if (!menucmp && usemenu != 3) {
 	    inststrlen(" ", 1, 1);
 	    minfo.insc++;
 	    if (minfo.we)
@@ -7897,7 +7898,7 @@
 
 /**/
 int
-ilistmatches(Hookdef dummy, Cmgroup amatches)
+ilistmatches(Hookdef dummy, Chdata dat)
 {
     Cmgroup g;
     Cmatch *p, m;
@@ -8150,6 +8151,7 @@
     struct cmgroup dg;
     int vl = validlist, sm = smatches;
     char *oclp = complastprompt;
+    Cmgroup am = amatches;
 
     if (listshown)
 	showagain = 1;
@@ -8159,7 +8161,9 @@
     validlist = 1;
     memset(&dg, 0, sizeof(struct cmgroup));
     dg.ylist = (char **) makearray(l, 1, &(dg.lcount), NULL);
-    ilistmatches(NULL, &dg);
+    amatches = &dg;
+    ilistmatches(NULL, NULL);
+    amatches = am;
 
     validlist = vl;
     smatches = sm;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

