From zsh-workers-return-9618-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Feb 08 11:32:49 2000
Return-Path: <zsh-workers-return-9618-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2085 invoked from network); 8 Feb 2000 11:32:48 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Feb 2000 11:32:48 -0000
Received: (qmail 4992 invoked by alias); 8 Feb 2000 11:32:34 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9618
Received: (qmail 4976 invoked from network); 8 Feb 2000 11:32:27 -0000
Date: Tue, 8 Feb 2000 12:32:21 +0100 (MET)
Message-Id: <200002081132.MAA02054@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Tanaka Akira's message of 07 Feb 2000 23:10:31 +0900
Subject: Re: core dump by completion.


Tanaka and I had a bit of a private discussion, trying to find
the memory bug he mentioned. He found a way to reproduce it:

> ...
>
> I couldn't remember.  But finally I found a reproducible way to dump core.
> 
> Z(2):akr@is27e1u11% Src/zsh -f
> is27e1u11% bindkey -e; autoload -U compinit; compinit -D; compdef _tst tst
> is27e1u11% _tst () { _arguments -a ":desc1:(arg1)" "*::desc2:_tst2" }
> is27e1u11% _tst2 () { _arguments "*:de:($CURRENT)" }
> is27e1u11% tst -a <TAB><TAB><TAB><TAB><TAB><TAB><TAB><TAB><TAB><TAB>
> ->
> is27e1u11% tst -a arg1 2 3 4 5 6 7 8 9 zsh: bus error (core dumped)  Src/zsh -f

When the cache of parsed _argument descriptions was full and a new one 
was added and that one happened to be the one just used, a bit of
information needed by the next invocation of ca_parse_line() was
overwritten: it didn't know the correct number of options anymore.

Of course, the cache entry for the definitions that were just used
shouldn't be used for the next set of definitions. And get_cadef()
tried to avoid that -- failing to do so because of a rather stupid
off-by-one error.

Thanks, Tanaka.

Bye
 Sven

diff -ru ../z.old/Src/Zle/computil.c Src/Zle/computil.c
--- ../z.old/Src/Zle/computil.c	Tue Feb  8 11:07:54 2000
+++ Src/Zle/computil.c	Tue Feb  8 11:47:25 2000
@@ -875,7 +875,7 @@
     Cadef *p, *min, new;
     int i, na = arrlen(args);
 
-    for (i = MAX_CACACHE, p = cadef_cache, min = NULL; *p && i--; p++)
+    for (i = MAX_CACACHE, p = cadef_cache, min = NULL; *p && i; p++, i--)
 	if (*p && na == (*p)->ndefs && arrcmp(args, (*p)->defs)) {
 	    (*p)->lastt = time(0);
 
@@ -1003,6 +1003,7 @@
 
 struct castate {
     Cadef d;
+    int nopts;
     Caarg def, ddef;
     Caopt curopt;
     int opt, arg, argbeg, optbeg, nargbeg, restbeg;
@@ -1029,7 +1030,7 @@
     /* Free old state. */
 
     if (ca_alloced) {
-	int i = ca_laststate.d->nopts;
+	int i = ca_laststate.nopts;
 	LinkList *p = ca_laststate.oargs;
 
 	freelinklist(ca_laststate.args, freestr);
@@ -1048,6 +1049,7 @@
     /* Default values for the state. */
 
     state.d = d;
+    state.nopts = d->nopts;
     state.def = state.ddef = NULL;
     state.curopt = NULL;
     state.argbeg = state.optbeg = state.nargbeg = state.restbeg =

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

