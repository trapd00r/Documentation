From zsh-workers-return-8442-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Oct 27 14:03:57 1999
Return-Path: <zsh-workers-return-8442-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22890 invoked from network); 27 Oct 1999 14:03:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Oct 1999 14:03:53 -0000
Received: (qmail 17780 invoked by alias); 27 Oct 1999 14:03:47 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8442
Received: (qmail 17773 invoked from network); 27 Oct 1999 14:03:46 -0000
Date: Wed, 27 Oct 1999 16:03:42 +0200 (MET DST)
Message-Id: <199910271403.QAA16743@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 26 Oct 1999 16:08:25 +0000
Subject: Re: PATCH: predict-on: suppress long listings


Bart Schaefer wrote:

> This is based on Sven's suggestion from 8399.  Also deletes two extraneous
> setopts.  Requires two patches I posted previously in 8364 and 8373.

May I pour some compconfig over this?

Also, this didn't really work together with AUTO_MENU, it started that 
too early (if it had just attempted completion). For now I've unset it 
in predict-on and restore it in predict-off, but there must be a
better solution.

Also, with a global match spec with partial-word stuff, the behavior
of always returning to the previous cursor position was clearly
wrong. With something like `Zle/z..' (and `r:.=*') this inserted
`Zle/zle.' and the dots typed simply vanished into thin air. Very
distracting. I've added the `predict_cursor' key for this. The value
`key' is probably the best for this (or the value `complete' which
uses `key' as a fallback). Looks much better for someone like me who
has gotten used to only type word parts nowadays.

And with a more sophisticated `completer' key, things sometimes just
got too slow and irritating (when it started to correct and things
like that), so there is now also `predict_completer'. I know that this 
defeats the purpose to make the string shown the one one could get by
typing tab, but still...

The last key, `predict_list', is probably not needed, but with the
usual behavior of showing a list below the command line, I find it
somewhat irritating when it suddenly stops doing so only because we
have reached the state where only one match is left.

I hope all this isn't completely the kind of stuff you didn't want to
have in predict-on...

Bye
 Sven

diff -u of/Zle/predict-on Functions/Zle/predict-on
--- of/Zle/predict-on	Wed Oct 27 15:41:45 1999
+++ Functions/Zle/predict-on	Wed Oct 27 15:53:26 1999
@@ -23,17 +23,28 @@
 # Note that all functions are defined when you first type the predict-on
 # key, which means typing the predict-off key before that gives a harmless
 # error message.
+#
+# This uses the configuration keys starting with `predict_'.
 
 predict-on() {
-    zle -N self-insert insert-and-predict
-    zle -N magic-space insert-and-predict
-    zle -N backward-delete-char delete-backward-and-predict
-    zle -N delete-char-or-list delete-no-predict
+  zle -N self-insert insert-and-predict
+  zle -N magic-space insert-and-predict
+  zle -N backward-delete-char delete-backward-and-predict
+  zle -N delete-char-or-list delete-no-predict
+
+  # Prediction doesn't work well with automenu set, so we unset it here
+  # and restore it in predict-off().
+  if [[ -o automenu ]]; then
+    unsetopt automenu
+    _predict_am=yes
+  fi
 }
 predict-off() {
-    zle -A .self-insert self-insert
-    zle -A .magic-space magic-space
-    zle -A .backward-delete-char backward-delete-char
+  zle -A .self-insert self-insert
+  zle -A .magic-space magic-space
+  zle -A .backward-delete-char backward-delete-char
+
+  [[ -n $_predict_am ]] && setopt automenu
 }
 insert-and-predict () {
   emulate -L zsh
@@ -50,11 +61,33 @@
 	RBUFFER=""
 	if [[ ${KEYS[-1]} != ' ' ]]
 	then
-	  integer curs=$CURSOR
+	  integer curs=$CURSOR pos nchar=${#LBUFFER//[^${KEYS[-1]}]}
 	  local -a +h comppostfuncs
 	  comppostfuncs=( predict-limit-list )
-	  zle complete-word
-	  CURSOR=$curs
+	  zle complete-word ${(s.:.)compconfig[predict_completer]}
+	  # Decide where to leave the cursor. The dummy loop is used to
+	  # get out of that `case'.
+	  while true; do
+	    case $compconfig[predict_cursor] in
+	    (complete)
+	      # At the place where the completion left it, if it is after
+	      # the character typed.
+	      [[ ${LBUFFER[-1]} = ${KEYS[-1]} ]] && break
+	      ;&
+	    (key)
+	      # Or maybe at the n'th occurrence of the character typed.
+	      pos=${BUFFER[(in:nchar:)${KEYS[-1]}]}
+	      if [[ pos -gt curs ]]; then
+	        CURSOR=$pos
+	        break
+	      fi
+	      ;&
+	    (*)
+	      # Or else at the previous position.
+	      CURSOR=$curs
+	    esac
+	    break
+	  done
 	fi
       fi
     fi
@@ -91,6 +124,7 @@
     compstate[list]=''
     compstate[force_list]=yes
   fi
+  [[ $compconfig[predict_list] = always ]] && compstate[force_list]=yes
 }
 
 # Handle zsh autoloading conventions
diff -u olddoc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- olddoc/Zsh/compsys.yo	Wed Oct 27 10:42:47 1999
+++ Doc/Zsh/compsys.yo	Wed Oct 27 15:52:08 1999
@@ -1795,4 +1795,32 @@
 If set to a non-empty string, the matches will be listed on every
 key-press.
 )
+item(tt(predict_completer))(
+The keys starting with tt(predict_) are used by the functions in the
+tt(predict-on) file in the tt(Functions/Zle) directory of the tt(zsh)
+source distribution.
+
+A colon separated list of completer functions (like the tt(completer)
+key for normal completion) to be used when attempting completion.
+)
+item(tt(predict_cursor))(
+This describes where the cursor should be left after completion was
+attempted. If it is set to `tt(complete)' the cursor is left where
+completion put it if it is after the character typed, otherwise this
+behaves like the value `tt(key)'. If it is set to `tt(key)' the
+prediction function will try to place the cursor after the character
+which corresponds to the last character typed. This is useful if one
+uses global match specifications with patterns for partial word
+completion. If no sensible place could be found or this configuration
+key is set to any other value (or unset), the cursor is moved back to
+the original position. With global match specifications as described
+above this sometimes means that the character typed does not appear on 
+the line.
+)
+item(tt(predict_list))(
+If this is set to `tt(always)' the list of possible matches when
+completion was tried will always be shown, even if there is only one
+match. Otherwise the listing behavior is as usual, i.e. the list will
+only be shown if there are multiple matches.
+)
 enditem()

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

