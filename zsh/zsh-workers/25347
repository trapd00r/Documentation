From zsh-workers-return-25347-mason-zsh=primenet.com.au@sunsite.dk Tue Jul 29 09:03:02 2008
Return-Path: <zsh-workers-return-25347-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19270 invoked from network); 29 Jul 2008 09:02:59 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 29 Jul 2008 09:02:59 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 20787 invoked from network); 29 Jul 2008 09:02:56 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 29 Jul 2008 09:02:55 -0000
Received: (qmail 6844 invoked by alias); 29 Jul 2008 09:02:53 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 25347
Received: (qmail 6835 invoked from network); 29 Jul 2008 09:02:53 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 29 Jul 2008 09:02:53 -0000
Received: from cluster-d.mailcontrol.com (cluster-d.mailcontrol.com [217.69.20.190])
	by bifrost.dotsrc.org (Postfix) with ESMTPS id A87D980561C5
	for <zsh-workers@sunsite.dk>; Tue, 29 Jul 2008 11:02:49 +0200 (CEST)
Received: from cameurexb01.EUROPE.ROOT.PRI ([193.128.72.68])
	by rly20d.srv.mailcontrol.com (MailControl) with ESMTP id m6T92PTg012964
	for <zsh-workers@sunsite.dk>; Tue, 29 Jul 2008 10:02:43 +0100
Received: from news01 ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.3959);
	 Tue, 29 Jul 2008 10:02:35 +0100
Date: Tue, 29 Jul 2008 10:02:35 +0100
From: Peter Stephenson <pws@csr.com>
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: Re: PATCH: interface from main shell to zle
Message-ID: <20080729100235.4fe254bc@news01>
In-Reply-To: <6315.1217266417@csr.com>
References: <6315.1217266417@csr.com>
Organization: CSR
X-Mailer: Claws Mail 3.4.0 (GTK+ 2.12.8; i386-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-OriginalArrivalTime: 29 Jul 2008 09:02:35.0961 (UTC) FILETIME=[D813AA90:01C8F159]
X-Scanned-By: MailControl A-08-50-03 (www.mailcontrol.com) on 10.68.0.130
X-Virus-Scanned: ClamAV 0.92.1/7875/Tue Jul 29 09:52:56 2008 on bifrost
X-Virus-Status: Clean

On Mon, 28 Jul 2008 18:33:37 +0100
Peter Stephenson <pws@csr.com> wrote:
> I'd like to simply the function call interface from the main shell into
> zle.  (The interface from zle back into the main shell is probably too
> horrible to think about.)  This patch reduces the current mess of pointers
> to a single entry point, which has autoload behaviour for all functions,
> not just a chosen few.

I didn't do the va_list handling in zleentry() carefully enough, and
apparently some older implementations need the start and end to match, so
here's just that bit...

Index: Src/init.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/init.c,v
retrieving revision 1.86
diff -u -r1.86 init.c
--- Src/init.c	17 Jul 2008 11:27:57 -0000	1.86
+++ Src/init.c	29 Jul 2008 08:57:24 -0000
@@ -84,11 +84,6 @@
 /**/
 mod_export int tccolours;
 
-/* Pointer to read-key function from zle */
-
-/**/
-mod_export int (*getkeyptr) _((long, int *));
-
 /* SIGCHLD mask */
 
 /**/
@@ -717,8 +712,6 @@
     zero_mnumber.type = MN_INTEGER;
     zero_mnumber.u.l = 0;
 
-    getkeyptr = NULL;
-
     lineno = 1;
     noeval = 0;
     curhist = 0;
@@ -1181,84 +1174,101 @@
     /* do nothing */
 }
 
-/* ZLE entry point pointers.  They are defined here because the initial *
- * values depend on whether ZLE is linked in or not -- if it is, we     *
- * avoid wasting space with the fallback functions.  No other source    *
- * file needs to know which modules are linked in.                      */
-
-#ifdef LINKED_XMOD_zshQszle
-
-/**/
-mod_export ZleVoidFn trashzleptr = noop_function;
-/**/
-mod_export ZleVoidFn zle_resetpromptptr = noop_function;
-/**/
-mod_export ZleVoidFn zrefreshptr = noop_function;
-/**/
-mod_export ZleVoidIntFn zleaddtolineptr = noop_function_int;
-/**/
-mod_export ZleGetLineFn zlegetlineptr = NULL;
-/**/
-mod_export ZleReadFn zlereadptr = autoload_zleread;
+/*
+ * ZLE entry point pointer.
+ * No other source file needs to know which modules are linked in.
+ */
 /**/
-mod_export ZleVoidIntFn zlesetkeymapptr = noop_function_int;
-
-#else /* !LINKED_XMOD_zshQszle */
-
-mod_export ZleVoidFn trashzleptr = noop_function;
-mod_export ZleVoidFn zle_resetpromptptr = noop_function;
-mod_export ZleVoidFn zrefreshptr = noop_function;
-mod_export ZleVoidIntFn zleaddtolineptr = noop_function_int;
-mod_export ZleGetLineFn zlegetlineptr = NULL;
-# ifdef UNLINKED_XMOD_zshQszle
-mod_export ZleReadFn zlereadptr = autoload_zleread;
-mod_export ZleVoidIntFn zlesetkeymapptr = autoload_zlesetkeymap;
-# else /* !UNLINKED_XMOD_zshQszle */
-mod_export ZleReadFn zlereadptr = fallback_zleread;
-mod_export ZleVoidIntFn zlesetkeymapptr = noop_function_int;
-# endif /* !UNLINKED_XMOD_zshQszle */
-
-#endif /* !LINKED_XMOD_zshQszle */
+mod_export ZleEntryPoint zle_entry_ptr;
 
+/*
+ * State of loading of zle.
+ * 0 = Not loaded, not attempted.
+ * 1 = Loaded successfully
+ * 2 = Failed to load.
+ */
 /**/
-char *
-autoload_zleread(char **lp, char **rp, int ha, int con)
-{
-    zlereadptr = fallback_zleread;
-    if (load_module("zsh/zle", NULL, 0) != 1)
-	(void)load_module("zsh/compctl", NULL, 0);
-    return zlereadptr(lp, rp, ha, con);
-}
+mod_export int zle_load_state;
 
 /**/
 mod_export char *
-fallback_zleread(char **lp, UNUSED(char **rp), UNUSED(int ha), UNUSED(int con))
+zleentry(VA_ALIST1(int cmd))
+VA_DCL
 {
-    char *pptbuf;
-    int pptlen;
+    char *ret = NULL;
+    va_list ap;
+    VA_DEF_ARG(int cmd);
+
+    VA_START(ap, cmd);
+    VA_GET_ARG(ap, cmd, int);
+
+#if defined(LINKED_XMOD_zshQszle) || defined(UNLINKED_XMOD_zshQszle)
+    /* autoload */
+    switch (zle_load_state) {
+    case 0:
+	if (load_module("zsh/zle", NULL, 0) != 1) {
+	    (void)load_module("zsh/compctl", NULL, 0);
+	    ret = zle_entry_ptr(cmd, ap);
+	    /* Don't execute fallback code */
+	    cmd = -1;
+	} else {
+	    zle_load_state = 2;
+	    /* Execute fallback code below */
+	}
+	break;
+
+    case 1:
+	ret = zle_entry_ptr(cmd, ap);
+	/* Don't execute fallback code */
+	cmd = -1;
+	break;
+
+    case 2:
+	/* Execute fallback code */
+	break;
+    }
+#endif
 
-    pptbuf = unmetafy(promptexpand(lp ? *lp : NULL, 0, NULL, NULL, NULL),
-		      &pptlen);
-    write(2, (WRITE_ARG_2_T)pptbuf, pptlen);
-    free(pptbuf);
+    switch (cmd) {
+	/*
+	 * Only the read command really needs a fallback if zle
+	 * is not available.  ZLE_CMD_GET_LINE has traditionally
+	 * had local code in bufferwords() to do this, but that'
+	 * probably only because bufferwords() is part of completion
+	 * and so everything to do with it is horribly complicated.
+	 */
+    case ZLE_CMD_READ:
+    {
+	char *pptbuf, **lp;
+	int pptlen;
 
-    return shingetline();
-}
+	lp = va_arg(ap, char **);
 
-/**/
-#ifdef UNLINKED_XMOD_zshQszle
+	pptbuf = unmetafy(promptexpand(lp ? *lp : NULL, 0, NULL, NULL,
+				       NULL),
+			  &pptlen);
+	write(2, (WRITE_ARG_2_T)pptbuf, pptlen);
+	free(pptbuf);
 
-/**/
-static void
-autoload_zlesetkeymap(int mode)
-{
-    zlesetkeymapptr = noop_function_int;
-    (void)load_module("zsh/zle", NULL, 0);
-    (*zlesetkeymapptr)(mode);
-}
+	ret = shingetline();
+	break;
+    }
 
-/**/
-#endif
+    case ZLE_CMD_GET_LINE:
+    {
+	int *ll, *cs;
+
+	ll = va_arg(ap, int *);
+	cs = va_arg(ap, int *);
+	*ll = *cs = 0;
+	ret = ztrdup("");
+	break;
+    }
+    }
+
+    va_end(ap);
+    return ret;
+}
 
 /* compctl entry point pointers.  Similar to the ZLE ones. */
 
-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070

