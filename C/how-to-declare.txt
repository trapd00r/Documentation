Declaring things in C
=====================


1. Declaring a simple variable
------------------------------
To declare a variable of type T, write 'T var;'.


2. Declaring an array
---------------------
To declare an array of size N of type T, declare a variable of type T and replace 'var' by 'var[N]'.


3. Declaring a function
-----------------------
To declare a function returning T, declare a variable of type T and replace 'var' by 'var(...)'.
Replace '...' by your function parameters.


4. Declaring a pointer
----------------------
To declare a pointer to T, declare a variable of type T and replace 'var' by '(*var)'.
Optional: If the ')' is not followed by '[' or '(', remove the parens around '*var'.


5. Declaring a const/volatile pointer
-------------------------------------
See rule #4 above, but use '*const' (or '*volatile') instead of '*'.


6. Declaring a typedef
----------------------
To create a typedef (alias) for some type, write a normal declaration, then add 'typedef' in the front.



Examples
========

One
---
Let's declare an array of 4 pointers to functions that return pointers to arrays of 3 doubles!

We want to declare an array, so we use rule #2. It tells us we first need to declare a pointer
to a function returning a pointer to an array of 3 doubles.

  To do that, we use rule #4. It tells us we first need to declare a function returning a pointer to
  an array of 3 doubles.

    To do that, we use rule #3. It tells us we first need to declare a pointer to an array of 3
    doubles.
    
      To do that, we use rule #4. It tells us we first need to declare an array of 3 doubles.

        To do that, we use rule #2. It tells us we first need to declare a double.

          To do that, we use rule #1:
>>           double var;  // a double
          Yay, we're done here.

        Now we can apply rule #2:
>>         double var[3];  // an array of 3 doubles

      Now we can apply rule #4:
>>       double (*var)[3]; // a pointer to an array of 3 doubles
      The character after ')' is '[', so we can't remove the parens.

    Now we can apply rule #3:
>>     double (*var(...))[3]; // a function(...) returning a pointer to an array of 3 doubles
    Let's say we want our function to take two ints:
>>     double (*var(int, int))[3]; // a function(int, int) returning a pointer to an array of 3 doubles

  Now we can apply rule #4:
>>   double (*(*var)(int, int))[3]; // a pointer to a function returning a pointer to an array of 3 doubles
  The character after ')' is '(', so we can't remove the (newly inserted) parens.

Now we can apply rule #2:
>> double (*(*var[4])(int, int))[3]; // an array of 4 pointers to functions returning pointers to arrays of 3 doubles

And we're done.

Two
---
Let's declare the standard signal() function. For FUN.
It takes a signal number (an int) and a pointer to a signal handler, and returns a pointer to a
signal handler. A signal handler is a function taking a signal number (an int) and returning
nothing.

So what would this look like in C?

We want to declare a function, so we use rule #3.
It tells us we first need to declare a pointer to a signal handler (because that's our return
type).

  To do that, we use rule #4. It tells us we first need to declare a signal handler.

    To do that, we use rule #3. It tells us we first need to declare ... nothing? Well, the formal
    return type of a function returning nothing is 'void'.

      So we just use rule #1 and pretend we can actually declare a variable of type 'void':
>>       void var;

    Now we can apply rule #3:
>>     void var(...); // a function(...) returning void
    We only have one parameter, an int:
>>     void var(int); // a function(int) returning void

  Now we can apply rule #4:
>>   void (*var)(int); // a pointer to a function(int) returning void
  Our ')' is followed by '(', so no way to simplify this.

Now we can apply rule #3:
>> void (*var(...))(int); // a function returning a pointer to a function(int) returning void
OK, now our parameters. First an int:
>> void (*var(int, ...))(int); // a function(int, ...) returning a pointer to a function(int) returning void
Then a pointer to a signal handler. But we already derived that (it's void (*var)(int)), so we're
simply going to plug that into our parameter list. And as usual we're going to omit the parameter
name, because this is just a function declaration, so the actual parameter names don't matter:
>> void (*var(int, void (*)(int)))(int); // a function(int, pointer to function(int) returning void) returning a pointer to a function(int) returning void

All that's left is to change the name to 'signal':

void (*signal(int, void (*)(int)))(int);

And that's it. This is what the declaration of signal() looks like in plain C.
