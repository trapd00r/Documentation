From zsh-workers-return-11776-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jun 06 12:18:17 2000
Return-Path: <zsh-workers-return-11776-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8734 invoked from network); 6 Jun 2000 12:18:15 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 6 Jun 2000 12:18:15 -0000
Received: (qmail 8500 invoked by alias); 6 Jun 2000 12:18:01 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11776
Received: (qmail 8492 invoked from network); 6 Jun 2000 12:18:00 -0000
Date: Tue, 6 Jun 2000 14:17:17 +0200 (MET DST)
Message-Id: <200006061217.OAA10059@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Adam Spiers's message of Tue, 6 Jun 2000 12:24:36 +0100
Subject: PATCH: Re: completing filenames containing spaces


Adam Spiers wrote:

> ...
> 
> I've narrowed it down to a test case:
> 
> pulse% zsh -f
> pulse% autoload compinit
> pulse% compinit
> pulse% setopt globcomplete

I'm more and more of the opinion that we need some shell-code
interface to haswilds(). Sigh.

Bye
 Sven

Index: Completion/Core/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_path_files,v
retrieving revision 1.18
diff -u -r1.18 _path_files
--- Completion/Core/_path_files	2000/05/31 09:38:26	1.18
+++ Completion/Core/_path_files	2000/06/06 12:16:37
@@ -184,7 +184,7 @@
 
 [[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" ||
    ( -n "$compstate[pattern_match]" &&
-     "${orig#\~}" != "${${orig#\~}:q}" ) ]] && menu=yes
+     "${orig#\~}" != (|*[^\\])[][*?#~^\|\<\>]* ) ]] && menu=yes
 
 # Now let's have a closer look at the string to complete.
 
@@ -491,7 +491,8 @@
     fi
 
     if (( tmp4 )) ||
-       [[ -n "$compstate[pattern_match]" && "$tmp2" != "${(q)tmp2}" ]]; then
+       [[ -n "$compstate[pattern_match]" &&
+          "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]; then
       # It is. For menucompletion we now add the possible completions
       # for this component with the unambigous prefix we have built
       # and the rest of the string from the line as the suffix.

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

