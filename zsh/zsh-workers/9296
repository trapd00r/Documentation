From zsh-workers-return-9296-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jan 12 09:08:12 2000
Return-Path: <zsh-workers-return-9296-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4846 invoked from network); 12 Jan 2000 09:08:10 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Jan 2000 09:08:10 -0000
Received: (qmail 26607 invoked by alias); 12 Jan 2000 09:08:02 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9296
Received: (qmail 26600 invoked from network); 12 Jan 2000 09:08:01 -0000
Date: Wed, 12 Jan 2000 10:07:58 +0100 (MET)
Message-Id: <200001120907.KAA31890@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Clint Adams's message of Tue, 11 Jan 2000 14:14:34 -0500
Subject: Re: completion with midword tildes


Clint Adams wrote:

> In dev-14 and the latest jaist CVS snapshot, at least, complete
> will not complete a word containing a tilde if the tilde is
> specified.  It will, however, do so if a backslash is specified.
> This happens whether or not EXTENDED_GLOB is set. That is to say
> 
> % mkdir a~b
> % cd a<TAB>   --> cd a\~b
> % cd a~<TAB>  --> cd a~<BEEP>
> % cd a\<TAB>  --> cd a\~b
> % cd a\~<TAB> --> cd a\~b
> 
> Some older behavior used to allow
> 
> % cd a~<TAB>  --> cd a\~b
> 
> Is the old behavior undesirable?  Particularly when EXTENDED_GLOB
> is unset, I would expect a~ to complete.

The old behaviour looks desirable, but in terms of cleanness it
isn't. Remember all the problems we had with quoting? Most of them had 
to do with the fact that the string from the line had its backslashes
removed (sometimes due to tokenizing followed by a remnulargs(),
sometimes due to rembslash()), and re-inserted by calling something
like quotename(). Most or all of this is removed now, making the
quoting rules quite simple -- the string on the line is not changed
and has to look like the stuff that would be inserted for the
match(es).

*But*: the quoting function we use has this nasty habit of quoting
some characters even if it isn't really necessary.

A pure user-code solution would be to use a match spec such as 'm:=\\'
(or several of these, making the backslash only optional before some
special characters) in ones $compmatchers, but maybe we should make
the completion code do that by default. What I want to say is that
nowadays I would implement it in exactly this way -- modify the
matching function to ignore backslashes. That's what the patch below
tries to attempt -- it works but there may be some complicated
interactions with complex match specs, I'll have to test that. Anyway, 
if we agree that this auto-backslash behaviour is a godd thing, the
patch should be used.

Bye
 Sven

diff -ru ../z.old/Src/Zle/compmatch.c Src/Zle/compmatch.c
--- ../z.old/Src/Zle/compmatch.c	Wed Jan 12 09:30:37 2000
+++ Src/Zle/compmatch.c	Wed Jan 12 10:03:52 2000
@@ -436,7 +436,7 @@
 	  int sfx, int test, int part)
 {
     int ll = strlen(l), lw = strlen(w), oll = ll, olw = lw;
-    int il = 0, iw = 0, t, ind, add, he = 0, bpc, obc = bc;
+    int il = 0, iw = 0, t, ind, add, he = 0, bpc, obc = bc, bslash;
     VARARR(unsigned char, ea, ll + 1);
     char *ow;
     Cmlist ms;
@@ -736,12 +736,15 @@
 	if (mp)
 	    continue;
 
-	if (l[ind] == w[ind]) {
+	bslash = 0;
+	if (l[ind] == w[ind] ||
+	    (bslash = (lw > 1 && w[ind] == '\\' &&
+		       (ind ? (w[0] == l[0]) : (w[1] == l[0]))))) {
 	    /* No matcher could be used, but the strings have the same
 	     * character here, skip over it. */
-	    l += add; w += add;
-	    il++; iw++;
-	    ll--; lw--;
+	    l += add; w += (bslash ? (add + add ) : add);
+	    il++; iw += 1 + bslash;
+	    ll--; lw -= 1 + bslash;
 	    bc++;
 	    if (!test)
 		while (bp && bc >= (useqbr ? bp->qpos : bp->pos)) {

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

