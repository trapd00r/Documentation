From zsh-workers-request@math.gatech.edu Thu Jun 25 08:42:50 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 12015 invoked from network); 25 Jun 1998 08:42:49 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 25 Jun 1998 08:42:49 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id EAA27122;
	Thu, 25 Jun 1998 04:36:36 -0400 (EDT)
Resent-Date: Thu, 25 Jun 1998 04:36:36 -0400 (EDT)
Message-Id: <9806250833.AA27200@ibmth.df.unipi.it>
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: Re: zsh exits suddenly. 
In-Reply-To: ""Bart Schaefer""'s message of "Wed, 24 Jun 1998 09:17:12 DFT."
             <980624091713.ZM4823@candle.brasslantern.com> 
Date: Thu, 25 Jun 1998 10:33:12 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>
Resent-Message-ID: <"XAkwX2.0.gd6.KmWar"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4164
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

"Bart Schaefer" wrote:
> On Jun 24, 10:51am, Peter Stephenson wrote:
> } Subject: Re: zsh exits suddenly.
> }
> } I can't be absolutely sure if all that lastc stuff is really needed.
> } It means, of course, that if there is more than one line in the
> } buffer, only the current one is flushed.  Is this the right behaviour?
> 
> This isn't changed by your patch, right?  It was the behavior all along?

Yes, this was exactly all it did before during an interactive read:
discard everything up to the next newline.

> The guideline should probably be, what does ZLE
> do to a multiline buffer when send-break is executed?  The SIGINT handler
> ought to do the same thing.  (In fact, why doesn't it call sendbreak()
> when ZLE is active?)

Actually, at the zle stage there shouldn't be any line input to flush
yet, so this doesn't really matter (i.e., after my last fix
inerrflush() always becomes a no-op here, regardless of the lastc
behaviour), but for what it's worth the complete multi-line buffer is
discarded in both cases.

The proper use of inerrflush() is when lexing the line just input.
I've found the difference: it's in a case like this:

% print !!:s/foo/bar/<ESC><RET>
print haha

The current code gives an error message for the substitution (assuming
of course there was no `foo' in the previous line), but prints `haha'
anyway.  Without the lastc stuff, the `print haha' is discarded along
with the rest of the previous line.

Oddly, the code for "event not found" and for "Ambiguous history
reference" performs the effect of inerrflush() itself, i.e. reading up
to a newline: this may well be just an oversight from before
inerrflush() was written.

So the question boils down to:  after a history subsitution failure,
should the rest of the input be discarded, or just the rest of the
line as at present?  (Note parsing failures don't flush the input in
any case, i.e.:

% if [[<ESC><RET>
then echo<ESC><RET>
fi<ESC><RET>
print haha

will always print `haha' after some error messages.  It also has an
extremely funny effect on the history lines stored.)

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 50 844536
WWW:  http://www.ifh.de/~pws/
Gruppo Teorico, Dipartimento di Fisica
Piazza Torricelli 2, 56100 Pisa, Italy

