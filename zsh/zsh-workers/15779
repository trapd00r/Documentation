From zsh-workers-return-15779-mason-zsh=primenet.com.au@sunsite.dk Mon Sep 10 15:20:54 2001
Return-Path: <zsh-workers-return-15779-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28948 invoked from network); 10 Sep 2001 15:20:53 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Sep 2001 15:20:53 -0000
Received: (qmail 16589 invoked by alias); 10 Sep 2001 15:20:36 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15779
Received: (qmail 16565 invoked from network); 10 Sep 2001 15:20:34 -0000
Date: Mon, 10 Sep 2001 11:20:29 -0400
From: Clint Adams <clint@zsh.org>
To: Oliver Kiddle <okiddle@yahoo.co.uk>
Cc: zsh-workers@sunsite.dk
Subject: Re: PATCH: ztcp
Message-ID: <20010910112029.A29473@dman.com>
References: <20010909200649.A17535@dman.com> <20010910110926.21520.qmail@web9305.mail.yahoo.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i
In-Reply-To: <20010910110926.21520.qmail@web9305.mail.yahoo.com>; from okiddle@yahoo.co.uk on Mon, Sep 10, 2001 at 12:09:26PM +0100

> I think it is better as Bart suggested with the option to specify a
> choice of fd because for everything else, you need to manage fd numbers
> yourself.

Well, here goes.  I am utterly perplexed because,
if I am not hallucinating, the desthost = ztrdup(arg[0]);
is actually passing the args[0] pointer, and thus
it chokes.

Index: Src/Modules/tcp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.c,v
retrieving revision 1.12
diff -u -r1.12 tcp.c
--- Src/Modules/tcp.c	2001/09/10 12:37:22	1.12
+++ Src/Modules/tcp.c	2001/09/10 15:17:02
@@ -298,7 +298,7 @@
     if (!tsess->next) return 1;
 
     if (ztcp_tail == sess)
-	    ztcp_tail = tsess;
+	ztcp_tail = tsess;
     tsess->next = sess->next;
     free(sess);
     return 0;
@@ -385,8 +385,8 @@
 static int
 bin_ztcp(char *nam, char **args, char *ops, int func)
 {
-    int herrno, err=1, destport, force=0, verbose=0, test=0, len;
-    char **addrp, *desthost, *localname, *remotename;
+    int herrno, err=1, destport, force=0, verbose=0, test=0, targetfd=0, len;
+    char **addrp, *desthost, *localname, *remotename, **arg = args;
     struct hostent *zthost = NULL, *ztpeer = NULL;
     struct servent *srv;
     Tcp_session sess = NULL;
@@ -399,14 +399,29 @@
 
     if (ops['t'])
         test = 1;
+
+    if (ops['d']) {
+	targetfd = atoi(arg[0]);
+	arg++;
+	if (!targetfd) {
+	    zwarnnam(nam, "%s is an invalid argument to -d", args[0], 0);
+	    return 1;
+	}
+    }
+
+
     
     if (ops['c']) {
-	if (!args[0]) {
+	if (!arg[0]) {
 	    tcp_cleanup();
 	}
 	else {
-	    int targetfd = atoi(args[0]);
+	    targetfd = atoi(arg[0]);
 	    sess = zts_byfd(targetfd);
+	    if(!targetfd) {
+		zwarnnam(nam, "%s is an invalid argument to -c", arg[0], 0);
+		return 1;
+	    }
 
 	    if (sess)
 	    {
@@ -420,7 +435,7 @@
 	    }
 	    else
 	    {
-		zwarnnam(nam, "fd %s not found in tcp table", args[0], 0);
+		zwarnnam(nam, "fd %s not found in tcp table", arg[0], 0);
 		return 1;
 	    }
 	}
@@ -428,16 +443,16 @@
     else if (ops['l']) {
 	int lport = 0;
 
-	if (!args[0]) {
+	if (!arg[0]) {
 	    zwarnnam(nam, "-l requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	srv = getservbyname(args[0], "tcp");
+	srv = getservbyname(arg[0], "tcp");
 	if (srv)
 	    lport = srv->s_port;
 	else
-	    lport = htons(atoi(args[0]));
+	    lport = htons(atoi(arg[0]));
 	if (!lport) { zwarnnam(nam, "bad service name or port number", NULL, 0);
 	return 1;
 	}
@@ -475,8 +490,14 @@
 	    return 1;
 	}
 
-	/* move the fd since no one will want to read from it */
-	sess->fd = movefd(sess->fd);
+	if (targetfd) {
+	    redup(sess->fd,targetfd);
+	    sess->fd = targetfd;
+	}
+	else {
+	    /* move the fd since no one will want to read from it */
+	    sess->fd = movefd(sess->fd);
+	}
 
 	setiparam("REPLY", sess->fd);
 
@@ -490,12 +511,12 @@
     {
 	int lfd, rfd;
 
-	if (!args[0]) {
+	if (!arg[0]) {
 	    zwarnnam(nam, "-a requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	lfd = atoi(args[0]);
+	lfd = atoi(arg[0]);
 
 	if (!lfd) {
 	    zwarnnam(nam, "invalid numerical argument", NULL, 0);
@@ -504,7 +525,7 @@
 
 	sess = zts_byfd(lfd);
 	if (!sess) {
-	    zwarnnam(nam, "fd %s is not registered as a tcp connection", args[0], 0);
+	    zwarnnam(nam, "fd %s is not registered as a tcp connection", arg[0], 0);
 	    return 1;
 	}
 
@@ -535,8 +556,15 @@
 	    zwarnnam(nam, "could not accept connection: %e", NULL, errno);
 	    tcp_close(sess);
 	    return 1;
+	}
+
+	if (targetfd) {
+	    redup(rfd, targetfd);
+	    sess->fd = targetfd;
+	}
+	else {
+	    sess->fd = rfd;
 	}
-	sess->fd = rfd;
 
 	setiparam("REPLY", sess->fd);
 
@@ -547,7 +575,7 @@
     else
     {
 	
-	if (!args[0]) {
+	if (!arg[0]) {
 	    for(sess = zts_head(); sess != NULL; sess = zts_next(sess))
 	    {
 		if (sess->fd != -1)
@@ -567,19 +595,19 @@
 	    }
 	    return 0;
 	}
-	else if (!args[1]) {
+	else if (!arg[1]) {
 	    destport = htons(23);
 	}
 	else {
 
-	    srv = getservbyname(args[1],"tcp");
+	    srv = getservbyname(arg[1],"tcp");
 	    if (srv)
 		destport = srv->s_port;
 	    else
-		destport = htons(atoi(args[1]));
+		destport = htons(atoi(arg[1]));
 	}
 	
-	desthost = ztrdup(args[0]);
+	desthost = ztrdup(arg[0]);
 	
 	zthost = zsh_getipnodebyname(desthost, AF_INET, 0, &herrno);
 	if (!zthost || errflag) {
@@ -614,10 +642,17 @@
 	    } while (err && errno == EINTR && !errflag);
 	}
 	
-	if (err)
+	if (err) {
 	    zwarnnam(nam, "connection failed: %e", NULL, errno);
+	    tcp_close(sess);
+	}
 	else
 	{
+	    if (targetfd) {
+		redup(sess->fd, targetfd);
+		sess->fd = targetfd;
+	    }
+
 	    setiparam("REPLY", sess->fd);
 
 	    if (verbose)
@@ -632,7 +667,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("ztcp", 0, bin_ztcp, 0, 2, 0, "acfltv", NULL),
+    BUILTIN("ztcp", 0, bin_ztcp, 0, 3, 0, "acdfltv", NULL),
 };
 
 /* The load/unload routines required by the zsh library interface */

