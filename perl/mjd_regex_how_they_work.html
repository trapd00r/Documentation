<html>
<head><title>How Regexes Work</title></head>
<body bgcolor="white">

<h1>How Regexes Work</h1>

<h2>Mark-Jason Dominus</h2>

<p>Copyright &copy; 1998 The Perl Journal.  Reprinted with permission.</p>

<p>This isn't an article about how to use regexes; you've probably seen
plenty of those already.  It's about how you would write a regex
package from scratch, in a language like C that doesn't already have
regexes.</p>

<p>I'll demonstrate a new module, <tt>Regex.pm</tt>, which implements regexes
from nothing, in Perl.  This will give you an idea of how regex matching is
possible, although the details differ rather substantially from what
Perl actually does.</p>

<p>Here's the basic strategy: We'll see a simple kind of `machine' that
reads a input, one character at a time, and then, depending on what's
in the input and on the various wheels and gears in the machine,
either says `yes' or `no'.  The machines are simple, and it turns out
that if we have a regex, it's not hard to construct a machine that
says `yes' for exactly those strings that match the regex, and `no'
for other strings.</p>

<p>When our program wants to see if <var>S</var> matched /<var>R</var>/, it'll do
something like this:</p>

<ol>
<li>	Look at <var>R</var>.
<li>	Construct the machine that corresponds to <var>R</var>.
<li>	Feed <var>S</var> into the machine.
<li>	If the machine says `yes', then <var>S</var> matched /<var>R</var>/.
<li>	Otherwise, it didn't.
</ol>

<p>Maybe this sounds bizarre, but bizarre or not, it's what Perl does.
If you can follow what we do in this article, you'll know what Perl is
really up to when it does a regex match.</p>


<h2>Machines</h2>

<p>We're on a tight budget here, so our machines will be made of circles
and arrows instead of wheels and gears, which are expensive.  Here's a
machine:</p>

<p align=center><img src="FA.gif" align=center></p>

<p>Let's see if this machine says `yes' to the string
<tt>&quot;abaa&quot;</tt>.  How do we do that?</p>

<p>We start by putting a penny down on the <b>M</b> circle, because
the <b>M</b> circle is the <em>start circle</em>.  We can tell that
<b>M</b> is the start circle because it has that arrow pointing to it
that says `start here'.  The letter `<b>M</b>' could have been
anything; it's not actually part of the machine.  I just put it on so
that you would know which circle I meant.</p>

<p>Now the machine will read the first character in the string; that's
<tt>&quot;a&quot;</tt>.  There's an arrow leading out of the <b>M</b>
circle that's labeled <tt>&quot;a&quot;</tt>, so we move the penny
along the arrow from <b>M</b> to <b>J</b>.</p>

<p>Next the machine will read the <tt>&quot;b&quot;</tt>.  The penny
moves back to <b>M</b>.  Then the machine reads another
<tt>&quot;a&quot;</tt>, and the penny moves back once more to
<b>J</b>.  Finally, the machine reads the last <tt>&quot;a&quot;</tt>,
and the penny follows the <tt>&quot;a&quot;</tt> arrow that leads from
<b>J</b> back to <b>J</b>.  </p>

<p>The penny is finally on circle <b>J</b>.  We're done.  So, how do
we tell if the machine said `yes'?  The rule is this: Some circles,
like <b>J</b>, are double circles.  These are called <em>final
circles</em>.  At the end of the input, if there are any pennies on
final circles, the machine says `yes'.  If no pennies are on final
circles, the machine says `no'.  In this case, there's a penny on
<b>J</b>, so the machine says `yes'.</p>

<p>Now, that's not so hard to do, and it's easy to see that this
machine will say `yes' to some strings and `no' to others.  It
actually happens that it says yes to any string that is matched by the
regex <tt>/^(a|b)*a$/</tt>, and `no' to all the strings that are not
matched.  We say that the machine is <em>equivalent</em> to the
regex.</p>

<p>Soon we'll see how to make machines that are equivalent to any regexes
we like.  First, though, we'll add a couple of features to the
machines that will make it easier to do this.</p>


<h2>Blank Arrows</h2>

<p>So far every arrow we've seen has been labeled with a letter.  But
some machines have unlabeled arrows, like this:</p>

<p align=center><img src="etrans.gif" align=center></p>
        . 

<p>The instant a penny arrives in a circle that has a blank arrow
leading out of it, we place <em>another</em> penny on the circle at
the far end of the blank arrow.  </p>

<p>Let's look at the machine above.  Let's see what it says about
<tt>&quot;ab&quot;</tt>.  The start circle is <b>V</b>, so we start
out by putting a penny there.  And then, because there's a blank arrow
from <b>V</b> to <b>W</b>, We immediately put a second penny on
<b>W</b>.  Now the machine is ready to read input.  It reads the
<tt>&quot;a&quot;</tt>. the penny on <b>V</b> moves along the arrow to
<b>V</b>, and the penny on <b>W</b> moves along the arrow to <b>X</b>,
so we now have pennies on <b>V</b> and <b>X</b>.  Now, because there's
a blank arrow leading from <b>X</b> to <b>Y</b>, we place a third
penny on <b>Y</b>, and because there's a blank arrow from <b>V</b> to
<b>W</b>, we place a fourth penny on <b>W</b>.</p>

<p>Next the machine reads <tt>&quot;b&quot;</tt>.  The penny on
<b>Y</b> moves to <b>Z</b>.  But what happens to the pennies on
<b>V</b>, <b>W</b>, and <b>X</b>?  There's a special rule for this:
Pennies that have nowhere to go must leave.  We take away the pennies
on <b>V</b>, <b>W</b>, and <b>X</b>.  Only the penny on <b>Z</b>
remains.</p>

<p>Now the machine is done reading the input.  There's a penny on
<b>Z</b>, which is a final circle, so the machine says `yes'.  </p>

<p>Sometimes a machine will have two arrows from the same circle that also
have the same label:</p>

<p align=center><img src="fork.gif" align=center></p>










<p>The penny here starts on <b>V</b>.  What happens when this machine
reads the string <tt>&quot;b&quot;</tt>?  There's a
<tt>&quot;b&quot;</tt> arrow from <b>V</b> to <b>W</b> and also from
<b>V</b> to <b>X</b>.  What happens?  The rule here is simple: The
penny clones itself, and one clone goes one way and the other goes the
other way; we end up with pennies on both <b>W</b> <em>and</em>
<b>X</b>.</p>

<p>You'll notice blank arrows from <b>X</b> to <b>Y</b> and from
<b>X</b> to <b>Z</b>; as soon as the penny arrives at <b>X</b>, we put
new pennies on <b>Y</b> and <b>Z</b> also.  Then, because a penny just
arrived at <b>Z</b>, we put one on <b>U</b> as well.</p>


<h2>Rules Again</h2>

<p>Before we see how to turn a regex into a machine, let's re-cap the rules
for moving pennies:</p>

<ol>
<li> To start, put a penny on the circle labeled `start here'.

<li> If there is a blank arrow leading from <b>X</b> to <b>Y</b>, then
     whenever a penny arrives at <b>X</b>, put another penny at
     <b>Y</b> also.

<li> Whenever the machine reads an input character <b>c</b>, move all
     the pennies.  If a penny is on a circle that has an outgoing
     arrow labeled <b>c</b>, move the penny along the arrow, and then
     follow rule 2 if appropriate.  If there is more than one such
     arrow, the penny clones itself and one clone follows each arrow.
     If a penny is on a circle with no arrow labeled <b>c</b>, remove
     that penny.

<li> When all the input is read, the machine says `yes' if any penny
     is on a final circle, and `no' otherwise.
</ol>

<p>Perhaps you can imagine that it might no be hard to write a program to
carry out these four simple rules, to keep track of where the pennies
are, and to yield the final `yes' or `no'.</p>

<p>And in fact that's exactly how regexes work.  Perl turns the regex into
a machine, then simulates the positions of the pennies, and at the end of
the input, reports on whether any pennies are on final circles.</p>

<p>Now the only question left is:  How can we turn a regex into a machine?</p>


<h2>How to Turn a Regex into a Penny Machine</h2>

<p>First, we're going to assume that all our regexes are anchored at
the front and the back.  That is, we're only going to deal with
regexes that look like <tt>/^P$/</tt>, where P might be complicated.
It turns out that this doesn't give anything away, because if
<tt>/Q/</tt> is some regex that isn't anchored, then
<tt>/^.*Q.*$/</tt> is a completely equivalent regex that matches the
same strings, which <em>is</em> anchored.  If someone wanted us to
make a machine for <tt>/Q/</tt>, we could make one for
<tt>/^.*Q.*$/</tt> instead, and they'd never be the wiser.  From now
on I'm going to leave out the <tt>^</tt> and the <tt>$</tt>, because
it makes the examples simpler to read.</p>

<p>Now, there are two kinds of regexes.  Regexes are either very
simple things like <tt>/x/</tt>, or they're built up from simpler
regexes.  For example, if <var>P</var> is a regex, then
<var>P</var><tt>*</tt> is also a regex.  That means we're going to
have to do two things: We'll have to see how to build simple machines
for the simple regexes, and we'll have to see how to build up those
simple machines into more complicated machines.</p>

<p>Here's the machine for the regex <tt>/a/</tt>:</p>


<p align=center><img src="sym.gif"></p>




<p>Stare at it a while to convince yourself that it really says `yes' only
for the string <tt>&quot;a&quot;</tt> and not for any other string.  What does it say about
<tt>&quot;&quot;</tt>?  What about <tt>&quot;b&quot;</tt>?  <tt>&quot;aa&quot;</tt>?</p>

<p>And here's an even simpler machine; it's equivalent to the regex <tt>//</tt>.</p>

<p align=center><img src="emptystr.gif"></p>





<p>(Remember that I left out <tt>^</tt> and <tt>$</tt>, so <tt>//</tt> really matches only the empty
string, <tt>&quot;&quot;</tt>, and the equivalent machine will say `yes' only for the
empty string.)</p>

<p>Now let's suppose we already have machines for <tt>/P/</tt> and
<tt>/Q/</tt>, and let's try to figure out how to make a machine for
<tt>/P|Q/</tt>.  That's also pretty easy:</p>

<p align=center><img src="altern.gif"></p>


<p>The penny starts on the left, and immediately clones move to the
circles that used to be the start circles for <var>P</var> and for
<var>Q</var>.  For the machine to say `yes', the `<var>P</var>' penny
must make its way to what used to be <var>P</var>'s final circle, or
the `<var>Q</var>' penny must make its way to what used to be
<var>Q</var>'s final circle; if either of those things happen, the
penny will clone itself to the real final circle on the far right.  If
neither of those things happens, no penny will escape from either
machine <var>P</var> or machine <var>Q</var>.  Any string that
`<var>P</var>' would have matched will get a penny through
<var>P</var> to the final circle, and any string that `<var>Q</var>'
would have matched will get a penny through <var>Q</var> to the final
circle, and so this machine says `yes' for any string that either
`<var>P</var>' or `<var>Q</var>' would have said `yes' to, and not to
any other strings.  That's exactly what we wanted.</p>



<p>How about if we have machines for /<var>P</var>/ and /<var>Q</var>/, and we want to make a machine
for /<var>PQ</var>/?  We can do it like this:</p>



<p align=center><img src="concat.gif"></p>


<p>It's easy to see that we can chain together as many machines as we
want this way.  For example, here is a machine that is equivalent to
the regex /<tt>perl</tt>/:</p>


<p align=center><img src="perl.gif"></p>


<p>Now let's tackle <var>P</var><tt>+</tt>, which turns out to be just
a little easier than <var>P</var><tt>*</tt>.</p>

<p align=center><img src="plus.gif"></p>

<p>After the penny makes it through P, it clones itself; one clone moves
to the final circle right away, and one moves back to the beginning of
P to try again, in case there are more P's coming up.</p>

<p>Now that we've seen this, P* is easy too; we just short-circuit the
beginning to the end, so that the penny doesn't have to go through P
even once:</p>

<p align=center><img src="star.gif"></p>

<p>Oh, now we're done.</p>


<h2>What Do You Mean, Done?</h2>

<p>Well, we left out character classes.  But <tt>[abc]</tt> is just
the same as <tt>(a|b|c)</tt>, so we can handle that all right by
pretending that the user wrote it that way.</p>

<p>We left out <tt>\d</tt>, <tt>\s</tt>, and all those things.  But
those are just character classes.  <tt>.</tt> is also a character
class if we don't mind writing it as <tt>(\000|\001|...|\255)</tt>.
That makes the machine big and inefficient, but hey, just so long as
it works.  We'll see later on how to make it better.</p>

<p>We left out <tt>?</tt>.  But <tt><var>P</var>?</tt> is just the
same as <tt>(<var>P</var>|)</tt>, so it's really there too.  And we
left out <tt>{<var>n</var>}</tt>.  But <var>P</var><tt>{3}</tt> is
just the same as <var>PPP</var>, so we really don't need
<tt>{<var>n</var>}</tt>.  <tt>{<var>m</var>,}</tt> and
<tt>{<var>m</var>,<var>n</var>}</tt> are similar.</p>

<p>We left out the `non-greedy' quantifiers.  But those don't change
<em>whether</em> the regexes will match, so they don't affect our
program; we can ignore them.</p>

<p>We left out <tt>^</tt> and <tt>$</tt>, but they're in there by
default; if you want to take them away you can attach <tt>.*</tt> at
the beginning or the end or both.  </p>

<p>We left out zero-width assertions like <tt>\b</tt> and
<tt>(?:...)</tt> and <tt>(?!...)</tt>.  But this is an introductory
article and I made a command decision to leave them out.  </p>

<p>We also left out backreferences, but I'll show how to put them in
later, just to prove I'm not a slacker.</p>

<p>That about covers it, right?  (Leafing through perlre man page....)
Yes, I was right.  We're done.</p>

<p>By the way, this construction for turning regexes into machines was
invented in 1968 by Ken Thompson.  You may have heard of Thompson
already: He and Dennis Ritchie invented Unix around the same time.</p>

<h2>The Module</h2>

<p>The module has three parts.  It has a part for turning strings into
regexes, a part for turning regexes into machines, and a part for
shuffling the pennies around.  Here's a program that looks to see if the
pattern <tt>/^ab+$/</tt> matches the string <tt>&quot;abbbbb&quot;</tt>:</p>

<pre>
	use Regex;

	$regex    = Regex-&gt;parse('ab+');    # Parse the string
	$machine  = NFA-&gt;compile($regex);   # Build the machine
	$result   = NFA_Exec-&gt;match($machine, 'abbbbb'); # Pennies

	print &quot;It &quot;, ($result ? &quot;did &quot; : &quot;did not &quot; ), &quot;match.\n&quot;;
</pre>

<p>The output, as we would hope, is</p>

<pre>
<i>	It did match.</i>
</pre>

<p>Now you can go try it yourself.  It lives at <a
href="http://perl.plover.com/Regex/Regex.pm">http://perl.plover.com/Regex/Regex.pm</a>.</p>


<p>There's a sample program at <a href="http://perl.plover.com/Regex/grep">http://perl.plover.com/Regex/grep</a>.</p>


<h2>Implications for Perl</h2>


<p>Is this really what Perl does?  Pretty much, except Perl's regexes are
written in C, while Regex.pm is written in Perl.  Perl parses the
regex string into an internal format, and then it turns the internal
format into a machine.  Perl's machine works a little differently from
the ones I showed, but in principle it's the same.  </p>

<p>Constructing the machine for a certain regex can take a relatively
long time, but once it's constructed, running an input through it is
very fast, and you can runs lots of different inputs through it
without reconstructing it.  That is just what Perl does do; at the
time you first run your program, it turns all your regexes into
machines and saves the machines for later.  Then it can do fast
pattern-matching with any of them because the machines are already on
the shelf waiting to be used.</p>

<p>Actually, I lied; Perl can't always build the machines as soon as you
run your program.  Consider this program, which reads an input, and
prints out each line if it happens to contain its own line number
(<tt>$.</tt> is the line number of the current line of input):</p>

<pre>
	while (&lt;&gt;) {
	  print if /$./;
	}
</pre>


<p>Perl can't possibly build the machine for <tt>/$./</tt> as soon as
your program is run, because <tt>/$./</tt> changes from line to line.
Perl has to build a new machine every time through the loop.  That
makes this a slow program.</p>

<p>Let's consider a slightly different program.  This one is like the
Unix <tt>grep</tt> command: you give it a pattern as the command-line
argument, and it prints all the lines from its input that match that
pattern:</p>

<pre>
	my $pat = shift;

	while (&lt;&gt;) {
	  print if /$pat/;
	}
</pre>

<p>Again, Perl rebuilds the machine every time through the loop.  It
does this because it it afraid that <tt>$pat</tt> might have changed
since last time, and it is too dumb to see that actually <tt>$pat</tt>
never changes.  </p>

<p>If only there were a way to tell Perl that <tt>$pat</tt> never
changes!</p>

<p>There <em>is</em> a way to tell Perl that <tt>$pat</tt> never
changes:</p>

<pre>
	my $pat = shift;

	while (&lt;&gt;) {
	  print if /$pat/o;
	}
</pre>

<p>The <tt>/o</tt> tells Perl that <tt>$pat</tt> never changes.
Normally, Perl likes to build the machine when it compiles the rest of
your program.  For regexes with variables in them, it rebuilds the
machine every time it uses the regex---unless you put in <tt>/o</tt>.
If you put in <tt>/o</tt>, Perl builds the machine for the regex
exactly once (<tt>o</tt> is for `once'), the first time it uses the
regex, and puts it on the shelf for later.  After the first time, it
assumes that the variables are always the same, and it uses the
machine from the shelf instead of making a new one every time.</p>

<p>Beginners are always writing slow program like this:</p>

<pre>
	my @pats = ('fo*', 'ba.', 'w+3');

	while (&lt;&gt;) {
	  foreach $pat (@pats) {
	    print if /$pat/;
	  }
	}
</pre>

<p>Here, again, Perl has to build a new machine every time
<tt>$pat</tt> changes.  You can make this program much faster by
writing it like this:</p>

<pre>
	my @pats = ('fo*', 'ba.', 'w+3');
	my $pat = join('|', @pats);

	while (&lt;&gt;) {
	    print if /$pat/o;
	}
</pre>

<p>By arranging to have only one pattern that never changes, instead of
three patterns that are used alternately, we can tell Perl to build a
regex machine exactly once instead of three times for every line of
input.</p>


<h2>What About Backreferences?</h2>

<p>I promised to show you how to do this to prove I wasn't a slacker.
You can skip this section if you don't care how to do backreferences,
as long as you agree first that I'm not a slacker.</p>

<p>Just to make things a little easier to discuss, we'll pretend that
you can have only one backreference in each regex.  <tt>\1</tt> will
work, and <tt>\2</tt>, <tt>\3</tt>, etc. won't.  After you see how we
can make <tt>\1</tt> work, it'll be easy to see how to make the rest
work too.</p>

<p>To do backreferences, we need to add a tape recorder to each penny.
If the tape recorder is on, it records the input that the machine is
receiving.  </p>

<p>We also add three new kinds of circles: A `record' circle; a `stop'
circle, and `replay' circle.  When the penny enters a `record' circle,
its tape recorder starts recording.  When the penny enters a `stop'
circle, it stops recording.</p>

<p>The `replay' circle is a little different.  It has exactly one
outgoing arrow.  When the penny enters the `replay' circle, it stops
and rewinds the tape.  Then it waits on the replay circle while the
machine reads more input, and it compares the input to what's on the
tape.  If the input doesn't match what's on the tape, or if the input
runs out before the tape does, the penny dies.  But if the input does
match the tape, the penny immediately moves off the `replay' circle
along the outgoing arrow, and then it continues moving normally.</p>

<p>If <var>P</var> is a regex, here's how we build the machine for
<tt>/(<var>P</var>)/</tt>; it's just like <tt>/<var>P</var>/</tt>
except it also records the input that matched <var>P</var>:</p>

<p align=center><img src="parens.gif"></p>



Here's the machine for <tt>/\1/</tt>:


<p align=center><img src="backslash.gif"></p>

	
Here's an example: It's the machine for <tt>/(a+)\1/</tt>:



<p align=center><img src="backref.gif"></p>




<p>Let's see what happens when this machines reads the string
<tt>&quot;aaaa&quot;</tt>.  We put a penny on <b>S1</b>, the start circle,
and the penny immediately begins recording on its tape recorder.  The
penny clones itself and its tape recorder, and clones move to <b>U</b> and to
<b>V</b>.  </p>

<p>Now, every time the machine reads an <tt>&quot;a&quot;</tt>, a
penny gets through to <b>W</b> with an additional
<tt>&quot;a&quot;</tt> written on its tape.  This penny moves through
to <b>E1</b>, which shuts off the tape recorder.  The first such penny
has just <tt>&quot;a&quot;</tt> on is tape; it arrives at <b>R1</b>;
when the machine reads the second <tt>&quot;a&quot;</tt> it moves to
<b>Z</b>, and then on the third <tt>&quot;a&quot;</tt> it dies.  But
the second penny to come out at <b>X</b> has two
<tt>&quot;a&quot;</tt>s on its tape; it gets out of <b>R1</b> just
after the machine reads the third and fourth <tt>&quot;a&quot;</tt>s,
and it gets to <b>Z</b> just in time for the end of the input.  The
penny on <b>Z</b> at the end of the input signals an `accept', and the
<tt>&quot;aa&quot;</tt> on its tape means that <tt>$1</tt> is
<tt>&quot;aa&quot;</tt>.  </p>

<p>There were two other pennies that came out at <b>X</b>, one with
<tt>&quot;aaa&quot;</tt> and one with <tt>&quot;aaaa&quot;</tt> no its
tape.  But these pennies stayed stuck in <b>R1</b> waiting for the
machine to read more <tt>&quot;a&quot;</tt>s.</p>

<p>Now, if you want to have more backreferences, you just add more tape
recorders to each penny.  And you have one kind of `record', `stop',
and `replay' circle for every backreference.  /\3/ becomes a circle
that says `replay tape 3', and the fifth <tt>(</tt> in a regex becomes a
circle that says `start recording on tape 5'.</p>
                    

<h2>Internals</h2>

<p><tt>NFA::compile</tt> transforms a regex into a machine, following
pretty much the same steps that we did in the article.  It starts with
the sub-expressions, and then combines smaller machines into one large
machine.  The structure for a machine is so simple that I'll just give
an example:</p>



<p align=center><img src="representation.gif"></p>



<p>Has the following representation:</p>

<pre>
	{ A =&gt; { '' =&gt; B,      # Unlabeled arrow from A to B
                 'x' =&gt; C,     # Arrow labeled `x' from A to C
               },
          B =&gt; { },            # No arrows from B
          C =&gt; { 'q' =&gt; B },   # Arrow labeled `q' from C to B
          Symbols =&gt; [ A, B ], # These are the start and final circles.
        }
</pre>

<p>This is convenient because it's easy to look up where a given penny
should move to when the machine reads a certain character in the
input.</p>

<p>The best way to see what the module is really doing is to run the test
program under the debugger and ask it to print out the data
structures.  Once you know about the machines and the pennies, the
whole thing should be almost transparent.  (Warning: The circle names
are generated automatically, so they all have names like <tt>Saa01</tt>.)</p>

<p>The module does a very ordinary simulation of where the pennies are
after each character in the input.  Here's a simple example: When the
input has run out, the simulator just looks to see if there is a penny
on the final circle, something like this:</p>

<pre>
  foreach $s ($self-&gt;circles_with_pennies) {
    if ($self-&gt;{machine}-&gt;is_final_circle($s)) {
      # Aha!  We win!
      return 1;
    }
  }
  # No penny was on a final circle; pattern match fails.
  return 0;
</pre>

<p>The real code uses technical jargon, but the code is identical
except for the jargon.  You can find it in the function
<tt>NFA_Exec::final_state</tt>.</p>


<H2>Lies</h2>

<p>Perl doesn't really do it exactly the way I showed you.  It's close,
and the principle is the same, but there's one big difference.  The
difference is that Perl never moves more than one penny at a time.</p>

<p>Whenever a penny clones itself, Perl makes a choice about which one
to move, and saves the locations of the others.  If the penny that
Perl is moving dies, it <em>backtracks</em> to one of the other
pennies, and picks up where it left off.</p>

<p>This has a number of benefits.  If the penny Perl happens to be
moving ends on the final circle at the end of the input, then Perl
knows that the input matched, even though it didn't move the other
pennies, so it was able to save time.</p>

<p>Alternatively, if the programmer asks for a second match, Perl just
has to go back and try some more pennies until it finds a second one
that wins; the path that the second penny took is the second match.
When you move all the pennies at once, you get all the matches at once
too, and there's no good way to make use of all the information you
get.</p>

<p>When a penny clones itself, Perl has to make a choice about which
penny to follow and which one to save for later.  By making the
decision one way, it gets the greedy operators <tt>*</tt>, <tt>+</tt>,
and <tt>?</tt>; by choosing the other penny in each case, the
operators become the non-greedy versions, <tt>*?</tt>, <tt>+?</tt>,
and <tt>??</tt>.</p>

<p>The one-penny-at-a-time system that Perl uses is also more convenient
for handling backreferences.  Instead of having to associate a set of
tape recordings with each penny, Perl only needs to have one set of
tape recordings for the single current penny, and some saved tape
recordings for the pennies it might have to backtrack to.</p>

<p>However, the one-penny-at-a-time system also has a terrible
drawback: For some patterns, the number of saved pennies can get huge,
and Perl can spend literally hours returning to one saved penny after
another.  For example, here's one such pattern: <tt>/^(\d+)*$/</tt>.
For a complete discussion of a similarly rotten expression, see
Jeffrey Friedl's article in TPJ #2.  Here's the short summary: Any
idiot can see that a string like <tt>1234567890:</tt> won't match
because of the <tt>:</tt> on the end.  But Perl wastes a lot of time
trying pointless backtracking.</p>

<p>Perl sees the <tt>*</tt>, and it needs to decide how many times to
repeat the preceding expression, the <tt>(\d+)</tt>.  This means it
gets to use as many <tt>\d+</tt>'s as it wants to.  First it lets
<tt>\d+</tt> match <tt>1234567890</tt>, using only one <tt>\d+</tt>,
but that doesn't work, because of the <tt>:</tt>, so Perl backs off
and lets <tt>\d+</tt> match just <tt>123456789</tt>, and it uses a
second <tt>\d+</tt> to match the <tt>0</tt>, but that doesn't work
either.  So it backs off some more and lets the first <tt>\d+</tt>
match <tt>012345678</tt>, and the second match <tt>90</tt>.  That
fails, so it tries making the second <tt>\d+</tt> match only the
<tt>9</tt>, and uses a third instance of <tt>\d+</tt> for the
<tt>0</tt>.  That fails too, so it shortens the first \d+ again to
match only the <tt>01234567</tt>...  Oh, dear.  What a disaster.</p>

<p>The many-pennies-at-once approach can score a huge win here.  The
machine doesn't have very many circles, at most two for every symbol
in the regular expression, and so there need never be very many
pennies.  Suppose two pennies happen to move onto the same circle.
The one-at-a-time approach would have dealt with them separately, at
different times.  But the many-pennies-at-once approach can replace
these two pennies with one penny.(FOOTNOTE: Only if we're ignoring
backreferences.  We can't join pennies if we're saving backreferences,
because the two pennies probably have different recordings on their
tapes.)  The result: Fewer pennies get moved, and there's no
backtracking, and the regular expression finishes quickly instead of
slowly.</p>

<p>The program at <a
href="http://perl.plover.com/Regex/demo.pl">http://perl.plover.com/Regex/demo.pl</a>
demonstrates this: It builds and runs the equivalent <tt>Regex.pm</tt>
penny machine first, and that takes less than two seconds, even on a
bitty box.  Then it tries using Perl's built-in regular expressions,
and that takes hours, even on a speedy computer.</p>
	

<h2>Other Directions</h2>

<p>For an easy project, try adding the <tt>.</tt> symbol.  You'll have
to modify the parser a little, and machines will need to have a new
kind of arrow that indicates a transition on any input at all.  From
there it's only a small step to adding general character classes.</p>

<p>OMAR might enjoy adding backreferences to the <tt>Regex</tt>
module.  Probably the most difficult part will be fixing the
string-to-regex parser, which is a terrible hack; the rest of the code
is much more flexible.</p>

<p>If you're interested in the details of how Perl's internal machines
work, you might enjoy running </p>

<pre>
	perl -Dr -ne 'print if /<var>SOMETHING</var>/';
</pre>

<p>to see what happens.  <tt>-Dr</tt> asks Perl to display the details
of its regular expression machinery, both at the times that the
machines are constructed and at the times they're used.  Be prepared
for surprises!  For example, The <tt>*</tt> in <tt>/x*/</tt> is
different from the <tt>*</tt> in <tt>/(xy)*/</tt>.  The former is a
real <tt>*</tt>, but Perl treats the latter as if you had written
<tt>/(xy){0,32767}/</tt> instead.</p>

<h2>Sidebar</h2>

<p>There's a sidebar about <a href="sidebar.html"> How to Talk Like a
Computer Scientist</a>.</p>

<h2>Notes From Last Month</h2>

<p>See <a
href="http://perl.plover.com/">http://perl.plover.com/</a>
for further developments on B-trees and other Perl odds and orts. </p>

<p>This column needs a name.  What should I call it?  It should
characterize the subject matter (Previous articles: Infinite lists;
B-Trees) and sound cool.  Send suggestions to <a
href="mailto:mjd-tpj@plover.com">mjd-tpj@plover.com</a>; the best one
will receive my grateful thanks in TPJ #11.</p>

<h2>BIBLIOGRAPHY</h2>

<dl>
<dt><cite>Understanding Regular Expressions</cite>
<dd> Jeffrey Friedl, <cite>The Perl Journal</cite>, vol 1 #2, or <cite>Perl
	Utilities Guide</cite>, O'Reilly & Associates, Sebastopol, CA,
	pp. 186--202.

<dt><cite>Introduction to Compiler Construction</cite>
<dd>Thomas W. Parsons, pp. 20--46
	(and especially 40-46.)  Computer Science Press, New York, 1992.

<dt><cite>Regular Expression Search Algorithm</cite>
<dd>Ken Thompson.  Communications
	of the ACM, vol. 11, no. 6, pp 419--422.
</dl>

<hr>

<p>Return to: 
<a href="http://www.plover.com/~mjd/">Universe of Discourse main page</a> |
<a href="http://www.plover.com/~mjd/whatsnew.html">What's new page</a> |
<a href="../">Perl Paraphernalia</a> |
<a href="index.html">How Regexes Work</a>
</p>

<p><a href="mailto:mjd-tpj-regex@plover.com">mjd-tpj-regex@plover.com</a></p>

</body>
</html>
