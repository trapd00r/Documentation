From zsh-workers-return-25628-mason-zsh=primenet.com.au@sunsite.dk Fri Sep 05 21:37:09 2008
Return-Path: <zsh-workers-return-25628-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21167 invoked from network); 5 Sep 2008 21:37:06 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00,HTML_MESSAGE
	autolearn=ham version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 5 Sep 2008 21:37:06 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 93314 invoked from network); 5 Sep 2008 21:36:59 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 5 Sep 2008 21:36:59 -0000
Received: (qmail 12726 invoked by alias); 5 Sep 2008 21:36:54 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 25628
Received: (qmail 12708 invoked from network); 5 Sep 2008 21:36:53 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 5 Sep 2008 21:36:53 -0000
Received: from py-out-1112.google.com (py-out-1112.google.com [64.233.166.181])
	by bifrost.dotsrc.org (Postfix) with ESMTP id E88F880307AC
	for <zsh-workers@sunsite.dk>; Fri,  5 Sep 2008 23:36:37 +0200 (CEST)
Received: by py-out-1112.google.com with SMTP id u77so378689pyb.23
        for <zsh-workers@sunsite.dk>; Fri, 05 Sep 2008 14:36:38 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:received:received:message-id:date:from:to
         :subject:in-reply-to:mime-version:content-type:references;
        bh=pYPSPT2FMdr5zm/hTEeZO8D5efN1lENMIA8c71FM1Qo=;
        b=RFrcA9uJboGyczTpnBbaPWMycTBXwP53Tx7gxwLCxfg1C8JDvVliNWfHl1b+F0WI3G
         /Y7d15sRxn1LrrjEMarqjmcoA2mGgUN7BZC9y+Pw2m79SEdAffnu+JPJlHkv06skWLo0
         Jd2R8Gy7EO5Y+PJbib/4IKS9HZnURib4LODb8=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=message-id:date:from:to:subject:in-reply-to:mime-version
         :content-type:references;
        b=jNODBxcqiQN7+wbwyKpBrxcl9qE4FWvqpOrj87PDFD8/RhCr24acfguqPJLry+DR7H
         WBE/JrOVOOOtuEphroFnsSJWz+caeTkvQPKwJx2gcb36Hvhf5se+KP5MgmtekoGTDlJI
         zuqmtq8ZE8v3XxE+uita+7TSOU2umU7yDVGgA=
Received: by 10.114.130.1 with SMTP id c1mr10543566wad.152.1220650597577;
        Fri, 05 Sep 2008 14:36:37 -0700 (PDT)
Received: by 10.114.159.2 with HTTP; Fri, 5 Sep 2008 14:36:37 -0700 (PDT)
Message-ID: <6cd6de210809051436l5b9d212fl62eabd07af277943@mail.gmail.com>
Date: Fri, 5 Sep 2008 17:36:37 -0400
From: "Rocky Bernstein" <rocky.bernstein@gmail.com>
To: "Zsh hackers list" <zsh-workers@sunsite.dk>
Subject: Re: Request: a way to get the subshell level nesting
In-Reply-To: <20080905214529.254cd16f@pws-pc>
MIME-Version: 1.0
Content-Type: multipart/alternative; 
	boundary="----=_Part_53981_11265226.1220650597562"
References: <6cd6de210809050711h4811efei413630fb514333ae@mail.gmail.com>
	 <20080905214529.254cd16f@pws-pc>
X-Virus-Scanned: ClamAV 0.92.1/8169/Fri Sep  5 22:15:20 2008 on bifrost
X-Virus-Status: Clean

------=_Part_53981_11265226.1220650597562
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Again, many thanks. I'll probably start putting this in prompt information
over the weekend. And again, alas it removes my excuse to blame zsh for why
my code is so broken in this regard ;-)

Comments in line.

On Fri, Sep 5, 2008 at 4:45 PM, Peter Stephenson <
p.w.stephenson@ntlworld.com> wrote:

> On Fri, 5 Sep 2008 10:11:45 -0400"Rocky Bernstein" <
> rocky.bernstein@gmail.com> wrote:
> > It would be great if there were a way to get the subshell level nesting.
> ksh
> > uses .sh.level and bash BASH_SUBSHELL.
>
> This is easy;


(Thought it would; but it's good to get that confirmed.)


> the only decision is whether the value should reflect a
> logical or an actual subshell.  I think the former, since the only
> difference is to optimise out an exec when the shell is going to exit
> anyway, and I think from the user's point of view that should be treated
> identically to a real exec.


I described my motivation. First as status information, second to let folks
realize that values may have gotten discarded and third to make facilitate
picking up state information to be passed back (without doing unnecessary
work in the majority of the cases where there is no subshell change.)

I think some in some of the optimization cases it doesn't matter all that
much, so I leave it to your judgment.

However, I find it interesting because I had a discussion about something
very similar with David Korn regarding SHLVL which should be added soon to
ksh. He had the same question because in some cases he optimizes a recursive
shell out if the say the shell call is in fact the last line of the script.
What was done there was to set SHLVL to be exactly what goes on, not trying
to hide the optimization done.

And in that case there is a reason why this is desirable. In a program such
as bashdb when a "quit" is done we may really need to quit several levels of
shells that may have gotten invoked in between.
Suppose you were writing a debugger for GNU Make. You'd have the same issue.
Or any program
that might call itself recursively and you don't have control in between of
how many *other* recursive shell invocations might have gone on.

So here we need the actual number counting whatever optimization was done,
not the virtual number of shells.  And here I don't think it too bad to have
the user aware that an optimization was done. When one debugs optimized C
code in gcc there are corresponding issues that any competent programmer
just needs to be aware of. Like in-lined functions or statements which
appear out of order because that's the way assembly code was reorganized.

------=_Part_53981_11265226.1220650597562
Content-Type: text/html; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

<div dir="ltr">Again, many thanks. I&#39;ll probably start putting this in prompt
information over the weekend. And again, alas it removes my excuse to
blame zsh for why my code is so broken in this regard ;-)<br><br>Comments in line.<br>
<br><div class="gmail_quote"><div class="Ih2E3d">On Fri, Sep 5, 2008 at 4:45 PM, Peter Stephenson <span dir="ltr">&lt;<a href="mailto:p.w.stephenson@ntlworld.com" target="_blank">p.w.stephenson@ntlworld.com</a>&gt;</span> wrote:<br>
<blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">
<div>On Fri, 5 Sep 2008 10:11:45 -0400&quot;Rocky Bernstein&quot; &lt;<a href="mailto:rocky.bernstein@gmail.com" target="_blank">rocky.bernstein@gmail.com</a>&gt; wrote:<br>
&gt; It would be great if there were a way to get the subshell level nesting. ksh<br>
&gt; uses .sh.level and bash BASH_SUBSHELL.<br>
<br>
</div>This is easy;</blockquote></div><div><br>(Thought it would; but it&#39;s good to get that confirmed.) <br>&nbsp;<br></div><div class="Ih2E3d"><blockquote class="gmail_quote" style="border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">

 the only decision is whether the value should reflect a<br>
logical or an actual subshell. &nbsp;I think the former, since the only<br>
difference is to optimise out an exec when the shell is going to exit<br>
anyway, and I think from the user&#39;s point of view that should be treated<br>
identically to a real exec.</blockquote></div><div><br>I
described my motivation. First as status information, second to let
folks realize that values may have gotten discarded and third to make
facilitate picking up state information to be passed back (without
doing unnecessary work in the majority of the cases where there is no
subshell change.)<br>
<br>I think some in some of the optimization cases it doesn&#39;t matter all that much, so I leave it to your judgment.<br><br>However,
I find it interesting because I had a discussion about something very
similar with David Korn regarding SHLVL which should be added soon to
ksh. He had the same question because in some cases he optimizes a
recursive shell out if the say the shell call is in fact the last line
of the script.&nbsp; What was done there was to set SHLVL to be exactly what
goes on, not trying to hide the optimization done.<br>
<br>And in that case there is a reason why this is desirable. In a
program such as bashdb when a &quot;quit&quot; is done we may really need to quit
several levels of shells that may have gotten invoked in between.<br>Suppose you were writing a debugger for GNU Make. You&#39;d have the same issue. Or any program <br>
that might call itself recursively and you don&#39;t have control in
between of how many *other* recursive shell invocations might have gone
on. <br><br>So
here we need the actual number counting whatever optimization was done,
not the virtual number of shells.&nbsp; And here I don&#39;t think it too bad to
have the user aware that an optimization was done. When one debugs
optimized C code in gcc there are corresponding issues that any
competent programmer just needs to be aware of. Like in-lined functions
or statements which appear out of order because that&#39;s the way assembly
code was reorganized. <br>
</div></div><br></div>

------=_Part_53981_11265226.1220650597562--

