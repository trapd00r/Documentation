From hzoli@cs.elte.hu Sat Jul 20 02:09:16 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.5/8.7.3/2) with ESMTP id CAA21383 for <mason@werple.mira.net.au>; Sat, 20 Jul 1996 02:09:14 +1000 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id MAA21589; Fri, 19 Jul 1996 12:03:21 -0400 (EDT)
Resent-Date: Fri, 19 Jul 1996 12:01:21 -0400 (EDT)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199607191600.SAA08613@bolyai.cs.elte.hu>
Subject: Re: Bug in case stmt with '('
To: schaefer@nbn.com
Date: Fri, 19 Jul 1996 18:00:37 +0200 (MET DST)
Cc: zsh-users@math.gatech.edu
In-Reply-To: <960718192358.ZM702@candle.brasslantern.com> from Bart Schaefer at "Jul 18, 96 07:23:58 pm"
Organization: Dept. of Comp. Sci., Eotvos University, Budapest, Hungary
Phone: (36 1)2669833 ext: 2667, home phone: (36 1) 2752368
X-Mailer: ELM [version 2.4ME+ PL16 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"yfdIC3.0.3G5.G5xxn"@euclid>
Resent-From: zsh-users@math.gatech.edu
X-Mailing-List: <zsh-users@math.gatech.edu> archive/latest/315
X-Loop: zsh-users@math.gatech.edu
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 2616
Status: O

> > Actually the patch below is a simpler solution for that.
> 
> Is it?  It handles (v|w)), but it doesn't handle this case:
> 
> 	case v in
> 	(v|w)|x)   gigo="case '(v|w)|x)'"
> 		echo $gigo;;
> 	*)      gigo="case '*)'"
> 		echo $gigo;;
> 	esac

All right.  It was late at night when I wrote that.  Below is an other
attempt.  It is a patch against unmodified 3_0-pre3.

> > An other
> > advantage of that is that hgetc()/hungetc() is not used which is
> > scientifically better since tokens should be recognized in lex.c
> 
> Yes, I know, but there are other cases in parse.c that lookahead with
> hgetc().

hgetc/hungetc is only used in parse.c to discard the remaining line after a
parse error.  It is not used for parsing.  For parsing only the tokens
return by yylex() must be used.

Zoltan


*** Src/parse.c	1996/07/13 20:26:35	2.20
--- Src/parse.c	1996/07/19 15:38:54
***************
*** 502,540 ****
  	    break;
  	}
  	str = tokstr;
! 	yylex();
! 	while (tok == BAR) {
! 	    char *str2;
! 	    int sl = strlen(str);
! 
  	    yylex();
  	    if (tok == OUTPAR) {
  		str2 = ncalloc(sl + 2);
  		strcpy(str2, str);
  		str2[sl] = Bar;
  		str2[sl+1] = '\0';
  		str = str2;
  		break;
  	    }
- 	    if (tok != STRING)
- 		YYERRORV;
- 	    str2 = ncalloc(sl + strlen(tokstr) + 2);
- 	    strcpy(str2, str);
- 	    str2[sl] = Bar;
- 	    strcpy(str2 + sl + 1, tokstr);
- 	    str = str2;
- 	    yylex();
  	}
- 	incasepat = 0;
- 	incmdpos = 1;
- 	if (tok != OUTPAR) {
- 	    /* POSIX allows (foo*) patterns */
- 	    char *s = str;
- 
- 	    if (skipparens(Inpar, Outpar, &s) || *s)
- 		YYERRORV;
- 	} else
- 	    yylex();
  	addlinknode(pats, str);
  	addlinknode(lists, par_list());
  	n++;
--- 502,546 ----
  	    break;
  	}
  	str = tokstr;
! 	incasepat = 0;
! 	incmdpos = 1;
! 	for (;;) {
  	    yylex();
  	    if (tok == OUTPAR) {
+ 		incasepat = 0;
+ 		incmdpos = 1;
+ 		yylex();
+ 		break;
+ 	    } else if (tok == BAR) {
+ 		char *str2;
+ 		int sl = strlen(str);
+ 
+ 		incasepat = 1;
+ 		incmdpos = 0;
  		str2 = ncalloc(sl + 2);
  		strcpy(str2, str);
  		str2[sl] = Bar;
  		str2[sl+1] = '\0';
  		str = str2;
+ 	    } else if (tok == STRING) {
+ 		char *str2;
+ 		int sl = strlen(str);
+ 
+ 		if (str[sl - 1] != Bar)
+ 		    YYERRORV;
+ 		str2 = ncalloc(sl + strlen(tokstr) + 1);
+ 		strcpy(str2, str);
+ 		strcpy(str2 + sl, tokstr);
+ 		str = str2;
+ 	    } else {
+ 		/* POSIX allows (foo*) patterns */
+ 		char *s = str;
+ 
+ 		if (skipparens(Inpar, Outpar, &s) || *s)
+ 		    YYERRORV;
  		break;
  	    }
  	}
  	addlinknode(pats, str);
  	addlinknode(lists, par_list());
  	n++;


