From zsh-workers-return-28363-mason-zsh=primenet.com.au@zsh.org Sun Oct 24 19:19:16 2010
Return-Path: <zsh-workers-return-28363-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3824 invoked by alias); 24 Oct 2010 19:19:16 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28363
Received: (qmail 15622 invoked from network); 24 Oct 2010 19:19:08 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at ntlworld.com designates 81.103.221.58 as permitted sender)
Date: Sun, 24 Oct 2010 19:12:29 +0100
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: zsh workers <zsh-workers@zsh.org>
Subject: Re: Fun redraw issue with double-width characters
Message-ID: <20101024191229.0bc47b23@pws-pc.ntlworld.com>
In-Reply-To: <AANLkTinpzD04E3cm+myCUDVEXvhUhQc7VyyNzz2WxzvL@mail.gmail.com>
References: <AANLkTinpzD04E3cm+myCUDVEXvhUhQc7VyyNzz2WxzvL@mail.gmail.com>
X-Mailer: Claws Mail 3.7.6 (GTK+ 2.20.1; x86_64-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-Cloudmark-Analysis: v=1.1 cv=3ENABmdyEd/Fm7fR7+mZIuMDn6+IErAeEhlfWBImZFk= c=1 sm=0 a=vhjmSAFYNw8A:10 a=IkcTkHD0fZMA:10 a=pGLkceISAAAA:8 a=NLZqzBF-AAAA:8 a=PEsLF-vSsDrCeRYza98A:9 a=c8C0CkNe9Ot8JvIW9mMA:7 a=GdxSF2xA3b7XDTOAdHtJxm5VGioA:4 a=QEXdDO2ut3YA:10 a=MSl-tDqOz04A:10 a=_dQi-Dcv4p4A:10 a=HpAAvcLHHh0Zw7uRqdWCyQ==:117

On Sun, 24 Oct 2010 14:11:08 +0200
Mikael Magnusson <mikachu@gmail.com> wrote:
> I got a random thought, "what if i enter five doublewidth characters,
> then go back to the start and enter a bunch of spaces". Turns out
> doing that causes the line to clear and cursor to move up one line.
> Doesn't happen with four or less.

I think that may depend on what you're inserting: if you're inserting
stuff such that the character you're inserting changes the line near
the start, it may happen early.   But this may be a wild goose chase.

> Long story short, it happens only if
> ich1 is defined in the terminfo for the current $TERM, which it
> happens to be for rxvt-unicode, but also for rxvt. It doesn't matter
> if you're using xterm or rxvt or urxvt, just set TERM=3Drxvt, enter five
> =E3=81=BE and go back to the start and hold down space. I don't really kn=
ow
> where to begin debugging this.

Actually, there's only one use of insert in the entire source, which is
in a quite short chunk in zle_refresh.c, so localising it was the easy
bit.

After staring enough I think I've worked out what's going on, but you
might want to stare at it, too.  Much of this is reformatting for
clarity, the important bit is near the end where I've moved an extra
chunk inside an #ifdef MULTIBYTE_SUPPORT with a new comment.

Index: Src/Zle/zle_refresh.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_refresh.c,v
retrieving revision 1.81
diff -p -u -r1.81 zle_refresh.c
--- Src/Zle/zle_refresh.c	17 Oct 2010 17:59:27 -0000	1.81
+++ Src/Zle/zle_refresh.c	24 Oct 2010 18:06:22 -0000
@@ -2000,7 +2000,7 @@ refreshline(int ln)
 		   newline: foobar	 / characters, then we have six matches */
 		if (tccan(TCDEL)) {
 		    int first =3D 1;
-		    for (i =3D 1; ol[i].chr; i++)
+		    for (i =3D 1; ol[i].chr; i++) {
 			if (tcdelcost(i) < wpfxlen(ol + i, nl)) {
 			    /*
 			     * Some terminals will output the current
@@ -2023,15 +2023,19 @@ refreshline(int ln)
 			    i =3D 0;
 			    break;
 			}
+		    }
 		    if (!i)
 			continue;
 		}
-		/* inserting characters - characters pushed off the right should be
-		   annihilated, but we don't do this if we're on the last line lest
-		   undesired scrolling occurs due to `illegal' characters on screen */
-
-		if (tccan(TCINS) && (vln !=3D lines - 1)) {	/* not on last line */
-		    for (i =3D 1; nl[i].chr; i++)
+		/*
+		 * inserting characters - characters pushed off the right
+		 * should be annihilated, but we don't do this if we're on the
+		 * last line lest undesired scrolling occurs due to `illegal'
+		 * characters on screen
+		 */=20
+		if (tccan(TCINS) && (vln !=3D lines - 1)) {
+		    /* not on last line */
+		    for (i =3D 1; nl[i].chr; i++) {
 			if (tcinscost(i) < wpfxlen(ol, nl + i)) {
 			    tc_inschars(i);
 			    zwrite(nl, i);
@@ -2044,19 +2048,37 @@ refreshline(int ln)
 #endif
 			    char_ins +=3D i;
 			    ccs =3D (vcs +=3D i);
-			    /* if we've pushed off the right, truncate oldline */
-			    for (i =3D 0; ol[i].chr && i < winw - ccs; i++);
+			    /*
+			     * if we've pushed off the right, truncate
+			     * oldline
+			     */
+			    for (i =3D 0; ol[i].chr && i < winw - ccs; i++)
+				;
 #ifdef MULTIBYTE_SUPPORT
 			    while (ol[i].chr =3D=3D WEOF)
 				i++;
-#endif
 			    if (i >=3D winw - ccs) {
+				/*
+				 * Yes, we're over the right.
+				 * Make sure we truncate at the real
+				 * character, not a WEOF added to
+				 * make up the width.
+				 */
+				while (ol[i-1].chr =3D=3D WEOF)
+				    i--;
 				ol[i] =3D zr_zr;
 				ins_last =3D 1;
 			    }
+#else
+			    if (i >=3D winw - ccs) {
+				ol[i] =3D zr_zr;
+				ins_last =3D 1;
+			    }
+#endif
 			    i =3D 0;
 			    break;
 			}
+		    }
 		    if (!i)
 			continue;
 		}

--=20
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

