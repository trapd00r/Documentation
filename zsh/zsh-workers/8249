From zsh-workers-return-8249-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Oct 14 11:41:32 1999
Return-Path: <zsh-workers-return-8249-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2147 invoked from network); 14 Oct 1999 11:41:29 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Oct 1999 11:41:29 -0000
Received: (qmail 26118 invoked by alias); 14 Oct 1999 11:41:18 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8249
Received: (qmail 26108 invoked from network); 14 Oct 1999 11:41:15 -0000
Date: Thu, 14 Oct 1999 13:41:10 +0200 (MET DST)
Message-Id: <199910141141.NAA13535@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Wed, 13 Oct 1999 16:34:23 +0100
Subject: PATCH: Re: _urls, _netscape, a seg fault and new completion thoughts


Oliver Kiddle wrote:

> I hadn't realised the significance of the part about line and options in
> the documentation. It should possibly be made very clear in the
> _arguments documentation that you need to declare line and opt_args
> local.

I hope this patch makes this clear enough (and I didn't mean to
critize anyone but me because indeed the manual didn't say much about
that before).

> One other thought I have relating to the new completion system stems
> from the following line which I still have in my .zshrc:
> 
> compctl -M 'm:{a-z}={A-Z}'
> 
> It might be better if a configuration key was added to give a default
> matching control.

A configuration key wouldn't easily help here, because one can give 
multiple match global specs and stuffing them together would suggest
to separate them with colons, then we need quoting for the
non-separating colons and so on. Also, this would still require us to
use `compctl' somewhere inside the shell code (and probably so often
that it may become expensive). So, instead of an compconfig key, the
patch below adds the special array `compmatchers' to the compctl
module as a next step to make `compctl' superfluous. The value of this
array directly corresponds to `compctl -M', you can set `compmatchers'
and list the contents with `compctl'. I also made the `compctl' module
be autoloaded on the use of `compmatchers'.

> The only other compctl line I have left in .zshrc is:
> compctl -k '( )' true false
> So to completely cleanse my setup of the old completion system I'd also
> have to create a function which explicitly completes nothing.

The patch adds `Builtins/_nothing' which just spews out a message.

Then I had a look at the utility functions (well, some of them) and
made them accept the `-[PSrRqM]' options if they didn't accept them
already.

Finally, `_nothing' made me think of this: a new config key
`warning_format' that, if set, makes `_main_complete' print a message
when no match could be generated. The `%d' is replaced by a string
containing the descriptions for the types of matches that were
tried. Did I get the commas right this time?

Bye
 Sven

diff -u -r oldsrc/Zle/compctl.c Src/Zle/compctl.c
--- oldsrc/Zle/compctl.c	Wed Oct 13 16:17:35 1999
+++ Src/Zle/compctl.c	Thu Oct 14 11:43:25 1999
@@ -122,6 +122,33 @@
     return r;
 }
 
+/* Set the global match specs. */
+
+/**/
+static int
+set_gmatcher(char *name, char **argv)
+{
+    Cmlist l = NULL, *q = &l, n;
+    Cmatcher m;
+
+    while (*argv) {
+	if ((m = parse_cmatcher(name, *argv)) == pcm_err)
+	    return 1;
+	*q = n = (Cmlist) zhalloc(sizeof(struct cmlist));
+	n->next = NULL;
+	n->matcher = m;
+	n->str = *argv++;
+
+	q = &(n->next);
+    }
+    freecmlist(cmatcher);
+    PERMALLOC {
+	cmatcher = cpcmlist(l);
+    } LASTALLOC;
+
+    return 1;
+}
+
 /* Try to get the global matcher from the given compctl. */
 
 /**/
@@ -130,27 +157,13 @@
 {
     if (!strcmp(*argv, "-M")) {
 	char **p = ++argv;
-	Cmlist l = NULL, *q = &l, n;
-	Cmatcher m;
 
 	while (*p) {
 	    if (**p++ == '-')
 		return 0;
 	}
-	while (*argv) {
-	    if ((m = parse_cmatcher(name, *argv)) == pcm_err)
-		return 2;
-	    *q = n = (Cmlist) zhalloc(sizeof(struct cmlist));
-	    n->next = NULL;
-	    n->matcher = m;
-	    n->str = *argv++;
-
-	    q = &(n->next);
-	}
-	freecmlist(cmatcher);
-	PERMALLOC {
-	    cmatcher = cpcmlist(l);
-	} LASTALLOC;
+	if (set_gmatcher(name, argv))
+	    return 2;
 
 	return 1;
     }
@@ -2586,6 +2599,42 @@
 			(id ? cond_str(a, 1, 1) : NULL), 0);
 }
 
+/**/
+static void
+cmsetfn(Param pm, char **v)
+{
+    set_gmatcher(pm->nam, v);
+}
+
+/**/
+static char **
+cmgetfn(Param pm)
+{
+    int num;
+    Cmlist p;
+    char **ret, **q;
+
+    for (num = 0, p = cmatcher; p; p = p->next, num++);
+
+    ret = (char **) zhalloc((num + 1) * sizeof(char *));
+
+    for (q = ret, p = cmatcher; p; p = p->next, q++)
+	*q = dupstring(p->str);
+    *q = NULL;
+
+    return ret;
+}
+
+/**/
+static void
+cmunsetfn(Param pm, int exp)
+{
+    char *dummy[1];
+
+    dummy[0] = NULL;
+    set_gmatcher(pm->nam, dummy);
+}
+
 static struct builtin bintab[] = {
     BUILTIN("compctl", 0, bin_compctl, 0, -1, 0, NULL, NULL),
     BUILTIN("compgen", 0, bin_compgen, 1, -1, 0, NULL, NULL),
@@ -2605,6 +2654,10 @@
     WRAPDEF(comp_wrapper),
 };
 
+static struct paramdef patab[] = {
+    PARAMDEF("compmatchers", PM_ARRAY|PM_SPECIAL, NULL, cmsetfn, cmgetfn, cmunsetfn)
+};
+
 /**/
 int
 setup_compctl(Module m)
@@ -2621,6 +2674,7 @@
 {
     if(!(addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab)) |
 	 addconddefs(m->nam, cotab, sizeof(cotab)/sizeof(*cotab)) |
+	 addparamdefs(m->nam, patab, sizeof(patab)/sizeof(*patab)) |
 	 !addwrapper(m, wrapper)))
 	return 1;
     return 0;
@@ -2634,6 +2688,7 @@
 {
     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
     deleteconddefs(m->nam, cotab, sizeof(cotab)/sizeof(*cotab));
+    deleteparamdefs(m->nam, patab, sizeof(patab)/sizeof(*patab));
     deletewrapper(m, wrapper);
     return 0;
 }
diff -u -r oldsrc/Zle/compctl.mdd Src/Zle/compctl.mdd
--- oldsrc/Zle/compctl.mdd	Thu Oct 14 11:31:06 1999
+++ Src/Zle/compctl.mdd	Thu Oct 14 11:34:12 1999
@@ -4,4 +4,6 @@
 
 autoprefixconds="prefix suffix between after"
 
+autoparams="compmatchers"
+
 objects="compctl.o"
diff -u olddoc/Zsh/compctl.yo Doc/Zsh/compctl.yo
--- olddoc/Zsh/compctl.yo	Wed Oct 13 16:17:45 1999
+++ Doc/Zsh/compctl.yo	Thu Oct 14 13:10:26 1999
@@ -132,7 +132,8 @@
 options specified by the tt(-D) flag.
 
 The form with tt(-M) as the first and only option defines global
-matching specifications, as described below in noderef(Matching Control).
+matching specifications, as described below in noderef(Matching
+Control).
 
 texinode(Option Flags)(Alternative Completion)(Command Flags)(Programmable Completion Using compctl)
 sect(Option Flags)
@@ -820,7 +821,9 @@
 completion is attempted for any command, the code will try the
 specifications in order until one matches.  This allows one to define
 simple and fast matches to be used first, more powerful matchers as a
-second choice, and so on.
+second choice, and so on. These global matchers can also be defined by 
+setting the tt(compmatchers) special array to the strings that would
+otherwise be given to tt(compctl -M) as arguments.
 
 For example, one can make the code match trial completions that contain
 the string on the command line as a substring, not just at the
diff -u olddoc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- olddoc/Zsh/compsys.yo	Wed Oct 13 16:17:45 1999
+++ Doc/Zsh/compsys.yo	Thu Oct 14 13:39:20 1999
@@ -13,14 +13,18 @@
 as `widgets'.
 
 Note that with the function-based completions described here, it
-is also possible to use the `tt(compctl -M ...)' mechanism to specify
+is also possible to use the `tt(compctl -M ...)' mechanism and the
+tt(compmatchers) special array to specify
 global matching control, such as case-insensitivity (`tt(abc)' will complete
 to a string beginning `tt(ABC)'), or wildcard behaviour on
 certain anchors (`tt(a-d)' will complete to abc-def as if there were a
 `tt(*)' after the `a').  See
 ifzman(the section `Matching Control' in zmanref(zshcompctl))\
 ifnzman(noderef(Matching Control))
-for further details.
+for further details. Note that it is recommended to use the the
+tt(compmatchers) array instead of tt(compctl) to define global
+matchers when using the function based completion system, although
+using tt(compctl -M) still works.
 
 startmenu()
 menu(Initialization)
@@ -674,8 +678,8 @@
 tt(_path_files) function.
 
 Like other utility functions, this function accepts the `tt(-V)',
-`tt(-J)', and `tt(-X)' options with an argument and passes them to the
-tt(compadd) builtin.
+`tt(-J)', `tt(-X)', `tt(-M)', `tt(-P)', `tt(-S)', `tt(-r)', `tt(-R)', and
+`tt(-q)' options and passes them to the tt(compadd) builtin.
 )
 item(tt(_sep_parts))(
 This function gets as arguments alternating arrays and separators.
@@ -686,8 +690,9 @@
 complete the string  `tt(f)' to `tt(foo)' and the string `tt(b@n)' to
 `tt(bar@news)'.
 
-This function passes the `tt(-V)', `tt(-J)', and `tt(-X)' options and
-their arguments to the tt(compadd) builtin used to add the matches.
+This function passes the `tt(-V)', `tt(-J)', `tt(-X)', `tt(-M)', `tt(-P)',
+`tt(-S)', `tt(-r)', `tt(-R)', and `tt(-q)' options and their arguments
+to the tt(compadd) builtin used to add the matches.
 )
 item(tt(_path_files) and tt(_files))(
 The function tt(_path_files) is used throughout the shell code
@@ -705,9 +710,9 @@
 it was passed and, if that generated no matches, calls tt(_path_files) again
 without any tt(-g) or tt(-/) option, thus generating all filenames.
 
-These functions also accept the `tt(-J)', `tt(-V)', `tt(-X)', `tt(-P)',
-`tt(-S)', `tt(-q)', `tt(-r)', and `tt(-R)' options from the
-tt(compadd) builtin.
+These functions also accept the `tt(-J)', `tt(-V)', `tt(-X)',
+`tt(-M)', `tt(-P)', `tt(-S)', `tt(-q)', `tt(-r)', and `tt(-R)' options
+from the tt(compadd) builtin.
 
 Finally, the tt(_path_files) function supports two configuration keys.
 startitem()
@@ -865,7 +870,16 @@
 value of 300 (to make it distinguishable from other return values)
 after setting the global `tt(line)' and `tt(opt_args)'
 parameters as described below and without resetting any changes made
-to the special parameters such as tt(PREFIX) and tt(words).
+to the special parameters such as tt(PREFIX) and tt(words). Note that
+this means that a function calling tt(_arguments) with at least one
+action containing such a `tt(->)var(string)' has to declare
+appropriate local parameters as in:
+
+example(local state line
+typeset -A opt_args)
+
+This will ensure that tt(_arguments) does not create unused global
+parameters.
 
 A string in
 braces will be evaluated to generate the matches and if the
@@ -1047,7 +1061,14 @@
 
 One last difference is that this function uses the associative array
 tt(val_args) to report values and their arguments (but otherwise this
-is the same as the tt(opt_args) association used by tt(_arguments)).
+is the same as the tt(opt_args) association used by
+tt(_arguments)). This also means that the function calling tt(_values) 
+should declare the tt(state) and tt(val_args) parameters as in:
+
+example(local state line
+typeset -A val_args)
+
+when using an action of the form `tt(->)var(string)'.
 )
 item(tt(_regex_arguments))(
 This function is a compiler to generate a completion function.  The
@@ -1386,6 +1407,12 @@
 item(tt(message_format))(
 Like tt(description_format), but used when displaying messages in
 those places where no completions can automatically be generated.
+)
+item(tt(warning_format))(
+Like the previous two, but used by tt(_main_complete) to show a
+warning if no matches could be generated. Any `tt(%d)' sequence in the 
+value will be replaced by the descriptions for the matches that were
+expected.
 )
 item(tt(option_prefix))(
 If set to a non-empty value, options will only be generated as
diff -u -r oldcompletion/Builtins/_nothing Completion/Builtins/_nothing
--- oldcompletion/Builtins/_nothing	Thu Oct 14 13:12:51 1999
+++ Completion/Builtins/_nothing	Thu Oct 14 11:45:22 1999
@@ -0,0 +1,3 @@
+#compdef true false
+
+_message 'no argument or option'
diff -u -r oldcompletion/Core/_description Completion/Core/_description
--- oldcompletion/Core/_description	Wed Oct 13 16:18:19 1999
+++ Completion/Core/_description	Thu Oct 14 12:02:02 1999
@@ -7,6 +7,8 @@
   shift
 fi
 
+_lastdescr=( "$_lastdescr[@]" "$2" )
+
 if [[ -n "$compconfig[group_matches]" ]]; then
   if [[ -n "$compconfig[description_format]" ]]; then
     eval "$1=($gropt ${(q)2} -X ${(q)compconfig[description_format]//\\%d/$2})"
diff -u -r oldcompletion/Core/_files Completion/Core/_files
--- oldcompletion/Core/_files	Wed Oct 13 16:18:19 1999
+++ Completion/Core/_files	Thu Oct 14 13:29:20 1999
@@ -17,9 +17,12 @@
   # files and give up immediatly.
 
   opts=()
-  while getopts "P:S:W:F:J:V:X:f/g:" opt; do
-    [[ "$opt" = f ]] && return
-    [[ "$opt" = [PSWFJVX] ]] && opts=("$opts[@]" "-$opt" "$OPTARG")
+  while getopts "P:S:qr:R:W:F:J:V:X:f/g:M:" opt; do
+    case "$opt" in
+    f)            return;;
+    [PSrRWFJVXM]) opts=("$opts[@]" "-$opt" "$OPTARG");;
+    q)            opts=("$opts[@]" -q);;
+    esac
   done
 
   _path_files "$opts[@]" && ret=0
diff -u -r oldcompletion/Core/_main_complete Completion/Core/_main_complete
--- oldcompletion/Core/_main_complete	Wed Oct 13 16:18:19 1999
+++ Completion/Core/_main_complete	Thu Oct 14 13:38:04 1999
@@ -24,6 +24,8 @@
 
 local comp post ret=1 _compskip
 
+typeset -U _lastdescr
+
 setopt localoptions nullglob rcexpandparam
 unsetopt markdirs globsubst shwordsplit nounset ksharrays
 
@@ -55,6 +57,24 @@
   "$post"
 done
 comppostfuncs=()
+
+_lastdescr=( "\`${(@)^_lastdescr:#}'" )
+if [[ compstate[nmatches] -eq 0 &&
+      -n "$compconfig[warning_format]" && $#_lastdescr -ne 0 ]]; then
+  local str
+
+  compstate[list]=list
+  compstate[force_list]=yes
+  compstate[insert]=''
+
+  case $#_lastdescr in
+  1) str="$_lastdescr[1]";;
+  2) str="$_lastdescr[1] or $_lastdescr[2]";;
+  *) str="${(j:, :)_lastdescr[1,-2]}, or $_lastdescr[-1]";;
+  esac
+
+  compadd -UX "${compconfig[warning_format]//\\%d/$str}" -n ''
+fi
 
 [[ "$compconfig[last_prompt]" = always ]] && compstate[last_prompt]=yes
 
diff -u -r oldcompletion/Core/_message Completion/Core/_message
--- oldcompletion/Core/_message	Wed Oct 13 16:18:20 1999
+++ Completion/Core/_message	Thu Oct 14 11:50:14 1999
@@ -2,15 +2,14 @@
 
 local format
 
-format="$compconfig[message_format]"
-[[ -z "$format" ]] && format="$compconfig[description_format]"
+format="${compconfig[message_format]:-$compconfig[description_format]}"
 
 if [[ -n "$format" ]]; then
   if [[ $compstate[nmatches] -eq 0 ]]; then
     compstate[list]=list
+    compstate[force_list]=yes
     compstate[insert]=''
     compadd -UX "${format//\\%d/$1}" -n ''
-    compstate[force_list]=yes
   else
     compadd -X "${format//\\%d/$1}" -n '' && compstate[force_list]=yes
   fi
diff -u -r oldcompletion/Core/_multi_parts Completion/Core/_multi_parts
--- oldcompletion/Core/_multi_parts	Wed Oct 13 16:18:20 1999
+++ Completion/Core/_multi_parts	Thu Oct 14 13:23:30 1999
@@ -8,16 +8,24 @@
 # separator character are then completed independently.
 
 local sep matches pref npref i tmp1 group expl menu pre suf opre osuf cpre
+local opts sopts match
 typeset -U tmp2
 
 # Get the options.
 
 group=()
 expl=()
-while getopts "J:V:X:" opt; do
+opts=()
+sopts=()
+while getopts "J:V:X:P:S:r:R:qM:" opt; do
   case "$opt" in
-  [JV]) group=("-$opt" "$OPTARG");;
-  X)    expl=(-X "$OPTARG");;
+  [JV])  group=("-$opt" "$OPTARG");;
+  X)     expl=(-X "$OPTARG");;
+  P)     opts=( "$opts[@]" -P "$OPTARG")
+         sopts=( "$sopts[@]" -P "$OPTARG");;
+  [SrR]) sopts=( "$sopts[@]" -P "$OPTARG");;
+  q)     sopts=( "$sopts[@]" -q);;
+  M)     match="$OPTARG";;
   esac
 done
 shift OPTIND-1
@@ -57,7 +65,7 @@
 # If the string from the line matches at least one of the strings,
 # we use only the matching strings.
 
-compadd -O tmp1 -M "r:|${sep}=* r:|=*" - "$matches[@]"
+compadd -O tmp1 -M "r:|${sep}=* r:|=* $match" - "$matches[@]"
 
 (( $#tmp1 )) && matches=( "$tmp1[@]" )
 
@@ -106,11 +114,11 @@
 	SUFFIX="$suf"
 
 	if (( $#tmp2 )); then
-	  compadd "$group[@]" "$expl[@]" -p "$pref" -qS "$sep" \
-                  -M "r:|${sep}=* r:|=*" - "$tmp1[1]"
+	  compadd "$group[@]" "$expl[@]" -p "$pref" -qS "$sep" "$opts[@]" \
+                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[1]"
         else
-	  compadd "$group[@]" "$expl[@]" -p "$pref" \
-                  -M "r:|${sep}=* r:|=*" - "$tmp1[1]"
+	  compadd "$group[@]" "$expl[@]" -p "$pref" "$sopts[@]" \
+                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[1]"
         fi
 	return 0
       fi
@@ -121,7 +129,7 @@
 
       PREFIX="$pre"
       SUFFIX="$suf"
-      compadd -O matches -M "r:|${sep}=* r:|=*" - "$matches[@]"
+      compadd -O matches -M "r:|${sep}=* r:|=* $match" - "$matches[@]"
 
       if [[ "$pre" = *${sep}* ]]; then
  	PREFIX="${cpre}${pre%%${sep}*}"
@@ -138,12 +146,12 @@
 
         tmp2="$pre$suf"
         if [[ "$tmp2" = *${sep}* ]]; then
-          compadd "$group[@]" "$expl[@]" \
+          compadd "$group[@]" "$expl[@]" "$sopts[@]" \
                   -p "$pref" -s "${sep}${tmp2#*${sep}}" \
-                  -M "r:|${sep}=* r:|=*" - "$tmp1[@]"
+                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[@]"
         else
-          compadd "$group[@]" "$expl[@]" -p "$pref"\
-                  -M "r:|${sep}=* r:|=*" - "$tmp1[@]"
+          compadd "$group[@]" "$expl[@]" -p "$pref" "$sopts[@]" \
+                  -M "r:|${sep}=* r:|=* $match" - "$tmp1[@]"
         fi
       else
         # With normal completion we add all matches one-by-one with
@@ -152,12 +160,12 @@
 
         for i in "${(@M)matches:#(${(j:|:)~tmp1})*}"; do
 	  if [[ "$i" = *${sep}* ]]; then
-            compadd "$group[@]" "$expl[@]" -S '' \
+            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
 	            -p "$pref" -s "${i#*${sep}}" \
-                    -M "r:|${sep}=* r:|=*" - "${i%%${sep}*}${sep}"
+                    -M "r:|${sep}=* r:|=* $match" - "${i%%${sep}*}${sep}"
           else
-            compadd "$group[@]" "$expl[@]" -S '' -p "$pref" \
-                    -M "r:|${sep}=* r:|=*" - "$i"
+            compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" \
+                    -M "r:|${sep}=* r:|=* $match" - "$i"
           fi
         done
       fi
@@ -173,11 +181,11 @@
       SUFFIX="$suf"
 
       if [[ -n "$suf" ]]; then
-        compadd "$group[@]" "$expl[@]" -s "$suf" \
-                -M "r:|${sep}=* r:|=*" - "$pref$pre"
+        compadd "$group[@]" "$expl[@]" -s "$suf" "$sopts[@]" \
+                -M "r:|${sep}=* r:|=* $match" - "$pref$pre"
       else
-        compadd "$group[@]" "$expl[@]" -S '' \
-                -M "r:|${sep}=* r:|=*" - "$pref$pre"
+        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
+                -M "r:|${sep}=* r:|=* $match" - "$pref$pre"
       fi
       return 0
     fi
@@ -208,7 +216,8 @@
     SUFFIX=""
 
     [[ -n "$pref" && "$orig" != "$pref" ]] &&
-        compadd "$group[@]" "$expl[@]" -S '' -M "r:|${sep}=* r:|=*" - "$pref"
+        compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" \
+                -M "r:|${sep}=* r:|=* $match" - "$pref"
 
     return
   fi
diff -u -r oldcompletion/Core/_path_files Completion/Core/_path_files
--- oldcompletion/Core/_path_files	Wed Oct 13 16:18:20 1999
+++ Completion/Core/_path_files	Thu Oct 14 13:29:04 1999
@@ -6,7 +6,7 @@
 local linepath realpath donepath prepath testpath exppath
 local tmp1 tmp2 tmp3 tmp4 i orig pre suf tpre tsuf opre osuf cpre
 local pats haspats=no ignore group expl addpfx addsfx remsfx
-local nm=$compstate[nmatches] menu
+local nm=$compstate[nmatches] menu match matcher
 
 typeset -U prepaths exppaths
 
@@ -23,10 +23,11 @@
 addsfx=()
 remsfx=()
 expl=()
+matcher=()
 
 # Get the options.
 
-while getopts "P:S:qr:R:W:F:J:V:X:f/g:" opt; do
+while getopts "P:S:qr:R:W:F:J:V:X:f/g:M:" opt; do
   case "$opt" in
   P)     addpfx=(-P "$OPTARG")
          ;;
@@ -68,6 +69,9 @@
          pats=("$pats[@]" ${=OPTARG})
 	 haspats=yes
 	 ;;
+  M)     match="$OPTARG"
+         matcher=(-M "$OPTARG")
+         ;;
   esac
 done
 
@@ -124,9 +128,11 @@
   # Now call compgen.
 
   if [[ -z "$gopt" ]]; then
-    compgen "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" "$tmp1[@]" $sopt
+    compgen "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
+            "$tmp1[@]" "$matcher[@]" $sopt
   else
-    compgen "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" "$tmp1[@]" $sopt -g "$pats"
+    compgen "$addpfx[@]" "$addsfx[@]" "$group[@]" "$expl[@]" \
+            "$tmp1[@]" "$matcher[@]" $sopt -g "$pats"
   fi
 
   # If this generated any matches, we don't want to do in-path completion.
@@ -243,7 +249,7 @@
       # See which of them match what's on the line.
 
       tmp2=("$tmp1[@]")
-      compadd -D tmp1 "$ignore[@]" - "${(@)tmp1:t}"
+      compadd -D tmp1 "$ignore[@]" "$matcher[@]" - "${(@)tmp1:t}"
 
       # If no file matches, save the expanded path and continue with
       # the outer loop.
@@ -346,14 +352,14 @@
         if [[ "$tmp3" = */* ]]; then
 	  compadd -Qf -p "$linepath${testpath:q}" -s "/${tmp3#*/}" \
 	          -W "$prepath$realpath$testpath" "$ignore[@]" \
-		  "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" -M 'r:|/=* r:|=*' \
-		  "$group[@]" "$expl[@]" \
+		  "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" \
+                  -M "r:|/=* r:|=* $match" "$group[@]" "$expl[@]" \
 		  - "${(@)${(@)tmp1%%/*}:q}"
 	else
 	  compadd -Qf -p "$linepath${testpath:q}" \
 	          -W "$prepath$realpath$testpath" "$ignore[@]" \
-		   "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" -M 'r:|/=* r:|=*' \
-		   "$group[@]" "$expl[@]" \
+		   "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" \
+                   -M "r:|/=* r:|=* $match" "$group[@]" "$expl[@]" \
 		   - "${(@)tmp1:q}"
 	fi
       else
@@ -361,15 +367,15 @@
           for i in "$tmp1[@]"; do
 	    compadd -Qf -p "$linepath${testpath:q}" -s "/${${i#*/}:q}" \
 		    -W "$prepath$realpath$testpath" "$ignore[@]" \
-		    "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" -M 'r:|/=* r:|=*' \
-		    "$group[@]" "$expl[@]" \
+		    "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" \
+                    -M "r:|/=* r:|=* $match" "$group[@]" "$expl[@]" \
 		    - "${${i%%/*}:q}"
 	  done
         else
 	  compadd -Qf -p "$linepath${testpath:q}" \
 		  -W "$prepath$realpath$testpath" "$ignore[@]" \
-		  "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" -M 'r:|/=* r:|=*' \
-		  "$group[@]" "$expl[@]" \
+		  "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" \
+                  -M "r:|/=* r:|=* $match" "$group[@]" "$expl[@]" \
 		  - "${(@)tmp1:q}"
         fi
       fi
@@ -400,8 +406,8 @@
     SUFFIX=""
     compadd -Qf -p "$linepath${testpath:q}" \
 	    -W "$prepath$realpath$testpath" "$ignore[@]" \
-	    "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" -M 'r:|/=* r:|=*' \
-	    "$group[@]" "$expl[@]" \
+	    "$addpfx[@]" "$addsfx[@]" "$remsfx[@]" \
+            -M "r:|/=* r:|=* $match" "$group[@]" "$expl[@]" \
 	    - "${(@)tmp1:q}"
   fi
 done
@@ -417,7 +423,7 @@
   PREFIX="${opre}${osuf}"
   SUFFIX=""
   compadd -Q -S '' "$group[@]" "$expl[@]" \
-          -M 'r:|/=* r:|=*' -p "$linepath" - "$exppaths[@]"
+          -M "r:|/=* r:|=* $match" -p "$linepath" - "$exppaths[@]"
 fi
 
 [[ nm -ne compstate[nmatches] ]]
diff -u -r oldcompletion/Core/_sep_parts Completion/Core/_sep_parts
--- oldcompletion/Core/_sep_parts	Wed Oct 13 16:18:20 1999
+++ Completion/Core/_sep_parts	Thu Oct 14 13:21:30 1999
@@ -18,16 +18,20 @@
 # `-X explanation' options.
 
 local str arr sep test testarr tmparr prefix suffixes matchers autosuffix
-local matchflags opt group expl nm=$compstate[nmatches] opre osuf
+local matchflags opt group expl nm=$compstate[nmatches] opre osuf opts match
 
 # Get the options.
 
 group=()
 expl=()
-while getopts "J:V:X:" opt; do
+opts=()
+while getopts "J:V:X:P:S:r:R:qM:" opt; do
   case "$opt" in
   [JV]) group=("-$opt" "$OPTARG");;
   X)    expl=(-X "$OPTARG");;
+  q)    opts=( "$opts[@]" -q );;
+  M)    match="$OPTARG";;
+  *)    opts=( "$opts[@]" "-$opt" "$OPTARG" );;
   esac
 done
 shift OPTIND-1
@@ -142,14 +146,14 @@
 # If we have collected matching specifications, we build an array
 # from it that can be used as arguments to `compadd'.
 
-[[ $#matchers -gt 0 ]] && matchers=(-M "$matchers")
+[[ $#matchers+$#match -gt 0 ]] && matchers=(-M "$matchers $match")
 
 # Add the matches for each of the suffixes.
 
 PREFIX="$pre"
 SUFFIX="$suf"
 for i in "$suffixes[@]"; do
-  compadd -U "$group[@]" "$expl[@]" "$matchers[@]" "$autosuffix[@]" \
+  compadd -U "$group[@]" "$expl[@]" "$matchers[@]" "$autosuffix[@]" "$opts[@]" \
           -i "$IPREFIX" -I "$ISUFFIX" -p "$prefix" -s "$i" - "$testarr[@]"
 done
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

