From zsh-workers-return-28294-mason-zsh=primenet.com.au@zsh.org Fri Sep 24 15:30:40 2010
Return-Path: <zsh-workers-return-28294-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21723 invoked by alias); 24 Sep 2010 15:30:40 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28294
Received: (qmail 14495 invoked from network); 24 Sep 2010 15:30:38 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100924083011.ZM4574@torch.brasslantern.com>
Date: Fri, 24 Sep 2010 08:30:11 -0700
In-reply-to: <20100924152618.036db8d0@pwslap01u.europe.root.pri>
Comments: In reply to Peter Stephenson <Peter.Stephenson@csr.com>
 "Re: !!$ unitialized at first prompt" (Sep 24,  3:26pm)
References: <alpine.LNX.2.01.1009232317460.4754@hp>
	<alpine.LNX.2.01.1009240037470.4754@hp>
	<AANLkTikvXfMnkWiZ0kay=s67X=UFhiSvhJGdU120=-6R@mail.gmail.com>
	<20100924133936.245765b2@pwslap01u.europe.root.pri>
	<alpine.LNX.2.01.1009241014290.4754@hp>
	<20100924152618.036db8d0@pwslap01u.europe.root.pri>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: Zsh Workers <zsh-workers@zsh.org>
Subject: Re: !!$ unitialized at first prompt
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 24,  3:26pm, Peter Stephenson wrote:
}
} So, without adding additional complexity, doing it on reading in is
} the only sensible place in the other case (what it happens to do at
} that point is a different matter but if you've seen the completion
} system you'll realise interfacing to the lexical analyser just to
} split up words isn't much fun with our current implementation).

The complexity here seems to be that the history is stored as an
array of lines with pointers into each line for the word positions,
so it's not as simple as calling bufferwords() to get the parsed
result and then store all the individual words.

History is doing a complex task, attempting to maintain both the
lexical interpretation and literal text of the history.  In fact it
originally stored both separately -- excerpt from an ancient manual:

`toggle-literal-history (ESC-R ESC-r)'
     Toggle between literal and lexical history.  The default is lexical
     history unless the `HIST_LIT' option is set.

