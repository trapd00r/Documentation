From zsh-workers-return-9197-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jan 04 12:21:55 2000
Return-Path: <zsh-workers-return-9197-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11389 invoked from network); 4 Jan 2000 12:21:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 4 Jan 2000 12:21:54 -0000
Received: (qmail 29314 invoked by alias); 4 Jan 2000 12:21:47 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9197
Received: (qmail 29307 invoked from network); 4 Jan 2000 12:21:47 -0000
Date: Tue, 4 Jan 2000 13:21:46 +0100 (MET)
Message-Id: <200001041221.NAA02772@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Thu, 23 Dec 1999 19:57:15 +0300
Subject: Re: approximate completion in _path_files and multipart completion


Andrej Borsenkow wrote:

> I believe, we should more precisely define, what actually approximate completion
> means in case of _path_files.
> 
> I have /archive/sni/mr, approximate with 3 errors, and tried
> 
> /a/sin/mr<TAB>
> 
> keeping in mind the above path. To my surprise I got
> 
> bor@itsrm2% cd /a1/sin/mr
> a1/   u1@   var/
> /a/sin/mr
> 
> and this after *really* long time. No wonder - zsh had tried the whole
> filesystem three levels deep!
> 
> Looking at it I doubt, if any sensible way to mix both
> (_approximate+_path_files) exists. And, in any case, decision about how and
> where to use approximate matching should be made by final completion function.
> Only this one knows about the real meaning of ${PREIFX}${SUFFIX}.

The patch below tries to improve this for the three functions we have
that do the matching themselves and do some sort of multi-level
matching (or are there more of them nowadays?). It makes these
functions use approximate matching only if no matches for a certain
part can be generated without it.

But I agree, that all this is a bit, er... complicated. Should the
number of errors allowed be used for each part or for all parts
together and questions like this. If anyone has any ideas for possible 
improvements, I'd like to hear about them.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_multi_parts Completion/Core/_multi_parts
--- ../z.old/Completion/Core/_multi_parts	Tue Jan  4 10:21:17 2000
+++ Completion/Core/_multi_parts	Tue Jan  4 11:52:50 2000
@@ -93,7 +93,11 @@
   else
     # No exact match, see how many strings match what's on the line.
 
-    compadd -O tmp1 - "${(@)matches%%${sep}*}"
+    builtin compadd -O tmp1 - "${(@)matches%%${sep}*}"
+
+    [[ $#tmp1 -eq 0 && -n "$_comp_correct" ]] &&
+      compadd -O tmp1 - "${(@)matches%%${sep}*}"
+
     tmp2=( "$tmp1[@]" )
     tmp1=( "$tmp2[@]" )
 
diff -ru ../z.old/Completion/Core/_path_files Completion/Core/_path_files
--- ../z.old/Completion/Core/_path_files	Tue Jan  4 10:21:17 2000
+++ Completion/Core/_path_files	Tue Jan  4 11:47:13 2000
@@ -256,8 +256,12 @@
     if [[ -n "$PREFIX$SUFFIX" ]]; then
       # See which of them match what's on the line.
 
-      tmp2=("$tmp1[@]")
-      compadd -D tmp1 "$ignore[@]" "$matcher[@]" - "${(@)tmp1:t}"
+      builtin compadd -D tmp1 "$ignore[@]" "$matcher[@]" - "${(@)tmp1:t}"
+
+      if [[ $#tmp1 -eq 0 && -n "$_comp_correct" ]]; then
+        tmp1=( "$tmp2[@]" )
+	compadd -D tmp1 "$ignore[@]" "$matcher[@]" - "${(@)tmp2:t}"
+      fi
 
       # If no file matches, save the expanded path and continue with
       # the outer loop.
diff -ru ../z.old/Completion/Core/_sep_parts Completion/Core/_sep_parts
--- ../z.old/Completion/Core/_sep_parts	Tue Jan  4 10:21:18 2000
+++ Completion/Core/_sep_parts	Tue Jan  4 11:57:10 2000
@@ -63,7 +63,9 @@
   # Get the matching array elements.
 
   PREFIX="${str%%${sep}*}"
-  compadd -O testarr - "${(@P)arr}"
+  builtin compadd -O testarr - "${(@P)arr}"
+  [[ $#testarr -eq 0 && -n "$_comp_correct" ]] &&
+    compadd -O testarr - "${(@P)arr}"
 
   # If there are no matches we give up. If there is more than one
   # match, this is the part we will complete.
@@ -91,7 +93,9 @@
   # No more separators, build the matches.
 
   PREFIX="$str"
-  compadd -O testarr - "${(@P)arr}"
+  builtin compadd -O testarr - "${(@P)arr}"
+  [[ $#testarr -eq 0 && -n "$_comp_correct" ]] &&
+    compadd -O testarr - "${(@P)arr}"
 fi
 
 [[ $#testarr -eq 0 || ${#testarr[1]} -eq 0 ]] && return 1
@@ -126,7 +130,9 @@
     arr=tmparr
   fi
 
-  compadd -O tmparr - "${(@P)arr}"
+  builtin compadd -O tmparr - "${(@P)arr}"
+  [[ $#tmparr -eq 0 && -n "$_comp_correct" ]] &&
+    compadd -O tmparr - "${(@P)arr}"
 
   suffixes=("${(@)^suffixes[@]}${1}${(@)^tmparr}")
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

