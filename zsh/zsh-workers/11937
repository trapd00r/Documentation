From zsh-workers-return-11937-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Jun 16 07:30:16 2000
Return-Path: <zsh-workers-return-11937-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2602 invoked from network); 16 Jun 2000 07:30:14 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Jun 2000 07:30:14 -0000
Received: (qmail 10456 invoked by alias); 16 Jun 2000 07:30:03 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11937
Received: (qmail 10425 invoked from network); 16 Jun 2000 07:30:02 -0000
Date: Fri, 16 Jun 2000 09:30:00 +0200 (MET DST)
Message-Id: <200006160730.JAA12325@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Thu, 15 Jun 2000 10:22:52 +0100
Subject: Re: PATCH: Re: expansion


Peter Stephenson wrote:

> Bart wrote:
> > Sven wrote:
> > } They should be turned into boolean styles and the condition should come
> > } from somewhere else, e.g. the -e option to zstyle I suggested (see
> > } 11691).
> > 
> > I agree.
> 
> Yes, that would be preferable.  Does `evaluated' mean `treated as a string
> to be passed directly to eval' or `split into words and executed' or
> `parsed and executed as a command line'?  I think it could be clearer.
> `$reply' would be more standard, but it doesn't really mean much here; I
> wish there were something more obvious, but I bet we've discussed that.

Here's the patch, including:

- an improved version of the zstyle -e code, together with a hopefully 
  clear enough manual entry (do we need to mention this possibility in 
  the compsys manual? hm, maybe, together with examples of how to
  access the current word, the command name, etc, right? other ideas
  for things might want to do?)
- the changes to turn the styles into boolean ones (glob, substitute,
  subst-globs-only, condition (the last one is from _list))
- and the _expand styles have now default values that make expansion
  be done per default when _expand is in the completer list (I hope I
  got the defaults right to come as near to e-o-c as is currently
  possible)

No attempt for the brace expansion thing yet.

Bye
 Sven

Index: Completion/Core/_expand
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_expand,v
retrieving revision 1.17
diff -u -r1.17 _expand
--- Completion/Core/_expand	2000/06/14 16:12:14	1.17
+++ Completion/Core/_expand	2000/06/16 07:23:54
@@ -21,8 +21,7 @@
 # First, see if we should insert all *completions*.
 
 if [[ "$force" = *c* ]] ||
-   { zstyle -s ":completion:${curcontext}:" completions expr &&
-     [[ "${(e):-\$[$expr]}" -eq 1 ]] }; then
+   zstyle -t ":completion:${curcontext}:" completions; then
   compstate[insert]=all
   [[ "$curcontext" = expand-word:* ]] && _complete && return 0
   return 1
@@ -34,11 +33,12 @@
   word="$IPREFIX$PREFIX$SUFFIX$ISUFFIX"
 fi
 
-zstyle -t ":completion:${curcontext}:" suffix &&
+zstyle -T ":completion:${curcontext}:" suffix &&
   [[ "$word" = (\~*/*|\$[a-zA-Z0-9_\[\]]##[^a-zA-Z0-9_\[\]]*|\$\{*\}?*) ]] &&
   return 1
 
 zstyle -t ":completion:${curcontext}:" accept-exact ||
+  [[ $? -eq 2 && ! -o recexact ]] ||
   { [[ "$word" = \~(|[-+]) ||
        ( "$word" = \~[-+][1-9]## && $word[3,-1] -le $#dirstack ) ||
        ( "$word" = \~* && ${#userdirs[(I)${word[2,-1]}*]}+${#nameddirs[(I)${word[2,-1]}*]} -ne 1 ) ||
@@ -54,9 +54,7 @@
 # this function from aborting on parse errors in the expansion.
 
 if [[ "$force" = *s* ]] ||
-   { { zstyle -s ":completion:${curcontext}:" substitute expr ||
-       { [[ "$curcontext" = expand-word:* ]] && expr=1 } } &&
-         [[ "${(e):-\$[$expr]}" -eq 1 ]] }; then
+   zstyle -T ":completion:${curcontext}:" substitute; then
   exp=( "${(e)exp//\\[ 	
 ]/ }" )
 else
@@ -71,10 +69,7 @@
 
 # Now try globbing.
 
-[[ "$force" = *g* ]] ||
-  { { zstyle -s ":completion:${curcontext}:" glob expr ||
-      { [[ "$curcontext" = expand-word:* ]] && expr=1 } } &&
-        [[ "${(e):-\$[$expr]}" -eq 1 ]] } &&
+[[ "$force" = *g* ]] || zstyle -T ":completion:${curcontext}:" glob &&
     exp=( ${~exp} )
 
 # If we don't have any expansions or only one and that is the same
@@ -87,10 +82,9 @@
 # With subst-globs-only we bail out if there were no glob expansions,
 # regardless of any substitutions
 
-[[ "$force" = *o* ]] ||
-  { zstyle -s ":completion:${curcontext}:" subst-globs-only expr &&
-      [[ "${(e):-\$[$expr]}" -eq 1 ]] } && 
-        [[ "$subd" = "$exp"(|\(N\)) ]] && return 1
+{ [[ "$force" = *o* ]] ||
+  zstyle -t ":completion:${curcontext}:" subst-globs-only } &&
+    [[ "$subd" = "$exp"(|\(N\)) ]] && return 1
 
 zstyle -s ":completion:${curcontext}:" keep-prefix tmp || tmp=changed
 if [[ "$word" = [\~\$]*/* && "$tmp" = (yes|true|on|1|changed) ]]; then
Index: Completion/Core/_list
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_list,v
retrieving revision 1.2
diff -u -r1.2 _list
--- Completion/Core/_list	2000/04/01 20:43:43	1.2
+++ Completion/Core/_list	2000/06/16 07:23:54
@@ -20,9 +20,8 @@
 
 # Should we only show a list now?
 
-zstyle -s ":completion:${curcontext}:" condition expr
-if [[ ( -z "$expr" || "${(e):-\$[$expr]}" -eq 1 ) &&
-      ( "$pre" != "$_list_prefix" || "$suf" != "$_list_suffix" ) ]]; then
+if zstyle -T ":completion:${curcontext}:" condition &&
+   [[ "$pre" != "$_list_prefix" || "$suf" != "$_list_suffix" ]]; then
 
   # Yes. Tell the completion code about it and save the new values
   # to compare the next time.
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.65
diff -u -r1.65 compsys.yo
--- Doc/Zsh/compsys.yo	2000/06/15 09:06:22	1.65
+++ Doc/Zsh/compsys.yo	2000/06/16 07:23:55
@@ -904,29 +904,16 @@
 )
 kindex(completions, completion style)
 item(tt(completions))(
-This style is used by the tt(_expand) completer function.
-
-If this is set to an non-empty string it should be an expression
-usable inside a `tt($((...)))' arithmetical expression. The completer
-function evaluates this expression and if the result is `tt(1)', no
-expansions will be generated, but instead the completions will be
-generated as normal and all of them will be inserted into the command
-line.
+This style is used by the tt(_expand) completer function. If it is set 
+to `true', the completer will not generate expansions, but instead the
+completions will be generated as normal and all of them will be
+inserted into the command line.
 )
 kindex(condition, completion style)
 item(tt(condition))(
-This style is used by the tt(_list) completer function.
-
-If it is not set or set to the empty string, the insertion of
-matches will be delayed unconditionally.  If it is set, the value
-should be an expression usable inside a `tt($((...)))'
-arithmetical expression.  In this case, delaying will be done if the
-expression evaluates to `tt(1)'. For example, with
-
-example(zstyle ':completion:*:list:::' condition '${NUMERIC:-1} != 1')
-
-delaying will be done only if given an explicit numeric argument
-other than `tt(1)'.
+This style is used by the tt(_list) completer function to decide if
+insertion of matches should be delayed unconditionally. The default is 
+`true'.
 )
 kindex(cursor, completion style)
 item(tt(cursor))(
@@ -1112,12 +1099,10 @@
 )
 kindex(glob, completion style)
 item(tt(glob))(
-Like tt(completions), this is used by the tt(_expand) completer.
-
-The value is used like the one for tt(completions) and if it evaluates to 
-`tt(1)', globbing will be attempted on the words resulting from
-substitution (see the tt(substitute) style) or the original string
-from the line.
+Like tt(completions), this is used by the tt(_expand) completer.  If
+it is set to `true' (the default), globbing will be attempted on the
+words resulting from substitution (see the tt(substitute) style) or
+the original string from the line.
 )
 kindex(group-name, completion style)
 item(tt(group-name))(
@@ -1785,26 +1770,21 @@
 )
 kindex(subst-globs-only, completion style)
 item(tt(subst-globs-only))(
-This is used by the tt(_expand) completer.  As for the tt(glob) style,
-the value should be a value usable in a `tt($((...)))' arithmetical
-expression.  If it evaluates to `tt(1)', the expansion will only be
-used if it resulted from globbing; hence, if expansions resulted
-from the use of the tt(substitute) style described below, but these
-were not further changed by globbing, the expansions will be rejected.
+This is used by the tt(_expand) completer.  If it is set to `true',
+the expansion will only be used if it resulted from globbing; hence,
+if expansions resulted from the use of the tt(substitute) style
+described below, but these were not further changed by globbing, the
+expansions will be rejected.
+
+The default for this style is `false'.
 )
 kindex(substitute, completion style)
 item(tt(substitute))(
-This style controls whether the tt(_expand) completer will first try to
-expand all substitutions in the string (such as `tt($LPAR()...RPAR())'
-and `tt(${...})').  It should be set to a number or an non-empty string
-which is an expression usable inside a `tt($((...)))' arithmetical
-expression.  Expansion of substitutions will be done if the expression
-evaluates to `tt(1)'. For example, with
+This boolean style controls whether the tt(_expand) completer will
+first try to expand all substitutions in the string (such as
+`tt($LPAR()...RPAR())' and `tt(${...})').
 
-example(zstyle ':completion:*:expand:::' substitute '${NUMERIC:-1} != 1')
-
-substitution will be performed only if given an explicit numeric
-argument other than `tt(1)', as by typing `tt(ESC 2 TAB)'.
+The default is `true'.
 )
 kindex(suffix, completion style)
 item(tt(suffix))(
@@ -1812,7 +1792,7 @@
 tilde or parameter expansion. If it is set to `true', the word will
 only be expanded if it doesn't have a suffix, i.e. if it is something
 like `tt(~foo)' or `tt($foo)', but not if it is `tt(~foo/)' or
-`tt($foo/bar)'. The default for this style is `false'.
+`tt($foo/bar)'.  The default for this style is `true'.
 )
 kindex(tag-order, completion style)
 item(tt(tag-order))(
@@ -2263,9 +2243,7 @@
 string from the line.
 
 Which kind of expansion is tried is controlled by the tt(substitute),
-tt(glob) and tt(subts-globs-only) styles.  Note that none of these
-has a default value so that they have to be set to make tt(_expand)
-generate any expansions at all.
+tt(glob) and tt(subst-globs-only) styles.
 
 There is another style, tt(completions), which allows tt(_expand) to
 display or insert all em(completions) generated for the string.  The use of
@@ -2451,10 +2429,6 @@
 Performs expansion on the current word:  equivalent to the standard
 tt(expand-word) command, but using the tt(_expand) completer.  Before
 calling it, the var(function) field is set to `tt(expand-word)'.
-
-Unlike tt(_expand) this uses a `tt(1)' (one) as the default
-value for the tt(substitute) and tt(glob) styles, so both types of
-expansion will normally be performed.
 )
 findex(_generic)
 item(tt(_generic))(
Index: Doc/Zsh/mod_zutil.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_zutil.yo,v
retrieving revision 1.9
diff -u -r1.9 mod_zutil.yo
--- Doc/Zsh/mod_zutil.yo	2000/06/07 07:38:02	1.9
+++ Doc/Zsh/mod_zutil.yo	2000/06/16 07:23:56
@@ -8,7 +8,7 @@
 startitem()
 findex(zstyle)
 xitem(tt(zstyle) [ tt(-L) ])
-xitem(tt(zstyle) [ tt(-) | tt(-)tt(-) ] var(pattern) var(style) var(strings) ...)
+xitem(tt(zstyle) [ tt(-e) | tt(-) | tt(-)tt(-) ] var(pattern) var(style) var(strings) ...)
 xitem(tt(zstyle -d) [ var(pattern) [ var(styles) ... ] ])
 xitem(tt(zstyle -g) var(name) [ var(pattern) [ var(style) ] ])
 xitem(tt(zstyle -abs) var(context) var(style) var(name) [ var(sep) ])
@@ -33,9 +33,16 @@
 done in the form of calls to tt(zstyle).  Forms with arguments:
 
 startitem()
-item(tt(zstyle) [ tt(-) | tt(-)tt(-) ] var(pattern) var(style) var(strings) ...)(
+item(tt(zstyle) [ tt(-e) | tt(-) | tt(-)tt(-) ] var(pattern) var(style) var(strings) ...)(
 Defines the given var(style) for the var(pattern) with the var(strings) as
-the value.
+the value.  If the tt(-e) option is given, the var(strings) will be
+concatenated (separated by spaces) and the resulting string will be
+evaluated (in the same way as it is dome by the tt(eval) builtin
+command) when the style is looked up.  In this case the parameter
+tt(reply) will be used to get the strings to return after the
+evaluation.  Before evaluating the value, tt(reply) will be unset and
+if it is still unset after the evaluation, this will be handled as if
+the style were not set.
 )
 item(tt(zstyle -d) [ var(pattern) [ var(styles) ... ] ])(
 Delete style definitions. Without arguments all definitions are deleted,
Index: Src/Modules/zutil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/zutil.c,v
retrieving revision 1.6
diff -u -r1.6 zutil.c
--- Src/Modules/zutil.c	2000/06/07 07:38:02	1.6
+++ Src/Modules/zutil.c	2000/06/16 07:23:56
@@ -48,6 +48,7 @@
     char *pat;			/* pattern string */
     Patprog prog;		/* compiled pattern */
     int weight;			/* how specific is the pattern? */
+    Eprog eval;			/* eval-on-retrieve? */
     char **vals;
 };
     
@@ -64,6 +65,8 @@
     freepatprog(p->prog);
     if (p->vals)
 	freearray(p->vals);
+    if (p->eval)
+	freeeprog(p->eval);
     zfree(p, sizeof(*p));
 }
 
@@ -101,13 +104,25 @@
 
 /* Store a value for a style. */
 
-static void
-setstypat(Style s, char *pat, Patprog prog, char **vals)
+static int
+setstypat(Style s, char *pat, Patprog prog, char **vals, int eval)
 {
     int weight, tmp, first;
     char *str;
     Stypat p, q, qq;
+    Eprog eprog = NULL;
+
+    if (eval) {
+	int ef = errflag;
+
+	eprog = parse_string(zjoin(vals, ' ', 1), 0);
+	errflag = ef;
+
+	if (!eprog)
+	    return 1;
 
+	eprog = dupeprog(eprog, 0);
+    }
     for (p = s->pats; p; p = p->next)
 	if (!strcmp(pat, p->pat)) {
 
@@ -115,9 +130,12 @@
 
 	    if (p->vals)
 		freearray(p->vals);
+	    if (p->eval)
+		freeeprog(p->eval);
 	    p->vals = zarrdup(vals);
+	    p->eval = eprog;
 
-	    return;
+	    return 0;
 	}
 
     /* New pattern. */
@@ -126,6 +144,7 @@
     p->pat = ztrdup(pat);
     p->prog = prog;
     p->vals = zarrdup(vals);
+    p->eval = eprog;
     p->next = NULL;
 
     /* Calculate the weight. */
@@ -161,6 +180,8 @@
 	qq->next = p;
     else
 	s->pats = p;
+
+    return 0;
 }
 
 /* Add a new style. */
@@ -184,9 +205,34 @@
     return s;
 }
 
+static char **
+evalstyle(Stypat p)
+{
+    int ef = errflag;
+    char **ret, *str;
+
+    unsetparam("reply");
+    execode(p->eval, 1, 0);
+    if (errflag) {
+	errflag = ef;
+	return NULL;
+    }
+    errflag = ef;
+
+    if ((ret = getaparam("reply")))
+	ret = arrdup(ret);
+    else if ((str = getsparam("reply"))) {
+	ret = (char **) hcalloc(2 * sizeof(char *));
+	ret[0] = dupstring(str);
+    }
+    unsetparam("reply");
+
+    return ret;
+}
+
 /* Look up a style for a context pattern. This does the matching. */
 
-static Stypat
+static char **
 lookupstyle(char *ctxt, char *style)
 {
     Style s;
@@ -196,7 +242,7 @@
 	if (!strcmp(s->name, style))
 	    for (p = s->pats; p; p = p->next)
 		if (pattry(p->prog, ctxt))
-		    return p;
+		    return (p->eval ? evalstyle(p) : p->vals);
 
     return NULL;
 }
@@ -204,7 +250,7 @@
 static int
 bin_zstyle(char *nam, char **args, char *ops, int func)
 {
-    int min, max, n, add = 0, list = 0;
+    int min, max, n, add = 0, list = 0, eval = 0;
 
     if (!args[0])
 	list = 1;
@@ -218,6 +264,10 @@
 	    }
 	    if (oc == 'L')
 		list = 2;
+	    else if (oc == 'e') {
+		eval = add = 1;
+		args++;
+	    }
 	} else {
 	    add = 1;
 	    args++;
@@ -243,9 +293,7 @@
 	}
 	if (!(s = getstyle(args[1])))
 	    s = addstyle(args[1]);
-	setstypat(s, args[0], prog, args + 2);
-
-	return 0;
+	return setstypat(s, args[0], prog, args + 2, eval);
     }
     if (list) {
 	Style s;
@@ -259,9 +307,9 @@
 	    }
 	    for (p = s->pats; p; p = p->next) {
 		if (list == 1)
-		    printf("    %s", p->pat);
+		    printf("%s  %s", (p->eval ? "(eval)" : "      "), p->pat);
 		else {
-		    printf("zstyle ");
+		    printf("zstyle %s", (p->eval ? "-e " : ""));
 		    quotedzputs(p->pat, stdout);
 		    printf(" %s", s->name);
 		}
@@ -343,12 +391,11 @@
 	break;
     case 's':
 	{
-	    Stypat s;
-	    char *ret;
+	    char **vals, *ret;
 	    int val;
 
-	    if ((s = lookupstyle(args[1], args[2])) && s->vals[0]) {
-		ret = sepjoin(s->vals, (args[4] ? args[4] : " "), 0);
+	    if ((vals = lookupstyle(args[1], args[2])) && vals[0]) {
+		ret = sepjoin(vals, (args[4] ? args[4] : " "), 0);
 		val = 0;
 	    } else {
 		ret = ztrdup("");
@@ -361,16 +408,15 @@
 	break;
     case 'b':
 	{
-	    Stypat s;
-	    char *ret;
+	    char **vals, *ret;
 	    int val;
 
-	    if ((s = lookupstyle(args[1], args[2])) &&
-		s->vals[0] && !s->vals[1] &&
-		(!strcmp(s->vals[0], "yes") ||
-		 !strcmp(s->vals[0], "true") ||
-		 !strcmp(s->vals[0], "on") ||
-		 !strcmp(s->vals[0], "1"))) {
+	    if ((vals = lookupstyle(args[1], args[2])) &&
+		vals[0] && !vals[1] &&
+		(!strcmp(vals[0], "yes") ||
+		 !strcmp(vals[0], "true") ||
+		 !strcmp(vals[0], "on") ||
+		 !strcmp(vals[0], "1"))) {
 		ret = "yes";
 		val = 0;
 	    } else {
@@ -384,12 +430,11 @@
 	break;
     case 'a':
 	{
-	    Stypat s;
-	    char **ret;
+	    char **vals, **ret;
 	    int val;
 
-	    if ((s = lookupstyle(args[1], args[2]))) {
-		ret = zarrdup(s->vals);
+	    if ((vals = lookupstyle(args[1], args[2]))) {
+		ret = zarrdup(vals);
 		val = 0;
 	    } else {
 		char *dummy = NULL;
@@ -405,14 +450,14 @@
     case 't':
     case 'T':
 	{
-	    Stypat s;
+	    char **vals;
 
-	    if ((s = lookupstyle(args[1], args[2])) && s->vals[0]) {
+	    if ((vals = lookupstyle(args[1], args[2])) && vals[0]) {
 		if (args[3]) {
 		    char **ap = args + 3, **p;
 
 		    while (*ap) {
-			p = s->vals;
+			p = vals;
 			while (*p)
 			    if (!strcmp(*ap, *p++))
 				return 0;
@@ -420,27 +465,25 @@
 		    }
 		    return 1;
 		} else
-		    return !(!strcmp(s->vals[0], "true") ||
-			     !strcmp(s->vals[0], "yes") ||
-			     !strcmp(s->vals[0], "on") ||
-			     !strcmp(s->vals[0], "1"));
+		    return !(!strcmp(vals[0], "true") ||
+			     !strcmp(vals[0], "yes") ||
+			     !strcmp(vals[0], "on") ||
+			     !strcmp(vals[0], "1"));
 	    }
-	    return (args[0][1] == 't' ? (s ? 1 : 2) : 0);
+	    return (args[0][1] == 't' ? (vals ? 1 : 2) : 0);
 	}
 	break;
     case 'm':
 	{
-	    Stypat s;
+	    char **vals;
 	    Patprog prog;
 
 	    tokenize(args[3]);
 
-	    if ((s = lookupstyle(args[1], args[2])) &&
+	    if ((vals = lookupstyle(args[1], args[2])) &&
 		(prog = patcompile(args[3], PAT_STATIC, NULL))) {
-		char **p = s->vals;
-
-		while (*p)
-		    if (pattry(prog, *p++))
+		while (*vals)
+		    if (pattry(prog, *vals++))
 			return 0;
 	    }
 	    return 1;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

