From zsh-workers-return-13346-mason-zsh=primenet.com.au@sunsite.dk Mon Jan 15 09:09:51 2001
Return-Path: <zsh-workers-return-13346-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20254 invoked from network); 15 Jan 2001 09:09:47 -0000
Received: from sunsite.dk (HELO sunsite.auc.dk) (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Jan 2001 09:09:47 -0000
Received: (qmail 13608 invoked by alias); 15 Jan 2001 09:09:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13346
Received: (qmail 13596 invoked from network); 15 Jan 2001 09:09:36 -0000
Date: Mon, 15 Jan 2001 10:09:33 +0100 (MET)
Message-Id: <200101150909.KAA31890@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Wed, 10 Jan 2001 17:53:49 +0000
Subject: PATCH: Re: Completion services patch (Re: new-style completition for gnu grep and ls)


Bart Schaefer wrote:

> On Jan 9,  9:51am, Sven Wischnowsky wrote:
> } Subject: Re: new-style completition for gnu grep and ls
> }
> } That also reminds me that my services-patch (`compdef krsh=rsh', see
> } 12977) is still not committed, mostly because I got no reply...
> 
> Sorry, I have some three-month-or-more-old items sitting around waiting to
> be responded to.
> 
> I think 12977 is fine.  It's possible that part of the reason I didn't
> reply right away was that I was still trying to reconcile this with the
> more generalized aliasing scheme I mentioned in 12964, but I still don't
> have a clear idea whether/how such aliasing would be useful, so there's
> no point in holding this up.

Well, then, here is the updated patch, with the stuff I mentioned in
12977.


Bye
 Sven

Index: Completion/Bsd/_bsd_pkg
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Bsd/_bsd_pkg,v
retrieving revision 1.5
diff -u -r1.5 _bsd_pkg
--- Completion/Bsd/_bsd_pkg	2000/10/06 13:01:53	1.5
+++ Completion/Bsd/_bsd_pkg	2001/01/15 09:08:10
@@ -13,7 +13,7 @@
 }
 
 _bsd_pkg() {
-  case "${words[1]:t}" in
+  case "$service" in
   pkg_add)
     _arguments -s \
         '-v[be verbose]' \
Index: Completion/Bsd/_kld
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Bsd/_kld,v
retrieving revision 1.5
diff -u -r1.5 _kld
--- Completion/Bsd/_kld	2000/10/06 13:01:53	1.5
+++ Completion/Bsd/_kld	2001/01/15 09:08:10
@@ -21,7 +21,7 @@
 }
 
 _kld() {
-  case "${words[1]:t}" in
+  case "$service" in
   kldload)
     _arguments -s \
         '-v[be verbose]' \
Index: Completion/Core/_compalso
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_compalso,v
retrieving revision 1.2
diff -u -r1.2 _compalso
--- Completion/Core/_compalso	2000/05/15 13:19:26	1.2
+++ Completion/Core/_compalso	2001/01/15 09:08:10
@@ -7,11 +7,11 @@
 # `_compalso -math-' to get the completions that would be generated for a
 # mathematical context.
 
-local i tmp ret=1
+local i tmp ret=1 service
 
 for i; do
-  tmp="$_comps[$1]"
-  [[ -z "$tmp" ]] || "$tmp" && ret=0
+  tmp="$_comps[$i]"
+  [[ -z "$tmp" ]] || service="${_services[$i]:-$i}" && "$tmp" && ret=0
 done
 
 return ret
Index: Completion/Core/_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_complete,v
retrieving revision 1.8
diff -u -r1.8 _complete
--- Completion/Core/_complete	2000/08/02 10:36:20	1.8
+++ Completion/Core/_complete	2001/01/15 09:08:10
@@ -4,7 +4,7 @@
 # a normal completion function, but as one possible value for the
 # completer style.
 
-local comp name oldcontext ret=1
+local comp name oldcontext ret=1 service
 typeset -T curcontext="$curcontext" ccarray
 
 oldcontext="$curcontext"
@@ -95,6 +95,7 @@
 
 comp="$_comps[-first-]"
 if [[ ! -z "$comp" ]]; then
+  service="${_services[-first-]:--first-}"
   ccarray[3]=-first-
   "$comp" && ret=0
   if [[ "$_compskip" = all ]]; then
@@ -123,6 +124,7 @@
   ccarray[3]="$cname"
 
   comp="$_comps[$cname]"
+  service="${_services[$cname]:-$cname}"
 
   # If not, we use default completion, if any.
 
@@ -133,7 +135,8 @@
     fi
     comp="$_comps[-default-]"
   fi
-  [[ -z "$comp" ]] || "$comp" && ret=0
+  [[ -z "$comp" ]] ||
+      service="${_services[-default-]:--default-}" && "$comp" && ret=0
 fi
 
 _compskip=
Index: Completion/Core/_normal
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_normal,v
retrieving revision 1.4
diff -u -r1.4 _normal
--- Completion/Core/_normal	2000/06/29 08:20:32	1.4
+++ Completion/Core/_normal	2001/01/15 09:08:10
@@ -1,7 +1,7 @@
 #compdef -command-line-
 
 local comp command cmd1 cmd2 pat val name i ret=1 _compskip="$_compskip"
-local curcontext="$curcontext"
+local curcontext="$curcontext" service
 
 # If we get the option `-s', we don't reset `_compskip'. This ensures
 # that a value set in the function for the `-first-' context is kept,
@@ -44,6 +44,7 @@
 # See if there are any matching pattern completions.
 
 if [[ "$_compskip" != (all|*patterns*) ]]; then
+  service="${_services[$cmd1]:-$cmd1}"
   for i in "${(@)_patcomps[(K)$cmd1]}"; do
     "$i" && ret=0
     if [[ "$_compskip" = *patterns* ]]; then
@@ -54,6 +55,7 @@
     fi
   done
   if [[ -n "$cmd2" ]]; then
+    service="${_services[$cmd2]:-$cmd2}"
     for i in "${(@)_patcomps[(K)$cmd2]}"; do
       "$i" && ret=0
       if [[ "$_compskip" = *patterns* ]]; then
@@ -71,8 +73,10 @@
 ret=1
 name="$cmd1"
 comp="$_comps[$cmd1]"
+service="${_services[$cmd1]:-$cmd1}"
 
-[[ -z "$comp" ]] && name="$cmd2" comp="$_comps[$cmd2]"
+[[ -z "$comp" ]] &&
+    name="$cmd2" comp="$_comps[$cmd2]" service="${_services[$cmd2]:-$cmd2}"
 
 # And generate the matches, probably using default completion.
 
@@ -86,6 +90,7 @@
 fi
 
 if [[ "$_compskip" != (all|*patterns*) ]]; then
+  service="${_services[$cmd1]:-$cmd1}"
   for i in "${(@)_postpatcomps[(K)$cmd1]}"; do
     _compskip=default
     "$i" && ret=0
@@ -97,6 +102,7 @@
     fi
   done
   if [[ -n "$cmd2" ]]; then
+    service="${_services[$cmd2]:-$cmd2}"
     for i in "${(@)_postpatcomps[(K)$cmd2]}"; do
       _compskip=default
       "$i" && ret=0
@@ -111,7 +117,7 @@
 fi
 
 [[ "$name" = -default- && -n "$comp" && "$_compskip" != (all|*default*) ]] &&
-  "$comp" && ret=0
+  service="${_services[-default-]:--default-}" && "$comp" && ret=0
 
 _compskip=''
 
Index: Completion/Core/compdump
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/compdump,v
retrieving revision 1.8
diff -u -r1.8 compdump
--- Completion/Core/compdump	2000/08/03 13:35:44	1.8
+++ Completion/Core/compdump	2001/01/15 09:08:10
@@ -35,12 +35,19 @@
 
 print "#files: $#_d_files" > $_d_file
 
-# First dump the arrays _comps and _patcomps.  The quoting hieroglyphyics
-# ensure that a single quote inside a variable is itself correctly quoted.
+# First dump the arrays _comps, _services and _patcomps.  The quoting
+# hieroglyphyics ensure that a single quote inside a variable is itself
+# correctly quoted.
 
 print "_comps=(" >> $_d_file
 for _d_f in ${(ok)_comps}; do
     print -r - "${(q)_d_f}" "${(q)_comps[$_d_f]}"
+done  >> $_d_file
+print ")" >> $_d_file
+
+print "_services=(" >> $_d_file
+for _d_f in ${(ok)_services}; do
+    print -r - "${(q)_d_f}" "${(q)_services[$_d_f]}"
 done  >> $_d_file
 print ")" >> $_d_file
 
Index: Completion/Core/compinit
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/compinit,v
retrieving revision 1.13
diff -u -r1.13 compinit
--- Completion/Core/compinit	2000/11/25 23:50:02	1.13
+++ Completion/Core/compinit	2001/01/15 09:08:10
@@ -100,12 +100,13 @@
   esac
 done
 
-# The associative array containing the definitions for the commands.
+# The associative array containing the definitions for the commands and
+# services.
 # Definitions for patterns will be stored in the associations `_patcomps'
 # and `_postpatcomps'. `_compautos' contains the names and options
 # for autoloaded functions that get options.
 
-typeset -gA _comps _patcomps _postpatcomps _compautos
+typeset -gA _comps _services _patcomps _postpatcomps _compautos
 
 # The associative array use to report information about the last
 # cmpletion to the outside.
@@ -198,12 +199,12 @@
 #   delete the definitions for the command names `bar' and `baz'
 
 compdef() {
-  local opt autol type func delete new i
+  local opt autol type func delete new i ret=0 cmd svc
 
   # Get the options.
 
   if [[ $#* -eq 0 ]]; then
-    echo "compdef needs parameters"
+    echo "$0: I needs arguments"
     return 1
   fi
   
@@ -233,11 +234,38 @@
   shift OPTIND-1
 
   if [[ $#* -eq 0 ]]; then
-    echo "compdef needs parameters"
+    echo "$0: I needs arguments"
     return 1
   fi
   
   if [[ -z "$delete" ]]; then
+    # If the first word contains an equal sign, all words must contain one
+    # and we define which services to use for the commands.
+
+    if [[ "$1" = *\=* ]]; then
+      for i; do
+        if [[ "$i" = *\=* ]]; then
+	  cmd="${i%%\=*}"
+	  svc="${i#*\=}"
+          func="$_comps[${(k)_services[(R)$svc]:-$svc}]"
+	  [[ -z "$func" ]] &&
+	    func="${_patcomps[(K)$svc][1]:-${_postpatcomps[(K)$svc][1]}}"
+          if [[ -n "$func" ]]; then
+	    _comps[$cmd]="$func"
+	    _services[$cmd]="$svc"
+	  else
+	    echo "$0: unknown command or service: $svc"
+	    ret=1
+	  fi
+	else
+	  echo "$0: invalid argument: $i"
+	  ret=1
+	fi
+      done
+
+      return ret
+    fi
+
     # Adding definitions, first get the name of the function name
     # and probably do autoloading.
 
@@ -307,15 +335,19 @@
     *)
       # For commands store the function name in the `_comps'
       # associative array, command names as keys.
-      if [[ -z "$new" ]]; then
-	for i; do
-	  _comps[$i]="$func"
-	done
-      else
-        for i; do
-          [[ "${+_comps[$i]}" -eq 0 ]] && _comps[$i]="$func"
-        done
-      fi
+      for i; do
+        if [[ "$i" = *\=* ]]; then
+	  cmd="${i%%\=*}"
+	  svc=yes
+        else
+	  cmd="$i"
+	  svc=
+        fi
+        if [[ -z "$new" || "${+_comps[$i]}" -eq 0 ]]; then
+          _comps[$cmd]="$func"
+	  [[ -n "$svc" ]] && _services[$cmd]="${i#*\=}"
+	fi
+      done
       ;;
     esac
   else
@@ -331,7 +363,7 @@
       # Oops, cannot do that yet.
 
       echo "$0: cannot restore key bindings"
-      return 1
+      return 1v
       ;;
     *)
       unset "_comps[$^@]"
Index: Completion/Debian/_apt
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_apt,v
retrieving revision 1.10
diff -u -r1.10 _apt
--- Completion/Debian/_apt	2000/12/23 06:53:19	1.10
+++ Completion/Debian/_apt	2001/01/15 09:08:11
@@ -1,12 +1,12 @@
 #compdef apt-get apt-cache apt-cdrom apt-config
 
 _apt () {
-  case "${words[1]:t}" in
+  case "$service" in
     apt-get) _apt-get "$@";;
     apt-cache) _apt-cache "$@";;
     apt-cdrom) _apt-cdrom "$@";;
     apt-config) _apt-config "$@";;
-    *) _message "unknown command $words[1]";;
+    *) _message "unknown command $service";;
   esac
 }
 
Index: Completion/Debian/_bug
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_bug,v
retrieving revision 1.4
diff -u -r1.4 _bug
--- Completion/Debian/_bug	2000/11/12 06:09:27	1.4
+++ Completion/Debian/_bug	2001/01/15 09:08:11
@@ -18,7 +18,7 @@
 	   '(--http_proxy)--proxy=:proxyhost:_hosts' \
 	   '(--proxy)--http_proxy=:proxyhost:_hosts')
 
-case "${words[1]:t}" in
+case "$service" in
 bug)
 _arguments '-c[exclude configs from report]' \
            '-f[argument is a file, not a package]' \
Index: Completion/Debian/_dpkg
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Debian/_dpkg,v
retrieving revision 1.9
diff -u -r1.9 _dpkg
--- Completion/Debian/_dpkg	2000/12/17 15:45:21	1.9
+++ Completion/Debian/_dpkg	2001/01/15 09:08:11
@@ -86,7 +86,7 @@
 #  _dpkg_actions_install=('(--install)-i[install]' '(-i)--install')
 #  _dpkg_actions_record_avail=('(--record-avail)-A[record available]' '(-A)--record-avail')
 
-case "${words[1]:t}" in
+case "$service" in
 dpkg)
 _arguments -C -s "$_dpkg_actions[@]" \
            "$_dpkg_deb_actions[@]" \
Index: Completion/User/_bzip2
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_bzip2,v
retrieving revision 1.4
diff -u -r1.4 _bzip2
--- Completion/User/_bzip2	2000/05/05 13:38:46	1.4
+++ Completion/User/_bzip2	2001/01/15 09:08:11
@@ -1,12 +1,12 @@
-#compdef bzip2 bzcat bunzip2 bzip2recover
+#compdef bzip2 bunzip2 bzcat=bunzip2 bzip2recover
 
 local decompress expl state line curcontext="$curcontext"
 typeset -A opt_args
 
-case "${words[1]:t}" in
+case "$service" in
   bzip2recover) [[ $CURRENT = 2 ]] && state=files;;
   bzip2) decompress=no;&
-  bunzip2|bzcat) _arguments -C -s \
+  bunzip2) _arguments -C -s \
     '(--help)-h[display help message]' \
     '(-h)--help[display help message]' \
     '(--decompress --compress -z --test -t)-d[decompress]' \
Index: Completion/User/_chown
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_chown,v
retrieving revision 1.3
diff -u -r1.3 _chown
--- Completion/User/_chown	2000/05/23 18:06:32	1.3
+++ Completion/User/_chown	2001/01/15 09:08:11
@@ -3,7 +3,7 @@
 local suf
 
 if [[ CURRENT -eq 2 || CURRENT -eq 3 && $words[CURRENT-1] = -* ]]; then
-  if [[ ${words[1]:t} = chgrp ]] || compset -P '*[:.]'; then
+  if [[ $service = chgrp ]] || compset -P '*[:.]'; then
     _groups
   else
     if [[ $OSTYPE = (solaris*|hpux*) ]]; then
Index: Completion/User/_compress
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_compress,v
retrieving revision 1.3
diff -u -r1.3 _compress
--- Completion/User/_compress	2000/05/05 13:38:46	1.3
+++ Completion/User/_compress	2001/01/15 09:08:11
@@ -17,7 +17,7 @@
   '(-q)-v[display compression statistics]' \
   "${common_args1[@]}" )
 
-case "${words[1]:t}" in
+case "$service" in
   compress)
     _arguments -C -s \
       "-b[specify maximum number of bits used to replace common substring]:bits:(${bits[*]})" \
Index: Completion/User/_dvi
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_dvi,v
retrieving revision 1.2
diff -u -r1.2 _dvi
--- Completion/User/_dvi	2000/04/05 11:28:09	1.2
+++ Completion/User/_dvi	2001/01/15 09:08:11
@@ -9,7 +9,7 @@
   ':output DVI file:_files -g \*.\(dvi\|DVI\)'
 )
 
-case "${words[1]:t}" in
+case "$service" in
 dvips)
   _arguments -s \
     '-a[make three passes]' \
Index: Completion/User/_gzip
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_gzip,v
retrieving revision 1.3
diff -u -r1.3 _gzip
--- Completion/User/_gzip	2000/05/05 13:38:46	1.3
+++ Completion/User/_gzip	2001/01/15 09:08:11
@@ -1,10 +1,10 @@
-#compdef gzip gunzip gzcat
+#compdef gzip gunzip gzcat=gunzip
 
 local decompress expl curcontext="$curcontext" state line
 typeset -A opt_args
 
-case "${words[1]:t}" in
-gunzip|zcat|gzcat)
+case "$service" in
+gunzip)
   decompress=yes
   ;&
 gzip)
Index: Completion/User/_imagemagick
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_imagemagick,v
retrieving revision 1.3
diff -u -r1.3 _imagemagick
--- Completion/User/_imagemagick	2000/05/05 13:38:46	1.3
+++ Completion/User/_imagemagick	2001/01/15 09:08:11
@@ -18,7 +18,7 @@
   return
 fi
 
-case "${words[1]:t}" in
+case "$service" in
 display)
   _arguments -M 'm:{a-z}={A-Z}' \
       '*-backdrop[use full screen]' \
Index: Completion/User/_ispell
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_ispell,v
retrieving revision 1.3
diff -u -r1.3 _ispell
--- Completion/User/_ispell	2000/05/24 05:58:20	1.3
+++ Completion/User/_ispell	2001/01/15 09:08:11
@@ -1,6 +1,6 @@
 #compdef ispell buildhash munchlist findaffix tryaffix icombine ijoin
 
-case "${words[1]:t}" in
+case "$service" in
 ispell)
   _arguments -s \
     '(-n -h)-t[input file is in TeX/LaTeX format]' \
Index: Completion/User/_java
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_java,v
retrieving revision 1.2
diff -u -r1.2 _java
--- Completion/User/_java	2000/07/08 07:16:13	1.2
+++ Completion/User/_java	2001/01/15 09:08:12
@@ -6,7 +6,7 @@
 
 jdb_args=()
 
-case "${words[1]:t}" in
+case "$service" in
 javac)
   _arguments \
     '-g-[generate debugging information]:debug:->debug' \
Index: Completion/User/_lp
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_lp,v
retrieving revision 1.6
diff -u -r1.6 _lp
--- Completion/User/_lp	2000/05/31 09:38:26	1.6
+++ Completion/User/_lp	2001/01/15 09:08:12
@@ -5,7 +5,7 @@
 if compset -P -P || [[ "$words[CURRENT-1]" = -P ]]; then
   _printers
 else
-  if [[ "${words[1]:t}" = (lpq|lprm) ]]; then
+  if [[ "$service" = (lpq|lprm) ]]; then
     if [[ "$words" = *-P* ]]; then
       printer=(-P "${${words##*-P( |)}%% *}")
     else
Index: Completion/User/_make
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_make,v
retrieving revision 1.10
diff -u -r1.10 _make
--- Completion/User/_make	2000/05/31 09:38:26	1.10
+++ Completion/User/_make	2001/01/15 09:08:12
@@ -25,7 +25,7 @@
     file=Makefile
   elif [[ -e makefile ]]; then
     file=makefile
-  elif [[ -e GNUmakefile ]]; then
+  elif [[ -n "$_is_gnu[$words[1]]" && -e GNUmakefile ]]; then
     file=GNUmakefile
   else
     file=''
Index: Completion/User/_mount
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_mount,v
retrieving revision 1.6
diff -u -r1.6 _mount
--- Completion/User/_mount	2000/05/31 09:38:26	1.6
+++ Completion/User/_mount	2001/01/15 09:08:12
@@ -368,7 +368,7 @@
   esac
 fi
 
-if [[ "${words[1]:t}" = mount ]]; then
+if [[ "$service" = mount ]]; then
 
   # Here are the tests and tables for the arguments and options for
   # the `mount' program. The `fss' array has to be set to the names
Index: Completion/User/_mysql_utils
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_mysql_utils,v
retrieving revision 1.3
diff -u -r1.3 _mysql_utils
--- Completion/User/_mysql_utils	2000/05/31 09:38:26	1.3
+++ Completion/User/_mysql_utils	2001/01/15 09:08:12
@@ -224,7 +224,7 @@
 }
 
 _mysql_utils () {
-  case "${words[1]:t}" in
+  case "$service" in
     mysql)
       _mysql "$@"
     ;;
Index: Completion/User/_pack
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_pack,v
retrieving revision 1.2
diff -u -r1.2 _pack
--- Completion/User/_pack	2000/05/05 10:08:26	1.2
+++ Completion/User/_pack	2001/01/15 09:08:12
@@ -1,15 +1,15 @@
-#compdef pack pcat unpack
+#compdef pack unpack pcat=unpack
 
 local expl state line
 
-case ${words[1]:t} in
+case $service in
   pack)
     _arguments -C \
       '-f[force packing even for files which will not benefit]' \
       '-[show statistics for files]' \
       '*:file to compress:_files -g \*\~\*.z'
   ;;
-  pcat|unpack)
+  unpack)
     _description files expl 'compressed file'
     _files "$expl[@]" -g '*.z'
   ;;
Index: Completion/User/_pbm
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_pbm,v
retrieving revision 1.5
diff -u -r1.5 _pbm
--- Completion/User/_pbm	2000/04/05 11:28:09	1.5
+++ Completion/User/_pbm	2001/01/15 09:08:12
@@ -6,14 +6,14 @@
 # defaults can be overridden by simply defining completion functions
 # for those commands whose arguments you want to complete differently.
 
-local pat expl ret=1 cmd="${words[1]:t}"
+local pat expl ret=1
 
-if [[ "$cmd" = pnm* ]]; then
+if [[ "$service" = pnm* ]]; then
   pat='*.(#i)p[bgp]m'
-elif [[ "$cmd" = *top[bgpn]m ]]; then
-  pat="*.(#i)${cmd%%top[bgpn]m}"
+elif [[ "$service" = *top[bgpn]m ]]; then
+  pat="*.(#i)${service%%top[bgpn]m}"
 else
-  pat="*.(#i)${cmd[1,3]}"
+  pat="*.(#i)${service[1,3]}"
 fi
   
 if [[ $# -ne 0 || $+_in_pbm -ne 0 ]]; then
@@ -24,7 +24,7 @@
 
 local _in_pbm=yes
 
-case "$cmd" in
+case "$service" in
 asciitop[gn]m)
   _arguments \
     '-d[specify divisor]:divisor:' \
Index: Completion/User/_psutils
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_psutils,v
retrieving revision 1.2
diff -u -r1.2 _psutils
--- Completion/User/_psutils	2000/04/05 11:28:09	1.2
+++ Completion/User/_psutils	2001/01/15 09:08:12
@@ -1,6 +1,6 @@
 #compdef epsffit extractres fixdlsrps fixfmps fixmacps fixpsditps fixpspps fixscribeps fixtpps fixwfwps fixwpps fixwwps includeres psbook psmerge psnup psresize psselect pstops getafm showchar
 
-case "${words[1]:t}" in
+case "$service" in
 epsffit)
   _arguments \
     '-v[print version]' \
Index: Completion/User/_rcs
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_rcs,v
retrieving revision 1.5
diff -u -r1.5 _rcs
--- Completion/User/_rcs	2000/11/06 17:26:43	1.5
+++ Completion/User/_rcs	2001/01/15 09:08:12
@@ -1,14 +1,14 @@
 #compdef co ci rcs
 
-local cmd="${words[1]:t}" ret=1
+local ret=1
 
-if [[ -d RCS && $cmd != ci ]]; then
+if [[ -d RCS && $service != ci ]]; then
   local rep expl
 
   rep=(RCS/*,v(:t:s/\,v//))
   (( $#rep )) && _wanted files expl 'RCS file' compadd -a rep && ret=0
 fi
 
-[[ $cmd = ci || $cmd = rcs || ret -eq 1 ]] && _files && ret=0
+[[ $service = ci || $service = rcs || ret -eq 1 ]] && _files && ret=0
 
 return ret
Index: Completion/User/_rlogin
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_rlogin,v
retrieving revision 1.5
diff -u -r1.5 _rlogin
--- Completion/User/_rlogin	2000/11/20 16:12:22	1.5
+++ Completion/User/_rlogin	2001/01/15 09:08:12
@@ -1,7 +1,7 @@
-#compdef rlogin rsh remsh rcp
+#compdef rlogin rsh remsh=rsh rcp
 
 _rlogin () {
-  case "${words[1]:t}" in
+  case "$service" in
   rlogin)
     _arguments -s \
       '-8[allow 8-Bit data]' \
Index: Completion/User/_ssh
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_ssh,v
retrieving revision 1.7
diff -u -r1.7 _ssh
--- Completion/User/_ssh	2000/11/20 16:12:22	1.7
+++ Completion/User/_ssh	2001/01/15 09:08:12
@@ -1,9 +1,12 @@
-#compdef ssh slogin scp ssh-add ssh-agent ssh-keygen
+#compdef ssh slogin=ssh scp ssh-add ssh-agent ssh-keygen
 
 _remote_files () {
   # This is extremely simple-minded; could parse "ls -F" output to do
   # colorings and LIST_TYPES and so on, but I'm just not that ambitious.
-  compadd $(ssh -a -x ${words[CURRENT]%:*} echo ${words[CURRENT]#*:}\*)
+  local expl
+
+  _wanted files expl 'remote files' \
+      compadd $(ssh -a -x ${words[CURRENT]%:*} echo ${words[CURRENT]#*:}\*)
 }
 
 _ssh () {
@@ -14,8 +17,8 @@
 
   # ssh-opt is a pseudo-command used to complete ssh options for `scp -o'.
 
-  case "${words[1]:t}" in
-  ssh|slogin)
+  case "$service" in
+  ssh)
     args=(
       ':remote host name:->userhost'
       '(-):command: _command_names -e'
@@ -179,6 +182,7 @@
       compset -q
       words=(ssh-opt "$words[@]" )
       (( CURRENT++ ))
+      service=ssh-opt
       _ssh
       return
     elif [[ -n "$state" ]]; then
Index: Completion/User/_tiff
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_tiff,v
retrieving revision 1.6
diff -u -r1.6 _tiff
--- Completion/User/_tiff	2000/10/06 13:11:48	1.6
+++ Completion/User/_tiff	2001/01/15 09:08:12
@@ -1,9 +1,9 @@
 #compdef -P (tiff*|*2tiff|pal2rgb)
 
-local pat expl ret=1 cmd="${words[1]:t}"
+local pat expl ret=1
 
-if [[ "$cmd" = *2tiff ]]; then
-  pat="*.(#i)${cmd%%2tiff}"
+if [[ "$service" = *2tiff ]]; then
+  pat="*.(#i)${service}"
 else
   pat="*.(#i)tiff"
 fi
@@ -23,7 +23,7 @@
 local curcontext="$curcontext" state line ret=1
 typeset -A opt_args
 
-case "$cmd" in
+case "$service" in
 tiff2bw)
   _arguments -C \
     '-c[specify compression scheme]:compression scheme:->compress' \
Index: Completion/User/_yp
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/User/_yp,v
retrieving revision 1.3
diff -u -r1.3 _yp
--- Completion/User/_yp	2000/05/31 09:38:26	1.3
+++ Completion/User/_yp	2001/01/15 09:08:13
@@ -14,7 +14,7 @@
   )
 fi
 
-case "${words[1]:t}" in
+case "$service" in
 ypcat)
   _arguments -C -s "$_yp_args[@]" ':map name:->map' && ret=0
   ;;
Index: Completion/X/_xutils
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/_xutils,v
retrieving revision 1.7
diff -u -r1.7 _xutils
--- Completion/X/_xutils	2000/05/31 09:38:26	1.7
+++ Completion/X/_xutils	2001/01/15 09:08:13
@@ -1,6 +1,6 @@
 #compdef xdpyinfo xwininfo xkill xfontsel xfd xev xhost xon xsetroot xwd xwud xrdb
 
-case "${words[1]:t}" in
+case "$service" in
 xdpyinfo)
   _x_arguments \
     -queryExtensions \
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.104
diff -u -r1.104 compsys.yo
--- Doc/Zsh/compsys.yo	2000/11/08 09:20:43	1.104
+++ Doc/Zsh/compsys.yo	2001/01/15 09:08:17
@@ -164,6 +164,14 @@
 either the name of a command whose arguments are to be completed or one of
 a number of special contexts in the form tt(-)var(context)tt(-) described
 below for the tt(_complete) function.
+
+Each var(name) may also be of the form `var(cmd)tt(=)var(service)'.  This
+is used by functions that offer multiple services, i.e. different
+completion behaviour for multiple commands.  Such a string
+makes the completion system call the function when completing
+arguments for the command `tt(cmd)', setting the parameter tt($service) 
+to the string `tt(service)'.  The function can then use that parameter 
+to decide what to complete.
 )
 item(tt(#compdef -p) var(pattern))(
 The file will be made autoloadable and the function defined in it will be
@@ -253,7 +261,15 @@
 item(tt(compdef -K) [ tt(-an) ] var(function name style key-sequences ...))(
 The first form tells the completion system to call the given
 var(function) when completing for the contexts or commands
-whose var(names) are given:  this is like the tt(#compdef) tag.  If the
+whose var(names) are given:  this is like the tt(#compdef) tag unless
+the first word contains an equal sign.  In this case all words have to 
+be of the form `var(cmd)tt(=)var(service)' where var(service) is the
+name of a command or of a service defined by an autoloaded function
+with the tt(#compdef) tag and an argument of the form
+`var(cmd)tt(=)var(service)'.  This kind of use makes the arguments of
+the var(cmd)s be completed as those for the var(services).
+
+If the
 tt(-n) option is given, any existing completion behaviour for particular
 contexts or commands will not be altered.  These definitions can be deleted
 by giving the tt(-d) option as in the second form.

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

