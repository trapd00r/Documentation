From zsh-workers-return-11635-mason-zsh=primenet.com.au@sunsite.auc.dk Mon May 29 13:10:26 2000
Return-Path: <zsh-workers-return-11635-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10469 invoked from network); 29 May 2000 13:10:21 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 May 2000 13:10:21 -0000
Received: (qmail 15359 invoked by alias); 29 May 2000 13:10:15 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11635
Received: (qmail 15288 invoked from network); 29 May 2000 13:09:58 -0000
Date: Mon, 29 May 2000 15:09:28 +0200 (MET DST)
Message-Id: <200005291309.PAA07914@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Mon, 29 May 2000 10:06:05 +0000
Subject: PATCH: Re: _path_files and glob qualifiers


Bart Schaefer wrote:

> On May 29, 11:54am, Sven Wischnowsky wrote:
> } Subject: Re: _path_files and glob qualifiers
> }
> } Maybe when doing matching, we should copy all qualifiers from the line 
> } to the patterns used when generating matches (and remove the
> } qualifiers for matching purposes).
> 
> That would probably work.

At least for this case, it looks good...

Bye
 Sven

Index: Completion/Core/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_path_files,v
retrieving revision 1.15
diff -u -r1.15 _path_files
--- Completion/Core/_path_files	2000/05/25 12:01:38	1.15
+++ Completion/Core/_path_files	2000/05/29 13:08:15
@@ -147,6 +147,29 @@
 
 zstyle -s ":completion:${curcontext}:files" ignore-parents ignpar
 
+if [[ -n "$compstate[pattern_match]" &&
+      ( ( -z "$SUFFIX" && "$PREFIX" = *\([^\|\~]##\) ) ||
+        "$SUFFIX" =  *\([^\|\~]##\) ) ]]; then
+  if [[ "$SUFFIX" = *\([^\|\~]##\) ]]; then
+    tmp3="${${(M)SUFFIX%\([^\|\~]##\)}[2,-2]}"
+    SUFFIX="${SUFFIX%\($tmp3\)}"
+  else
+    tmp3="${${(M)PREFIX%\([^\|\~]##\)}[2,-2]}"
+    PREFIX="${PREFIX%\($tmp3\)}"
+  fi
+  tmp2=()
+  for tmp1 in "$pats[@]"; do
+    if [[ "$tmp1" = (#b)(?*)(\(\([^\|~]##\)\)) ]]; then
+      tmp2=( "$tmp2[@]" "${match[1]}((${tmp3}${match[2][3,-1]}" )
+    elif [[ "$tmp1" = (#b)(?*)(\([^\|~]##\)) ]]; then
+      tmp2=( "$tmp2[@]" "${match[1]}(${tmp3}${match[2][2,-1]}" )
+    else
+      tmp2=( "$tmp2[@]" "${tmp1}(${tmp3})" )
+    fi
+  done
+  pats=( "$tmp2[@]" )
+fi
+
 # We get the prefix and the suffix from the line and save the whole
 # original string. Then we see if we will do menucompletion.
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

