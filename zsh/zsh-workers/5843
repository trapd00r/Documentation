From zsh-workers-return-5843-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 17 11:44:01 1999
Return-Path: <zsh-workers-return-5843-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29326 invoked from network); 17 Mar 1999 11:43:59 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Mar 1999 11:43:59 -0000
Received: (qmail 19797 invoked by alias); 17 Mar 1999 11:43:30 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5843
Received: (qmail 19788 invoked from network); 17 Mar 1999 11:43:27 -0000
Date: Wed, 17 Mar 1999 12:43:20 +0100 (MET)
Message-Id: <199903171143.MAA27007@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Wed, 17 Mar 1999 12:09:39 +0100
Subject: Re: PATCH: nested substitution documentation


Peter Stephenson wrote:

> One thing is a little inconsistent: if $foo is an array, "${foo[1]}"
> produces the first word of foo (this is certainly correct), but
> "${${(@)foo}[1]}" produces the first character.

I don't think this is inconsistent, because it is quoted but there is
no `(@)' in the outer `${...}' that would say to use separate words
for the inner `${...}'.

> I wanted to say `the
> result of a nested substitution is treated exactly as if came directly from
> a scalar or array parameter', but that's not true in this case.  Maybe all
> array values should be subscripted word-wise by the next enclosing
> substitution, regardless of double quotes.  But then how do you index on
> characters?  And is this (which was my guess of how to do it) right:
> 
> % foo=(bar baz)
> % print ${foo[@][1]}
> bar
> % print "${foo[@][1]}"
> bar
> 
> ([*] does the same in both cases)?  "${foo[1][1]}" does work the way I
> would expect.

As for your examples, I think this is right. But with `[*]' it should
produce the first character when the whole thing is quoted.

And while we are at it: I also wanted to point out that `(@)' isn't
the same as an `[@]' with nested expansions because the `[@]' is found
after the inner thing has been expanded and so the value is already
split in elements (or not). Another slightly ugly thing.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

