From zsh-users-return-3752-mason-zsh=primenet.com.au@sunsite.dk Tue Mar 27 09:13:42 2001
Return-Path: <zsh-users-return-3752-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17993 invoked from network); 27 Mar 2001 09:13:41 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 27 Mar 2001 09:13:40 -0000
Received: (qmail 12553 invoked by alias); 27 Mar 2001 09:13:22 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3752
Received: (qmail 12540 invoked from network); 27 Mar 2001 09:13:21 -0000
Date: Tue, 27 Mar 2001 11:13:21 +0200 (MET DST)
Message-Id: <200103270913.LAA14857@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-users@sunsite.dk
In-reply-to: Adam Spiers's message of Mon, 26 Mar 2001 17:47:37 +0100
Subject: PATCH: Re: Completing strings from history?


Apologies for posting a patch to the -users list.

Adam Spiers wrote:

> ...
> 
> I think the reason this is all such a mess is because there's no
> internal mechanism for controlling the behaviour of automenu when it
> reaches the start or end of the match list, so it had to be
> reimplemented in the shell function.  Ideally the `stop' style would
> be implemented in the core of the completion code to control this, and
> which would greatly simplify the current nastiness that is
> _history_complete_word.  It would also leave the core engine in charge
> of deciding when to generate the match list, rather than the current
> _history_complete_word_gen_matches.
> 
> We could also then move the verbosity control from the `stop' style
> (which can currently be `true' or `verbose') into the `verbosity'
> style, which would make much more sense.
> 
> Sven? ;-)

You mean the `verbose' style, I think.

Anyway.  I don't want to mess with it so short before the official
release (esp. since it can be made better with the means we have now,
see below).  For the time after the release I already said that I
wanted to look into moving more of the C-completion-code into shell
code (and probably integrate completion widgest better with normal zle 
widgets).  Then we can think about menu completion behaviour, too.

Actually I once tried to kindle interest in moving the menu completion 
behaviour into shell code -- at that time I wrote the _menu completer --
but obviously nobody was interested enough, I don't have enough
experience with menu completion and was far too busy at that time
anyway...

So, no I don't plan to add this to the core just now (and it would
have to be controlled by options anyway, because it's in C and that
doesn't use styles).

> Incidentally, the `Completion System Configuration' section in the
> info pages is enormous; how about splitting it up into smaller chunks?

Every volunteer is certainly welcome ;-)


Ok, below is my first attempt at making _history_complete_words
smarter.  I didn't integrate Bart's changes, maybe that should be
done.

The behaviour is now to stop at the beginning/end once.  Going up or
down in the previously used direction will wrap around.  Reversing the 
direction when at the beginning or end will also work (at least it
works for me).

That beep was partly caused by a little quirk of the C-code.  It was
the beep output when the completion is ambiguous.  It was a bit ugly
that it beeped even if the old list was re-used -- the hunk in the
C-code changes that.  But that means that on still gets the beep at
the first attempt and after a wrap-around.  One can use `unsetopt
listbeep' to turn this particular beep off.

The function also intentionally beeps when reaching the beginning or
end.  This can easily be changed or made optional using the `stop'
style.

I hope with the style settings Bart and Adam reported the behaviour is 
now good enough...

Bye
 Sven

Index: Completion/Commands/_history_complete_word
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Commands/_history_complete_word,v
retrieving revision 1.10
diff -u -r1.10 _history_complete_word
--- Completion/Commands/_history_complete_word	2001/02/28 16:55:28	1.10
+++ Completion/Commands/_history_complete_word	2001/03/27 08:57:14
@@ -50,36 +50,51 @@
     slice=$max
   fi
 
-  if [[ -n "$compstate[old_list]" &&
-        ( -n "$stop" || "$compstate[insert]" = menu ) ]] ; then
-    # array of matches is newest -> oldest (reverse of history order)
-    if [[ "$direction" == 'older' ]]; then
-      if [[ compstate[old_insert] -eq $_hist_menu_length ||
-            "$_hist_stop" == 'oldest' ]]; then
-        _hist_stop='oldest'
-        [[ "$stop" = verbose ]] &&
-          _message 'beginning of history reached'
-      elif [[ "$_hist_stop" == 'newest' ]]; then
-        zle -Rc
+  if [[ ( -n "$compstate[old_list]" ||
+          ( $LASTWIDGET = _history-complete-* && -n $_hist_stop ) ) &&
+        ( -n "$stop" || "$compstate[insert]" = menu ) ]]; then
+    if [[ "$direction" == older ]]; then
+      if [[ $_hist_stop = new ]]; then
+        PREFIX=$_hist_old_prefix
         _history_complete_word_gen_matches
-      else
+        compstate[insert]=2
+        _hist_stop=
+      elif [[ $_hist_stop = old ]]; then
+        PREFIX=$_hist_old_prefix
+        _history_complete_word_gen_matches
+        compstate[insert]=1
+        _hist_stop=
+      elif [[ compstate[old_insert] -lt _hist_menu_length ]]; then
         compstate[old_list]=keep
         (( compstate[insert] = compstate[old_insert] + 1 ))
+      else
+        _hist_stop=old
+        _message 'beginning of history reached'
+        return 1
       fi
     elif [[ "$direction" == 'newer' ]]; then
-      if [[ compstate[old_insert] -eq 1 || "$_hist_stop" == 'newest' ]]; then
-        _hist_stop='newest'
-        [[ "$stop" = verbose ]] && _message 'end of history reached'
-      elif [[ "$_hist_stop" == 'oldest' ]]; then
-        zle -Rc
+      if [[ $_hist_stop = old ]]; then
+        PREFIX=$_hist_old_prefix
         _history_complete_word_gen_matches
-      else
+        compstate[insert]=$(( $compstate[nmatches] - 1 ))
+        _hist_stop=
+      elif [[ $_hist_stop = new ]]; then
+        PREFIX=$_hist_old_prefix
+        _history_complete_word_gen_matches
+        compstate[insert]=$compstate[nmatches]
+        _hist_stop=
+      elif [[ compstate[old_insert] -gt 1 ]]; then
         compstate[old_list]=keep
         (( compstate[insert] = compstate[old_insert] - 1 ))
+      else
+        _hist_stop=new
+        _message 'end of history reached'
+        return 1
       fi
     fi
+    return 0
   else
-    _hist_stop=''
+    _hist_stop=
     _hist_old_prefix="$PREFIX"
     _history_complete_word_gen_matches
   fi
Index: Src/Zle/compresult.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compresult.c,v
retrieving revision 1.35
diff -u -r1.35 compresult.c
--- Src/Zle/compresult.c	2001/03/05 10:48:11	1.35
+++ Src/Zle/compresult.c	2001/03/27 08:57:14
@@ -822,7 +822,7 @@
 
     /* At this point, we might want a completion listing.  Show the listing *
      * if it is needed.                                                     */
-    if (isset(LISTBEEP))
+    if (isset(LISTBEEP) && !oldlist)
 	ret = 1;
 
     if (uselist && (usemenu != 2 || (!listshown && !oldlist)) &&

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

