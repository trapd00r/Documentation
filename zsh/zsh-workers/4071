From zsh-workers-request@math.gatech.edu Tue Jun 09 22:46:14 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3594 invoked from network); 9 Jun 1998 22:46:13 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 9 Jun 1998 22:46:13 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id SAA24075;
	Tue, 9 Jun 1998 18:41:30 -0400 (EDT)
Resent-Date: Tue, 9 Jun 1998 18:41:30 -0400 (EDT)
Message-Id: <199806092242.PAA08814@bebop.clari.net>
To: "Bart Schaefer" <schaefer@brasslantern.com>
Cc: zsh-workers@math.gatech.edu
Subject: PATCH: revamped history-search-{for,back}ward for 3.1.4
Date: Tue, 09 Jun 1998 15:42:33 -0700
From: Wayne Davison <wayne@clari.net>
Resent-Message-ID: <"IIp_I2.0.6u5.PeRVr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4071
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

> It's my assertion that history-search-*ward are now broken and
> should be made to behave the way they used to (but not implemented
> the way they used to be implemented).

Here's one way to implement most of the old behavior without using a
special ZLE flag:

My idea is that most of the time the search gets initialized when we
first leave the "curhist" line, and then we continue to execute the
last search when we're moving around in the history.  This makes the
search more modal than before, since the 3.0.x code used to start a
new search if you did anything but another search.

The new code allows two exceptions to start a new search while up in
the history:  if you set the mark away from the start of the line, or
if the current line becomes too short for the current search to
succeed.

Let me know what you think of the idea.

Since this behavior relies on having a working spaceinline() function
(my code depends on the mark being set to the start of the line),
either apply that patch or just change line 87 of zle_utils.c to be:

    if (mark > cs)

instead of:

    if (mark >= cs)

I happened to find and fix a few other minor problems in zle_hist.c,
but I'll send that stuff separately from this.

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: Src/Zle/zle_hist.c
@@ -369,17 +369,20 @@
 	feep();
 }
 
+static int histpos;
+
 /**/
 void
 historysearchbackward(void)
 {
-    int histpos, histmpos, hl = histline;
+    int hl = histline;
     char *s;
 
-    for (histpos = histmpos = 0; histpos < ll && !iblank(line[histpos]);
-	histpos++, histmpos++)
-	if(imeta(line[histpos]))
-	    histmpos++;
+    if (histline == curhist || ll < histpos || mark != 0) {
+	for (histpos = 0; histpos < ll && !iblank(line[histpos]); histpos++) ;
+	if (histpos < ll)
+	    histpos++;
+    }
     for (;;) {
 	hl--;
 	if (!(s = zle_get_event(hl))) {
@@ -387,7 +390,6 @@
 	    return;
 	}
 	if (metadiffer(s, (char *) line, histpos) < 0 &&
-	    iblank(s[histmpos] == Meta ? s[histmpos+1]^32 : s[histmpos]) &&
 	    metadiffer(s, (char *) line, ll))
 	    break;
     }
@@ -398,22 +400,21 @@
 void
 historysearchforward(void)
 {
-    int histpos, histmpos, hl = histline;
+    int hl = histline;
     char *s;
 
-    for (histpos = histmpos = 0; histpos < ll && !iblank(line[histpos]);
-	histpos++, histmpos++)
-	if(imeta(line[histpos]))
-	    histmpos++;
+    if (histline == curhist || ll < histpos || mark != 0) {
+	for (histpos = 0; histpos < ll && !iblank(line[histpos]); histpos++) ;
+	if (histpos < ll)
+	    histpos++;
+    }
     for (;;) {
 	hl++;
 	if (!(s = zle_get_event(hl))) {
 	    feep();
 	    return;
 	}
-	if (metadiffer(s, (char *) line, histpos) < (histline == curhist) &&
-	    (!s[histmpos] ||
-	     iblank(s[histmpos] == Meta ? s[histmpos+1]^32 : s[histmpos])) &&
+	if (metadiffer(s, (char *) line, histpos) < (hl == curhist) &&
 	    metadiffer(s, (char *) line, ll))
 	    break;
     }
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

