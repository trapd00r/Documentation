From zsh-users-return-15396-mason-zsh=primenet.com.au@zsh.org Mon Sep 13 04:21:09 2010
Return-Path: <zsh-users-return-15396-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22105 invoked by alias); 13 Sep 2010 04:21:09 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15396
Received: (qmail 21622 invoked from network); 13 Sep 2010 04:21:07 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100912212039.ZM18674@torch.brasslantern.com>
Date: Sun, 12 Sep 2010 21:20:39 -0700
In-reply-to: <20100912234331.GA2497@gmx.de>
Comments: In reply to Dominik Vogt <dominik.vogt@gmx.de>
 "Re: Tesing a fifo without opening it?" (Sep 13,  1:43am)
References: <20100910063544.45240@gmx.net>  <20100910113632.GA4692@yahoo.fr>
	<20100910123616.114190@gmx.net>	<100912120223.ZM17365@torch.brasslantern.com>
	<20100912234331.GA2497@gmx.de>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Tesing a fifo without opening it?
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 13,  1:43am, Dominik Vogt wrote:
} On Sun, Sep 12, 2010 at 12:02:23PM -0700, Bart Schaefer wrote:
} > On Sep 10,  8:35am, Dominik Vogt wrote:
} > } ---- sub script
} > } 01 read REQUEST < "$1"
} > } 02 echo answer > "$2"
} > 
} > Of course with the coproc, these are stdin/stdout so you don't need
} > $1 and $2 and redirections.  If for some reason you're counting on
} > the script to have inherited the parent's stdin/out, you can't use
} > coproc.
} 
} Actually, the script may exec a c-program that can not use stdin
} and stdout for the command channels.  Is it possible to have the
} coproc use separate descriptors for stdio and the coproc pipes?

Ah, I wondered.  First let me note that c-programs, unless specifically
designed to, e.g., use non-blocking I/O, are highly likely to encounter
the deadlock situation I described previously.  The standard set of
text utilities (cat, sed, et al.) are very difficult to use in these
circumstances.

That said ... the coprocess when first started will always have its
stdin and stdout connected to the pipes.  However, you can use exec
with redirection to juggle that any way you wish.  E.g.,

    # Copy shell stdio
    exec {s_in}<&0 {s_out}>&1
    # Start coprocess
    coproc {
	# Save coprocess stdio
	exec {c_in}<&0 {c_out}>&1
	# Reconnect to shell stdio
	exec <&$s_in >&$s_out
	# Now do the original work 
	read -u $c_in command
	eval "$command"
	print -u $c_out "all finished"
    }
    # Try it
    print -p 'echo IN COPROCESS' ; read -E -p

You could do all four redirections in a single "exec" but it's a bit
more obvious what's happening if you use two.

