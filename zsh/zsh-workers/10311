From zsh-workers-return-10311-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 29 09:15:04 2000
Return-Path: <zsh-workers-return-10311-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11414 invoked from network); 29 Mar 2000 09:15:02 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Mar 2000 09:15:02 -0000
Received: (qmail 995 invoked by alias); 29 Mar 2000 09:14:45 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10311
Received: (qmail 981 invoked from network); 29 Mar 2000 09:14:44 -0000
Date: Wed, 29 Mar 2000 11:14:41 +0200 (MET DST)
Message-Id: <200003290914.LAA22586@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 28 Mar 2000 18:04:23 +0000
Subject: Re: PATCH: was: Re: endianness of wordcode


Bart Schaefer wrote:

> ...
> 
> (1)	cd $^fpath/_cvs(|)(:h)
> 	zcompile _cvs
> 
> (2)	compinit
> 	zcompile -c _cvs _cvs
> 
> ...
> 
> (3)	compinit
> 	cvs <TAB><C-U>
> 	zcompile -c _cvs _cvs
> 
> And it also doesn't "work" to list all the helper functions explicitly.
> 
> I don't mind the discrepancy between (1) and (3) so much, but (2) and (3)
> is really unfortunate.  Maybe an additional (or simply different) option
> should be required to get the effect of (2)?

(I wasn't too sure about this anyway...)

So, this adds the -a option to zcompile which is needed to make
functions that are currently only marked for autoloading to be written 
into the zwc file. If it is not given and there is at least one name
of such a function given, zcompile will return an error (and not write 
the zwc file).

Bye
 Sven

diff -ru ../z.old/Doc/Zsh/builtins.yo Doc/Zsh/builtins.yo
--- ../z.old/Doc/Zsh/builtins.yo	Wed Mar 29 10:36:27 2000
+++ Doc/Zsh/builtins.yo	Wed Mar 29 11:11:41 2000
@@ -1304,7 +1304,7 @@
 cindex(.zwc files, creation)
 cindex(compilation)
 xitem(tt(zcompile) [ tt(-U) ] [ tt(-z) | tt(-k) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
-xitem(tt(zcompile) tt(-c) [ tt(-m) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
+xitem(tt(zcompile) tt(-c) [ tt(-ma) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
 item(tt(zcompile -t) var(file) [ var(name) ... ])(
 This builtin command can be used to compile functions or scripts and
 store the compiled form in a file, and to examine files containing
@@ -1336,13 +1336,16 @@
 
 The second form, with the tt(-c) option, writes the definitions for
 all the named functions into var(file).  The names must be functions
-currently defined in the shell or marked for autoloading.  If the
-tt(-m) option is given, too, the var(name)s are used as patterns and
-all functions whose names match one of these patterns will be
-written. If no var(name) is given, the definitions of all functions
-currently defined or marked as autoloaded will be written. In any
-case, the functions in files written with the tt(-c) option will be
-autoloaded as if the tt(KSH_AUTOLOAD) option were unset.
+currently defined in the shell.  Functions that are only marked for
+autoloading can not be written unless the tt(-a) option is given, too.
+In that case the contents of the definition files for those functions
+will be written to the var(file).  If the tt(-m) option is given, too,
+the var(name)s are used as patterns and all functions whose names
+match one of these patterns will be written. If no var(name) is given,
+the definitions of all functions currently defined or marked as
+autoloaded will be written.  In any case, the functions in files
+written with the tt(-c) option will be autoloaded as if the
+tt(KSH_AUTOLOAD) option were unset.
 
 The third form, with the tt(-t) option, examines an existing
 compiled file.  Without further arguments, the names of the original
diff -ru ../z.old/Src/builtin.c Src/builtin.c
--- ../z.old/Src/builtin.c	Wed Mar 29 10:51:11 2000
+++ Src/builtin.c	Wed Mar 29 10:58:31 2000
@@ -124,7 +124,7 @@
     BUILTIN("where", 0, bin_whence, 0, -1, 0, "pmsw", "ca"),
     BUILTIN("which", 0, bin_whence, 0, -1, 0, "ampsw", "c"),
     BUILTIN("zmodload", 0, bin_zmodload, 0, -1, 0, "ILabcfdipue", NULL),
-    BUILTIN("zcompile", 0, bin_zcompile, 0, -1, 0, "tUmrcMzk", NULL),
+    BUILTIN("zcompile", 0, bin_zcompile, 0, -1, 0, "tUMRcmzka", NULL),
 };
 
 /****************************************/
diff -ru ../z.old/Src/parse.c Src/parse.c
--- ../z.old/Src/parse.c	Wed Mar 29 10:51:13 2000
+++ Src/parse.c	Wed Mar 29 10:59:01 2000
@@ -2285,7 +2285,7 @@
 
     if ((ops['k'] && ops['z']) || (ops['R'] && ops['M']) ||
 	(ops['c'] && (ops['U'] || ops['k'] || ops['z'])) ||
-	(!ops['c'] && ops['m'])) {
+	(!ops['c'] && (ops['m'] || ops['a']))) {
 	zwarnnam(nam, "illegal combination of options", NULL, 0);
 	return 1;
     }
@@ -2333,7 +2333,8 @@
 
     dump = (strsfx(FD_EXT, *args) ? *args : dyncat(*args, FD_EXT));
 
-    return (ops['c'] ? build_cur_dump(nam, dump, args + 1, ops['m'], map) :
+    return (ops['c'] ?
+	    build_cur_dump(nam, dump, args + 1, ops['m'], map, ops['a']) :
 	    build_dump(nam, dump, args + 1, ops['U'], map, flags));
 }
 
@@ -2556,7 +2557,7 @@
 
 static int
 cur_add_func(Shfunc shf, LinkList names, LinkList progs,
-	     int *hlen, int *tlen)
+	     int *hlen, int *tlen, int autol)
 {
     Eprog prog;
     WCFunc wcf;
@@ -2564,6 +2565,9 @@
     if (shf->flags & PM_UNDEFINED) {
 	int ona = noaliases;
 
+	if (!autol)
+	    return 2;
+
 	noaliases = (shf->flags & PM_UNALIASED);
 	if (!(prog = getfpfunc(shf->nam, NULL)) || prog == &dummy_eprog) {
 	    noaliases = ona;
@@ -2593,9 +2597,10 @@
 
 /**/
 static int
-build_cur_dump(char *nam, char *dump, char **names, int match, int map)
+build_cur_dump(char *nam, char *dump, char **names, int match, int map,
+	       int autol)
 {
-    int dfd, hlen, tlen;
+    int dfd, hlen, tlen, err;
     LinkList progs, lnames;
     Shfunc shf = NULL;
 
@@ -2618,9 +2623,10 @@
 
 	for (i = 0; i < shfunctab->hsize; i++)
 	    for (hn = shfunctab->nodes[i]; hn; hn = hn->next)
-		if (cur_add_func((Shfunc) hn, lnames, progs,
-				 &hlen, &tlen)) {
-		    zwarnnam(nam, "can't load function: %s", shf->nam, 0);
+		if ((err = cur_add_func((Shfunc) hn, lnames, progs,
+					&hlen, &tlen, autol))) {
+		    zwarnnam(nam, (err == 1 ? "can't load function: %s" :
+				   "function is not loaded: %s"), shf->nam, 0);
 		    errflag = 0;
 		    close(dfd);
 		    unlink(dump);
@@ -2644,9 +2650,10 @@
 		for (hn = shfunctab->nodes[i]; hn; hn = hn->next)
 		    if (!listcontains(lnames, hn->nam) &&
 			pattry(pprog, hn->nam) &&
-			cur_add_func((Shfunc) hn, lnames, progs,
-				     &hlen, &tlen)) {
-			zwarnnam(nam, "can't load function: %s", shf->nam, 0);
+			(err = cur_add_func((Shfunc) hn, lnames, progs,
+					    &hlen, &tlen, autol))) {
+			zwarnnam(nam, (err == 1 ? "can't load function: %s" :
+				       "function is not loaded: %s"), shf->nam, 0);
 			errflag = 0;
 			close(dfd);
 			unlink(dump);
@@ -2663,8 +2670,9 @@
 		unlink(dump);
 		return 1;
 	    }
-	    if (cur_add_func(shf, lnames, progs, &hlen, &tlen)) {
-		zwarnnam(nam, "can't load function: %s", shf->nam, 0);
+	    if ((err = cur_add_func(shf, lnames, progs, &hlen, &tlen, autol))) {
+		zwarnnam(nam, (err == 1 ? "can't load function: %s" :
+			       "function is not loaded: %s"), shf->nam, 0);
 		errflag = 0;
 		close(dfd);
 		unlink(dump);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

