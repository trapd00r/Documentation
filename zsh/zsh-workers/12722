From zsh-workers-return-12722-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Sep 02 17:06:12 2000
Return-Path: <zsh-workers-return-12722-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17161 invoked from network); 2 Sep 2000 17:06:11 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 2 Sep 2000 17:06:11 -0000
Received: (qmail 18410 invoked by alias); 2 Sep 2000 17:05:56 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12722
Received: (qmail 18403 invoked from network); 2 Sep 2000 17:05:55 -0000
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: output base selection without outputting prefix
Message-Id: <E13VGc3-0005lF-00@dext.rous.org>
From: Zefram <zefram@dext.rous.org>
Date: Sat, 02 Sep 2000 16:57:51 +0000

This patch modifies the [#base] syntax for selecting an output base
so that if the # is doubled then the resulting value is output in the
selected base but without outputting the base prefix.  E.g.:

% echo $(([#16]65))
16#41
% echo $(([##16]65))
41
%

Along the way I made the [] parsing code a bit more stringent: it now
doesn't allow things such as $(([16 41)) (missing ]) which the old
code allowed.  I note that the supported base range of [2, 36] isn't
enforced anywhere; I haven't changed that yet.

-zefram

Index: Doc/Zsh/arith.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/arith.yo,v
retrieving revision 1.3
diff -c -r1.3 arith.yo
*** Doc/Zsh/arith.yo	2000/05/19 18:22:51	1.3
--- Doc/Zsh/arith.yo	2000/09/02 16:49:53
***************
*** 65,70 ****
--- 65,75 ----
  implicitly typed by the arithmetic evaluation, where it acquires the output
  base 8.
  
+ When an output base is specified using the `tt([#)var(base)tt(])' syntax,
+ an appropriate base prefix will be output if necessary, so that the value
+ output is valid syntax for input.  If the tt(#) is doubled, for example
+ `tt([##16])', then no base prefix is output.
+ 
  Floating point constants are recognized by the presence of a decimal point
  or an exponent.  The decimal point may be the first character of the
  constant, but the exponent character tt(e) or tt(E) may not, as it will be
Index: Src/math.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/math.c,v
retrieving revision 1.5
diff -c -r1.5 math.c
*** Src/math.c	2000/05/19 18:22:51	1.5
--- Src/math.c	2000/09/02 16:49:59
***************
*** 342,362 ****
  	    return EOI;
  	case '[':
  	    {
! 		int base, setradix = 0;
! 		if (*ptr == '#') {
! 		    ptr++;
! 		    setradix = 1;
! 		}
! 		base = zstrtol(ptr, &ptr, 10);
  
! 		if (*ptr == ']')
! 		    ptr++;
! 		if (setradix)
! 		    outputradix = base;
! 		else {
! 		    yyval.u.l = zstrtol(ptr, &ptr, lastbase = base);
  		    return NUM;
  		}
  		break;
  	    }
  	case ' ':
--- 342,375 ----
  	    return EOI;
  	case '[':
  	    {
! 		int n;
  
! 		if (idigit(*ptr)) {
! 		    n = zstrtol(ptr, &ptr, 10);
! 		    if (*ptr != ']' || !idigit(*++ptr)) {
! 			zerr("bad base syntax", NULL, 0);
! 			return EOI;
! 		    }
! 		    yyval.u.l = zstrtol(ptr, &ptr, lastbase = n);
  		    return NUM;
  		}
+ 		if (*ptr == '#') {
+ 		    n = 1;
+ 		    if (*++ptr == '#') {
+ 			n = -1;
+ 			ptr++;
+ 		    }
+ 		    if (!idigit(*ptr))
+ 			goto bofs;
+ 		    outputradix = n * zstrtol(ptr, &ptr, 10);
+ 		} else {
+ 		    bofs:
+ 		    zerr("bad output format specification", NULL, 0);
+ 		    return EOI;
+ 		}
+ 		if(*ptr != ']')
+ 			goto bofs;
+ 		ptr++;
  		break;
  	    }
  	case ' ':
Index: Src/params.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/params.c,v
retrieving revision 1.26
diff -c -r1.26 params.c
*** Src/params.c	2000/08/10 16:19:12	1.26
--- Src/params.c	2000/09/02 16:50:16
***************
*** 3041,3050 ****
  
      if (v < 0)
  	*s++ = '-', v = -v;
!     if (base <= 1)
! 	base = 10;
  
!     if (base != 10) {
  	if (isset(CBASES) && base == 16)
  	    sprintf(s, "0x");
  	else if (isset(CBASES) && base == 8 && isset(OCTALZEROES))
--- 3041,3050 ----
  
      if (v < 0)
  	*s++ = '-', v = -v;
!     if (base >= -1 && base <= 1)
! 	base = -10;
  
!     if (base > 0) {
  	if (isset(CBASES) && base == 16)
  	    sprintf(s, "0x");
  	else if (isset(CBASES) && base == 8 && isset(OCTALZEROES))
***************
*** 3052,3058 ****
  	else
  	    sprintf(s, "%d#", base);
  	s += strlen(s);
!     }
      for (x = v; x; digs++)
  	x /= base;
      if (!digs)
--- 3052,3059 ----
  	else
  	    sprintf(s, "%d#", base);
  	s += strlen(s);
!     } else
! 	base = -base;
      for (x = v; x; digs++)
  	x /= base;
      if (!digs)

