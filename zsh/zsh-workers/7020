From zsh-workers-return-7020-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jul 07 16:11:55 1999
Return-Path: <zsh-workers-return-7020-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16005 invoked from network); 7 Jul 1999 16:11:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Jul 1999 16:11:54 -0000
Received: (qmail 4400 invoked by alias); 7 Jul 1999 16:11:42 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7020
Received: (qmail 4393 invoked from network); 7 Jul 1999 16:11:41 -0000
Message-Id: <9907071543.AA37134@ibmth.df.unipi.it>
To: "ZSH workers mailing list" <zsh-workers@sunsite.auc.dk>
Subject: Re: ${(A)=xxx} - second go - now real bug. 
In-Reply-To: ""Andrej Borsenkow""'s message of "Wed, 07 Jul 1999 19:32:42 DFT."
             <002501bec88d$f467f470$21c9ca95@mow.siemens.ru> 
Date: Wed, 07 Jul 1999 17:43:00 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

"Andrej Borsenkow" wrote:
> Reading docs once more I noted this:
> 
> A
>      Create an array parameter with ${...=...}, ${...:=...} or
>      ${...::=...}.  If this flag is repeated (as in AA), create an
>      associative array parameter.  Assignment is made before sorting or
>      padding.  The NAME part may be a subscripted range for ordinary
>      arrays; the WORD part *must* be converted to an array, for example
>      by using ${(AA)=...} to activate word splitting, when creating an
>      associative array.
> 
> Please, note the last sentence. It implies, that in case of array/hash
> assignment the word is treated as in array assignment - that is, ${(A)foo=bar
> baz} is basically the same as foo=(bar baz). At least, I find this natural an
> d
> useful. And I have a feeling, that it was once so.

I think you've missed the sense of the = after the (AA) in that
substitution, which is to turn on word-splitting: ${(AA)=foo::=a b}.  As
far as I know it's always been like that.  (=, ~, ^ would have been flags
if they'd been invented later, it's rather a mess to say the least.)

But I don't really like this way of doing things anyway, since it's getting
round lexing and parsing in slightly odd ways.  It would be nice to be able
to do this properly, though.  We really need a syntactically sensible way
of generating expansions arbitrarily deeply inside other expressions
without forking.  The suggestion for doing globbing here in ordinary cases
doesn't fit in with the shell expansion order, which is that globbing is
only performed on the final result of parameter expansion (assuming
globsubst, of course).

The error message has got too many newlines, which is annoying me.

--- Src/params.c~	Tue Jul  6 13:31:11 1999
+++ Src/params.c	Wed Jul  7 17:29:26 1999
@@ -1905,7 +1905,7 @@
 
     if (alen % 2) {
 	freearray(val);
-	zerr("bad set of key/value pairs for associative array\n",
+	zerr("bad set of key/value pairs for associative array",
 	     NULL, 0);
 	return;
     }

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

