From zsh-workers-return-12434-mason-zsh=primenet.com.au@sunsite.auc.dk Sun Jul 30 16:58:01 2000
Return-Path: <zsh-workers-return-12434-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5220 invoked from network); 30 Jul 2000 16:57:59 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 30 Jul 2000 16:57:59 -0000
Received: (qmail 29237 invoked by alias); 30 Jul 2000 16:57:53 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12434
Received: (qmail 29229 invoked from network); 30 Jul 2000 16:57:52 -0000
To: "Bart Schaefer" <schaefer@candle.brasslantern.com>
In-reply-to: <1000729234923.ZM18609@candle.brasslantern.com>
Cc: Zsh hackers list <zsh-workers@sunsite.auc.dk>
Subject: PATCH: Re: GNU-style long options for zsh
From: zefram@fysh.org
Message-Id: <E13IwHm-0005TQ-00@dext.rous.org>
Sender: Zefram <zefram@dext.rous.org>
Date: Sun, 30 Jul 2000 17:49:58 +0100

The patch below is a modified version of Bart's long options patch.
Things that have changed from Bart's version:

1.

Bart wrote:
>Zsh accepts `-opts-junk' where "opts" are any valid option letters and
>"junk" gets ignored.  Thus `--sh-option-letters' and `-sh-option-letters'
>mean significantly different things ....

This always annoyed me about zsh, and other programs that parse options
that way.  I've fixed that such that `zsh -sh-word-split' (for example)
is an error.  An error seems a much more appropriate response than
ignoring the extra letters.

2. Specifying an invalid option name on the command line causes zsh
to exit, rather than continuing with an error message.  This makes it
consistent with the handling of single-letter option names.  It also
fixes a bug probably caused by using zerr() rather than zwarn(): do
"zsh -o wibble" with an unpatched zsh and look at $SHLVL.

3. "-" characters are permitted in GNU-style long option names --
they get transformed into "_" characters -- so that the usual
style "--sh-word-split" is permitted (Bart's version required
"--sh_word_split").

4. Options can be turned off with "+-option-name" just like "+o
option_name".

5. Fixed a dependency: init.o now depends on version.h.

6. Moved the "--version" special casing so that "-o version" *doesn't*
work.

7. Added handling of "--help"; it lists the supported options (with
the appropriate set of option letters), so it'll provide the necessary
information to a completion function when we write one.

8. "--version" and "--help" output goes to stdout, which seems to be
standard, rather than stderr.

9. Documented the long options.

10. Corrected the documentation about -c.  (The command argument is
what would otherwise be the first positional argument, *not* an extra
argument after the option.)

11.

>Zsh accepts `+-' and `+b' as end of options

I left this intact, seeing no reason to change it.  But I documented it.

-zefram

Index: Doc/Zsh/invoke.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/invoke.yo,v
retrieving revision 1.2
diff -c -r1.2 invoke.yo
*** Doc/Zsh/invoke.yo	2000/05/22 15:01:35	1.2
--- Doc/Zsh/invoke.yo	2000/07/30 16:23:24
***************
*** 4,37 ****
  sect(Invocation Options)
  cindex(flags, shell)
  cindex(shell flags)
! If the tt(-s) flag is not present and an argument is given,
! the first argument is taken to be the pathname of a script to
! execute.  The remaining arguments are assigned to the positional
! parameters.  The following flags are interpreted by the shell
! when invoked:
  
  startitem()
! item(tt(-c) var(string))(
! Read commands from var(string).
  )
  item(tt(-i))(
  Force shell to be interactive.
  )
  item(tt(-s))(
! Read command from the standard input.
  )
  enditem()
  
  For further options, which are common to invocation and the tt(set)
  builtin, see
  ifzman(zmanref(zshoptions))\
  ifnzman(noderef(Options))\
! .  Flags may be specified by name using the tt(-o) option.  For example,
  
  example(zsh -x -o shwordsplit scr)
  
  runs the script tt(scr), setting the tt(XTRACE) option by the corresponding
  letter `tt(-x)' and the tt(SH_WORD_SPLIT) option by name.
  
  startmenu()
  menu(Compatibility)
--- 4,79 ----
  sect(Invocation Options)
  cindex(flags, shell)
  cindex(shell flags)
! The following flags are interpreted by the shell when invoked to determine
! where the shell will read commands from:
  
  startitem()
! item(tt(-c))(
! Take the first argument as a command to execute, rather than reading commands
! from a script or standard input.  If any further arguments are given, the
! first one is assigned to tt($0), rather than being used as a positional
! parameter.
  )
  item(tt(-i))(
  Force shell to be interactive.
  )
  item(tt(-s))(
! Force shell to read commands from the standard input.
! If the tt(-s) flag is not present and an argument is given,
! the first argument is taken to be the pathname of a script to
! execute.
  )
  enditem()
  
+ After the first one or two arguments have been appropriated as described above,
+ the remaining arguments are assigned to the positional parameters.
+ 
  For further options, which are common to invocation and the tt(set)
  builtin, see
  ifzman(zmanref(zshoptions))\
  ifnzman(noderef(Options))\
! .
  
+ Options may be specified by name using the tt(-o) option.  tt(-o) acts like
+ a single-letter option, but takes a following string as the option name.
+ For example,
+ 
  example(zsh -x -o shwordsplit scr)
  
  runs the script tt(scr), setting the tt(XTRACE) option by the corresponding
  letter `tt(-x)' and the tt(SH_WORD_SPLIT) option by name.
+ Options may be turned em(off) by name by using tt(PLUS()o) instead of tt(-o).
+ tt(-o) can be stacked up with preceding single-letter options, so for example
+ `tt(-xo shwordsplit)' or `tt(-xoshwordsplit)' is equivalent to
+ `tt(-x -o shwordsplit)'.
+ 
+ Options may also be specified by name in GNU long option style,
+ `tt(--)var(option-name)'.  When this is done, `tt(-)' characters in the
+ option name are permitted: they are translated into `tt(_)', and thus ignored.
+ So, for example, `tt(zsh --sh-word-split)' invokes zsh with the
+ tt(SH_WORD_SPLIT) option turned on.  Like other option syntaxes, options can
+ be turned off by replacing the initial `tt(-)' with a `tt(PLUS())'; thus
+ `tt(+-sh-word-split)' is equivalent to `tt(--no-sh-word-split)'.
+ Unlike other option syntaxes, GNU-style long options cannot be stacked with
+ any other options, so for example `tt(-x-shwordsplit)' is an error,
+ rather than being treated like `tt(-x --shwordsplit)'.
+ 
+ The special GNU-style option `tt(--version)' is handled; it sends to standard
+ output the shell's version information, then exits successfully.
+ `tt(--help)' is also handled; it sends to standard output a list of options
+ that can be used when invoking the shell, then exits successfully.
+ 
+ Option processing may be finished, allowing following arguments that start with
+ `tt(-)' or `tt(PLUS())' to be treated as normal arguments, in two ways.
+ Firstly, a lone `tt(-)' (or `tt(PLUS())') as an argument by itself ends option
+ processing.  Secondly, a special option `tt(--)' (or `tt(PLUS()-)'), which may
+ be specified on its own (which is the standard POSIX usage) or may be stacked
+ with preceding options (so `tt(-x-)' is equivalent to `tt(-x --)').  Options
+ are not permitted to be stacked after `tt(--)' (so `tt(-x-f)' is an error),
+ but note the GNU-style option form discussed above, where `tt(--shwordsplit)'
+ is permitted and does not end option processing.
+ Except when emulating sh or ksh, the option `tt(-b)' is treated the same way
+ as `tt(--)' for the purpose of ending option processing.
  
  startmenu()
  menu(Compatibility)
Index: Src/init.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/init.c,v
retrieving revision 1.7
diff -c -r1.7 init.c
*** Src/init.c	2000/07/19 21:09:40	1.7
--- Src/init.c	2000/07/30 16:23:24
***************
*** 34,39 ****
--- 34,41 ----
  
  #include "init.pro"
  
+ #include "version.h"
+ 
  /**/
  int noexitct = 0;
  
***************
*** 207,221 ****
      while (*argv && (**argv == '-' || **argv == '+')) {
  	char *args = *argv;
  	action = (**argv == '-');
! 	if(!argv[0][1])
  	    *argv = "--";
  	while (*++*argv) {
  	    /* The pseudo-option `--' signifies the end of options. *
  	     * `-b' does too, csh-style, unless we're emulating a   *
  	     * Bourne style shell.                                  */
  	    if (**argv == '-' || (!bourne && **argv == 'b')) {
! 		argv++;
! 		goto doneoptions;
  	    }
  
  	    if (**argv == 'c') {         /* -c command */
--- 209,243 ----
      while (*argv && (**argv == '-' || **argv == '+')) {
  	char *args = *argv;
  	action = (**argv == '-');
! 	if (!argv[0][1])
  	    *argv = "--";
  	while (*++*argv) {
  	    /* The pseudo-option `--' signifies the end of options. *
  	     * `-b' does too, csh-style, unless we're emulating a   *
  	     * Bourne style shell.                                  */
  	    if (**argv == '-' || (!bourne && **argv == 'b')) {
! 		if(!argv[0][1]) {
! 		    argv++;
! 		    goto doneoptions;
! 		}
! 		if(*argv != args+1 || **argv != '-')
! 		    goto badoptionstring;
! 		/* GNU-style long options */
! 		++*argv;
! 		if (!strcmp(*argv, "version")) {
! 		    printf("zsh %s (%s-%s-%s)\n",
! 			    ZSH_VERSION, MACHTYPE, VENDOR, OSTYPE);
! 		    exit(0);
! 		}
! 		if (!strcmp(*argv, "help")) {
! 		    printhelp();
! 		    exit(0);
! 		}
! 		/* `-' characters are allowed in long options */
! 		for(args = *argv; *args; args++)
! 		    if(*args == '-')
! 			*args = '_';
! 		goto longoptions;
  	    }
  
  	    if (**argv == 'c') {         /* -c command */
***************
*** 230,238 ****
  		    zerr("string expected after -o", NULL, 0);
  		    exit(1);
  		}
! 		if(!(optno = optlookup(*argv)))
  		    zerr("no such option: %s", *argv, 0);
! 		else if (optno == RESTRICTED)
  		    restricted = action;
  		else
  		    dosetopt(optno, action, 1);
--- 252,262 ----
  		    zerr("string expected after -o", NULL, 0);
  		    exit(1);
  		}
! 	    longoptions:
! 		if (!(optno = optlookup(*argv))) {
  		    zerr("no such option: %s", *argv, 0);
! 		    exit(1);
! 		} else if (optno == RESTRICTED)
  		    restricted = action;
  		else
  		    dosetopt(optno, action, 1);
***************
*** 241,246 ****
--- 265,271 ----
  		/* zsh's typtab not yet set, have to use ctype */
  		while (*++*argv)
  		    if (!isspace(STOUC(**argv))) {
+ 		    badoptionstring:
  			zerr("bad option string: `%s'", args, 0);
  			exit(1);
  		    }
***************
*** 292,297 ****
--- 317,343 ----
      argzero = ztrdup(argzero);
  }
  
+ /**/
+ static void
+ printhelp(void)
+ {
+     int bourne = (emulation == EMULATE_KSH || emulation == EMULATE_SH);
+ 
+     printf("Usage: %s [<options>] [<argument> ...]\n", argzero);
+     printf("\nSpecial options:\n");
+     printf("  --help     show this message, then exit\n");
+     printf("  --version  show zsh version number, then exit\n");
+     if(!bourne)
+ 	printf("  -b         end option processing, like --\n");
+     printf("  -c         take first argument as a command to execute\n");
+     printf("  -o OPTION  set an option by name (see below)\n");
+     printf("\nNormal options are named.  An option may be turned on by\n");
+     printf("`-o OPTION', `--OPTION', `+o no_OPTION' or `+-no-OPTION'.  An\n");
+     printf("option may be turned off by `-o no_OPTION', `--no-OPTION',\n");
+     printf("`+o OPTION' or `+-OPTION'.  Options are listed below only in\n");
+     printf("`--OPTION' or `--no-OPTION' form.\n");
+     printoptionlist();
+ }
  
  /**/
  mod_export void
Index: Src/options.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/options.c,v
retrieving revision 1.4
diff -c -r1.4 options.c
*** Src/options.c	2000/05/15 18:48:21	1.4
--- Src/options.c	2000/07/30 16:23:24
***************
*** 694,696 ****
--- 694,741 ----
      *val = '\0';
      return buf;
  }
+ 
+ /* Print option list for --help */
+ 
+ /**/
+ void
+ printoptionlist(void)
+ {
+     short *lp;
+     char c;
+ 
+     printf("\nNamed options:\n");
+     scanhashtable(optiontab, 1, 0, OPT_ALIAS, printoptionlist_printoption, 0);
+     printf("\nOption aliases:\n");
+     scanhashtable(optiontab, 1, OPT_ALIAS, 0, printoptionlist_printoption, 0);
+     printf("\nOption letters:\n");
+     for(lp = optletters, c = FIRST_OPT; c <= LAST_OPT; lp++, c++) {
+ 	if(!*lp)
+ 	    continue;
+ 	printf("  -%c  ", c);
+ 	printoptionlist_printequiv(*lp);
+     }
+ }
+ 
+ /**/
+ static void
+ printoptionlist_printoption(HashNode hn, int ignored)
+ {
+     Optname on = (Optname) hn;
+ 
+     if(on->flags & OPT_ALIAS) {
+ 	printf("  --%-19s  ", on->nam);
+ 	printoptionlist_printequiv(on->optno);
+     } else
+ 	printf("  --%s\n", on->nam);
+ }
+ 
+ /**/
+ static void
+ printoptionlist_printequiv(int optno)
+ {
+     int isneg = optno < 0;
+ 
+     optno *= (isneg ? -1 : 1);
+     printf("  equivalent to --%s%s\n", isneg ? "no-" : "", optns[optno-1].nam);
+ }
Index: Src/zsh.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/zsh.h,v
retrieving revision 1.16
diff -c -r1.16 zsh.h
*** Src/zsh.h	2000/06/22 08:42:37	1.16
--- Src/zsh.h	2000/07/30 16:23:30
***************
*** 1345,1353 ****
      EXTENDEDHISTORY,
      FLOWCONTROL,
      FUNCTIONARGZERO,
      GLOBALEXPORT,
      GLOBALRCS,
-     GLOBOPT,
      GLOBASSIGN,
      GLOBCOMPLETE,
      GLOBDOTS,
--- 1345,1353 ----
      EXTENDEDHISTORY,
      FLOWCONTROL,
      FUNCTIONARGZERO,
+     GLOBOPT,
      GLOBALEXPORT,
      GLOBALRCS,
      GLOBASSIGN,
      GLOBCOMPLETE,
      GLOBDOTS,
Index: Src/zsh.mdd
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/zsh.mdd,v
retrieving revision 1.1.1.13
diff -c -r1.1.1.13 zsh.mdd
*** Src/zsh.mdd	2000/01/14 19:15:00	1.1.1.13
--- Src/zsh.mdd	2000/07/30 16:23:30
***************
*** 27,33 ****
  
  init.o: bltinmods.list zshpaths.h zshxmods.h
  
! params.o: version.h
  
  version.h: $(sdir_top)/Config/version.mk
  	echo '#define ZSH_VERSION "'$(VERSION)'"' > $@
--- 27,33 ----
  
  init.o: bltinmods.list zshpaths.h zshxmods.h
  
! init.o params.o: version.h
  
  version.h: $(sdir_top)/Config/version.mk
  	echo '#define ZSH_VERSION "'$(VERSION)'"' > $@
END

