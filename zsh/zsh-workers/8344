From zsh-workers-return-8344-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Oct 20 20:50:28 1999
Return-Path: <zsh-workers-return-8344-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8107 invoked from network); 20 Oct 1999 20:50:23 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Oct 1999 20:50:23 -0000
Received: (qmail 7021 invoked by alias); 20 Oct 1999 20:34:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8344
Received: (qmail 26356 invoked from network); 20 Oct 1999 18:01:24 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <991020180115.ZM8801@candle.brasslantern.com>
Date: Wed, 20 Oct 1999 18:01:15 +0000
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: Completeinword and ambiguous completions
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

Consider the following situation:

zsh% setopt completeinword
zsh% setopt pro<TAB>
zsh% setopt prompt<TAB>
promptbang     promptcr       promptpercent  promptsubst    promptvars

Note that the prefix "prompt" is unambiguous.  Now consider what happens
if the cursor is over the "m" when TAB is hit in each of these cases:

zsh% setopt prompt
(feep, cursor stays on "m")
zsh% setopt promptvars
zsh% setopt promptvars
(cursor is one space past end of word)

What I'd like is, in the first of those cases, the cursor doesn't stay
on the "m" but rather moves to the end of the unambiguous prefix, so that
I can immediately start menu completion for the rest of the word.  The
following almost does it:

    complete-in-prefix () {
        local lbuf=$LBUFFER rbuf=$RBUFFER
        integer i=1 curs=$CURSOR
        RBUFFER="" 
        zle expand-or-complete
        while ((curs < CURSOR)) && [[ $rbuf[i] == $LBUFFER[++curs] ]]
        do
             ((++i))
        done
        if ((curs == CURSOR)) || [[ -z $rbuf[i] || $rbuf[i] == [$' \t'] ]]
        then
            RBUFFER=$rbuf[i,-1]
        else
            LBUFFER=$lbuf 
            RBUFFER=$rbuf 
            return 1
        fi
    }
    zle -N complete-in-prefix
    bindkey '\t' complete-in-prefix

But it advances the cursor even when there is no overlap at all among rbuf
and any of the ambiguous suffixes, which is not what I want; it does the
wrong thing when the remainder of rbuf could disambiguate the completion
more; and of course I'd like to integrate it into the completion system
rather than run it as a wrapper.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

