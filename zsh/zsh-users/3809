From zsh-users-return-3809-mason-zsh=primenet.com.au@sunsite.dk Sat Apr 07 14:34:22 2001
Return-Path: <zsh-users-return-3809-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6804 invoked from network); 7 Apr 2001 14:34:21 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Apr 2001 14:34:21 -0000
Received: (qmail 11153 invoked by alias); 7 Apr 2001 14:34:03 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3809
Received: (qmail 11141 invoked from network); 7 Apr 2001 14:34:02 -0000
X-Authentication-Warning: DarkSun.local: luthien set sender to dominik.vogt@gmx.de using -f
Date: Sat, 7 Apr 2001 16:33:48 +0200
From: Dominik Vogt <dominik.vogt@gmx.de>
To: zsh-users@sunsite.auc.dk
Subject: displaying top cpu using process
Message-ID: <20010407163348.A619@gmx.de>
Reply-To: dominik.vogt@gmx.de
Mail-Followup-To: zsh-users@sunsite.auc.dk
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.3.12i
X-Sender: 510058704406-0001@t-dialin.net

I want to have a button in the button bar of my window manager
(fvwm with FvwmButtons) that displays the process that currently
uses most CPU.  The information I want to display is the process
id, used CPU and the command line of the process, e.g.

  12345 99.0% netscape

The part dealing with X and the window manager is not the problen,
althoug it is not easy to do.  The problem is that it is
surprisingly difficult to get said information (SuSE 7.1 Linux
with 2.4.0 kernel)

I tried out about a dozen different programs that display load or
process information, and the only candidates I came across are ps
and top.

ps:

  ps gives me complete control over the output format, but I can't
  make it give me the CPU percentage.  Although the 'C' output
  modifier is documented as 

    "use raw CPU time for %CPU instead of decaying average"

  I always get the decaying average.  Because of this, most of the
  time I see that X uses most CPU.

top:

  Top provides all the output I need, but it is *very* cumbersome
  to parse.  Okay, I have an (inefficient) shell script that
  extracts the information:

    top -b -n 1 | sed '<script>'

  But then, this only works if the terminal window from which top
  was started has enough lines.  If its too short, top generates
  only the header or no lines at all.  This is certainly a strange
  notion of a batch mode (b option).  To get the full output I
  have to detach top from the terminal.  In other words, I need
  one process that generates the data and one that writes it into
  the terminal window.  There are several ways to do this, but
  the best solution seems to be a coprocess (because the coprocess
  is killed if the terminal window that runs the script is
  closed).

  Of course this all wastes a lot of cpu and memory and is very
  ugly to write.

Can anybody think of a better solution (that does not include
writing any C code)?

Bye

Dominik ^_^  ^_^

--
Dominik Vogt, dominik.vogt@gmx.de
Reply-To: dominik.vogt@gmx.de

