From zsh-users-return-3743-mason-zsh=primenet.com.au@sunsite.dk Sun Mar 25 19:04:27 2001
Return-Path: <zsh-users-return-3743-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13974 invoked from network); 25 Mar 2001 19:04:26 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 25 Mar 2001 19:04:26 -0000
Received: (qmail 7734 invoked by alias); 25 Mar 2001 19:04:05 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 3743
Received: (qmail 7723 invoked from network); 25 Mar 2001 19:04:04 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010325190320.ZM10531@candle.brasslantern.com>
Date: Sun, 25 Mar 2001 19:03:20 +0000
In-Reply-To: <200103081027.LAA09315@beta.informatik.hu-berlin.de>
Comments: In reply to Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
        "Re: Inter-Shell communication ?" (Mar  8, 11:27am)
References: <200103081027.LAA09315@beta.informatik.hu-berlin.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.dk
Subject: Re: Inter-Shell communication ?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Mar 8, 11:27am, Sven Wischnowsky wrote:
} 
} jarausch@igpm.rwth-aachen.de wrote:
} 
} > is there an elegant technique for one zshell waiting
} > for a different zshell (i.e. running in a different xterm)
} > to complete?

I take it that for some reason you can't simply start the second xterm
from the first shell and wait for the xterm process to exit?

} I can only think of named pipes (`mknod foo p') with `read var <foo' and
} `print go >foo'.
} 
} We really need that generic socket module ;-)

The zpty module can be used for this, if you have zsh-3.1.9 or later.

(Some of you may recognize bits of this from my "zplitty" posting on
zsh-workers.)

---- 8< ---- snip ---- 8< ----

# Load the module
zmodload -i zsh/zpty || return

# Utility functions

zttywait () {
    stty onlret -ocrnl -onlcr   # May need to adjust this for your OS
    tty
    read -e
}

zttyget() {
    setopt localoptions extendedglob noshwordsplit
    zpty $1 zttywait
    zpty -r $1 $1
    : ${(P)1::=${(P)1%%[[:space:]]#}}
}

# Set up the pty -- this happens in the shell that will do the waiting

zttyget WAITPTY

# Now the parameter $WAITPTY has the name of the device from which the
# waiting zsh will read.  How you propagate this name to the waited-for
# zsh is up to you.  Perhaps write it to a file that's read into a new
# zsh from .zshenv?

# Now we wait.

zpty -r WAITPTY message

# When that wakes up, the other shell has finished.

print -u2 Shell exited: $message

# You can either delete this now, or keep using it for other exchanges.

zpty -d WAITPTY

---- 8< ---- snip ---- 8< ----

# This part happens in the second shell, that is to be waited-for.  This
# assumes that both shells are owned by the same user so they will both
# have write permission on the slave-side of the pty.

TRAPEXIT () { print "All finished here." > $WAITPTY }

# That's it.

---- 8< ---- snip ---- 8< ----

It is possible for the second shell to die without executing the trap, if
it crashes or is hit with "kill -9"; in that case the waiting shell will
have to be woken up with a ctrl-C.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

