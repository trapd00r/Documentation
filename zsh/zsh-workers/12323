From zsh-workers-return-12323-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jul 20 07:06:39 2000
Return-Path: <zsh-workers-return-12323-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 12324 invoked from network); 20 Jul 2000 07:06:37 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 20 Jul 2000 07:06:37 -0000
Received: (qmail 27281 invoked by alias); 20 Jul 2000 07:06:31 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12323
Received: (qmail 27274 invoked from network); 20 Jul 2000 07:06:30 -0000
Date: Thu, 20 Jul 2000 00:06:03 -0700 (PDT)
From: Wayne Davison <wayned@users.sourceforge.net>
X-Sender: wayne@phong.blorf.net
To: Zsh Workers <zsh-workers@sunsite.auc.dk>
Subject: PATCH: HIST_NO_STORE supports "builtin"
Message-ID: <Pine.LNX.4.21.0007200000190.27265-100000@phong.blorf.net>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

I noticed that my latest HIST_NO_STORE support wouldn't work if you
ran "builtin history" rather than just "history".  This fixes that,
but I didn't bother to worry about things like "noglob" or anything
else.

If anyone knows of a better way to do this matching (like maybe
compiling a pattern or something) please let me know.  I looked at the
underlying list data that the lexer generated, and it didn't look to
be useful for this test (unlike the HIST_NO_FUNCTIONS support, where
it was very useful).

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: Src/hist.c
@@ -965,21 +965,24 @@
 
     if (isset(HISTNOSTORE)) {
 	char *b = getpermtext(prog, NULL);
+	char *t = b;
+	if (*b == 'b' && strncmp(b, "builtin ", 8) == 0)
+	    b += 8;
 	if (*b == 'h' && strncmp(b, "history", 7) == 0
 	 && (!b[7] || b[7] == ' ')) {
-	    zsfree(b);
+	    zsfree(t);
 	    return 1;
 	}
 	if (*b == 'f' && b[1] == 'c' && b[2] == ' ' && b[3] == '-') {
 	    b += 3;
 	    do {
 		if (*++b == 'l') {
-		    zsfree(b);
+		    zsfree(t);
 		    return 1;
 		}
 	    } while (isalpha(*b));
 	}
-	zsfree(b);
+	zsfree(t);
     }
 
     return 0;
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

