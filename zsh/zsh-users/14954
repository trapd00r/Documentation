From zsh-users-return-14954-mason-zsh=primenet.com.au@zsh.org Mon Mar 22 09:23:57 2010
Return-Path: <zsh-users-return-14954-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29968 invoked by alias); 22 Mar 2010 09:23:57 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14954
Received: (qmail 12400 invoked from network); 22 Mar 2010 09:23:46 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00,SPF_HELO_PASS
	autolearn=ham version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at bewatermyfriend.org does not designate permitted sender hosts)
From: Frank Terbeck <ft@bewatermyfriend.org>
To: "Benjamin R. Haskell" <zsh@benizi.com>
Cc: Zsh Users <zsh-users@zsh.org>
Subject: Re: Use of vcs_info
In-Reply-To: <alpine.LNX.2.01.1003220433570.19615@hp.internal> (Benjamin
	R. Haskell's message of "Mon, 22 Mar 2010 04:48:34 -0400 (EDT)")
References: <alpine.LNX.2.01.1003212254040.19615@hp.internal>
	<87y6hk3grn.fsf@ft.bewatermyfriend.org>
	<alpine.LNX.2.01.1003220433570.19615@hp.internal>
User-Agent: Gnus/5.13 (Gnus v5.13) Emacs/23.1 (gnu/linux)
Date: Mon, 22 Mar 2010 10:19:29 +0100
Message-ID: <87tys83e8u.fsf@ft.bewatermyfriend.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: quoted-printable
X-Df-Sender: 430444

Benjamin R. Haskell wrote:
> On Mon, 22 Mar 2010, Frank Terbeck wrote:
>> Benjamin R. Haskell wrote:
[...]
>> > My first question is:  what's with the weird $vcs_info_msg_#_=20
>> > variable names? (Why not an array?)
>>=20
>> Those variables are exported (there was a reason for it, I don't=20
>> remember what it was exactly). And you can't export arrays.
>
> Ah, okay.  So... why the trailing underscore?  Not a huge deal, just=20
> curious.

At the time I was writing it, I thought it was a really good idea. :)
My idea was to show that something controls that variable, much like
compsys usually controls variables named _* (like `_comps[]').

[...]
> Ah.  I misinterpreted the '_comm' as 'common', not 'communication'.  I=20
> hadn't really delved too deeply yet, but it looked like that var was=20
> updated in a few places that were grabbing items I wanted to examine.

It's mostly used for carrying over information from the detection
mechanisms to the actual information-retrieval functions. At first there
was only `$vcs', but at some point it began to be clear that I needed
more information to be carried over.


[...]
>> > shortened version of the branch name.  So, is there a way to get the=20
>> > info out of vcs_info?
>>=20
>> Yes, there is.
>> The "shortened" make it a little trickier, though. In currently=20
>> released code (4.3.7), you can make one format to just be "%b" and=20

                  ^- This should have been 4.3.10...

>> change the corresponding variable after calling vcs_info your precmd=20
>> function.
>>=20
>> Vcs_info in CVS has hooks. The manual explains them in some detail and=20
>> gives some simpler examples. You can use a "set-message" hook to get=20
>> full control over what will be inserted for the branch-name. That is=20
>> probably what you want.
>>=20
>
> Thanks for the pointers.  I saw the hook stuff in the git repo, but I=20
> think I'm going to do something like your format suggestion: just make=20
> the various formats easily-splitable, and parse out what I want.
>
> The two things I want are abbreviated git branch names (not sure what=20
> I'll decide on how to abbreviate), and to modify my entire prompt when=20
> in a git rebase (as a big visual reminder to myself).
>
> Both of those would be easy-peasy if I had some kind of data structure=20
> storing the parsed VCS data (rather than a formatted string), hence the=20
> initial email.

With hooks you could do something like this:

# Say you only want to set a hook for the hg, git and bzr backends:
zstyle =E2=80=99:vcs_info:(bzr|git|hg)+set-message:*=E2=80=99 hooks treatbr=
anch

# Now define the appropriate function:
function +vi-treatbranch() {
    # There's an associative array `hook_com[]' which is used for
    # communication between vcs_info and its hooks. The relevant
    # keys for each hook (if any) are described in the manual.
    # Here, we need `branch'. There is also `branch_orig' which is
    # a copy of branch, so we always have the original value of
    # branch in case we're changing the value of the branch key.
    # That is needed because `set-message' is run for every format
    # variable that is being set (like $vcs_info_msg_0_ and
    # $vcs_info_msg_1_).

    # See below for what this is about:
    [[ ${hook_com[brh-branch-treated] =3D=3D '1' ]] && return 0

    # Say, you're calling your branches `brh/*' and you want the
    # "brh" prefix to be gone and only the first five characters of
    # the remainder.

    hook_com[branch]=3D${${hook_com[branch]}/(#s)brh/}
    (( ${#hook_com[branch]} > 5 )) &&
        hook_com[branch]=3D${${hook_com[branch]}[1,5]}

    # Now, if you're using a lot of formats and don't want this to
    # run each time, you can just insert something into hook_com,
    # that is not used by vcs_info itself, like this:
    hook_com[brh-branch-treated]=3D1
    return 0
}

I didn't test it, but something like that can do the trick.

Regards, Frank

--=20
In protocol design, perfection has been reached not when there is
nothing left to add, but when there is nothing left to take away.
                                                  -- RFC 1925

