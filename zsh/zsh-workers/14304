From zsh-workers-return-14304-mason-zsh=primenet.com.au@sunsite.dk Thu May 10 17:26:22 2001
Return-Path: <zsh-workers-return-14304-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2969 invoked from network); 10 May 2001 17:26:21 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 May 2001 17:26:21 -0000
Received: (qmail 23576 invoked by alias); 10 May 2001 17:26:16 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14304
Received: (qmail 23559 invoked from network); 10 May 2001 17:26:15 -0000
Date: Thu, 10 May 2001 10:25:47 -0700 (PDT)
From: Wayne Davison <wayned@users.sourceforge.net>
X-X-Sender:  <wayne@phong.blorf.net>
To: Zsh Workers <zsh-workers@sunsite.dk>
Subject: Minor history bugfix
Message-ID: <Pine.LNX.4.33L2.0105101017160.24080-100000@phong.blorf.net>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

While I was playing around with the history code, I found an obscure bug
in the current codebase.  If you have SHARE_HISTORY on but HIST_NO_STORE
off, plus you have local-history mode set (so that you don't see foreign
commands when moving up and down in the history), and you type a second
"history" command in a row that just happens to slurp in some foreign
history in between the two, the displayed history is not quite right.

The fix is much simpler than the problem description above.  The old
code was trying to get fancy when it merged the current command with the
previously-typed one.  This patch makes it do the simple thing that will
always work right.

..wayne..

---8<------8<------8<------8<---cut here--->8------>8------>8------>8---
Index: Src/hist.c
@@ -1067,8 +1067,6 @@
 	Histent he;
 	int keepflags;

-	for (he = hist_ring; he && he->flags & hist_skip_flags;
-	     he = up_histent(he)) ;
 #ifdef DEBUG
 	/* debugging only */
 	if (chwordpos%2) {
@@ -1083,13 +1081,14 @@
 	    if (isset(HISTREDUCEBLANKS))
 		histreduceblanks();
 	}
-	if ((isset(HISTIGNOREDUPS) || isset(HISTIGNOREALLDUPS)) && he
-	 && histstrcmp(chline, he->text) == 0) {
+	if ((isset(HISTIGNOREDUPS) || isset(HISTIGNOREALLDUPS)) && hist_ring
+	 && histstrcmp(chline, hist_ring->text) == 0) {
 	    /* This history entry compares the same as the previous.
 	     * In case minor changes were made, we overwrite the
 	     * previous one with the current one.  This also gets the
 	     * timestamp right.  Perhaps, preserve the HIST_OLD flag.
 	     */
+	    he = hist_ring;
 	    keepflags = he->flags & HIST_OLD; /* Avoid re-saving */
 	    freehistdata(he, 0);
 	    curline.histnum = curhist;
---8<------8<------8<------8<---cut here--->8------>8------>8------>8---

