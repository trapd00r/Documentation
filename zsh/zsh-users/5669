From zsh-users-return-5669-mason-zsh=primenet.com.au@sunsite.dk Sat Jan 11 11:02:21 2003
Return-Path: <zsh-users-return-5669-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20718 invoked from network); 11 Jan 2003 11:02:20 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 11 Jan 2003 11:02:20 -0000
Received: (qmail 6239 invoked by alias); 11 Jan 2003 11:02:06 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5669
Received: (qmail 6231 invoked from network); 11 Jan 2003 11:02:05 -0000
From: Carlos Carvalho <carlos@fisica.ufpr.br>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit
Message-Id: <15903.36155.716460.639226@fisica.ufpr.br>
Date: Sat, 11 Jan 2003 01:19:23 -0200
To: zsh-users@sunsite.dk
Subject: Re: aliases not getting expanded inside functions?
In-Reply-To: <1030106125404.ZM4660@candle.brasslantern.com>
References: <15893.44217.393956.262362@fisica.ufpr.br>
	<20030103164552.A28966@globnix.org>
	<15893.50996.646711.184945@fisica.ufpr.br>
	<20030103184455.A5692@globnix.org>
	<15893.53780.524763.695176@fisica.ufpr.br>
	<20030103185407.GA11836@fysh.org>
	<15897.15986.562636.628562@fisica.ufpr.br>
	<1030106125404.ZM4660@candle.brasslantern.com>
X-Mailer: VM 7.07 under Emacs 19.34.1

Sorry I couldn't follow up earlier :-( Anyway the below told me how to
pass parameters by name to a function so that it changes the values.
Good!

Bart Schaefer (schaefer@brasslantern.com) wrote on 6 January 2003 12:54:
 >On Jan 6,  6:29am, Carlos Carvalho wrote:
 >}
 >} % a[1]=name1 a[2]=name2 etc.
 >} % b[1]=b_name1 b[2]=b_name2 etc.
 >} 
 >} and then to do the transfer
 >} 
 >} for ((i=1; i< number-of-elements; i++)) {
 >} 	: ${(P)b[i]::=$a[i]}
 >} }
 >
 >I presume you mean ${(P)${b[i]}::=${(P)${a[i]}}}

Yes, sorry, according to my example you're right. I just note that the
braces are not necessary in ${b[i]}, $b[i] works as well.

 >but I can't figure out
 >_why_ you'd want to do that.
 >
 >This sort of question often results from a sequence of events along the
 >lines of:  Problem X is encountered.  Solution Y is considered.  Attempt
 >to implement Y fails at detail Z.  The list is asked how to accomplish Z.
 >
 >Nearly as often, the right thing is instead to ask the list how to solve
 >problem X, because there's a better solution than Y.

Agreed, so here's the story, with two questions. I read a csv file
that comes from a spreadsheet and need to split the fields to
different variables. Instead of doing the full parsing of the data
line by hand, it's easier to have zsh do the split:

fields=( ${(s:;:)dataline} )

Now comes the first question: when there are several consecutive
semicolons the fields end up empty. This is correct, the problem is
that zsh removes the empty fields from the assignment, and instead of
getting 15 fields with many empty I have only 6 (I mean ${#fields} is
less than the number of variables in $dataline). Is there a way to
avoid this? I vaguely recall an option to not remove empty values from
the line but didn't find it. I've worked around the situation by
filling consecutive semicolons with some characters before doing the
split, but it's a hack.

Next, it's necessary to deal with the fields by meaningful names, so I'm
doing

rate=$fields[1] capital=$fields[2] etc.

I modify the variables directly, not only through fields. Later on I
have to copy all these fields to other variables like

rate_prev=$rate capital_prev=$capital etc.

Instead of copying manually I'd like to do

rate_prev=$fields_prev[1] capital_prev=$fields_prev[2] etc.

only once, and then just do fields_prev=( $fields ) whenever I have to
copy the values. This way with a single assignment all variables are
copied to the *_prev counterparts. If this is not possible, I
mentioned some variant of a loop like

for ((i=1; i<= num_fields; i++)) {
    fields_prev[i]=$fields[i]
}

which Bart said should be ${(P)${fields_prev[i]}::=${(P)${fields[i]}}}

However this doesn't work because I cannot assign to the individual
variables (ex. capital=$((capital+interest)) ) without losing the
connection with the fields array.

If you have any better ideas please speak up. As I said, I used the
trick above in another place to make a function change the value of a
parameter, so it's already been useful. Thanks for it.

