From zsh-workers-request@math.gatech.edu Mon Apr 27 09:29:45 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16119 invoked from network); 27 Apr 1998 09:29:38 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 27 Apr 1998 09:29:38 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id FAA10935;
	Mon, 27 Apr 1998 05:22:39 -0400 (EDT)
Resent-Date: Mon, 27 Apr 1998 05:22:39 -0400 (EDT)
Date: Mon, 27 Apr 1998 10:22:42 +0100
From: Andrew Main <zefram@tao.co.uk>
Message-Id: <199804270922.KAA25058@diamond.tao.co.uk>
To: zsh-workers@math.gatech.edu
Subject: PATCH: optional file types
X-Patch: 273
Resent-Message-ID: <"mMgPb1.0.lg2.Uv4Hr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3874
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

zsh currently doesn't compile on systems that don't support symbolic
links.  This patch should fix that.  With this patch, the S_IS* macros are
used in all cases instead of S_IF*, and dummy S_IS* macros are defined
for file types not supported on the current system.  This means that
there is no need for conditional compilation to protect code relating
to non-standard file types.  readlink() is also given a dummy definition.

I'd like the stat module (and hence zls) to support all possible file
types.  Therefore, if your system has any file types not currently in
the list in system.h, please post to zsh-workers, listing for each such
file type

	* the relevant S_IS* and S_IF* macro names
	* the full name of the file type
	* the identifying letter used by the native ls in -l mode
	* the identifying character used by the native ls in -F mode

The information for S_ISMPB, S_ISMPC, S_ISNWK, S_ISOFD and S_ISOFL is
incomplete, so anyone on the relevant systems please let us know about
these also.

 -zefram

 *** configure.in	1998/03/23 22:28:47	1.49
 --- configure.in	1998/04/26 12:49:08
 ***************
 *** 535,541 ****
                 getlogin setpgid gettimeofday gethostname mkfifo wait3 difftime \
                 sigblock sigsetmask sigrelse sighold killpg sigaction getrlimit \
                 sigprocmask setuid seteuid setreuid setresuid setsid strerror \
 !               nis_list initgroups fchdir cap_init)
   if test $dynamic = yes; then
     AC_CHECK_FUNCS(dlopen dlerror dlsym dlclose)
   fi
 --- 535,541 ----
                 getlogin setpgid gettimeofday gethostname mkfifo wait3 difftime \
                 sigblock sigsetmask sigrelse sighold killpg sigaction getrlimit \
                 sigprocmask setuid seteuid setreuid setresuid setsid strerror \
 !               nis_list initgroups fchdir cap_init readlink)
   if test $dynamic = yes; then
     AC_CHECK_FUNCS(dlopen dlerror dlsym dlclose)
   fi
 *** Src/cond.c	1997/06/17 15:59:43	1.14
 --- Src/cond.c	1998/04/26 11:16:48
 ***************
 *** 88,98 ****
       case 's':
   	return ((st = getstat(c->left)) && !!(st->st_size));
       case 'S':
 - #ifdef S_ISSOCK
   	return (S_ISSOCK(dostat(c->left)));
 - #else
 - 	return 0;   /* some versions of SCO are missing S_ISSOCK */
 - #endif
       case 'u':
   	return (!!(dostat(c->left) & S_ISUID));
       case 'w':
 --- 88,94 ----
 *** Src/glob.c	1998/04/25 17:17:48	1.44
 --- Src/glob.c	1998/04/26 11:48:31
 ***************
 *** 934,970 ****
   			/* Toggle matching of symbolic links */
   			sense ^= 2;
   			break;
 - #ifdef S_IFLNK
   		    case '@':
   			/* Match symbolic links */
 ! 			func = qualmode;
 ! 			data = S_IFLNK;
   			break;
 - #endif
 - #ifdef S_IFSOCK
   		    case Equals:
   		    case '=':
   			/* Match sockets */
 ! 			func = qualmode;
 ! 			data = S_IFSOCK;
   			break;
 - #endif
 - #ifdef S_IFIFO
   		    case 'p':
   			/* Match named pipes */
 ! 			func = qualmode;
 ! 			data = S_IFIFO;
   			break;
 - #endif
   		    case '/':
   			/* Match directories */
 ! 			func = qualmode;
 ! 			data = S_IFDIR;
   			break;
   		    case '.':
   			/* Match regular files */
 ! 			func = qualmode;
 ! 			data = S_IFREG;
   			break;
   		    case '%':
   			/* Match special files: block, *
 --- 934,959 ----
   			/* Toggle matching of symbolic links */
   			sense ^= 2;
   			break;
   		    case '@':
   			/* Match symbolic links */
 ! 			func = qualislnk;
   			break;
   		    case Equals:
   		    case '=':
   			/* Match sockets */
 ! 			func = qualissock;
   			break;
   		    case 'p':
   			/* Match named pipes */
 ! 			func = qualisfifo;
   			break;
   		    case '/':
   			/* Match directories */
 ! 			func = qualisdir;
   			break;
   		    case '.':
   			/* Match regular files */
 ! 			func = qualisreg;
   			break;
   		    case '%':
   			/* Match special files: block, *
 ***************
 *** 972,978 ****
   			if (*s == 'b')
   			    s++, func = qualisblk;
   			else if (*s == 'c')
 ! 			    s++, func = qualischar;
   			else
   			    func = qualisdev;
   			break;
 --- 961,967 ----
   			if (*s == 'b')
   			    s++, func = qualisblk;
   			else if (*s == 'c')
 ! 			    s++, func = qualischr;
   			else
   			    func = qualisdev;
   			break;
 ***************
 *** 1323,1353 ****
   char
   file_type(mode_t filemode)
   {
 !     switch (filemode & S_IFMT) {/* screw POSIX */
 !     case S_IFDIR:
   	return '/';
 ! #ifdef S_IFIFO
 !     case S_IFIFO:
   	return '|';
 ! #endif
 !     case S_IFCHR:
 ! 	return '%';
 !     case S_IFBLK:
 ! 	return '#';
 ! #ifdef S_IFLNK
 !     case S_IFLNK:
 ! 	return /* (access(pbuf, F_OK) == -1) ? '&' :*/ '@';
 ! #endif
 ! #ifdef S_IFSOCK
 !     case S_IFSOCK:
   	return '=';
 ! #endif
 !     default:
 ! 	if (filemode & 0111)
 ! 	    return '*';
 ! 	else
 ! 	    return ' ';
 !     }
   }
   
   /* check to see if str is eligible for brace expansion */
 --- 1312,1333 ----
   char
   file_type(mode_t filemode)
   {
 !     if(S_ISBLK(filemode))
 ! 	return '#';
 !     else if(S_ISCHR(filemode))
 ! 	return '%';
 !     else if(S_ISDIR(filemode))
   	return '/';
 !     else if(S_ISFIFO(filemode))
   	return '|';
 !     else if(S_ISLNK(filemode))
 ! 	return '@';
 !     else if(S_ISREG(filemode))
 ! 	return (filemode & 0111) ? '*' : ' ';
 !     else if(S_ISSOCK(filemode))
   	return '=';
 !     else
 ! 	return '?';
   }
   
   /* check to see if str is eligible for brace expansion */
 ***************
 *** 2603,2610 ****
   static int
   qualisdev(struct stat *buf, long junk)
   {
 !     junk = buf->st_mode & S_IFMT;
 !     return junk == S_IFBLK || junk == S_IFCHR;
   }
   
   /* block special file? */
 --- 2583,2589 ----
   static int
   qualisdev(struct stat *buf, long junk)
   {
 !     return S_ISBLK(buf->st_mode) || S_ISCHR(buf->st_mode);
   }
   
   /* block special file? */
 ***************
 *** 2613,2639 ****
   static int
   qualisblk(struct stat *buf, long junk)
   {
 !     junk = buf->st_mode & S_IFMT;
 !     return junk == S_IFBLK;
   }
   
   /* character special file? */
   
   /**/
   static int
 ! qualischar(struct stat *buf, long junk)
   {
 !     junk = buf->st_mode & S_IFMT;
 !     return junk == S_IFCHR;
   }
   
 ! /* file type is requested one */
   
   /**/
   static int
 ! qualmode(struct stat *buf, long mod)
   {
 !     return (buf->st_mode & S_IFMT) == mod;
   }
   
   /* given flag is set in mode */
 --- 2592,2652 ----
   static int
   qualisblk(struct stat *buf, long junk)
   {
 !     return S_ISBLK(buf->st_mode);
   }
   
   /* character special file? */
   
   /**/
   static int
 ! qualischr(struct stat *buf, long junk)
 ! {
 !     return S_ISCHR(buf->st_mode);
 ! }
 ! 
 ! /* directory? */
 ! 
 ! /**/
 ! static int
 ! qualisdir(struct stat *buf, long junk)
 ! {
 !     return S_ISDIR(buf->st_mode);
 ! }
 ! 
 ! /* FIFO? */
 ! 
 ! /**/
 ! static int
 ! qualisfifo(struct stat *buf, long junk)
 ! {
 !     return S_ISFIFO(buf->st_mode);
 ! }
 ! 
 ! /* symbolic link? */
 ! 
 ! /**/
 ! static int
 ! qualislnk(struct stat *buf, long junk)
 ! {
 !     return S_ISLNK(buf->st_mode);
 ! }
 ! 
 ! /* regular file? */
 ! 
 ! /**/
 ! static int
 ! qualisreg(struct stat *buf, long junk)
   {
 !     return S_ISREG(buf->st_mode);
   }
   
 ! /* socket? */
   
   /**/
   static int
 ! qualissock(struct stat *buf, long junk)
   {
 !     return S_ISSOCK(buf->st_mode);
   }
   
   /* given flag is set in mode */
 ***************
 *** 2660,2666 ****
   static int
   qualiscom(struct stat *buf, long mod)
   {
 !     return (buf->st_mode & (S_IFMT | S_IEXEC)) == (S_IFREG | S_IEXEC);
   }
   
   /* size in required range? */
 --- 2673,2679 ----
   static int
   qualiscom(struct stat *buf, long mod)
   {
 !     return S_ISREG(buf->st_mode) && (buf->st_mode & S_IXUSR);
   }
   
   /* size in required range? */
 *** Src/system.h	1998/01/09 22:58:31	1.19
 --- Src/system.h	1998/04/26 13:30:32
 ***************
 *** 418,461 ****
   
   /* If your stat macros are broken, we will *
    * just undefine them.                     */
 ! #ifdef  STAT_MACROS_BROKEN
 ! # ifdef S_ISBLK
 ! #  undef S_ISBLK
 ! # endif
 ! # ifdef S_ISCHR
 ! #  undef S_ISCHR
 ! # endif
 ! # ifdef S_ISDIR
 ! #  undef S_ISDIR
 ! # endif
 ! # ifdef S_ISFIFO
 ! #  undef S_ISFIFO
 ! # endif
 ! # ifdef S_ISLNK
 ! #  undef S_ISLNK
 ! # endif
 ! # ifdef S_ISMPB
 ! #  undef S_ISMPB
 ! # endif
 ! # ifdef S_ISMPC
 ! #  undef S_ISMPC
 ! # endif
 ! # ifdef S_ISNWK
 ! #  undef S_ISNWK
 ! # endif
 ! # ifdef S_ISREG
 ! #  undef S_ISREG
 ! # endif
 ! # ifdef S_ISSOCK
 ! #  undef S_ISSOCK
 ! # endif
   #endif  /* STAT_MACROS_BROKEN.  */
   
   /* If you are missing the stat macros, we *
    * define our own                         */
   #ifndef S_IFMT
   # define S_IFMT 0170000
   #endif
   #if !defined(S_ISBLK) && defined(S_IFBLK)
   # define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
   #endif
 --- 418,446 ----
   
   /* If your stat macros are broken, we will *
    * just undefine them.                     */
 ! 
 ! #ifdef STAT_MACROS_BROKEN
 ! # undef S_ISBLK
 ! # undef S_ISCHR
 ! # undef S_ISDIR
 ! # undef S_ISFIFO
 ! # undef S_ISLNK
 ! # undef S_ISMPB
 ! # undef S_ISMPC
 ! # undef S_ISNWK
 ! # undef S_ISOFD
 ! # undef S_ISOFL
 ! # undef S_ISREG
 ! # undef S_ISSOCK
   #endif  /* STAT_MACROS_BROKEN.  */
   
   /* If you are missing the stat macros, we *
    * define our own                         */
 + 
   #ifndef S_IFMT
   # define S_IFMT 0170000
   #endif
 + 
   #if !defined(S_ISBLK) && defined(S_IFBLK)
   # define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
   #endif
 ***************
 *** 465,492 ****
   #if !defined(S_ISDIR) && defined(S_IFDIR)
   # define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
   #endif
 - #if !defined(S_ISREG) && defined(S_IFREG)
 - # define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
 - #endif
   #if !defined(S_ISFIFO) && defined(S_IFIFO)
   # define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
   #endif
   #if !defined(S_ISLNK) && defined(S_IFLNK)
   # define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
   #endif
 ! #if !defined(S_ISSOCK) && defined(S_IFSOCK)
 ! # define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
 ! #endif
 ! #if !defined(S_ISMPB) && defined(S_IFMPB)        /*   V7  */
   # define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
   # define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
   #endif
   #if !defined(S_ISNWK) && defined(S_IFNWK)        /* HP/UX */
   # define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
   #endif
   
   #ifndef HAVE_LSTAT
 ! # define lstat(X,Y) stat(X,Y)
   #endif
   
   #ifndef F_OK          /* missing macros for access() */
 --- 450,529 ----
   #if !defined(S_ISDIR) && defined(S_IFDIR)
   # define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
   #endif
   #if !defined(S_ISFIFO) && defined(S_IFIFO)
   # define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
   #endif
   #if !defined(S_ISLNK) && defined(S_IFLNK)
   # define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
   #endif
 ! #if !defined(S_ISMPB) && defined(S_IFMPB)        /* V7 */
   # define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
 + #endif
 + #if !defined(S_ISMPC) && defined(S_IFMPC)        /* V7 */
   # define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
   #endif
   #if !defined(S_ISNWK) && defined(S_IFNWK)        /* HP/UX */
   # define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
   #endif
 + #if !defined(S_ISOFD) && defined(S_IFOFD)        /* Cray */
 + # define S_ISOFD(m) (((m) & S_IFMT) == S_IFOFD)
 + #endif
 + #if !defined(S_ISOFL) && defined(S_IFOFL)        /* Cray */
 + # define S_ISOFL(m) (((m) & S_IFMT) == S_IFOFL)
 + #endif
 + #if !defined(S_ISREG) && defined(S_IFREG)
 + # define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
 + #endif
 + #if !defined(S_ISSOCK) && defined(S_IFSOCK)
 + # define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
 + #endif
 + 
 + /* We will pretend to have all file types on any system. */
 + 
 + #ifndef S_ISBLK
 + # define S_ISBLK(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISCHR
 + # define S_ISCHR(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISDIR
 + # define S_ISDIR(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISFIFO
 + # define S_ISFIFO(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISLNK
 + # define S_ISLNK(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISMPB
 + # define S_ISMPB(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISMPC
 + # define S_ISMPC(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISNWK
 + # define S_ISNWK(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISOFD
 + # define S_ISOFD(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISOFL
 + # define S_ISOFL(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISREG
 + # define S_ISREG(m) ((void)(m), 0)
 + #endif
 + #ifndef S_ISSOCK
 + # define S_ISSOCK(m) ((void)(m), 0)
 + #endif
   
   #ifndef HAVE_LSTAT
 ! # define lstat stat
 ! #endif
 ! 
 ! #ifndef HAVE_READLINK
 ! # define readlink(PATH, BUF, BUFSZ) \
 !     ((void)(PATH), (void)(BUF), (void)(BUFSZ), errno = ENOSYS, -1)
   #endif
   
   #ifndef F_OK          /* missing macros for access() */
 *** Src/Modules/files.c	1997/06/17 16:00:22	1.20
 --- Src/Modules/files.c	1998/04/26 11:14:34
 ***************
 *** 292,300 ****
   		return 0;
   	    doit = 1;
   	} else if((flags & MV_ASKNW) &&
 - #ifdef S_ISLNK
   		!S_ISLNK(st.st_mode) &&
 - #endif
   		access(qbuf, W_OK)) {
   	    nicezputs(nam, stderr);
   	    fputs(": replace `", stderr);
 --- 292,298 ----
 ***************
 *** 403,411 ****
   	    if(!ask())
   		return 0;
   	} else if(!ops['f'] &&
 - #ifdef S_ISLNK
   		!S_ISLNK(st.st_mode) &&
 - #endif
   	    	access(rp, W_OK)) {
   	    nicezputs(nam, stderr);
   	    fputs(": remove `", stderr);
 --- 401,407 ----
 *** Src/Modules/stat.c	1997/06/17 16:00:22	1.9
 --- Src/Modules/stat.c	1998/04/26 12:19:24
 ***************
 *** 55,88 ****
   	int ioff, itest;
   	char pm[11] = "?---------";
   
 - #ifdef S_ISBLK
   	if (S_ISBLK(mode))
   	    *pm = 'b';
 ! #endif
 ! #ifdef S_ISCHR
 ! 	if (S_ISCHR(mode))
   	    *pm = 'c';
 ! #endif
 ! #ifdef S_ISREG
 ! 	if (S_ISREG(mode))
 ! 	    *pm = '-';
 ! #endif
 ! #ifdef S_ISDIR
 ! 	if (S_ISDIR(mode))
   	    *pm = 'd';
 ! #endif
 ! #ifdef S_ISFIFO
 ! 	if (S_ISFIFO(mode))
   	    *pm = 'p';
 ! #endif
 ! #ifdef S_ISLNK
 ! 	if (S_ISLNK(mode))
   	    *pm = 'l';
 ! #endif
 ! #ifdef S_ISSOCK
 ! 	if (S_ISSOCK(mode))
   	    *pm = 's';
 - #endif
   
   	/* too much hassle using macros for the following which should be
   	 * standardish.
 --- 55,82 ----
   	int ioff, itest;
   	char pm[11] = "?---------";
   
   	if (S_ISBLK(mode))
   	    *pm = 'b';
 ! 	else if (S_ISCHR(mode))
   	    *pm = 'c';
 ! 	else if (S_ISDIR(mode))
   	    *pm = 'd';
 ! 	else if (S_ISFIFO(mode))
   	    *pm = 'p';
 ! 	else if (S_ISLNK(mode))
   	    *pm = 'l';
 ! 	else if (S_ISMPC(mode))
 ! 	    *pm = 'm';
 ! 	else if (S_ISNWK(mode))
 ! 	    *pm = 'n';
 ! 	else if (S_ISOFD(mode))
 ! 	    *pm = 'M';
 ! 	else if (S_ISOFL(mode))
 ! 	    *pm = 'M';
 ! 	else if (S_ISREG(mode))
 ! 	    *pm = '-';
 ! 	else if (S_ISSOCK(mode))
   	    *pm = 's';
   
   	/* too much hassle using macros for the following which should be
   	 * standardish.
 ***************
 *** 182,195 ****
   statlinkprint(struct stat *sbuf, char *outbuf, char *fname)
   {
       int num;
 ! #ifdef S_ISLNK
       /* fname is NULL if we are looking at an fd */
       if (fname && S_ISLNK(sbuf->st_mode) &&
    	(num = readlink(fname, outbuf, PATH_MAX)) > 0) {
   	/* readlink doesn't terminate the buffer itself */
   	outbuf[num] = '\0';
       }
 - #endif
   }
   
   
 --- 176,188 ----
   statlinkprint(struct stat *sbuf, char *outbuf, char *fname)
   {
       int num;
 ! 
       /* fname is NULL if we are looking at an fd */
       if (fname && S_ISLNK(sbuf->st_mode) &&
    	(num = readlink(fname, outbuf, PATH_MAX)) > 0) {
   	/* readlink doesn't terminate the buffer itself */
   	outbuf[num] = '\0';
       }
   }
   
   
 *** Src/Zle/zle_tricky.c	1998/04/04 16:21:06	1.43
 --- Src/Zle/zle_tricky.c	1998/04/26 13:23:46
 ***************
 *** 2090,2098 ****
   			continue;
   		}
   		if (all ||
 ! 		    (dirs && (buf.st_mode & S_IFMT) == S_IFDIR) ||
 ! 		    (execs && ((buf.st_mode & (S_IFMT | S_IEXEC))
 ! 		      == (S_IFREG | S_IEXEC)))) {
   		    /* If we want all files or the file has the right type... */
   		    if (*psuf) {
   			/* We have to test for a path suffix. */
 --- 2090,2097 ----
   			continue;
   		}
   		if (all ||
 ! 		    (dirs && S_ISDIR(buf.st_mode)) ||
 ! 		    (execs && S_ISREG(buf.st_mode) && (buf.st_mode&S_IXUSR))) {
   		    /* If we want all files or the file has the right type... */
   		    if (*psuf) {
   			/* We have to test for a path suffix. */
 ***************
 *** 3424,3430 ****
   			fsuf, psuf);
   	    }
   	    /* And do the stat. */
 ! 	    if (!ztat(p, &buf, 0) && (buf.st_mode & S_IFMT) == S_IFDIR) {
   		/* It is a directory, so add the slash. */
   		havesuff = 1;
   		inststrlen("/", 1, 1);
 --- 3423,3429 ----
   			fsuf, psuf);
   	    }
   	    /* And do the stat. */
 ! 	    if (!ztat(p, &buf, 0) && S_ISDIR(buf.st_mode)) {
   		/* It is a directory, so add the slash. */
   		havesuff = 1;
   		inststrlen("/", 1, 1);

-----BEGIN PGP SIGNATURE-----
Version: PGPfreeware 5.0i for non-commercial use
Charset: ascii

iQEVAwUBNUM/R5mk9GeOHh7BAQHHYgf8DAQWhskEjLvQ7tQ8y28gu5QpOMKaWyDf
+Td8Bs7F5qoYUWmPWoJi7wOQJ84DjEQ06k9ySaGQWg24Mr3uksog6KiEE5FNCkLv
2qWHYjCj8aPN5KpVdQBr6T3q1qg3MsutWMPswE8hS+7tiX/wxqcwbFWc4qDNZeCl
n8tIcvcCsEkDWq+aC276c1A/paWQike+n2hNCz8+ytJjyOGanijYyOE0CrpDjX0x
Nkwqs+l/LNCGvZrTqCY2p+NXHy7weDIjEW5DKyyfq5Dm0ZVbH9r4G9747r3VPutv
9Er+v/KBFDNxTtyxUnaErZNEs6QqC3T+nEyulIxXnw29kbIP985geA==
=VT1d
-----END PGP SIGNATURE-----

