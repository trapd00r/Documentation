From zsh-workers-return-16841-mason-zsh=primenet.com.au@sunsite.dk Fri Mar 15 16:03:48 2002
Return-Path: <zsh-workers-return-16841-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1029 invoked from network); 15 Mar 2002 16:03:47 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 15 Mar 2002 16:03:47 -0000
Received: (qmail 8894 invoked by alias); 15 Mar 2002 16:03:42 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16841
Received: (qmail 8881 invoked from network); 15 Mar 2002 16:03:41 -0000
To: zsh-workers@sunsite.dk
Subject: Re: (backward-)kill-argument     (1/2 thanks  1/2 problem re-statement)
References: <m2zo1cxvvl.fsf@linux3.maruska.tin.it>
	<15505.46831.979708.369781@wischnow.berkom.de>
	<m2ofhsw728.fsf_-_@linux3.maruska.tin.it>
	<15505.46831.979708.369781@wischnow.berkom.de>
	<1020315153147.ZM2228@candle.brasslantern.com>
From: mmc@maruska.dyndns.org (Michal =?iso-8859-2?q?Maru=B9ka?=)
Date: 15 Mar 2002 16:49:41 +0100
In-Reply-To: <1020315153147.ZM2228@candle.brasslantern.com>
Message-ID: <m2zo1996ga.fsf_-_@linux3.maruska.tin.it>
Lines: 82
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.1
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

"Bart Schaefer" <schaefer@brasslantern.com> writes:

> On Mar 15, 9:55am, Sven Wischnowsky wrote:
> }
> } > i want to: * kill filenames w/ spaces: e.g.  this\ is\ file.txt
> }  Write yourself a little widget. As a starting point:
> } 
> }   kill-with-spaces() { local words words="${(z)BUFFER}"
> }BUFFER="${BUFFER%${words[-1]}[ ]#}" }
> 
> That's a nice function, Sven, but I think I'd call it something like
> `backward-kill-shell-word', and it ought to test $LBUFFER, not $BUFFER.  If you
> throw in `setopt localoptions extendedglob', we could even put it in the
> distribution,
> 
> } (There's a space and a TAB inside that [ ].)
> 
> You can write that as [[:space:]] now, I think?
> 

Thanks to both of you. I am arriving to what i wanted.


> } >   * maybe even the bracketed part: find { -name '*.h' }
> } > 
> } > Is it possible in Zsh?
> }  Using the above you could check if $words[-1] is one of the closing braces
> }and if it is, search back in the array for the matching opening brace. When
> }found, you can delete the end of $BUFFER up to that matching brace by using a
> }pattern of the form:
> } 
> }   ${words[-n]}[ ]##...[ ]##${words[-1]}[ ]#
> 
> Hmm, I think I'd just do a loop killing words until the open-brace was missing
> from $LBUFFER.  So, putting it all together,
> 
>     backward-kill-shell-expression() {
>         setopt localoptions extendedglob
>         local words
>         words="${(z)LBUFFER}"
>         LBUFFER="${LBUFFER%${words[-1]}[[:space:]]#}"
>         if [[ "$words[-1]" == '}' ]]
>         then
>             words="${(z)LBUFFER}"
>             while [[ "${${(@M)words:#[\{\}]}[-1]}" == '{' ]]
>             do
>                 LBUFFER="${LBUFFER%${words[-1]}[[:space:]]#}"
>                 words="${(z)LBUFFER}"
>             done
>         fi
>     }
> 
> This could be extended to handle `( ... )', `[[ ... ]]', etc., and we could of
> course also write a forward- version.


But here i again explained wrongly what i intended.

[
I must admit, i would like to migrate from Zsh, sh etc.  to SCSH (scheme
shell). Just Zsh has these unique and elaborated completion & other systems. But
these remain cryptic to me, and i (still) prefer to improve my understanding of scheme
rather that of Zsh (module system of ?) completion system.
]

I immagine Zsh keeps a database (roughly) like:
                        [and i am interested in how it works]

commands| minus-arguments|sort-of-type| completion action for the type (widget?)
--------------------------------------------------------------------------
find       -name           wants 1 text


now these brakets:
        find { -name '*.h' }
i used only to delimit what i would like to remove. I have got in
the  ZLE buffer (on the line) simply:
        find  -name '*.h' 

And now i want to delete all "-name '*.h' "  which is  product of some grammar
rule, or simply the minus-argument with its argument(s).

