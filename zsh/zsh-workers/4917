From zsh-workers-request@math.gatech.edu Fri Jan 15 15:24:07 1999
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 22392 invoked from network); 15 Jan 1999 15:24:03 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 15 Jan 1999 15:24:03 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id KAA03357;
	Fri, 15 Jan 1999 10:20:42 -0500 (EST)
Resent-Date: Fri, 15 Jan 1999 10:20:42 -0500 (EST)
Date: Fri, 15 Jan 1999 09:20:15 -0600 (CST)
From: "Daniel X. Pape" <dpape@canis.uiuc.edu>
To: zsh-workers@math.gatech.edu
Subject: PATCH: was Re: Question: patch for memory leak
In-Reply-To: <Pine.GSO.4.05.9901142014380.29749-100000@sabine.canis.uiuc.edu>
Message-ID: <Pine.GSO.4.05.9901150916340.3262-100000@sabine.canis.uiuc.edu>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Resent-Message-ID: <"dMfOg2.0.Oq.Aprds"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4917
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Thu, 14 Jan 1999, Daniel X. Pape wrote:

> I recently downloaded and compiled zsh-3.1.5-pws-4. However, I found a
> couple of memory leaks in builtin.c where the result of a ztrdup was
> being used as an argument, and not freed, and also where the result of a
> "promptexpand" was being passed to "unmetafy," and then that result was
> never freed.
> 
> After fixing the problem and re-compiling, I have been using the
> resulting executable for two days now, and have seen no problems.
> 
> Is there any kind of test suite to use before submitting a patch? or
> should I just go ahead and send it?

Here is the patch - let me know if it helps:



*** builtin.orig.c	Thu Jan 14 20:04:36 1999
--- builtin.c	Thu Jan 14 19:52:35 1999
***************
*** 1646,1651 ****
--- 1646,1652 ----
  		    setsparam(asg->name, ztrdup(asg->value));
  	    }
  	} else {
+         char *t;
  	    if (bit) {
  		if (pm->flags & PM_READONLY) {
  		    on |= ~off & PM_READONLY;
***************
*** 1657,1663 ****
  	    }
  	    /* create a new node for a parameter with the *
  	     * flags in `on' minus the readonly flag      */
! 	    pm = createparam(ztrdup(asg->name), on & ~PM_READONLY);
  	    DPUTS(!pm, "BUG: parameter not created");
  	    pm->ct = auxlen;
  	    if (func != BIN_EXPORT)
--- 1658,1666 ----
  	    }
  	    /* create a new node for a parameter with the *
  	     * flags in `on' minus the readonly flag      */
!         t = ztrdup(asg->name);
! 	    pm = createparam(t, on & ~PM_READONLY);
!         zsfree(t);
  	    DPUTS(!pm, "BUG: parameter not created");
  	    pm->ct = auxlen;
  	    if (func != BIN_EXPORT)
***************
*** 2300,2305 ****
--- 2303,2309 ----
      int *len;
      Histent ent;
      FILE *fout = stdout;
+     char *arg_to_free = 0;
  
      /* -m option -- treat the first argument as a pattern and remove
       * arguments not matching */
***************
*** 2328,2336 ****
  	    args[n] = getkeystring(args[n], &len[n],
  				    func != BIN_ECHO && !ops['e'], &nnl);
  	/* -P option -- interpret as a prompt sequence */
! 	if(ops['P'])
! 	    args[n] = unmetafy(promptexpand(metafy(args[n], len[n],
! 		META_NOALLOC), 0, NULL, NULL), &len[n]);
  	/* -D option -- interpret as a directory, and use ~ */
  	if(ops['D']) {
  	    Nameddir d = finddir(args[n]);
--- 2332,2342 ----
  	    args[n] = getkeystring(args[n], &len[n],
  				    func != BIN_ECHO && !ops['e'], &nnl);
  	/* -P option -- interpret as a prompt sequence */
!     if(ops['P']) {
!         arg_to_free = unmetafy(promptexpand(metafy(args[n], len[n],
!                           META_NOALLOC), 0, NULL, NULL), &len[n]);
!         args[n] = arg_to_free;
!     }
  	/* -D option -- interpret as a directory, and use ~ */
  	if(ops['D']) {
  	    Nameddir d = finddir(args[n]);
***************
*** 2349,2354 ****
--- 2355,2362 ----
  	PERMALLOC {
  	    pushnode(bufstack, sepjoin(args, NULL));
  	} LASTALLOC;
+     if(arg_to_free)
+         free(arg_to_free);
  	return 0;
      }
      /* -s option -- add the arguments to the history list */
***************
*** 2378,2383 ****
--- 2386,2393 ----
  	    ent->stim = ent->ftim = time(NULL);
  	    ent->flags = 0;
  	} LASTALLOC;
+     if(arg_to_free)
+         free(arg_to_free);
  	return 0;
      }
      /* -u and -p -- output to other than standard output */
***************
*** 2392,2401 ****
--- 2402,2415 ----
  	    fd = coprocout;
  	if ((fd = dup(fd)) < 0) {
  	    zwarnnam(name, "bad file number", NULL, 0);
+         if(arg_to_free)
+             free(arg_to_free);
  	    return 1;
  	}
  	if ((fout = fdopen(fd, "w")) == 0) {
  	    zwarnnam(name, "bad mode on fd", NULL, 0);
+         if(arg_to_free)
+             free(arg_to_free);
  	    return 1;
  	}
      }
***************
*** 2448,2453 ****
--- 2462,2469 ----
  	}
  	if (fout != stdout)
  	    fclose(fout);
+     if(arg_to_free)
+         free(arg_to_free);
  	return 0;
      }
      /* normal output */
***************
*** 2460,2465 ****
--- 2476,2483 ----
  	fputc(ops['N'] ? '\0' : '\n', fout);
      if (fout != stdout)
  	fclose(fout);
+     if(arg_to_free)
+         free(arg_to_free);
      return 0;
  }
  

