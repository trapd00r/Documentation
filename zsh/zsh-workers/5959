From zsh-workers-return-5959-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Mar 26 12:46:17 1999
Return-Path: <zsh-workers-return-5959-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 28224 invoked from network); 26 Mar 1999 12:46:15 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Mar 1999 12:46:15 -0000
Received: (qmail 16210 invoked by alias); 26 Mar 1999 12:45:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5959
Received: (qmail 16203 invoked from network); 26 Mar 1999 12:45:53 -0000
Date: Fri, 26 Mar 1999 13:45:47 +0100 (MET)
Message-Id: <199903261245.NAA26178@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Bruce Stephens's message of 26 Mar 1999 11:41:50 +0000
Subject: Re: Completion of files with spaces in


Bruce Stephens wrote:

> OK, that quotes the spaces, but I don't get completion after that.
> For example, if I have the file as above, and another one 
> "readme - yarrow.txt", then I get:
> 
>         % less readme\ -\ 
>                           ^ cursor here
> 
> as I'd expect, but <TAB> after that just beeps (I'd expect to be shown
> the possible completions).  And typing an extra "c" or "y" (to
> disambiguate) doesn't help: <TAB> just beeps.

Yep. The patch below should fix this, but it still has one problem:
braces are not re-inserted in the right place if there were characters
that needed quoting before them. I don't see a simple enough solution
for this now, I'll have to think about this some more.

The patch looks big but that's just a function getting one more
argument.


Bye
 Sven

diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Fri Mar 26 11:50:01 1999
+++ Src/Zle/zle_tricky.c	Fri Mar 26 13:26:36 1999
@@ -61,7 +61,7 @@
 #endif
 
 
-#define inststr(X) inststrlen((X),1,-1)
+#define inststr(X) inststrlen((X),1,-1,0)
 
 /* wb and we hold the beginning/end position of the word we are completing. */
 
@@ -515,7 +515,7 @@
 	cs = menupos + menulen + menuinsc;
 	iremovesuffix(' ', 1);
 
-	inststrlen(" ", 1, 1);
+	inststrlen(" ", 1, 1, 0);
 	menuinsc = menulen = 0;
 	menupos = cs;
 	menuwe = 1;
@@ -2422,9 +2422,6 @@
 	Cline pli, plil;
 	int mpl, rpl, wl;
 
-	if (qu)
-	    w = quotename(w, NULL);
-
 	wl = strlen(w);
 
 	/* Always try to match the prefix. */
@@ -2491,6 +2488,9 @@
 	    pli = matchparts;
 	}
 	r = dupstring(matchbuf);
+	if (qu)
+	    r = quotename(r, NULL);
+
 	*clp = pli;
 
 	/* Test if the string built is equal to the one from the line. */
@@ -3583,7 +3583,7 @@
 		    lc = bld_parts(s, sl, -1, NULL);
 		    isexact = 0;
 		} else if (!(ms = comp_match(lpre, lsuf, s, cp, &lc,
-					     (aflags & CAF_QUOTE),
+					     !(aflags & CAF_QUOTE),
 					     &bpl, &bsl, &isexact)))
 		    continue;
 
@@ -4224,20 +4224,17 @@
 	zsfree(compprefix);
 	zsfree(compsuffix);
 	if (unset(COMPLETEINWORD)) {
-	    if (linwhat == IN_MATH)
-		tmp = s;
-	    else
-		tmp = quotename(s, NULL);
+	    /* Maybe we'll have to do quoting here some time. */
+	    tmp = dupstring(s);
 	    untokenize(tmp);
 	    compprefix = ztrdup(tmp);
 	    compsuffix = ztrdup("");
 	} else {
-	    char *ss = s + offs, sav;
+	    char *ss, sav;
 	    
-	    if (linwhat == IN_MATH)
-		tmp = s;
-	    else
-		tmp = quotename(s, &ss);
+	    tmp = dupstring(s);
+	    ss = tmp + offs;
+
 	    sav = *ss;
 	    *ss = '\0';
 	    untokenize(tmp);
@@ -6318,20 +6315,29 @@
 
 /* Insert the given string into the command line.  If move is non-zero, *
  * the cursor position is changed and len is the length of the string   *
- * to insert (if it is -1, the length is calculated here).              */
+ * to insert (if it is -1, the length is calculated here).              *
+ * The last argument says if we should quote the string.                */
 
 /**/
-static void
-inststrlen(char *str, int move, int len)
+static int
+inststrlen(char *str, int move, int len, int qu)
 {
     if (!len || !str)
-	return;
+	return 0;
     if (len == -1)
 	len = strlen(str);
+    if (qu) {
+	VARARR(char, b,  len + 1);
+	memcpy(b, str, len);
+	b[len] = '\0';
+	str = quotename(b, NULL);
+	len = strlen(str);
+    }
     spaceinline(len);
     strncpy((char *)(line + cs), str, len);
     if (move)
 	cs += len;
+    return len;
 }
 
 /* This builds the unambiguous string. If ins is non-zero, it is
@@ -6358,11 +6364,11 @@
 	    slen = strlen(brend); sl = we - wb - brsl - plen - slen + 1;
 	}
 	if (!pl) {
-	    inststrlen(brbeg, 1, -1);
+	    inststrlen(brbeg, 1, -1, 0);
 	    pl = -1; hasp = 0;
 	}
 	if (!sl) {
-	    inststrlen(brend, 1, -1);
+	    inststrlen(brend, 1, -1, 0);
 	    sl = -1; hass = 0;
 	}
     }
@@ -6374,7 +6380,7 @@
 	    spos = -1;
 	/* Insert the original string if no prefix. */
 	if (l->olen && !(l->flags & CLF_SUF) && !l->prefix) {
-	    inststrlen(l->orig, 1, l->olen);
+	    inststrlen(l->orig, 1, l->olen, 1);
 	    if (ins) {
 		li += l->olen;
 		if (pl >= 0 && li >= pl) {
@@ -6389,9 +6395,9 @@
 	    for (s = l->prefix; s; s = s->next) {
 		pcs = cs;
 		if (s->flags & CLF_LINE)
-		    inststrlen(s->line, 1, s->llen);
+		    inststrlen(s->line, 1, s->llen, 1);
 		else
-		    inststrlen(s->word, 1, s->wlen);
+		    inststrlen(s->word, 1, s->wlen, 1);
 		if (d < 0 && (s->flags & CLF_DIFF))
 		    d = cs;
 		if (ins) {
@@ -6412,9 +6418,9 @@
 	pcs = cs;
 	/* Insert the anchor. */
 	if (l->flags & CLF_LINE)
-	    inststrlen(l->line, 1, l->llen);
+	    inststrlen(l->line, 1, l->llen, 1);
 	else
-	    inststrlen(l->word, 1, l->wlen);
+	    inststrlen(l->word, 1, l->wlen, 1);
 	if (ins) {
 	    li += l->llen;
 	    if (pl >= 0 && li >= pl) {
@@ -6434,7 +6440,7 @@
 	/* And now insert the suffix or the original string. */
 	if (l->olen && (l->flags & CLF_SUF) && !l->suffix) {
 	    pcs = cs;
-	    inststrlen(l->orig, 1, l->olen);
+	    inststrlen(l->orig, 1, l->olen, 1);
 	    if (ins) {
 		li += l->olen;
 		if (pl >= 0 && li >= pl) {
@@ -6451,10 +6457,10 @@
 		if (j < 0 && (s->flags & CLF_DIFF))
 		    j = i;
 		if (s->flags & CLF_LINE) {
-		    inststrlen(s->line, 0, s->llen);
+		    inststrlen(s->line, 0, s->llen, 1);
 		    i += s->llen; pcs = cs + s->llen;
 		} else {
-		    inststrlen(s->word, 0, s->wlen);
+		    inststrlen(s->word, 0, s->wlen, 1);
 		    i += s->wlen; pcs = cs + s->wlen;
 		}
 		if (ins) {
@@ -6480,14 +6486,14 @@
 	    if (hasp && ppos >= 0) {
 		i = cs;
 		cs = ppos;
-		inststrlen(brbeg, 1, plen);
+		inststrlen(brbeg, 1, plen, 0);
 		cs = i + plen;
 		hasp = 0;
 	    }
 	    if (hass && spos >= 0) {
 		i = cs;
 		cs = spos;
-		inststrlen(brend, 1, slen);
+		inststrlen(brend, 1, slen, 0);
 		cs = i + slen;
 		hass = 0;
 	    }
@@ -6495,9 +6501,9 @@
 	l = l->next;
     }
     if (pl >= 0)
-	inststrlen(brbeg, 1, plen);
+	inststrlen(brbeg, 1, plen, 0);
     if (sl >= 0)
-	inststrlen(brend, 1, slen);
+	inststrlen(brend, 1, slen, 0);
 
     /* This calculates the new cursor position. If we had a mid cline
      * with missing characters, we take this, otherwise if we have a
@@ -6568,21 +6574,21 @@
 
     /* Ignored prefix. */
     if (m->ipre) {
-	inststrlen(m->ipre, 1, (l = strlen(m->ipre)));
+	inststrlen(m->ipre, 1, (l = strlen(m->ipre)), 0);
 	r += l;
     }
     /* -P prefix. */
     if (m->pre) {
-	inststrlen(m->pre, 1, (l = strlen(m->pre)));
+	inststrlen(m->pre, 1, (l = strlen(m->pre)), 0);
 	r += l;
     }
     /* Path prefix. */
     if (m->ppre) {
-	inststrlen(m->ppre, 1, (l = strlen(m->ppre)));
+	inststrlen(m->ppre, 1, (l = strlen(m->ppre)), 0);
 	r += l;
     }
     /* The string itself. */
-    inststrlen(m->str, 1, (l = strlen(m->str)));
+    inststrlen(m->str, 1, (l = strlen(m->str)), 0);
     r += l;
     ocs = cs;
     /* Re-insert the brace beginning, if any. */
@@ -6590,14 +6596,14 @@
 	cs = a + m->brpl + (m->pre ? strlen(m->pre) : 0);
 	l = strlen(brbeg);
 	brpcs = cs;
-	inststrlen(brbeg, 1, l);
+	inststrlen(brbeg, 1, l, 0);
 	r += l;
 	ocs += l;
 	cs = ocs;
     }
     /* Path suffix. */
     if (m->psuf) {
-	inststrlen(m->psuf, 1, (l = strlen(m->psuf)));
+	inststrlen(m->psuf, 1, (l = strlen(m->psuf)), 0);
 	r += l;
     }
     /* Re-insert the brace end. */
@@ -6606,19 +6612,19 @@
 	cs -= m->brsl;
 	ocs = brscs = cs;
 	l = strlen(brend);
-	inststrlen(brend, 1, l);
+	inststrlen(brend, 1, l, 0);
 	r += l;
 	cs = a + l;
     } else
 	brscs = -1;
     /* -S suffix */
     if (m->suf) {
-	inststrlen(m->suf, 1, (l = strlen(m->suf)));
+	inststrlen(m->suf, 1, (l = strlen(m->suf)), 0);
 	r += l;
     }
     /* ignored suffix */
     if (m->isuf) {
-	inststrlen(m->isuf, 1, (l = strlen(m->isuf)));
+	inststrlen(m->isuf, 1, (l = strlen(m->isuf)), 0);
 	r += l;
     }
     lastend = cs;
@@ -6796,7 +6802,7 @@
 	if (m->ripre && (m->flags & CMF_PARBR)) {
 	    /*{{*/
 	    /* Completing a parameter in braces.  Add a removable `}' suffix. */
-	    inststrlen("}", 1, 1);
+	    inststrlen("}", 1, 1, 0);
 	    menuinsc++;
 	    if (menuwe)
 		menuend++;
@@ -6817,7 +6823,7 @@
 	    if (!(sr = ztat(p, &buf, 0)) && S_ISDIR(buf.st_mode)) {
 		/* It is a directory, so add the slash. */
 		havesuff = 1;
-		inststrlen("/", 1, 1);
+		inststrlen("/", 1, 1, 0);
 		menuinsc++;
 		if (menuwe)
 		    menuend++;
@@ -6841,7 +6847,7 @@
 	    /* Otherwise, add a `,' suffix, and let `}' remove it. */
 	    cs = menuend;
 	    havesuff = 1;
-	    inststrlen(",", 1, 1);
+	    inststrlen(",", 1, 1, 0);
 	    menuinsc++;
 	    makesuffix(1);
 	    if ((!menucmp || menuwe) && isset(AUTOPARAMKEYS))
@@ -6851,7 +6857,7 @@
 	/* If we didn't add a suffix, add a space, unless we are *
 	 * doing menu completion or we are completing files and  *
 	 * the string doesn't name an existing file.             */
-	inststrlen(" ", 1, 1);
+	inststrlen(" ", 1, 1, 0);
 	menuinsc++;
 	if (menuwe)
 	    makesuffix(1);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

