From zsh-workers-return-11274-mason-zsh=primenet.com.au@sunsite.auc.dk Tue May 09 11:03:50 2000
Return-Path: <zsh-workers-return-11274-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15686 invoked from network); 9 May 2000 11:03:40 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 May 2000 11:03:40 -0000
Received: (qmail 19152 invoked by alias); 9 May 2000 11:02:19 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11274
Received: (qmail 19123 invoked from network); 9 May 2000 11:02:19 -0000
Date: Tue, 9 May 2000 13:02:04 +0200 (MET DST)
Message-Id: <200005091102.NAA19935@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Mon, 8 May 2000 12:40:49 +0200 (MET
	DST)
Subject: PATCH: RE: Command completion in nslookup


I wrote:

> Another suggestion: allow compstate[insert] to take the value `tab'
> (or something like this). On entry to the widget it has this value
> when in the first column. On exit, if it has this value, only a T=tab
> will be inserted. But then the widget can decide what it wants to do
> and we could easily add a style for this.

This adds this and a style (`insert-tab') that can be used to say if
one wants the tab inserted (the default) or not. I.e. one can now do:

  zstyle ':completion:nslookup:*' insert-tab no

To not get the TAB in nslookup.


Nicely small patch...

Bye
 Sven

Index: Completion/Builtins/_zstyle
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Builtins/_zstyle,v
retrieving revision 1.11
diff -u -r1.11 _zstyle
--- Completion/Builtins/_zstyle	2000/05/08 08:44:54	1.11
+++ Completion/Builtins/_zstyle	2000/05/09 10:59:17
@@ -40,6 +40,7 @@
   ignore-parents         c:ignorepar
   ignored-patterns	 c:
   insert-ids             c:insert-ids
+  insert-tab             c:bool
   insert-unambiguous	 c:bool
   last-prompt		 c:bool
   list			 c:listwhen
Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.14
diff -u -r1.14 _main_complete
--- Completion/Core/_main_complete	2000/05/08 08:16:32	1.14
+++ Completion/Core/_main_complete	2000/05/09 10:59:17
@@ -34,6 +34,12 @@
 
 [[ -z "$curcontext" ]] && curcontext=:::
 
+if [[ "$compstate[insert]" = tab* ]]; then
+  zstyle -T ":completion:${curcontext}:" insert-tab && return 1
+
+  compstate[insert]="${compstate[insert]//tab /}"
+fi
+
 # Special completion contexts after `~' and `='.
 
 if compset -P 1 '='; then
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.39
diff -u -r1.39 compsys.yo
--- Doc/Zsh/compsys.yo	2000/05/09 09:05:35	1.39
+++ Doc/Zsh/compsys.yo	2000/05/09 10:59:19
@@ -1253,6 +1253,15 @@
 the line is longer than the prefix of the IDs of all matching
 processes.
 )
+kindex(insert-tab, completion style)
+item(tt(insert-tab))(
+If this has one of the `true' values, the completion system will only
+insert the TAB character if the completion code would normally do that 
+(i.e. when there is no non-blank character to the left of the cursor
+yet). If set to `false', completion will be done even there.
+
+The default value of this style is `true'.
+)
 kindex(insert-unambiguous, completion style)
 item(tt(insert-unambiguous))(
 This is used by the tt(_match) and tt(_approximate) completer
Index: Doc/Zsh/compwid.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compwid.yo,v
retrieving revision 1.9
diff -u -r1.9 compwid.yo
--- Doc/Zsh/compwid.yo	2000/05/02 10:30:41	1.9
+++ Doc/Zsh/compwid.yo	2000/05/09 10:59:20
@@ -275,7 +275,10 @@
 completion code may start menucompletion (due to the tt(AUTO_MENU)
 option being set); if set to tt(menu) or tt(automenu) menucompletion
 will be started for the matches currently generated (in the
-latter case this will happen because the tt(AUTO_MENU) is set).
+latter case this will happen because the tt(AUTO_MENU) is set). The
+value may also contain the string `tt(tab)' when the completion code
+woul normally not really do completion, but only insert the TAB
+character.
 
 On exit it may be set to any of the values above (where setting it to
 the empty string is the same as unsetting it), or to a number, in which
@@ -290,6 +293,10 @@
 Both tt(menu) and tt(automenu) may also specify the the number of the
 match to insert, given after a colon.  For example, `tt(menu:2)' says
 to start menucompletion, beginning with the second match.
+
+Note that a value containing the substring `tt(tab)' makes the
+matches generated be ignored and only the character that was used to
+call the completion widget be inserted.
 
 Finally, it may also be set to tt(all), which makes all matches
 generated be inserted into the line.
Index: Src/Zle/compcore.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/compcore.c,v
retrieving revision 1.16
diff -u -r1.16 compcore.c
--- Src/Zle/compcore.c	2000/05/05 12:06:21	1.16
+++ Src/Zle/compcore.c	2000/05/09 10:59:21
@@ -292,7 +292,7 @@
 	compqstack[0] = '\'';
 
     hasunqu = 0;
-    useline = (lst != COMP_LIST_COMPLETE);
+    useline = (wouldinstab ? -1 : (lst != COMP_LIST_COMPLETE));
     useexact = isset(RECEXACT);
     zsfree(compexactstr);
     compexactstr = ztrdup("");
@@ -334,6 +334,8 @@
 	clearlist = 1;
 	ret = 1;
 	minfo.cur = NULL;
+	if (useline < 0)
+	    selfinsert(zlenoargs);
 	goto compend;
     }
     zsfree(lastprebr);
@@ -342,7 +344,9 @@
 
     if (comppatmatch && *comppatmatch && comppatmatch != opm)
 	haspattern = 1;
-    if (!useline && uselist) {
+    if (useline < 0)
+	selfinsert(zlenoargs);
+    else if (!useline && uselist) {
 	/* All this and the guy only wants to see the list, sigh. */
 	cs = 0;
 	foredel(ll);
@@ -430,7 +434,7 @@
     /* Print the explanation strings if needed. */
     if (!showinglist && validlist && usemenu != 2 && 
 	(nmatches != 1 || diffmatches) &&
-	useline != 2 && (!oldlist || !listshown)) {
+	useline >= 0 && useline != 2 && (!oldlist || !listshown)) {
 	onlyexpl = 1;
 	showinglist = -2;
     }
@@ -706,7 +710,8 @@
 	    compinsert = "";
 	    kset &= ~CP_INSERT;
 	}
-	compinsert = ztrdup(compinsert);
+	compinsert = (useline < 0 ? tricat("tab ", "", compinsert) :
+		      ztrdup(compinsert));
 	if (useexact)
 	    compexact = ztrdup("accept");
 	else {
@@ -780,6 +785,8 @@
 
 	if (!compinsert)
 	    useline = 0;
+	else if (strstr(compinsert, "tab"))
+	    useline = -1;
 	else if (!strcmp(compinsert, "unambig") ||
 		 !strcmp(compinsert, "unambiguous") ||
 		 !strcmp(compinsert, "automenu-unambiguous"))
Index: Src/Zle/zle_tricky.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_tricky.c,v
retrieving revision 1.7
diff -u -r1.7 zle_tricky.c
--- Src/Zle/zle_tricky.c	2000/04/19 13:42:51	1.7
+++ Src/Zle/zle_tricky.c	2000/05/09 10:59:21
@@ -77,6 +77,11 @@
 /**/
 mod_export int usemenu, useglob;
 
+/* != 0 if we would insert a TAB if we weren't calling a completion widget. */
+
+/**/
+mod_export int wouldinstab;
+
 /* != 0 if we are in the middle of a menu completion. May be == 2 to force *
  * menu completion even if using different widgets.                        */
 
@@ -153,9 +158,15 @@
 {
     unsigned char *s = line + cs - 1;
 
+    wouldinstab = 0;
     for (; s >= line && *s != '\n'; s--)
 	if (*s != '\t' && *s != ' ')
 	    return 0;
+    if (compfunc) {
+	wouldinstab = 1;
+
+	return 0;
+    }
     return 1;
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

