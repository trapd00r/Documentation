From zsh-workers-return-10685-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Apr 12 08:23:00 2000
Return-Path: <zsh-workers-return-10685-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16435 invoked from network); 12 Apr 2000 08:22:55 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Apr 2000 08:22:55 -0000
Received: (qmail 26798 invoked by alias); 12 Apr 2000 08:22:48 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10685
Received: (qmail 26784 invoked from network); 12 Apr 2000 08:22:47 -0000
Date: Wed, 12 Apr 2000 10:22:37 +0200 (MET DST)
Message-Id: <200004120822.KAA06887@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 11 Apr 2000 15:25:06 +0000
Subject: PATCH: Re: copy-prev-word question RE: Bug report interface comments


Bart Schaefer wrote:

> ...
> On Apr 11, 11:48am, Sven Wischnowsky wrote:
> }
> } Back to the original question: should I commit the patch? With a
> } to-the-left-of-the-cursor manual as suggested by Oliver? Should I make 
> } it a separate widget? (Name? I can only think of copy-last-word which
> } is probably to easily confused with copy-prev-word and insert-last-word.)
> 
> Oliver's suggestion:  Yes.
> 
> A new widget:  Yes.  Call it repeat-prev-word or copy-prev-shell-word or
> some such.  (The distinction is whether the word boundary is typographical 
> or shell-lexical, right?)

Right. Here's the patch. I've used `copy-prev-shell-word'.

Bye
 Sven

Index: Doc/Zsh/zle.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/zle.yo,v
retrieving revision 1.3
diff -u -r1.3 zle.yo
--- Doc/Zsh/zle.yo	2000/04/05 08:49:50	1.3
+++ Doc/Zsh/zle.yo	2000/04/12 08:16:34
@@ -637,7 +637,13 @@
 )
 tindex(copy-prev-word)
 item(tt(copy-prev-word) (ESC-^_) (unbound) (unbound))(
-Duplicate the word behind the cursor.
+Duplicate the word to the left of the cursor.
+)
+tindex(copy-prev-shell-word)
+item(tt(copy-prev-shell-word) (ESC-^_) (unbound) (unbound))(
+Like tt(copy-prev-word), but the word is found by using shell parsing, 
+whereas tt(copy-prev-word) looks for blanks. This makes a difference
+when the word is quoted and contains spaces.
 )
 tindex(vi-delete)
 item(tt(vi-delete) (unbound) (d) (unbound))(
Index: Src/hist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/hist.c,v
retrieving revision 1.1.1.18
diff -u -r1.1.1.18 hist.c
--- Src/hist.c	2000/02/23 15:18:44	1.1.1.18
+++ Src/hist.c	2000/04/12 08:16:35
@@ -2032,3 +2032,66 @@
 	free(lockfile);
     }
 }
+
+/* Get the words in the current buffer. Using the lexer. */
+
+/**/
+mod_export LinkList
+bufferwords(int *index)
+{
+    LinkList list = newlinklist();
+    int num = 0, cur = -1, got = 0, ne = noerrs, ocs = cs;
+    char *p;
+
+    zleparse = 1;
+    addedx = 0;
+    noerrs = 1;
+    lexsave();
+    if (!isfirstln && chline) {
+	p = (char *) zhalloc(hptr - chline + ll + 2);
+	memcpy(p, chline, hptr - chline);
+	memcpy(p + (hptr - chline), line, ll);
+	p[(hptr - chline) + ll] = ' ';
+	p[(hptr - chline) + ll + 1] = '\0';
+	inpush(p, 0, NULL);
+	cs += hptr - chline;
+    } else {
+	p = (char *) zhalloc(ll + 2);
+	memcpy(p, line, ll);
+	p[ll] = ' ';
+	p[ll + 1] = '\0';
+	inpush(p, 0, NULL);
+    }
+    if (cs)
+	cs--;
+    strinbeg(0);
+    noaliases = 1;
+    do {
+	ctxtlex();
+	if (tok == ENDINPUT || tok == LEXERR)
+	    break;
+	if (tokstr && *tokstr) {
+	    untokenize((p = dupstring(tokstr)));
+	    addlinknode(list, p);
+	    num++;
+	}
+	if (!got && !zleparse) {
+	    got = 1;
+	    cur = num - 1;
+	}
+    } while (tok != ENDINPUT && tok != LEXERR);
+    if (cur < 0 && num)
+	cur = num - 1;
+    noaliases = 0;
+    strinend();
+    inpop();
+    errflag = zleparse = 0;
+    noerrs = ne;
+    lexrestore();
+    cs = ocs;
+
+    if (index)
+	*index = cur;
+
+    return list;
+}
Index: Src/Modules/parameter.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/parameter.c,v
retrieving revision 1.3
diff -u -r1.3 parameter.c
--- Src/Modules/parameter.c	2000/04/10 08:22:09	1.3
+++ Src/Modules/parameter.c	2000/04/12 08:16:35
@@ -1093,10 +1093,14 @@
 histwgetfn(Param pm)
 {
     char **ret, **p, *h, *e, sav;
-    LinkList l = newlinklist();
+    LinkList l = newlinklist(), ll;
     LinkNode n;
     int i = addhistnum(curhist, -1, HIST_FOREIGN), iw;
     Histent he = quietgethistent(i, GETHIST_UPWARD);
+
+    ll = bufferwords(NULL);
+    for (n = firstnode(ll); n; incnode(n))
+	pushnode(l, getdata(n));
 
     while (he) {
 	for (iw = he->nwords - 1; iw >= 0; iw--) {
Index: Src/Zle/iwidgets.list
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/iwidgets.list,v
retrieving revision 1.2
diff -u -r1.2 iwidgets.list
--- Src/Zle/iwidgets.list	2000/04/01 20:49:48	1.2
+++ Src/Zle/iwidgets.list	2000/04/12 08:16:35
@@ -28,6 +28,7 @@
 "clear-screen", clearscreen, ZLE_MENUCMP | ZLE_KEEPSUFFIX | ZLE_LASTCOL | ZLE_NOTCOMMAND
 "complete-word", completeword, ZLE_MENUCMP | ZLE_KEEPSUFFIX | ZLE_ISCOMP
 "copy-prev-word", copyprevword, ZLE_KEEPSUFFIX
+"copy-prev-shell-word", copyprevshellword, ZLE_KEEPSUFFIX
 "copy-region-as-kill", copyregionaskill, ZLE_KEEPSUFFIX
 "delete-char", deletechar, ZLE_KEEPSUFFIX
 "delete-char-or-list", deletecharorlist, ZLE_MENUCMP | ZLE_KEEPSUFFIX | ZLE_ISCOMP
Index: Src/Zle/zle_misc.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_misc.c,v
retrieving revision 1.1.1.21
diff -u -r1.1.1.21 zle_misc.c
--- Src/Zle/zle_misc.c	2000/03/14 09:43:53	1.1.1.21
+++ Src/Zle/zle_misc.c	2000/04/12 08:16:35
@@ -542,6 +542,32 @@
 
 /**/
 int
+copyprevshellword(char **args)
+{
+    LinkList l;
+    LinkNode n;
+    int i;
+    char *p = NULL;
+
+    l = bufferwords(&i);
+
+    for (n = firstnode(l); n; incnode(n))
+	if (!i--) {
+	    p = getdata(n);
+	    break;
+	}
+    if (p) {
+	int len = strlen(p);
+
+	spaceinline(len);
+	memcpy(line + cs, p, len);
+	cs += len;
+    }
+    return 0;
+}
+
+/**/
+int
 sendbreak(char **args)
 {
     errflag = 1;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

