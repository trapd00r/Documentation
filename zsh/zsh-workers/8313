From zsh-workers-return-8313-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Oct 18 08:38:19 1999
Return-Path: <zsh-workers-return-8313-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7902 invoked from network); 18 Oct 1999 08:38:17 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Oct 1999 08:38:17 -0000
Received: (qmail 14690 invoked by alias); 18 Oct 1999 08:38:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8313
Received: (qmail 14682 invoked from network); 18 Oct 1999 08:38:04 -0000
Date: Mon, 18 Oct 1999 10:38:03 +0200 (MET DST)
Message-Id: <199910180838.KAA25889@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Fri, 15 Oct 1999 18:26:51 +0400
Subject: RE: PATCH: Re: _match still does not work in _path_files


Andrej Borsenkow wrote:

> > Believe it or not, it works correctly. I always said, that with
> > matching (a.k.a. GLOB_COMPLETE), the match specs are not used, and
> > functions like `_path_files' rely on them.
> 
> I do not believe it :-) It did work for me in all 3.1.5* and in 3.1.6-pws-XX
> (well, at least in pws-1 and pws-2). It stopped to work now. Unless there was a
> good reason to break it ... may I have it back?

The reason was the request to have completion inside braces work if
the brace is in the path prefix. That required to use a `compadd' with 
matching when we finally add the matches and since the match specs
aren't used when glob-completion is done, the prefix line-pattern
doesn't match the prefix added with the matches.

The patch below implements some kind of mixed-matching style. Even
with glob-complete behaviour it will try to match the prefix using the 
match specs currently in effect. This is as far as we can get. Is it
enough?

The patch also makes the path-expand behaviour a bit more powerful.
I.e. it changes the way the `path_expand' key is used (NOTE
incompatible change): if the value contains the substring `prefix',
the prefix is expanded as far as possible (this is what was previously 
achieved by setting it to any non-empty value). If the value contains
`suffix', it will add possible files in the suffix when not using
menu-completion, i.e. it will try to produce an unambiguous string
which is as long as possible (this was previously the default
behaviour).

People like Andrej might want to leave it unset.

If anyone has an idea how we could make it find out when it would be
interesting to expand the suffix anyway, let me know.


In a different message:

> Ahem ... but why is menu completion started for the last path component in the
> first place? I expect it to be started for {functions,functions.old} - the first
> ambiguous part. And I bet it was - once.
> 
> I tested it in zsh-3.1.6 and there _match works :-) and look what happens:
> 
> itsrm2% l /t/s/z/f*/_<TAB>
> itsrm2% l /tools/share/zsh/functions/_
> functions/      functions.old/
> 
> press TAB once more and selection is started for the first ambiguous component:

This works for me again. If it still doesn't work for you, I need to
know your compconfig.

> I (from a user's point of view) fail to see, how /t/s/z/f/_ differs from
> /t/s/z/f*/_ - it has exactly and precisely the same meaning.

For me, they are completely different. The second one is a pattern
(note: the *whole* string) and even though the patch should make it
work the way you want it, I think there is still a point in saying
that *should* be treated differently. If I ever try completion on a
pattern (which is seldom nowadays, I mostly use spiffy xor'ed global
match specs), I would probably want it to be interpreted as `I know
what I'm doing here, I give you a pattern and you should handle
exactly that and nothing else'. I.e. it shouldn't use match-specs
(which is just a different type of pattern matching for me).

Bye
 Sven

diff -u -r oldsrc/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- oldsrc/Zle/zle_tricky.c	Mon Oct 18 09:50:07 1999
+++ Src/Zle/zle_tricky.c	Mon Oct 18 10:05:37 1999
@@ -4118,23 +4118,6 @@
 		    llpl -= pl;
 		    lpre += pl;
 		}
-		if (comppatmatch && *comppatmatch) {
-		    int is = (*comppatmatch == '*');
-		    char *tmp = (char *) zhalloc(2 + llpl + llsl);
-
-		    strcpy(tmp, lpre);
-		    tmp[llpl] = 'x';
-		    strcpy(tmp + llpl + is, lsuf);
-
-		    tokenize(tmp);
-		    remnulargs(tmp);
-		    if (haswilds(tmp)) {
-			if (is)
-			    tmp[llpl] = Star;
-			if ((cp = patcompile(tmp, 0, NULL)))
-			    haspattern = 1;
-		    }
-		}
 	    }
 	    /* Now duplicate the strings we have from the command line. */
 	    if (dat->ipre)
@@ -4195,6 +4178,23 @@
 			lsuf[llsl - lsl] = '\0';
 		    else
 			*argv = NULL;
+		}
+		if (comppatmatch && *comppatmatch) {
+		    int is = (*comppatmatch == '*');
+		    char *tmp = (char *) zhalloc(2 + llpl + llsl);
+
+		    strcpy(tmp, lpre);
+		    tmp[llpl] = 'x';
+		    strcpy(tmp + llpl + is, lsuf);
+
+		    tokenize(tmp);
+		    remnulargs(tmp);
+		    if (haswilds(tmp)) {
+			if (is)
+			    tmp[llpl] = Star;
+			if ((cp = patcompile(tmp, 0, NULL)))
+			    haspattern = 1;
+		    }
 		}
 	    }
 	    if (*argv) {
diff -u -r oldcompletion/Core/_main_complete Completion/Core/_main_complete
--- oldcompletion/Core/_main_complete	Mon Oct 18 09:48:51 1999
+++ Completion/Core/_main_complete	Mon Oct 18 10:12:31 1999
@@ -60,6 +60,7 @@
 
 _lastdescr=( "\`${(@)^_lastdescr:#}'" )
 if [[ compstate[nmatches] -eq 0 &&
+      compstate[matcher] -eq compstate[total_matchers] &&
       -n "$compconfig[warning_format]" && $#_lastdescr -ne 0 ]]; then
   local str
 
diff -u -r oldcompletion/Core/_path_files Completion/Core/_path_files
--- oldcompletion/Core/_path_files	Mon Oct 18 09:48:51 1999
+++ Completion/Core/_path_files	Mon Oct 18 10:05:37 1999
@@ -347,7 +347,7 @@
 	SUFFIX=""
       fi
 
-      if [[ -n $menu ]]; then
+      if [[ -n $menu || "$compconfig[path_expand]" != *suffix* ]]; then
         [[ -n "$compconfig[path_cursor]" ]] && compstate[to_end]=''
         if [[ "$tmp3" = */* ]]; then
 	  compadd -Qf -p "$linepath${testpath:q}" -s "/${tmp3#*/}" \
@@ -418,7 +418,7 @@
 
 exppaths=( "${(@)exppaths:#$orig}" )
 
-if [[ -n "$compconfig[path_expand]" &&
+if [[ "$compconfig[path_expand]" = *prefix* &&
       $#exppaths -gt 0 && nm -eq compstate[nmatches] ]]; then
   PREFIX="${opre}${osuf}"
   SUFFIX=""
diff -u -r oldcompletion/Core/compinit Completion/Core/compinit
--- oldcompletion/Core/compinit	Mon Oct 18 09:48:52 1999
+++ Completion/Core/compinit	Mon Oct 18 10:05:37 1999
@@ -368,7 +368,7 @@
 
 # Utility function to call a function if it exists.
 #
-# Usage: call <return> <name> [ <args> ... ]
+# Usage: funcall <return> <name> [ <args> ... ]
 #
 # If a function named <name> is defined (or defined to be autoloaded),
 # it is called. If <return> is given not the string `-' or empty, it is
@@ -385,10 +385,11 @@
 
   shift
 
-  if builtin functions "$1"; then
+  if builtin functions "$1" >& /dev/null; then
     "$@"
     _ret="$?"
     [[ -n "$_name" ]] && eval "${_name}=${_ret}"
+    compstate[restore]=''
     return 0
   fi
   return 1
diff -u olddoc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- olddoc/Zsh/compsys.yo	Mon Oct 18 09:50:35 1999
+++ Doc/Zsh/compsys.yo	Mon Oct 18 10:37:32 1999
@@ -720,9 +720,16 @@
 Finally, the tt(_path_files) function supports two configuration keys.
 startitem()
 item(tt(path_expand))(
-If this is set to any non-empty string, the partially
+If this is set to a string containing `tt(prefix)', the partially
 typed path from the line will be expanded as far as possible even if
-trailing pathname components can not be completed.
+trailing pathname components can not be completed. If it contains the
+substring `tt(suffix)' and normal (non-menu-) completion is used,
+matching names for components after the first ambiguous one will be
+added, too. This means that the resulting string is the longest
+unambiguous string possible, but if menu-completion is started on the
+list of matches generated this way (e.g. due to the option
+tt(AUTO_MENU) being set), this will also cycle through the names
+of the files in pathname components after the first ambiguous one.
 )
 item(tt(path_cursor))(
 If this is set to a non-empty string, the cursor will be left

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

