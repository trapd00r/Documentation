From zsh-users-return-14569-mason-zsh=primenet.com.au@zsh.org Thu Nov 12 23:15:05 2009
Return-Path: <zsh-users-return-14569-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27998 invoked by alias); 12 Nov 2009 23:15:05 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14569
Received: (qmail 14353 invoked from network); 12 Nov 2009 23:15:02 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at klanderman.net does not designate permitted sender hosts)
From: Greg Klanderman <gak@klanderman.net>
To: zsh-users@zsh.org
Subject: Re: the function to show a digit argument while it is being typed
Reply-To: gak@klanderman.net
Date: Thu, 12 Nov 2009 18:06:35 -0500
In-Reply-To: <091111094507.ZM30174@torch.brasslantern.com> (Bart Schaefer's message of "Wed, 11 Nov 2009 09:45:07 -0800")
Message-ID: <m3r5s35on8.fsf@klanderman.net>
User-Agent: Gnus/5.1008 (Gnus v5.10.8) XEmacs/21.4.17 (linux)
References: <10081257897632@webmail89.yandex.ru>
	<237967ef0911101822g5bfcf4fao25fc33ba0a2e8604@mail.gmail.com>
	<091110204748.ZM28704@torch.brasslantern.com>
	<237967ef0911102217m1325dc59y8d7388e9f6f21c7b@mail.gmail.com>
	<091111001419.ZM28852@torch.brasslantern.com>
	<m3eio56o4i.fsf@klanderman.net>
	<091111094507.ZM30174@torch.brasslantern.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

>>>>> On November 11, 2009 Bart Schaefer <schaefer@brasslantern.com> wrote:

> } Also would be nice if this worked with universal-argument.

> Hmm, that one is a lot trickier; universal-argument effectively is a
> trap on the next self-insert, such that if a digit is typed it behaves
> like digit-argument (and also discards any "pending" neg-argument,
> which may be yet another bug).  It handles that next keypress in a
> way that makes it impossible to intercept in a wrapper widget, which
> requires that the new widget not call .universal-argument.

So I hacked up a proof of concept in C for showing the argument in the
universal-argument code.. let me know what you think.  It's pretty
light on error checking at this point, mainly I'd like to know if it
prints the right thing, clears when appropriate, and if some cleaned
up version of this might be acceptable.

thanks,
Greg


Index: Src/Zle/zle_misc.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_misc.c,v
retrieving revision 1.58
diff -u -r1.58 zle_misc.c
--- Src/Zle/zle_misc.c	24 Apr 2009 09:00:38 -0000	1.58
+++ Src/Zle/zle_misc.c	12 Nov 2009 23:02:11 -0000
@@ -710,15 +710,63 @@
 }
 
 /**/
+char *
+int2string(char *buf, int i, int base)
+{
+    char *b = buf;
+    int p, v;
+
+    if (i < 0) {
+        *b++ = '-';
+        i = -1;
+    }
+
+    for (p = 1; p <= i; p *= base)
+        ;
+
+    while (p > 1) {
+        p /= base;
+        v = i / p;
+        i -= v * p;
+        *b++ = (v < 10) ? v+'0' : v-10+'a';
+    }
+
+    *b = (char)0;
+    return buf;
+}
+
+/**/
+void
+showarg(int digcnt, int pref, int minus)
+{
+    char msg[100], buf[100];
+
+    if (minus < 0 && digcnt <= 1)
+        strcpy(msg, "arg: -");
+    else if (digcnt)
+        sprintf(msg, "arg: %s", int2string(buf, minus * (pref ? pref : 1), zmod.base));
+    else
+        sprintf(msg, "arg: %sx", int2string(buf, 4*zmod.tmult, zmod.base));
+
+    if (zmod.base != 10)
+        sprintf(msg+strlen(msg), " [base %d]", zmod.base);
+
+    showmsg(msg);
+    zrefresh();
+}
+
+/**/
 int
 universalargument(char **args)
 {
     int digcnt = 0, pref = 0, minus = 1, gotk;
+
     if (*args) {
 	zmod.mult = atoi(*args);
 	zmod.flags |= MOD_MULT;
 	return 0;
     }
+
     /*
      * TODO: this is quite tricky to do when trying to maintain
      * compatibility between the old input system and Unicode.
@@ -734,16 +782,19 @@
      *
      * Hence for now this remains byte-by-byte.
      */
+    showarg(digcnt, pref, minus);
     while ((gotk = getbyte(0L, NULL)) != EOF) {
 	if (gotk == '-' && !digcnt) {
 	    minus = -1;
 	    digcnt++;
+            showarg(digcnt, pref, minus);
 	} else {
 	    int newdigit = parsedigit(gotk);
 
 	    if (newdigit >= 0) {
 		pref = pref * zmod.base + newdigit;
 		digcnt++;
+                showarg(digcnt, pref, minus);
 	    } else {
 		ungetbyte(gotk);
 		break;
@@ -756,6 +807,8 @@
 	zmod.tmult *= 4;
     zmod.flags |= MOD_TMULT;
     prefixflag = 1;
+    showmsg("");
+    zrefresh();
     return 0;
 }
 

