From zsh-workers-return-12114-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jun 29 07:02:56 2000
Return-Path: <zsh-workers-return-12114-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25814 invoked from network); 29 Jun 2000 07:02:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Jun 2000 07:02:54 -0000
Received: (qmail 9162 invoked by alias); 29 Jun 2000 07:02:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12114
Received: (qmail 9155 invoked from network); 29 Jun 2000 07:02:41 -0000
Date: Thu, 29 Jun 2000 09:02:40 +0200 (MET DST)
Message-Id: <200006290702.JAA04157@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Wed, 28 Jun 2000 09:08:04 +0200
	(MET DST)
Subject: Re: PATCH: Re: (forw) --help able programs and completion]


I wrote:

> [ the menu style and `yes=<num>' ]
> 
> Another question is if it should mean `if there are less than <num>
> matches, start menu completion', because menu completion (at least the 
> *real* menu completion, not selection) works best with few matches.
> 
> That's easy to change, though (I'd like to get opinions from menu
> completion users).

This patch does that (as long as I don't get replies, I'll happily
continue hacking).

> > > Does anybody now want support for `no=3'?
> > 
> > Which would mean ...?
> 
> If one has `setopt menucomplete', setting the menu style to one of the 
> `false' values can be used to turn menu completion off for some
> contexts. Allowing `no=<num>' would either mean to turn it of if there 
> are more or less than <num> matches, whatever we decide `yes=<num>'
> means.

It also does this (with `if there are at least <num> matches, don't
start menu completion').

> > However, a plain-ol'-menu-completion variant of select=long-list might be
> > interesting.
> 
> Hmhm, right.

And it does this (`yes=long-list').

Bye
 Sven

Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.32
diff -u -r1.32 _main_complete
--- Completion/Core/_main_complete	2000/06/28 09:42:51	1.32
+++ Completion/Core/_main_complete	2000/06/29 07:02:03
@@ -170,8 +170,9 @@
 
   _menu_style=( "$_menu_style[@]" "$_def_menu_style[@]" )
 
-  if [[ "$compstate[list]" = *list &&
-        -n "$_menu_style[(r)select=long-list]" && tmp -gt LINES ]]; then
+  if [[ "$compstate[list]" = *list && tmp -gt LINES &&
+        ( -n "$_menu_style[(r)select=long-list]" ||
+          -n "$_menu_style[(r)(yes|true|on|1)=long-list]" ) ]]; then
     compstate[insert]=menu
   elif [[ "$compstate[insert]" = "$_saved_insert" ]]; then
     if [[ -n "$_menu_style[(r)select=long]" && tmp -gt LINES ]]; then
@@ -180,28 +181,46 @@
       sel=( "${(@M)_menu_style:#(yes|true|1|on)*}" )
 
       if (( $#sel )); then
-	min=9999999
+	min=0
         for i in "$sel[@]"; do
           if [[ "$i" = *\=* ]]; then
   	    num="${i#*\=}"
   	    [[ num -lt 0 ]] && num=0
   	  else
-  	    num=0
+  	    num=$nm
   	  fi
-  	  [[ num -lt min ]] && min="$num"
+  	  [[ num -gt min ]] && min="$num"
   
-	  (( min )) || break
+	  [[ min -ge nm ]] && break
         done
       fi
-      if [[ ( -n "$min" && nm -ge min ) ||
+      if [[ ( -n "$min" && nm -le min ) ||
             ( -n "$_menu_style[(r)auto*]" &&
               "$compstate[insert]" = automenu ) ]]; then
         compstate[insert]=menu
       elif [[ -n "$_menu_style[(r)auto*]" &&
               "$compstate[insert]" != automenu ]]; then
         compstate[insert]=automenu-unambiguous
-      elif [[ -n "$_menu_style[(r)(no|false|0|off)]" ]]; then
-        compstate[insert]=unambiguous
+      else
+        sel=( "${(@M)_menu_style:#(no|false|0|off)*}" )
+
+        if (( $#sel )); then
+	  min=9999999
+          for i in "$sel[@]"; do
+            if [[ "$i" = *\=* ]]; then
+  	      num="${i#*\=}"
+  	      [[ num -lt 0 ]] && num=0
+  	    else
+  	      num=0
+  	    fi
+  	    [[ num -lt min ]] && min="$num"
+  
+	    (( min )) || break
+          done
+        else
+          min=
+        fi
+        [[ -n "$min" && nm -ge min ]] && compstate[insert]=unambiguous
       fi
     fi
   fi
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.77
diff -u -r1.77 compsys.yo
--- Doc/Zsh/compsys.yo	2000/06/28 09:08:03	1.77
+++ Doc/Zsh/compsys.yo	2000/06/29 07:02:04
@@ -1595,7 +1595,13 @@
 
 Using the form `tt(yes=)var(num)', where `tt(yes)' may be any of the
 true values (`tt(yes)', `tt(true)', `tt(on)' and `tt(1)') turns on
-menu completion if there at least var(num) matches.
+menu completion if there at most var(num) matches.  Using this for one
+of the `false' values (as in `tt(no=10)') makes menu completion
+em(not) be used if there are var(num) or more matches.  Of course,
+this is only useful when menu completion is normally used, e.g. by
+setting the tt(MENU_COMPLETE) option.  The `true' values may also be
+used in the form `tt(yes=long-list)' to turn on menu completion
+whenever listing is done and the list does not fit onto the screen.
 
 In addition to (or instead of) the above possibilities, the value may
 contain the string `tt(select)', optionally followed by an equal sign and a

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

