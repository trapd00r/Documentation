From zsh-workers-return-14091-mason-zsh=primenet.com.au@sunsite.dk Wed Apr 25 12:55:46 2001
Return-Path: <zsh-workers-return-14091-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3710 invoked from network); 25 Apr 2001 12:55:44 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 25 Apr 2001 12:55:44 -0000
Received: (qmail 4976 invoked by alias); 25 Apr 2001 12:55:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14091
Received: (qmail 4781 invoked from network); 25 Apr 2001 12:55:18 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Wed, 25 Apr 2001 09:10:00 +0200 (MET DST)
Message-Id: <200104250710.JAA03263@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: problem with _arguments exclusion lists
In-Reply-To: <3AE3EF09.C25C8DF8@u.genie.co.uk>

I only just noticed that the mail I sent for this yesterday never made
it to the list (or at least: back to me).  Apologies if you get this
twice.


This adds the `-w' option to _arguments, a stronger form of -W, that
makes it complete options even directly after options that get arguments
in the same word.

It also makes _arguments try to complete options in such places even
without the -w option if the action for the argument returns a non-zero
value.

Then I suggest using the following as the pattern-matching function were
discussed:

  local mesg pat garbage

  mesg=()
  zparseopts -K -D -a garbage M: J: V: 1 2 n F: X:=mesg 

  [[ "$PREFIX$SUFFIX" != $~1 ]] && return 1

  if [[ $# -gt 1 || $#mesg -eq 0 ]]; then
    shift
    _message "$*"
  else
    _message -r "$mesg[2]"
  fi

  [[ -n "$PREFIX$SUFFIX" ]] 

It ignores the compadd-options that might be passed down from
_description and the like, but is able to extract the description from
the -X option.  The message to display can also be given as the
second-to-last argument.  The first argument (after any compadd-options)
is the pattern to match.

So, this can be used as in:

  _arguments  -s '(-conf)-c+:numeric value:prop "[0-9]#"' '-conf' '-f'

or:

  _arguments  -s '(-conf)-c+: :prop "[0-9]#" numeric value' '-conf' '-f'

and completes options (and displays the message) directly after `-c<TAB>',
it only displays the message after `-c<digits><TAB>' and it only
completes options after `-c<non-digits><TAB>'.

This isn't committed yet, because I don't know how to call that utility
function.  Can someone please help me there?  Oliver?


Bye
  Sven

Index: Completion/Base/Utility/_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_arguments,v
retrieving revision 1.3
diff -u -r1.3 _arguments
--- Completion/Base/Utility/_arguments	2001/04/05 12:12:47	1.3
+++ Completion/Base/Utility/_arguments	2001/04/25 07:03:13
@@ -4,7 +4,7 @@
 # descriptions given as arguments to this function.
 
 local long cmd="$words[1]" descr mesg subopts opt usecc autod
-local oldcontext="$curcontext" hasopts rawret optarg singopt
+local oldcontext="$curcontext" hasopts rawret optarg singopt alwopt
 
 long=$argv[(I)--]
 if (( long )); then
@@ -174,7 +174,7 @@
 
 subopts=()
 singopt=()
-while [[ "$1" = -(O*|[CRWs]) ]]; do
+while [[ "$1" = -(O*|[CRWsw]) ]]; do
   case "$1" in
   -C)  usecc=yes; shift ;;
   -O)  subopts=( "${(@P)2}" ); shift 2 ;;
@@ -182,13 +182,14 @@
   -R)  rawret=yes; shift;;
   -W)  optarg=yes; shift;;
   -s)  singopt=(-s); shift;;
+  -w)  alwopt=yes; shift;;
   esac
 done
 
 zstyle -s ":completion:${curcontext}:options" auto-description autod
 
 if (( $# )) && comparguments -i "$autod" "$singopt[@]" "$@"; then
-  local action noargs aret expl local tried
+  local action noargs aret expl local tried ret=1
   local next direct odirect equal single matcher matched ws tmp1 tmp2 tmp3
   local opts subc tc prefix suffix descrs actions subcs anum
   local origpre="$PREFIX" origipre="$IPREFIX" nm="$compstate[nmatches]"
@@ -280,7 +281,8 @@
 
               eval ws\=\( "${action[3,-3]}" \)
 
-              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]"
+              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]" ||
+                  alwopt=yes
 	      tried=yes
 
             elif [[ "$action" = \(*\) ]]; then
@@ -289,15 +291,17 @@
 
               eval ws\=\( "${action[2,-2]}" \)
 
-              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws
+              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws ||
+                  alwopt=yes
 	      tried=yes
             elif [[ "$action" = \{*\} ]]; then
 
               # A string in braces is evaluated.
 
               while _next_label "$subc" expl "$descr"; do
-                eval "$action[2,-2]"
+                eval "$action[2,-2]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             elif [[ "$action" = \ * ]]; then
 
@@ -305,8 +309,9 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[@]"
+                "$action[@]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             else
 
@@ -314,15 +319,17 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}"
+                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}" && ret=0
 	      done
+              (( ret )) && alwopt=yes
 	      tried=yes
             fi
           fi
         fi
       done
-
-      if [[ -z "$matched$hasopts" && ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
+      if [[ -z "$hasopts" &&
+            ( -z "$matched" || -n "$alwopt" ) &&
+            ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
           _requested options &&
           { ! zstyle -T ":completion:${curcontext}:options" prefix-needed ||
             [[ "$origpre" = [-+]* || -z "$aret$mesg$tried" ]] } ; then
@@ -378,9 +385,10 @@
 	PREFIX="$prevpre"
 	IPREFIX="$previpre"
       fi
-      [[ -n "$tried" && "$PREFIX" != [-+]* ]] && break
+      [[ -n "$tried" && "${${alwopt:+$origpre}:-$PREFIX}" != [-+]* ]] && break
     done
-    if [[ -n "$opts" && -z "$aret$matched$mesg" &&
+    if [[ -n "$opts" && -z "$aret" &&
+          ( -z "$matched$mesg" || -n "$alwopt" ) &&
           nm -eq compstate[nmatches] ]]; then
 
       PREFIX="$origpre"
Index: Completion/X/Utility/_x_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_x_arguments,v
retrieving revision 1.2
diff -u -r1.2 _x_arguments
--- Completion/X/Utility/_x_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_x_arguments	2001/04/25 07:03:14
@@ -17,7 +17,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Completion/X/Utility/_xt_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_xt_arguments,v
retrieving revision 1.2
diff -u -r1.2 _xt_arguments
--- Completion/X/Utility/_xt_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_xt_arguments	2001/04/25 07:03:14
@@ -53,7 +53,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.117
diff -u -r1.117 compsys.yo
--- Doc/Zsh/compsys.yo	2001/04/04 11:29:22	1.117
+++ Doc/Zsh/compsys.yo	2001/04/25 07:03:16
@@ -2937,6 +2937,18 @@
 normally not complete the other option directly after `tt(-a)', but it would
 allow that if given the tt(-W) option.
 
+Similarly, the option tt(-w) may be given to force completion of options
+even after options that get an argument in the same word.  For example,
+if a command takes the options `tt(a)' and `tt(b)', where `tt(a)' needs
+an argument in the same word, directly after the option character,
+tt(_arguments) would normally only execute the action for that argument
+and not offer other options as possible completions.  If given the
+tt(-w) option, it will offer other options as possible completions after
+executing the action for the argument.  Note that, depending on the
+action, this may mean that the other options can't really be completed,
+but at least they will be listed.  For more control, use an utility
+function like tt(_XXX) in the argument's action.
+
 The forms of var(optspec) are:
 
 startitem()
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.48
diff -u -r1.48 computil.c
--- Src/Zle/computil.c	2001/04/17 09:52:32	1.48
+++ Src/Zle/computil.c	2001/04/25 07:03:17
@@ -1941,7 +1941,12 @@
     case 's':
 	for (; lstate; lstate = lstate->snext)
 	    if (lstate->d->single && lstate->singles &&
-		lstate->actopts && lstate->opt) {
+		lstate->actopts
+#if 0
+                /* let's try without, for the -w option of _arguments */
+                && lstate->opt
+#endif
+                ) {
 		setsparam(args[1],
 			  ztrdup((lstate->ddef && lstate->dopt) ?
 				 (lstate->dopt->type == CAO_DIRECT ?

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

