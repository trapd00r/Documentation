From zsh-workers-return-6757-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jun 21 11:52:36 1999
Return-Path: <zsh-workers-return-6757-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1831 invoked from network); 21 Jun 1999 11:52:34 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 21 Jun 1999 11:52:34 -0000
Received: (qmail 14892 invoked by alias); 21 Jun 1999 11:51:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6757
Received: (qmail 14884 invoked from network); 21 Jun 1999 11:51:52 -0000
Date: Mon, 21 Jun 1999 13:51:48 +0200 (MET DST)
Message-Id: <199906211151.NAA18539@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Mon, 21 Jun 1999 11:53:25 +0400
Subject: Re: pws-23: RE: _match and auto menu with multipath again


Andrej Borsenkow wrote:

> > Does any of these do what you want? Note that setting `match_insert=unambig'
> > may sometimes remove a short pattern if enough components further up
> > the path were expanded. This is a bit ugly, yes, but I can't think of
> > an easy way to find out where that precious pattern is which one might
> > want to have preserved.
> 
> Thinking more and more about it: what is the reason for _match to automatically
> start menu completion at all (apart from compatibility with old zsh, that can be
> preserved with configuration key).

Because a pattern may match anything -- we can not be sure that all
results have some common prefix (or other common string).

> Think about it:
> 
> 1. We complete /u/l/s/z/f -> /usr/local/share/zsh/functions
> This is actually the same as if we completed /u*/l*/s*/z*/f* - and is
> interpreted and implemented this way.

Not really: every path component is matched using normal completion
matching rules. Nowadays we don't use patterns like `/u*/l*' any more.

> What happens is, that unambiguous prefix
> is replaced and first ambiguous part is replaced with the largest common prefix;
> remaining parts retain there (implicit) glob pattern. That is, we get something
> like
> 
> /usr/local/s/z*/f*
> share status ...

No, the code expands the remaining pathname components, too (if possible).

> how does it differ from
> 
> 2. We complete /u/l/s/z/f*s -> /usr/local/share/zsh/functions ?
> In no way, except, that we know better some patterns (more than only initial
> character) and thus are able to reduce possible matches.

See above, and: for the completion code there is a big difference
between working on a pattern and working on a normal string. Only in
the latter case do we use the match specs (-M) -- and I really think
it should be so because if you type a pattern, you probably know
better what you want than the completion code.

> Note, that patterns are
> often longer than most common prefix - typing /u/l/lib*X* will typically leave
> me with just 'lib' prefix.

I know, that's why I pointed out that the result is sometimes ugly.

> So, I think, that either match_insert should be changed to always insert prefix
> (irrespectively of length) or we need additional config key to force it.

Feel free to implement something in _match that preserves the pattern
parts of a pathname. Dunno when I find time for this... don't hold
your breath.

> And about cutrrent behaviour:
> 
> compconf correct_accept='2n'
> compconf match_original='yes'
> compconf completer='_complete:_match'
> compconf dumpfile='/home/bor/.zcompdump'
> compconf path_cursor='yes'
> compconf match_insert='unambig'
> compconf correct_prompt='correct to:'
> bor@itsrm2:~%> l /u/l/lib*X*<TAB>
> bor@itsrm2:~%> l /usr/lib/lib*X*
> lib/     lib64s/         ^ cursor here
> 
> That is correct and is what I expected. But simply pressing TAB once more
> results in
> 
> bor@itsrm2:~%> l /usr/lib/libX11.a
> lib/     lib64s/
> 
> While if I press any cursor movement key and then TAB I get
> 
> bor@itsrm2:~%> l /usr/lib/lib*X*
> lib/     lib64s/          ^ cursor here (after cursor-right)
> bor@itsrm2:~%> l /usr/lib/libX11.a
> libX11.a@           libXaw.so.6.1@      libXmSni.so.3.0@    libXpm.so.3.4@
> libX11.so@          libXdUtils.so.3.1@  libXmu.a@           libXpm.so.4.6@
> .................... (long list),

Completion was started and _path_files skipped over pathname
components that really exist, matches are the files matching lib*X* in 
/usr/lib. (The list is what you have in /usr/lib, right? If so, then
this is correct behavior.)

> or if I explicitly enter '6'
> 
> bor@itsrm2:~%> l /usr/lib/lib*X*
> lib/     lib64s/         ^ cursor here
> bor@itsrm2:~%> l /usr/lib6/lib*X*
> lib/     lib64s/          ^ cursor here and TAB
> bor@itsrm2:~%> l /usr/lib64s/libX11.a
> libX11.a@          libXaw.so.6.1@     libXmu.so@         libXpm.so@
> libX11.so@         libXdmcp.a@        libXmu.so.6.0@     libXpm.so.3.4@
> ........................

If these are the files in /usr/lib642 matching lib*X*, then this is
correct again (see above).

If not, then I can't reproduce this bug. But maybe I understood you
completely wrong?

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

