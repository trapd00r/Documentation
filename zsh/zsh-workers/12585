From zsh-workers-return-12585-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Aug 10 22:58:25 2000
Return-Path: <zsh-workers-return-12585-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21375 invoked from network); 10 Aug 2000 22:58:23 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Aug 2000 22:58:23 -0000
Received: (qmail 5440 invoked by alias); 10 Aug 2000 22:58:05 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12585
Received: (qmail 5399 invoked from network); 10 Aug 2000 22:58:03 -0000
Message-Id: <200008102155.WAA01236@nano.thoth.u-net.com>
From: opk@u.genie.co.uk (Oliver Kiddle)
Date: Thu, 10 Aug 2000 22:55:31 +0100
X-Mailer: Mail User's Shell (7.2.6 beta(5) 10/07/98)
To: Zsh Workers List <zsh-workers@sunsite.auc.dk>
Subject: PATCH: minor doc fixes

This is just a few corrections. I've also reordered the utility
functions in the two places where they were out of alphabetical
order. This makes the patch look longer than it really is.

Oliver

Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.91
diff -u -r1.91 compsys.yo
--- Doc/Zsh/compsys.yo	2000/08/10 21:22:25	1.91
+++ Doc/Zsh/compsys.yo	2000/08/10 22:54:33
@@ -888,7 +888,7 @@
 )
 kindex(assign-list, completion style)
 item(tt(assign-list))(
-When completing after an equal sign, the completion system normally
+When completing after an equals sign, the completion system normally
 completes only one filename.  In some cases, particularly for certain
 parameters such as tt(PATH), a list of filenames separated by colons is
 required.  This style can be set to a list of patterns matching the names
@@ -1642,7 +1642,7 @@
 even then, the value `tt(yes=long-list)' can be used.
 
 In addition to (or instead of) the above possibilities, the value may
-contain the string `tt(select)', optionally followed by an equal sign and a
+contain the string `tt(select)', optionally followed by an equals sign and a
 number.  In this case menu-selection (as defined by the tt(zsh/complist)
 module) will be started.  Without the optional number, it will be started
 unconditionally and with a number it will be started only if at least that
@@ -2281,7 +2281,7 @@
 )
 kindex(-equal-, completion context)
 item(tt(-equal-))(
-for completion of words beginning with an equal sign
+for completion of words beginning with an equals sign
 )
 kindex(-first-, completion context)
 item(tt(-first-))(
@@ -2339,7 +2339,7 @@
 var(action) says what should be completed in one of the forms
 described for the tt(_arguments) utility function below.
 
-Finally, if `tt(compcontext)' is set a string without colons, the
+Finally, if `tt(compcontext)' is set to a string without colons, the
 value is taken as the name of the context to use and the function
 defined for that context will be called.  For this purpose, there is a
 special context named tt(-command-line-) that completes whole command
@@ -2848,10 +2848,10 @@
 )
 item(tt(-)var(optname)tt(=))(
 The argument may appear as the next word, or in same word as the option
-name provided that it is separated from it by an equal sign.
+name provided that it is separated from it by an equals sign.
 )
 item(tt(-)var(optname)tt(=-))(
-The argument to the option must appear after an equal sign in the same
+The argument to the option must appear after an equals sign in the same
 word, and may not be given in the next argument.
 )
 item(var(optspec)tt([)var(explanation)tt(]))(
@@ -2997,7 +2997,7 @@
 before executing the var(action) and hence may be used in it (normally 
 in an expansion like `tt($expl[@])').
 
-If the var(action) starts with `tt(= )' (an equal sign followed by a
+If the var(action) starts with `tt(= )' (an equals sign followed by a
 space), tt(_arguments) will insert the contents of the var(argument)
 field of the current context as the new first element in the tt(words) 
 special array and increments the value of the tt(CURRENT) special
@@ -3091,7 +3091,7 @@
 Note that using multiple sets will be slower than using only one set
 because the completion code has to parse the command line once for
 every set. So more than one set should only be used if the command
-syntax is too complicated. Note also that a option specification with
+syntax is too complicated. Note also that an option specification with
 rest-arguments (as in `tt(-foo:*:...)') often allows to avoid the use
 of multiple sets.
 
@@ -3107,7 +3107,7 @@
 `tt(r:|[_-]=* r:|=*)'. 
 
 Finally, the option tt(-C) can be given to make tt(_arguments) modify
-the tt(curcontext) parameter when a action of the form
+the tt(curcontext) parameter when an action of the form
 `tt(->)var(state)' is used. This parameter is used to keep track of
 the current context and in this case it (and not the parameter
 tt(context) as explained above) has to be made local to make sure that 
@@ -3126,7 +3126,7 @@
 to make sure that this feature is not used for a command that does not
 support this option.
 
-For such automatically found options that get an argument after a
+For such automatically found options that get an argument after an
 `tt(=)', the function also tries
 to automatically find out what should be completed as the argument.
 The possible completions for option-arguments can be described with
@@ -3241,7 +3241,7 @@
 The style name should consist of multiple parts separated by
 hyphens which are then used as field names.  Known values for such
 fields can be given after the second argument in arguments of the form 
-`var(field)tt(=)var(pattern)'.  The first argument without a equal sign 
+`var(field)tt(=)var(pattern)'.  The first argument without an equals sign 
 is taken as the name of the field for which completions should be
 generated.
 
@@ -3332,7 +3332,7 @@
 The options placed in the array will also make sure that the matches
 are placed in a separate group, depending on the value of the
 tt(group-name) style.  Normally a sorted group will be used for this
-(with the `tt(-J)' option), but if a option starting with `tt(-V)',
+(with the `tt(-J)' option), but if an option starting with `tt(-V)',
 `tt(-J)', `tt(-1)', or `tt(-2)' is given, that option will be included
 in the array, so that it is possible to make the group unsorted by
 giving the option `tt(-V)', `tt(-1V)', or `tt(-2V)'. 
@@ -3468,6 +3468,14 @@
 the same effect here as in the tt(-first-) context: if it is set, no more
 completion functions are called even if there are no matches so far.
 )
+findex(_options)
+item(tt(_options))(
+This can be used to complete option names.  It uses a matching
+specification that ignores a leading `tt(no)', ignores underscores and 
+allows the user to type upper-case letters which will match their
+lower-case counterparts.  All arguments passed to this function are
+propagated unchanged to the tt(compadd) builtin.
+)
 findex(_parameters)
 item(tt(_parameters))(
 This should be used to complete parameter names.  tt(_parameters) can
@@ -3517,14 +3525,6 @@
 Finally, the tt(_path_files) function  uses the styles tt(expand),
 tt(ambiguous) and tt(special-dirs) and tt(file-sort).
 )
-findex(_options)
-item(tt(_options))(
-This can be used to complete option names.  It uses a matching
-specification that ignores a leading `tt(no)', ignores underscores and 
-allows the user to type upper-case letters which will match their
-lower-case counterparts.  All arguments passed to this function are
-propagated unchanged to the tt(compadd) builtin.
-)
 findex(_regex_arguments)
 item(tt(_regex_arguments) var(name) var(specs) ...)(
 This function is a compiler to generate a completion function.  The
@@ -3594,7 +3594,7 @@
 item(tt(_requested) [ tt(-12VJ) ] var(tag) [ var(name) var(descr) [ var(command) var(args) ... ] ])(
 This function is called to decide whether a tag already registered by a
 call to tt(_tags) (see below) is requested and hence completion should be
-performed for it; it returns status zero if the tags is requested and
+performed for it; it returns status zero if the tag is requested and
 non-zero otherwise.  This will usually be done in a loop such as the
 following:
 
@@ -3811,7 +3811,7 @@
 This function also accepts the tt(-C) option followed by a
 var(name). This name is temporarily (i.e. not visible outside
 tt(_tags)) stored in the argument field of the context name in the
-tt(curcontext) parameter. This allows to make tt(_tags) use a more
+tt(curcontext) parameter. This allows tt(_tags) to be made to use a more
 specific context name without having to change and reset the
 tt(curcontext) parameter (which would otherwise have the same effect).
 )
@@ -3834,30 +3834,6 @@
 command has to be called and hence it shouldn't be used if one can't
 be sure that the command understands the `tt(-)tt(-help)' option.
 )
-findex(_wanted)
-item(tt(_wanted) [ tt(-C) var(name) ]  [ tt(-12VJ) ] var(tag) var(name) var(descr) var(command) var(args) ...)(
-In many contexts, completion will one generate one particular set of
-matches (usually corresponding to a single tag); however, it is
-still necessary to decide whether the user requires matches of this type.
-This function is useful in such a case.
-
-Like tt(_requested), it should be passed arguments as for tt(_description).
-It calls tt(_tags) with the given var(tag) and if that returns zero 
-(so that the var(tag) is requested by the user) it calls
-tt(_description).  Hence to offer only one tag and immediately
-use the description generated:
-
-example(_wanted tag expl 'description' \ 
-    compadd matches...)
-
-Unlike tt(_requested), however, tt(_wanted) cannot be called without
-the var(command).  This is because tt(_wanted) also implements the loop
-over the tags, not just the one for the labels; conversely, it should not
-be called in the middle of a tt(_tags) loop.
-
-Like tt(_tags) this function supports the tt(-C) option to give a
-different name for the argument context field.
-)
 findex(_values)
 item(tt(_values) var(specs) ...)(
 This is used to complete values (strings) and their arguments or
@@ -3931,6 +3907,30 @@
 Like tt(_arguments), tt(_values) supports the tt(-C) option in
 which case you have to make the parameter tt(curcontext) local instead 
 of tt(context) (as described above).
+)
+findex(_wanted)
+item(tt(_wanted) [ tt(-C) var(name) ]  [ tt(-12VJ) ] var(tag) var(name) var(descr) var(command) var(args) ...)(
+In many contexts, completion will generate one particular set of
+matches (usually corresponding to a single tag); however, it is
+still necessary to decide whether the user requires matches of this type.
+This function is useful in such a case.
+
+Like tt(_requested), it should be passed arguments as for tt(_description).
+It calls tt(_tags) with the given var(tag) and if that returns zero 
+(so that the var(tag) is requested by the user) it calls
+tt(_description).  Hence to offer only one tag and immediately
+use the description generated:
+
+example(_wanted tag expl 'description' \ 
+    compadd matches...)
+
+Unlike tt(_requested), however, tt(_wanted) cannot be called without
+the var(command).  This is because tt(_wanted) also implements the loop
+over the tags, not just the one for the labels; conversely, it should not
+be called in the middle of a tt(_tags) loop.
+
+Like tt(_tags) this function supports the tt(-C) option to give a
+different name for the argument context field.
 )
 enditem()
 
Index: Doc/Zsh/compwid.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compwid.yo,v
retrieving revision 1.21
diff -u -r1.21 compwid.yo
--- Doc/Zsh/compwid.yo	2000/07/05 21:05:58	1.21
+++ Doc/Zsh/compwid.yo	2000/08/10 22:54:38
@@ -498,7 +498,7 @@
 This adds per-match display strings. The var(array) should contain one 
 element per var(word) given. The completion code will then display the 
 first element instead of the first var(word), and so on. The
-var(array) may be given as the name of a array parameter or directly
+var(array) may be given as the name of an array parameter or directly
 as a space-separated list of words in parentheses.
 
 If there are fewer display strings than var(words), the leftover
Index: Doc/Zsh/expn.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/expn.yo,v
retrieving revision 1.20
diff -u -r1.20 expn.yo
--- Doc/Zsh/expn.yo	2000/07/05 21:05:58	1.20
+++ Doc/Zsh/expn.yo	2000/08/10 22:54:46
@@ -721,8 +721,8 @@
 of the parameter would usually appear. This string consists of keywords
 separated by hyphens (`tt(-)'). The first keyword in the string describes
 the main type, it can be one of `tt(scalar)', `tt(array)', `tt(integer)',
-or `tt(association)'. The other keywords describe the type in more
-detail:
+`tt(float)' or `tt(association)'. The other keywords describe the type in
+more detail:
 
 startitem()
 item(tt(local))(
Index: Doc/Zsh/mod_complist.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_complist.yo,v
retrieving revision 1.11
diff -u -r1.11 mod_complist.yo
--- Doc/Zsh/mod_complist.yo	2000/07/03 08:05:27	1.11
+++ Doc/Zsh/mod_complist.yo	2000/08/10 22:54:49
@@ -78,7 +78,7 @@
 Apart from these strings, the var(name) may also be an asterisk
 (`tt(*)') followed by any string. The var(value) given for such a
 string will be used for all files whose name ends with the string.
-The var(name) may also be a equal sign (`tt(=)') followed by a
+The var(name) may also be an equals sign (`tt(=)') followed by a
 pattern.  The var(value) given for this pattern will be used for all
 matches (not just filenames) whose display string are matched by
 the pattern.  Definitions for both of these take precedence over the
Index: Doc/Zsh/mod_zutil.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_zutil.yo,v
retrieving revision 1.12
diff -u -r1.12 mod_zutil.yo
--- Doc/Zsh/mod_zutil.yo	2000/07/05 21:05:58	1.12
+++ Doc/Zsh/mod_zutil.yo	2000/08/10 22:54:50
@@ -131,7 +131,7 @@
 to the right so that the var(sep) strings in the result (and hence the 
 var(right) strings after them) are all aligned if the strings are
 printed below each other.  All strings without a colon are left
-unchanged and all strings with a empty var(right) string have the
+unchanged and all strings with an empty var(right) string have the
 trailing colon removed.  In both cases the lengths of the strings
 are not used to determine how the other strings are to be aligned.
 The resulting strings are stored in the var(array).

