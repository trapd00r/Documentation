From zsh-workers-return-8789-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Nov 26 11:38:40 1999
Return-Path: <zsh-workers-return-8789-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13066 invoked from network); 26 Nov 1999 11:38:39 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Nov 1999 11:38:39 -0000
Received: (qmail 10036 invoked by alias); 26 Nov 1999 11:38:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8789
Received: (qmail 10029 invoked from network); 26 Nov 1999 11:38:31 -0000
Date: Fri, 26 Nov 1999 12:38:28 +0100 (MET)
Message-Id: <199911261138.MAA14654@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: bash-2.04 programmable completion


Just found this:

> From: chet@nike.ins.cwru.edu (Chet Ramey)
> Subject: Bash-2.04 Programmable Completion message 4
> Date: 05 Nov 1999 00:00:00 GMT
> Message-ID: <991105173103.AA78566.SM@nike.ins.cwru.edu>
> ...
> Newsgroups: gnu.bash.bug

Some excerpts:

> ...
> # this isn't exactly right yet -- needs to skip shell functions and
> # do $PATH lookup (or do compgen -c and filter out matches that also
> # appear in compgen -A function)
> complete -c command
> 
> # could add -S '=', but that currently screws up because readline appends
> # a space unconditionally
> 
> complete -v export local readonly
> ...
> #
> # Job control builtins: fg, bg, disown, kill, wait
> # kill not done yet
> #
> 
> complete -A stopped -P '%' bg
> complete -j -P '%' fg jobs disown
> ...
> #
> # meta-completion (completion for complete/compgen)
> #
> _complete_meta_func()
> {
>         local cur prev cmd
>         COMPREPLY=()
> 
>         cmd=$1
> 
>         cur=${COMP_WORDS[COMP_CWORD]}
>         prev=${COMP_WORDS[COMP_CWORD-1]}
> 
>         if (( $COMP_CWORD <= 1 )) || [[ "$cur" == '-' ]]; then
>                 case "$cmd" in
>                 complete) COMPREPLY=(-a -b -c -d -e -f -j -k -v -u -r -p -A -G -W -P -S -X -F -C);;
>                 compgen)  COMPREPLY=(-a -b -c -d -e -f -j -k -v -u -A -G -W -P -S -X -F -C);;
>                 esac
>                 return 0
>         fi
> 
>         if [[ $prev == -A ]]; then
>                 COMPREPLY=(alias arrayvar binding builtin command directory \
> disabled enabled export file function helptopic hostname job keyword \
> running setopt shopt signal stopped variable)
>                 return 0
>         elif [[ $prev == -F ]]; then
>                 COMPREPLY=( $( compgen -A function $cur ) )
>         elif [[ $prev == -C ]]; then
>                 COMPREPLY=( $( compgen -c $cur ) )
>         else
>                 COMPREPLY=( $( compgen -c $cur ) )
>         fi
>         return 0
> }
> complete -F _complete_meta_func complete compgen
> ...
> complete -f chown ln more cat
> complete -d mkdir rmdir
> ...
> complete -f -X '!*.pl' perl perl5
> 
> complete -A hostname rsh telnet rlogin ftp ping xping host traceroute nslookup
> ...
> complete -u su

Two builtins `complete' and `compgen' with almost the same options,
functions starting with underscore, -[PS] options, COMPREPLY, arrays
holding names of stopped jobs and functions, etc.

`compgen' is lightly different from what was our `compgen', it
obviously just outputs the possible matches. But then -- the name.

Are we being monitored? ;-)

Unfortunately I couldn't any more info...

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

