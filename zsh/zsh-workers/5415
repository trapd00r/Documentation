From zsh-workers-return-5415-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 18 09:01:23 1999
Return-Path: <zsh-workers-return-5415-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1584 invoked from network); 18 Feb 1999 09:01:22 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 18 Feb 1999 09:01:22 -0000
Received: (qmail 16736 invoked by alias); 18 Feb 1999 09:00:55 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5415
Received: (qmail 16729 invoked from network); 18 Feb 1999 09:00:54 -0000
Date: Thu, 18 Feb 1999 10:00:12 +0100 (MET)
Message-Id: <199902180900.KAA06759@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: opk@thoth.u-net.com's message of Thu, 18 Feb 1999 01:00:01 +0000
Subject: PATCH Re: Problem with completion matching control


Oliver Kiddle wrote:

> I've just noticed something else regarding matching control with my
> ncftp compctl which uses 'r:|.=* r:|=*' the following happens:
> 
> ncftp sunsite.d<tab>
> 
> offers
> 
> sunsite.auc.dk and sunsite.doc.ic.ac.uk
> 
> This is exactly what I would expect from the matching but it isn't quite
> what I want to achieve.

Actually I wanted to give it the behavior you wanted to achieve (so,
in a certain sense, the patch below is a bug fix).

> I've tried a number of things, mostly involving [^.]# in the tpat
> without success. If anyone can work this out, I'd appreciate it - I've
> given up for now because it's getting late.

In both the manual and my original description I took care to say that 
this does not support all the patterns known from globbing and the
like. So `[^.]#' just means a non-dot followed by a `#'.

Bye
 Sven

--- os/Zle/zle_tricky.c	Wed Feb 17 17:30:06 1999
+++ Src/Zle/zle_tricky.c	Thu Feb 18 09:55:47 1999
@@ -3238,13 +3238,17 @@
 		    else if (mp->wlen < 0) {
 			/* This is reached if we have a `*' pattern. */
 			if ((t = pattern_match(mp->line, l, NULL, NULL))) {
-			    if (mp->flags & CMF_RIGHT) {
-				if (mp->right && ll >= mp->llen + mp->ralen)
-				    t = pattern_match(mp->right, l + mp->llen,
-						      NULL, NULL);
-				else
-				    t = 0;
-			    }
+			    if (mp->flags & CMF_RIGHT)
+				/* Check if the anchor matches what's on the
+				 * line. If it also matches the word, we don't
+				 * use the matcher since we don't want one of
+				 * these patterns on the line to match more
+				 * than one such sub-string in the word. */
+				t = (mp->right && ll >= mp->llen + mp->ralen &&
+				     pattern_match(mp->right, l + mp->llen,
+						   NULL, NULL) &&
+				     lw >= mp->ralen &&
+				     !pattern_match(mp->right, w, NULL, NULL));
 			    if (t) {
 				/* The anchor matched, so find out how many
 				 * characters are matched by the `*' pattern.
@@ -3467,14 +3471,14 @@
 		    else if (mp->wlen < 0) {
 			if ((t = pattern_match(mp->line, l - mp->llen,
 					       NULL, NULL))) {
-			    if (mp->flags & CMF_LEFT) {
-				if (mp->left && ll >= mp->llen + mp->lalen)
-				    t = pattern_match(mp->left,
-						      l - mp->llen - mp->lalen,
-						      NULL, NULL);
-				else
-				    t = 0;
-			    }
+			    if (mp->flags & CMF_LEFT)
+				t = (mp->left && ll >= mp->llen + mp->lalen &&
+				     pattern_match(mp->left,
+						   l - mp->llen - mp->lalen,
+						   NULL, NULL) &&
+				     lw >= mp->lalen &&
+				     !pattern_match(mp->left, w - mp->lalen,
+						    NULL, NULL));
 			    if (t) {
 				int i = 0, j = iw, k = lw;
 				int jj = il + mp->llen, kk = ll - mp->llen;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

