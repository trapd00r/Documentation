From zsh-workers-return-9865-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 24 12:56:04 2000
Return-Path: <zsh-workers-return-9865-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25542 invoked from network); 24 Feb 2000 12:56:03 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Feb 2000 12:56:03 -0000
Received: (qmail 4475 invoked by alias); 24 Feb 2000 12:55:47 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9865
Received: (qmail 4467 invoked from network); 24 Feb 2000 12:55:46 -0000
Date: Thu, 24 Feb 2000 13:55:41 +0100 (MET)
Message-Id: <200002241255.NAA20465@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Wed, 23 Feb 2000 10:36:41 +0100
	(MET)
Subject: PATCH: ignored matches (was: Re: PATCH: warnings and misc)


I wrote:

> If you set up the ignored-patterns style for functions as suggested in
> the guide:
> 
>   zstyle ':completion:*:functions' ignored-patterns '_*'
> 
> and you have the _approximate completer in your list, you'll almost
> certainly won't get functions beginning with an underscore after
> `_<TAB>', but instead get corrections. Now one could fiddle with the
> context for ignored-patterns and such, but I don't find any of the
> results really good.
> 
> Maybe we should make someone test if $compstate[alternate_matches] is
> non-zero somewhere, sometime. But who, where, when? Possibilities that 
> come to mind are:

This adds the prefer-ignored style, tested in _main_complete before
calling completers. If it is set to true and there are ignored
matches, no other completer will be called.

This time I think, the name of the style is fine, but all this
ignored-matches business makes me rather uneasy. I just wished there
were a better way... the only thing I can think of are separate
alternate groups and things like that which would make administration
even worse.


The hunks for the C-code should once and for all make sure that we
never shorten the string from the line (with matches added with
different match specs this still could happen because the clines for
them could not really be combined; there is no way around that).

Bye
 Sven

diff -ru ../z.old/Completion/Builtins/_zstyle Completion/Builtins/_zstyle
--- ../z.old/Completion/Builtins/_zstyle	Thu Feb 24 11:03:58 2000
+++ Completion/Builtins/_zstyle	Thu Feb 24 13:49:35 2000
@@ -50,6 +50,7 @@
   packageset		 c:packageset
   path			 'c:_path_files -/'
   ports			 c:_ports
+  prefer-ignored         c:bool
   prefix-hidden		 c:bool
   prefix-needed		 c:bool
   prompt		 c:
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Thu Feb 24 11:04:01 2000
+++ Completion/Core/_main_complete	Thu Feb 24 13:41:30 2000
@@ -19,7 +19,7 @@
 setopt localoptions nullglob rcexpandparam extendedglob
 unsetopt markdirs globsubst shwordsplit nounset ksharrays
 
-local comp post ret=1 tmp _compskip format _comp_ignore \
+local ctxt post ret=1 tmp _compskip format _comp_ignore \
       _completers _completer _completer_num \
       _matchers _matcher _matcher_num \
       context state line opt_args val_args curcontext="$curcontext" \
@@ -66,7 +66,14 @@
 _completer_num=1
 
 for _completer; do
-  zstyle -a ":completion:${curcontext/::/:${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}:}:" matcher-list _matchers ||
+  ctxt=":completion:${curcontext/::/:${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}:}:"
+
+  if zstyle -t "$ctxt" prefer-ignored && (( $compstate[alternate_nmatches] )); then
+    ret=0
+    break;
+  fi
+
+  zstyle -a "$ctxt" matcher-list _matchers ||
       _matchers=( '' )
 
   _matcher_num=1
@@ -82,7 +89,6 @@
 
 if zstyle -s ":completion:${curcontext}:" single-ignored tmp &&
    [[ $compstate[old_list] != shown &&
-      $compstate[nmatches] = 0 &&
       $compstate[alternate_nmatches] = 1 ]]; then
   case "$tmp" in
   show) compstate[insert]='' compstate[list]='list force' tmp='' ;;
@@ -99,7 +105,8 @@
 
 if [[ -n "$tmp" || $compstate[old_list] = keep ||
       $compstate[nmatches]+$compstate[alternate_nmatches] -gt 1 ]]; then
-  [[ _last_nmatches -ge 0 && _last_nmatches -ne compstate[nmatches] ]] &&
+  [[ _last_nmatches -ge 0 &&
+     _last_nmatches -ne $compstate[nmatches]+$compstate[alternate_nmatches ]] &&
       _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
   if [[ "$compstate[insert]" = "$_saved_insert" ]]; then
diff -ru ../z.old/Completion/Core/_setup Completion/Core/_setup
--- ../z.old/Completion/Core/_setup	Thu Feb 24 11:04:02 2000
+++ Completion/Core/_setup	Thu Feb 24 13:37:37 2000
@@ -62,7 +62,7 @@
     _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
 if zstyle -a ":completion:${curcontext}:$1" menu val; then
-  _last_nmatches="$nm"
+  _last_nmatches=$(( $nm + $compstate[alternate_nmatches] ))
   _last_menu_style=( "$val[@]" )
 else
   _last_nmatches=-1
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Thu Feb 24 11:03:44 2000
+++ Doc/Zsh/compsys.yo	Thu Feb 24 13:47:44 2000
@@ -1267,6 +1267,23 @@
 not set by the user, the service names from `tt(/etc/services)' will
 be used.
 )
+item(tt(prefer-ignored))(
+This style is tested by the main completion function before calling a
+completer. The context name is formed in the same way as for the
+tt(matcher-list) style, i.e. it contains the name of the completer
+that will be called plus a hyphen and the number of the call to that
+completer.
+
+If the style is set to true and completion did not generate any normal 
+matches yet, but there are matches that were ignored because they
+matched one of the patterns given with the tt(fignore) array or the
+tt(ignored-patterns) style, these ignored matches are used immediatly
+and no other completer will be called.
+
+It is sometimes useful to set this style for the tt(correct) or
+tt(approximate) completer so that ignored matches are prefered over
+corrections.
+)
 item(tt(prefix-hidden))(
 This is used when matches with a common prefix are added (e.g. option
 names). If it is `true', this prefix will not be shown in the list of
diff -ru ../z.old/Src/Zle/compcore.c Src/Zle/compcore.c
--- ../z.old/Src/Zle/compcore.c	Thu Feb 24 11:03:35 2000
+++ Src/Zle/compcore.c	Thu Feb 24 13:23:36 2000
@@ -163,10 +163,10 @@
 /**/
 mod_export int ispattern, haspattern;
 
-/* Non-zero if at least one match was added without -U. */
+/* Non-zero if at least one match was added without/with -U. */
 
 /**/
-mod_export int hasmatched;
+mod_export int hasmatched, hasunmatched;
 
 /* The current group of matches. */
 
@@ -304,7 +304,7 @@
     startauto = isset(AUTOMENU);
     movetoend = ((cs == we || isset(ALWAYSTOEND)) ? 2 : 1);
     showinglist = 0;
-    hasmatched = 0;
+    hasmatched = hasunmatched = 0;
     minmlen = 1000000;
     maxmlen = -1;
 
@@ -1522,9 +1522,12 @@
     /* Switch back to the heap that was used when the completion widget
      * was invoked. */
     SWITCHHEAPS(compheap) {
-	if ((doadd = (!dat->apar && !dat->opar && !dat->dpar)) &&
-	    (dat->aflags & CAF_MATCH))
-	    hasmatched = 1;
+	if ((doadd = (!dat->apar && !dat->opar && !dat->dpar))) {
+	    if (dat->aflags & CAF_MATCH)
+		hasmatched = 1;
+	    else
+		hasunmatched = 1;
+	}
 	if (dat->apar)
 	    aparl = newlinklist();
 	if (dat->opar)
diff -ru ../z.old/Src/Zle/compresult.c Src/Zle/compresult.c
--- ../z.old/Src/Zle/compresult.c	Thu Feb 24 11:03:37 2000
+++ Src/Zle/compresult.c	Thu Feb 24 13:24:57 2000
@@ -610,6 +610,7 @@
 	do_ambig_menu();
     } else if (ainfo) {
 	int atend = (cs == we), la, eq, tcs;
+	VARARR(char, old, we - wb);
 
 	minfo.cur = NULL;
 	minfo.asked = 0;
@@ -617,11 +618,25 @@
 	fixsuffix();
 
 	/* First remove the old string from the line. */
+	tcs = cs;
 	cs = wb;
+	memcpy(old, (char *) line + wb, we - wb);
 	foredel(we - wb);
 
 	/* Now get the unambiguous string and insert it into the line. */
 	cline_str(ainfo->line, 1, NULL);
+
+	/* Sometimes the different match specs used may result in a cline
+	 * that is shorter than the original string. If that happened, we
+	 * re-insert the old string. Unless there were matches added with
+	 * -U, that is. */
+	if (lastend - wb < we - wb && !hasunmatched) {
+	    cs = wb;
+	    foredel(lastend - wb);
+	    inststrlen(old, 0, we - wb);
+	    lastend = we;
+	    cs = tcs;
+	}
 	if (eparq) {
 	    tcs = cs;
 	    cs = lastend;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

