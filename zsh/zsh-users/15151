From zsh-users-return-15151-mason-zsh=primenet.com.au@zsh.org Fri Jul 09 14:11:43 2010
Return-Path: <zsh-users-return-15151-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8370 invoked by alias); 9 Jul 2010 14:11:43 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15151
Received: (qmail 26007 invoked from network); 9 Jul 2010 14:11:31 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at seiken.de designates 94.23.38.107 as permitted sender)
From: Joke de Buhr <joke@seiken.de>
To: zsh-users@zsh.org
Subject: Re: generate series of strings
Date: Fri, 9 Jul 2010 16:05:13 +0200
User-Agent: KMail/1.13.2 (Linux/2.6.32-22-generic; KDE/4.4.2; x86_64; ; )
References: <20100709152718.df78ca73.tartifola@gmail.com> <AANLkTikjaSGkBzR_aWvhYfFL418ml_x-hbg4qBrzg88w@mail.gmail.com> <20100709154246.2f2fe276.tartifola@gmail.com>
In-Reply-To: <20100709154246.2f2fe276.tartifola@gmail.com>
MIME-Version: 1.0
Content-Type: multipart/signed;
  boundary="nextPart7393600.OICLociR1O";
  protocol="application/pgp-signature";
  micalg=pgp-ripemd160
Content-Transfer-Encoding: 7bit
Message-Id: <201007091605.15291.joke@seiken.de>

--nextPart7393600.OICLociR1O
Content-Type: Text/Plain;
  charset="utf-8"
Content-Transfer-Encoding: quoted-printable

On Friday 09 July 2010 15:42:46 tartifola@gmail.com wrote:
> On Fri, 9 Jul 2010 15:36:00 +0200
>=20
> Guillaume Brunerie <guillaume.brunerie@gmail.com> wrote:
> > 2010/7/9 <tartifola@gmail.com>
> >=20
> > > Hi,
> > > is there a way to obtain from the command line a series of strings li=
ke
> > >=20
> > > (1:3) (4:6) (7:9)...
> > >=20
> > > always with the same increment. I'm playing with 'seq' and 'sed' but
> > > perhaps it's not the best approach.
> > > Thanks,
> > > A.
> >=20
> > Hi,
> > You can use a for-loop :
> >=20
> > for (( i =3D 0; i < 5; i++ ))
> > do
> >=20
> >     echo -n "($(( 3 * i + 1 )):$(( 3 * i + 3))) "
> >=20
> > done
>=20
> Thanks for your help, it works perfectly. Just a curiosity, any possible
> solution without a loop for?

Actually there is a solution without loops. But it not as nice as a looping=
=20
solution (for, while, until, ...). You can use recursive functions as a loo=
p-
replacement. But it's not as easy as a for-loop.


## recursive function
expand() {
    (( $1 < 0 )) && return

    print -n "$(expand $(($1 - 1))) ($((3 * $1 + 1)):$((3 * $1 + 3)))"=20
}

## call recursive function
expand 20

--nextPart7393600.OICLociR1O
Content-Type: application/pgp-signature; name=signature.asc 
Content-Description: This is a digitally signed message part.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)

iQG7BAABAwAlBQJMNyyZHhhoa3A6Ly9wb29sLnNrcy1rZXlzZXJ2ZXJzLm5ldAAK
CRCWUloJhwFWxuOzC/sEdn9hd47rHejlKj56PPH/UguZhQY+yzfdmtUvdkpk8Emn
oOj35zbOIsX1vuQ9FQYEn+MMyKME+6fDC0iXi5CXWNuBN9AG9HpxeOEFDQCAHpeJ
0XO9jF/tfIm25a402W4MqVirQ9QRx4yUXAJe4wAaJSqggEbfO4tBurU89FOodHrY
iVWJKj8gNDkANt3M1DAgoX6usxvRM/X1UhTDQTp9QDC+a/1NRUhmgBW8rfyVgx50
Glzz0aF3AquETdh+2Qqgv3Ctq9dKRh2uCQCTe6CRWe5JlVCBAWpTz/CjhMzN/dJc
4ckT+y8LePHzz5M9BfpYmYbfNXM7t5R/QN/x3pXaPi18IwsKig0vUjWoXsPU7Tfg
+2+0vR7DGc/9/7E5C4qAvxHfzD2axaRo0TOWDjHSRGO0wo+0dsNQTuURpAkdnjx7
Cod4FZV0oCXNyMKg1pq0rTTQQk/WZRuPNOc39YAtXNkT07BpOK9rbqvIpQC6rpw4
nJfN0SoAP3fbxvbN0Vg=
=bUZL
-----END PGP SIGNATURE-----

--nextPart7393600.OICLociR1O--

