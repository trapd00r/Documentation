From zsh-users-return-13187-mason-zsh=primenet.com.au@sunsite.dk Thu Sep 04 11:08:39 2008
Return-Path: <zsh-users-return-13187-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13089 invoked from network); 4 Sep 2008 11:08:36 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=BAYES_00,HTML_MESSAGE
	autolearn=ham version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 4 Sep 2008 11:08:36 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 99735 invoked from network); 4 Sep 2008 11:08:03 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 4 Sep 2008 11:08:03 -0000
Received: (qmail 16313 invoked by alias); 4 Sep 2008 11:06:56 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 13187
Received: (qmail 16269 invoked from network); 4 Sep 2008 11:06:53 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 4 Sep 2008 11:06:53 -0000
Received: from wr-out-0506.google.com (wr-out-0506.google.com [64.233.184.238])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 26EDB809A17E
	for <zsh-users@sunsite.dk>; Thu,  4 Sep 2008 11:11:33 +0200 (CEST)
Received: by wr-out-0506.google.com with SMTP id 50so3657762wra.13
        for <zsh-users@sunsite.dk>; Thu, 04 Sep 2008 02:11:28 -0700 (PDT)
Received: by 10.90.86.9 with SMTP id j9mr12127403agb.11.1220483057562;
        Wed, 03 Sep 2008 16:04:17 -0700 (PDT)
Received: by 10.90.101.11 with HTTP; Wed, 3 Sep 2008 16:04:17 -0700 (PDT)
Message-ID: <682f90440809031604j5e349af2q8d40f24fc429dcc3@mail.gmail.com>
Date: Thu, 4 Sep 2008 01:04:17 +0200
From: "=?ISO-8859-1?Q?Bj=F6rn_Herzig?=" <raichoo@googlemail.com>
To: zsh-users@sunsite.dk
Subject: Re: compsys maps anonymous memory and never frees it
In-Reply-To: <080902200652.ZM9887@torch.brasslantern.com>
MIME-Version: 1.0
Content-Type: multipart/alternative; 
	boundary="----=_Part_41651_31816200.1220483057543"
References: <48BDF1EC.4050204@gmail.com>
	 <080902200652.ZM9887@torch.brasslantern.com>
X-Virus-Scanned: ClamAV version 0.92.1, clamav-milter version 0.92.1 on bifrost
X-Virus-Status: Clean

------=_Part_41651_31816200.1220483057543
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

On Wed, Sep 3, 2008 at 5:06 AM, Bart Schaefer <schaefer@brasslantern.com>wr=
ote:

> On Sep 3,  4:09am, xRaich[o]=B2x wrote:
> }
> } I made an interesting observation while testing compsys in zsh on
> } OpenSolaris. Everytime completion kicks in zsh maps a segment of
> } anonymous memory and it looks like that it won't unmap it.
>
> Version number of zsh involved?
>
> There are only three places where zsh maps memory.  One is when it
> loads a .zwc file (zcompiled functions); one is whan it references
> the $mapfile special parameter (which the standard set of compsys
> functions never does); and one is the heap allocator in Src/mem.c:
>
>     There are two ways to allocate memory in zsh.  The first way is
>     to call zalloc/zshcalloc, which call malloc/calloc directly.  It
>     is legal to call realloc() or free() on memory allocated this way.
>     The second way is to call zhalloc/hcalloc, which allocates memory
>     from one of the memory pools on the heap stack.  Such memory pools
>     will automatically created when the heap allocation routines are
>     called.  [...]
>
>     If possible, the heaps are allocated using mmap() so that the
>     (*real*) heap isn't filled up with empty zsh heaps. If mmap()
>     is not available and zsh's own allocator is used, we use a simple tri=
ck
>     to avoid that: we allocate a large block of memory before allocating
>     a heap pool, this memory is freed again immediately after the pool
>     is allocated. If there are only small blocks on the free list this
>     guarantees that the memory for the pool is at the end of the memory
>     which means that we can give it back to the system when the pool is
>     freed.
>
> It's possible that there's a popheap() or the equivalent missing from
> somewhere.  It's also possible that the OpenSolaris munmap() does not
> really (or not immediately) release memory back to the system, because
> if I repeat your same example on my CentOS 4 box, the number of mapped
> blocks remains constant.
>

Zsh version is 4.3.6 and 4.3.4. Both show the same behavior.

I looked at the problem a little closer. Zsh does not call mmap to allocate
them and they dont get allocated when completion happens but when the next
command gets issued. So in my example the new maps got added to the process=
'
address space when i executed pmap, but the same happens with any other
programm. Builtins however are an exception. So things start to go wrong
when it comes to forking.

I hope this helps to pinpoint the problem. Here are the backtraces i got
from dtrace when one of those "sticky" segments get added to the zsh
address space. This might also help:

Userspace stacktrace:

  0  -> as_addseg
              libc.so.1`__forkx+0xb
              libc.so.1`fork+0x1a
              zsh`zfork+0x56
              zsh`execcmd+0xe85
              zsh`execpline2+0xe4
              zsh`execpline+0x195
              zsh`execlist+0x390
              zsh`execode+0x38
              zsh`loop+0x26e
              zsh`zsh_main+0x1ea
              zsh`main+0x11
              zsh`_start+0x7a

Kernelspace backtrace:
              genunix`seg_attach+0x21
              genunix`seg_alloc+0xb4
              genunix`as_dup+0xba
              genunix`cfork+0xe1
              genunix`forksys+0x19
              unix`sys_call+0x10c

Regards,
Bj=F6rn

------=_Part_41651_31816200.1220483057543
Content-Type: text/html; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable
Content-Disposition: inline

<div dir=3D"ltr"><br><br><div class=3D"gmail_quote">On Wed, Sep 3, 2008 at =
5:06 AM, Bart Schaefer <span dir=3D"ltr">&lt;<a href=3D"mailto:schaefer@bra=
sslantern.com">schaefer@brasslantern.com</a>&gt;</span> wrote:<br><blockquo=
te class=3D"gmail_quote" style=3D"border-left: 1px solid rgb(204, 204, 204)=
; margin: 0pt 0pt 0pt 0.8ex; padding-left: 1ex;">
<div class=3D"Ih2E3d">On Sep 3, &nbsp;4:09am, xRaich[o]=B2x wrote:<br>
}<br>
} I made an interesting observation while testing compsys in zsh on<br>
} OpenSolaris. Everytime completion kicks in zsh maps a segment of<br>
} anonymous memory and it looks like that it won&#39;t unmap it.<br>
<br>
</div>Version number of zsh involved?<br>
<br>
There are only three places where zsh maps memory. &nbsp;One is when it<br>
loads a .zwc file (zcompiled functions); one is whan it references<br>
the $mapfile special parameter (which the standard set of compsys<br>
functions never does); and one is the heap allocator in Src/mem.c:<br>
<br>
 &nbsp; &nbsp; There are two ways to allocate memory in zsh. &nbsp;The firs=
t way is<br>
 &nbsp; &nbsp; to call zalloc/zshcalloc, which call malloc/calloc directly.=
 &nbsp;It<br>
 &nbsp; &nbsp; is legal to call realloc() or free() on memory allocated thi=
s way.<br>
 &nbsp; &nbsp; The second way is to call zhalloc/hcalloc, which allocates m=
emory<br>
 &nbsp; &nbsp; from one of the memory pools on the heap stack. &nbsp;Such m=
emory pools<br>
 &nbsp; &nbsp; will automatically created when the heap allocation routines=
 are<br>
 &nbsp; &nbsp; called. &nbsp;[...]<br>
<br>
 &nbsp; &nbsp; If possible, the heaps are allocated using mmap() so that th=
e<br>
 &nbsp; &nbsp; (*real*) heap isn&#39;t filled up with empty zsh heaps. If m=
map()<br>
 &nbsp; &nbsp; is not available and zsh&#39;s own allocator is used, we use=
 a simple trick<br>
 &nbsp; &nbsp; to avoid that: we allocate a large block of memory before al=
locating<br>
 &nbsp; &nbsp; a heap pool, this memory is freed again immediately after th=
e pool<br>
 &nbsp; &nbsp; is allocated. If there are only small blocks on the free lis=
t this<br>
 &nbsp; &nbsp; guarantees that the memory for the pool is at the end of the=
 memory<br>
 &nbsp; &nbsp; which means that we can give it back to the system when the =
pool is<br>
 &nbsp; &nbsp; freed.<br>
<br>
It&#39;s possible that there&#39;s a popheap() or the equivalent missing fr=
om<br>
somewhere. &nbsp;It&#39;s also possible that the OpenSolaris munmap() does =
not<br>
really (or not immediately) release memory back to the system, because<br>
if I repeat your same example on my CentOS 4 box, the number of mapped<br>
blocks remains constant.<br>
</blockquote></div><br>Zsh version is 4.3.6 and <a href=3D"http://4.3.4.">4=
.3.4.</a> Both show the same behavior.<br><br>I looked at the problem a lit=
tle closer. Zsh does not call mmap to allocate them and they dont get alloc=
ated when completion happens but when the next command gets issued. So in m=
y example the new maps got added to the process&#39; address space when i e=
xecuted pmap, but the same happens with any other programm. Builtins howeve=
r are an exception. So things start to go wrong when it comes to forking.<b=
r>
<br>I hope this helps to pinpoint the problem. Here are the backtraces i go=
t from dtrace when one of those &quot;sticky&quot; segments get added to th=
e zsh&nbsp; address space. This might also help:<br><br>Userspace stacktrac=
e:<br>
<br>&nbsp; 0&nbsp; -&gt; as_addseg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libc.so.1`__fo=
rkx+0xb<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp; libc.so.1`fork+0x1a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&=
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`zfork+0x56<br>&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`execcmd=
+0xe85<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp; zsh`execpline2+0xe4<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp; zsh`execpline+0x195<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`execlist+0x390<br>&nbsp;&nbsp;&nbsp;&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`execode+0x38<b=
r>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&=
nbsp; zsh`loop+0x26e<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`zsh_main+0x1ea<br>&nbsp;&nbsp;&nbsp;&nbsp;&=
nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zsh`main+0x11<br>&nbs=
p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
zsh`_start+0x7a<br>
<br>Kernelspace backtrace:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genunix`seg_attach+0x21<br>&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genunix`se=
g_alloc+0xb4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp=
;&nbsp;&nbsp;&nbsp; genunix`as_dup+0xba<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&n=
bsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genunix`cfork+0xe1<br>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge=
nunix`forksys+0x19<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=
sp; unix`sys_call+0x10c<br><br>Regards,<br>Bj=F6rn<br><br></div>

------=_Part_41651_31816200.1220483057543--

