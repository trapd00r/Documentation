From zsh-workers-return-20861-mason-zsh=primenet.com.au@sunsite.dk Thu Feb 24 13:49:59 2005
Return-Path: <zsh-workers-return-20861-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18412 invoked from network); 24 Feb 2005 13:49:58 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 24 Feb 2005 13:49:58 -0000
Received: (qmail 97318 invoked from network); 24 Feb 2005 13:49:52 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 24 Feb 2005 13:49:52 -0000
Received: (qmail 16894 invoked by alias); 24 Feb 2005 13:49:46 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 20861
Received: (qmail 16885 invoked from network); 24 Feb 2005 13:49:46 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 24 Feb 2005 13:49:46 -0000
Received: (qmail 97029 invoked from network); 24 Feb 2005 13:49:46 -0000
Received: from mailhost1.csr.com (HELO MAILSWEEPER01.csr.com) (81.105.217.43)
  by a.mx.sunsite.dk with SMTP; 24 Feb 2005 13:49:39 -0000
Received: from exchange03.csr.com (unverified [10.100.137.60]) by MAILSWEEPER01.csr.com
 (Content Technologies SMTPRS 4.3.12) with ESMTP id <T6f5108a1be0a6c8d018f0@MAILSWEEPER01.csr.com> for <zsh-workers@sunsite.dk>;
 Thu, 24 Feb 2005 13:48:10 +0000
Received: from news01.csr.com ([10.103.143.38]) by exchange03.csr.com with Microsoft SMTPSVC(5.0.2195.6713);
	 Thu, 24 Feb 2005 13:50:36 +0000
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.1/8.12.11) with ESMTP id j1ODncnV018482
	for <zsh-workers@sunsite.dk>; Thu, 24 Feb 2005 13:49:38 GMT
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.1/8.13.1/Submit) with ESMTP id j1ODnc5a018479
	for <zsh-workers@sunsite.dk>; Thu, 24 Feb 2005 13:49:38 GMT
Message-Id: <200502241349.j1ODnc5a018479@news01.csr.com>
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: zle status line
Date: Thu, 24 Feb 2005 13:49:37 +0000
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 24 Feb 2005 13:50:36.0969 (UTC) FILETIME=[D196F990:01C51A77]
X-Spam-Checker-Version: SpamAssassin 3.0.2 on a.mx.sunsite.dk
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=6.0 tests=AWL,BAYES_00 autolearn=ham 
	version=3.0.2
X-Spam-Hits: -2.5

This does much of the work to fix up the status line.  After Andrej's
change yesterday the easiest thing to do was to put it into ZLE_STRING_T
format.  This removes the difficulty with backing up characters in
execute-named-command.

isearch etc. still needs fixing up; I think that's the last bit related
to the status line.  This is tricky as there will need to be quite a lot
of conversion from multibyte strings in history entries into
ZLE_STRING_T.

There are a couple of changes to suppress warnings in zle_refresh.c.  It
became apparent that ZWS to create wide or ordinary strings would be
necessary in addition to ZWC, since strings are of unsigned characters
so a cast is necessary.

Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.66
diff -u -r1.66 complist.c
--- Src/Zle/complist.c	23 Feb 2005 13:59:33 -0000	1.66
+++ Src/Zle/complist.c	24 Feb 2005 13:07:27 -0000
@@ -2115,8 +2115,8 @@
         }
         first = 0;
         if (mode == MM_INTER) {
-            statusline = status;
-            statusll = strlen(status);
+	    statusline = stringaszleline((unsigned char *)status,
+					 &statusll, NULL);
         } else if (mode) {
             int l = sprintf(status, "%s%sisearch%s: ",
                             ((msearchstate & MS_FAILED) ? "failed " : ""),
@@ -2125,15 +2125,18 @@
 
             strncat(status, msearchstr, MAX_STATUS - l - 1);
 
-            statusline = status;
-            statusll = strlen(status);
+            statusline = stringaszleline((unsigned char *)status,
+					 &statusll, NULL);
         } else {
             statusline = NULL;
             statusll = 0;
         }
         zrefresh();
-        statusline = NULL;
-        statusll = 0;
+	if (statusline) {
+	    free(statusline);
+	    statusline = NULL;
+	    statusll = 0;
+	}
         inselect = 1;
         if (noselect) {
             broken = 1;
@@ -2291,9 +2294,13 @@
 	    if (nmatches < 1 || !minfo.cur || !*(minfo.cur)) {
 		nolist = 1;
                 if (mode == MM_INTER) {
-                    statusline = status;
-                    statusll = strlen(status);
-                }
+                    statusline = stringaszleline((unsigned char *)status,
+						 &statusll, NULL);
+                } else {
+		    /* paranoia */
+		    statusline = NULL;
+		    statusll = 0;
+		}
 		if (nmessages) {
 		    showinglist = -2;
 		    zrefresh();
@@ -2310,8 +2317,11 @@
 		    zrefresh();
 		    showinglist = clearlist = 0;
 		}
-                statusline = NULL;
-                statusll = 0;
+		if (statusline) {
+		    free(statusline);
+		    statusline = NULL;
+		    statusll = 0;
+		}
 
 		goto getk;
 	    }
@@ -2425,12 +2435,19 @@
 
             if (nolist) {
                 if (mode == MM_INTER) {
-                    statusline = status;
-                    statusll = strlen(status);
-                }
+                    statusline = stringaszleline((unsigned char *)status,
+						 &statusll, NULL);
+                } else {
+		    /* paranoia */
+		    statusline = NULL;
+		    statusll = 0;
+		}
                 zrefresh();
-                statusline = NULL;
-                statusll = 0;
+		if (statusline) {
+		    free(statusline);
+		    statusline = NULL;
+		    statusll = 0;
+		}
                 goto getk;
             }
             if (mode)
Index: Src/Zle/zle.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle.h,v
retrieving revision 1.11
diff -u -r1.11 zle.h
--- Src/Zle/zle.h	23 Feb 2005 16:30:54 -0000	1.11
+++ Src/Zle/zle.h	24 Feb 2005 13:07:27 -0000
@@ -46,6 +46,7 @@
 
 /* Convert character or string to wide character or string */
 #define ZWC(c)	L ## c
+#define ZWS(s)	L ## s
 
 #define ZLEEOF	WEOF
 
@@ -68,8 +69,9 @@
 typedef int ZLE_INT_T;
 #define ZLE_CHAR_SIZE	sizeof(unsigned char)
 
-/* Leave character or string as is */
+/* Leave character or string as is, but string must be unsigned char * */
 #define ZWC(c)	c
+#define ZWS(s)	(unsigned char *)s
 
 #define ZLEEOF	EOF
 
Index: Src/Zle/zle_hist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_hist.c,v
retrieving revision 1.19
diff -u -r1.19 zle_hist.c
--- Src/Zle/zle_hist.c	23 Feb 2005 13:50:45 -0000	1.19
+++ Src/Zle/zle_hist.c	24 Feb 2005 13:07:27 -0000
@@ -766,6 +766,10 @@
 #define NORM_PROMPT_POS		8
 #define FIRST_SEARCH_CHAR	(NORM_PROMPT_POS + 14)
 
+/*
+ * TODO: use of isearch buffer and strings need fixing for Unicode.
+ */
+
 /**/
 static void
 doisearch(char **args, int dir)
@@ -866,7 +870,7 @@
 	    statusline = ibuf + NORM_PROMPT_POS;
 	}
 	sbuf[sbptr] = '_';
-	statusll = sbuf - statusline + sbptr + 1;
+	statusll = sbuf - (char *)/*TODO*/statusline + sbptr + 1;
     ref:
 	zrefresh();
 	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.62
diff -u -r1.62 zle_main.c
--- Src/Zle/zle_main.c	23 Feb 2005 13:50:45 -0000	1.62
+++ Src/Zle/zle_main.c	24 Feb 2005 13:07:27 -0000
@@ -137,7 +137,7 @@
 /* the status line, and its length */
 
 /**/
-mod_export char *statusline;
+mod_export ZLE_STRING_T statusline;
 /**/
 mod_export int statusll;
 
@@ -1374,8 +1374,8 @@
     if (statusline)
 	return 1;
     clearlist = 1;
-    statusline = "Describe key briefly: _";
-    statusll = strlen(statusline);
+    statusline = ZWS("Describe key briefly: _");
+    statusll = ZS_strlen(statusline);
     zrefresh();
     seq = getkeymapcmd(curkeymap, &func, &str);
     statusline = NULL;
Index: Src/Zle/zle_misc.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_misc.c,v
retrieving revision 1.18
diff -u -r1.18 zle_misc.c
--- Src/Zle/zle_misc.c	23 Feb 2005 13:50:45 -0000	1.18
+++ Src/Zle/zle_misc.c	24 Feb 2005 13:07:27 -0000
@@ -738,7 +738,11 @@
     return ol;
 }
 
-static char *cmdbuf;
+/*
+ * cmdstr is the buffer used for execute-named-command converted
+ * to a metafied multibyte string.
+ */
+static char *cmdstr;
 static LinkList cmdll;
 static int cmdambig;
 
@@ -749,7 +753,7 @@
     int l;
     Thingy t = (Thingy) hn;
 
-    if(strpfx(cmdbuf, t->nam)) {
+    if(strpfx(cmdstr, t->nam)) {
 	addlinknode(cmdll, t->nam);
 	l = pfxlen(peekfirst(cmdll), t->nam);
 	if (l < cmdambig)
@@ -765,20 +769,22 @@
 executenamedcommand(char *prmt)
 {
     Thingy cmd;
-    int len, l = strlen(prmt), feep = 0, listed = 0, curlist = 0;
+    int l, len, feep = 0, listed = 0, curlist = 0;
     int ols = (listshown && validlist), olll = lastlistlen;
-    char *ptr;
+    ZLE_STRING_T cmdbuf, ptr, zprmt;
     char *okeymap = ztrdup(curkeymapname);
 
     clearlist = 1;
-    cmdbuf = zhalloc(l + NAMLEN + 2);
-    strcpy(cmdbuf, prmt);
+    zprmt = stringaszleline((unsigned char *)prmt, &l, NULL);
+    cmdbuf = zhalloc((l + NAMLEN + 2) * ZLE_CHAR_SIZE);
+    ZS_memcpy(cmdbuf, zprmt, l);
+    free(zprmt);
     statusline = cmdbuf;
     selectkeymap("main", 1);
     ptr = cmdbuf += l;
     len = 0;
     for (;;) {
-	*ptr = '_';
+	*ptr = ZWC('_');
 	statusll = l + len + 1;
 	zrefresh();
 	if (!(cmd = getkeycmd()) || cmd == Th(z_sendbreak)) {
@@ -814,35 +820,31 @@
 		zmult = zmultsav;
 	    }
 	} else if(cmd == Th(z_viquotedinsert)) {
-	    *ptr = '^';
+	    *ptr = ZWC('^');
 	    zrefresh();
 	    getfullchar(0);
 	    if(LASTFULLCHAR == ZLEEOF || !LASTFULLCHAR || len == NAMLEN)
 		feep = 1;
 	    else {
-		/* TODO: convert back to multibyte string */
-		*ptr++ = lastchar, len++, curlist = 0;
+		*ptr++ = LASTFULLCHAR, len++, curlist = 0;
 	    }
 	} else if(cmd == Th(z_quotedinsert)) {
 	    if(getfullchar(0) == ZLEEOF ||
 	       !LASTFULLCHAR || len == NAMLEN)
 		feep = 1;
 	    else {
-		/* TODO: convert back to multibyte string */
-		*ptr++ = lastchar, len++, curlist = 0;
+		*ptr++ = LASTFULLCHAR, len++, curlist = 0;
 	    }
 	} else if(cmd == Th(z_backwarddeletechar) ||
 	    	cmd == Th(z_vibackwarddeletechar)) {
 	    if (len) {
-		/* TODO: backward full character in multibyte string. Yuk. */
 		len--, ptr--, curlist = 0;
 	    }
 	} else if(cmd == Th(z_killregion) || cmd == Th(z_backwardkillword) ||
 		  cmd == Th(z_vibackwardkillword)) {
 	    if (len)
 		curlist = 0;
-	    /* TODO: backward full character in multibyte string. Yuk. */
-	    while (len && (len--, *--ptr != '-'));
+	    while (len && (len--, *--ptr != ZWC('-')));
 	} else if(cmd == Th(z_killwholeline) || cmd == Th(z_vikillline) ||
 	    	cmd == Th(z_backwardkillline)) {
 	    len = 0;
@@ -855,7 +857,10 @@
 		Thingy r;
 		unambiguous:
 		*ptr = 0;
-		r = rthingy(cmdbuf);
+		cmdstr = zlelineasstring(cmdbuf, len, 0, NULL, NULL, 0);
+		r = rthingy(cmdstr);
+		free(cmdstr);
+		cmdstr = NULL;
 		if (!(r->flags & DISABLED)) {
 		    unrefthingy(r);
 		    statusline = NULL;
@@ -881,9 +886,11 @@
 		cmdambig = 100;
 
 		cmdll = newlinklist();
-		*ptr = 0;
 
+		cmdstr = zlelineasstring(cmdbuf, len, 0, NULL, NULL, 0);
 		scanhashtable(thingytab, 1, 0, DISABLED, scancompcmd, 0);
+		free(cmdstr);
+		cmdstr = NULL;
 
 		if (empty(cmdll)) {
 		    feep = 1;
@@ -893,7 +900,7 @@
 		} else if (cmd == Th(z_listchoices) ||
 		    cmd == Th(z_deletecharorlist)) {
 		    int zmultsav = zmult;
-		    *ptr = '_';
+		    *ptr = ZWC('_');
 		    statusll = l + len + 1;
 		    zmult = 1;
 		    listlist(cmdll);
@@ -901,14 +908,21 @@
 		    showinglist = 0;
 		    zmult = zmultsav;
 		} else if (!nextnode(firstnode(cmdll))) {
-		    strcpy(ptr = cmdbuf, peekfirst(cmdll));
-		    ptr += (len = strlen(ptr));
+		    ZLE_STRING_T ztmp = stringaszleline(peekfirst(cmdll),
+							&len, NULL);
+		    ZS_memcpy(ptr = cmdbuf, ztmp, len);
+		    ptr += len;
+		    free(ztmp);
 		    if(cmd == Th(z_acceptline) || cmd == Th(z_vicmdmode))
 			goto unambiguous;
 		} else {
-		    strcpy(cmdbuf, peekfirst(cmdll));
+		    int ltmp;
+		    ZLE_STRING_T ztmp = stringaszleline(peekfirst(cmdll),
+							&ltmp, NULL);
+		    ZS_mempcy(cmdbuf, ztmp, ltmp);
+		    free(ztmp);
 		    ptr = cmdbuf + cmdambig;
-		    *ptr = '_';
+		    *ptr = ZWC('_');
 		    if (isset(AUTOLIST) &&
 			!(isset(LISTAMBIGUOUS) && cmdambig > len)) {
 			int zmultsav = zmult;
@@ -938,8 +952,7 @@
 			feep = 1;
 		    }
 		    else {
-			/* TODO: convert back to multibyte string */
-			*ptr++ = lastchar, len++, curlist = 0;
+			*ptr++ = LASTFULLCHAR, len++, curlist = 0;
 		    }
 		}
 	    }
Index: Src/Zle/zle_refresh.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_refresh.c,v
retrieving revision 1.19
diff -u -r1.19 zle_refresh.c
--- Src/Zle/zle_refresh.c	23 Feb 2005 16:30:54 -0000	1.19
+++ Src/Zle/zle_refresh.c	24 Feb 2005 13:07:27 -0000
@@ -320,9 +320,8 @@
     ZLE_STRING_T s,		/* pointer into the video buffer	     */
 	sen,			/* pointer to end of the video buffer (eol)  */
 	t,			/* pointer into the real buffer		     */
-	scs;			/* pointer to cursor position in real buffer */
-    unsigned char *u;		/* pointer for status line stuff
-				   TODO convert to wide characters */
+	scs,			/* pointer to cursor position in real buffer */
+	u;			/* pointer for status line stuff */
     ZLE_STRING_T tmpline,	/* line with added pre/post text */
 	*qbuf;			/* tmp					     */
     int tmpcs, tmpll;		/* ditto cursor position and line length */
@@ -509,7 +508,11 @@
 		nbuf[ln][winw + 1] = ZWC('\n');	/* text wrapped */
 		nextline
 	    }
+#ifdef ZLE_UNICODE_SUPPORT
 	    *s++ = ((*t == 127) || (*t > 255)) ? ZWC('?') : (*t | ZWC('@'));
+#else
+	    *s++ = (*t == 127) ? ZWC('?') : (*t | ZWC('@'));
+#endif
 	} else {			/* normal character */
 	    *s++ = *t;
 	}
@@ -538,9 +541,9 @@
 	tosln = ln + 1;
 	nbuf[ln][winw + 1] = ZWC('\0');	/* text not wrapped */
 	snextline
-	u = (unsigned char *)statusline;
-	for (; u < (unsigned char *)statusline + statusll; u++) {
-	    if (icntrl(*u)) {	/* simplified processing in the status line */
+	u = statusline;
+	for (; u < statusline + statusll; u++) {
+	    if (ZC_icntrl(*u)) { /* simplified processing in the status line */
 		*s++ = ZWC('^');
 		if (s == sen) {
 		    nbuf[ln][winw + 1] = ZWC('\n');	/* text wrapped */
@@ -771,7 +774,7 @@
 /* 0: setup */
     nl = nbuf[ln];
     rnllen = nllen = nl ? ZS_strlen(nl) : 0;
-    ol = obuf[ln] ? obuf[ln] : ZWC("");
+    ol = obuf[ln] ? obuf[ln] : ZWS("");
     ollen = ZS_strlen(ol);
 
 /* optimisation: can easily happen for clearing old lines.  If the terminal has
Index: Src/Zle/zle_thingy.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_thingy.c,v
retrieving revision 1.16
diff -u -r1.16 zle_thingy.c
--- Src/Zle/zle_thingy.c	18 Feb 2005 13:57:28 -0000	1.16
+++ Src/Zle/zle_thingy.c	24 Feb 2005 13:07:27 -0000
@@ -407,7 +407,7 @@
 static int
 bin_zle_refresh(UNUSED(char *name), char **args, Options ops, UNUSED(char func))
 {
-    char *s = statusline;
+    ZLE_STRING_T s = statusline;
     int sl = statusll, ocl = clearlist;
 
     if (!zleactive)
@@ -416,8 +416,8 @@
     statusll = 0;
     if (*args) {
 	if (**args) {
-	    statusline = *args;
-	    statusll = strlen(statusline);
+	    statusline = stringaszleline((unsigned char *)*args, &statusll,
+					 NULL);
 	}
 	if (*++args) {
 	    LinkList l = newlinklist();
@@ -442,6 +442,9 @@
     }
     zrefresh();
 
+    if (statusline)
+	free(statusline);
+
     clearlist = ocl;
     statusline = s;
     statusll = sl;
Index: Src/Zle/zle_vi.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_vi.c,v
retrieving revision 1.6
diff -u -r1.6 zle_vi.c
--- Src/Zle/zle_vi.c	23 Feb 2005 13:50:47 -0000	1.6
+++ Src/Zle/zle_vi.c	24 Feb 2005 13:07:27 -0000
@@ -831,8 +831,8 @@
 {
     clearlist = 1;
     zbeep();
-    statusline = "press a lowercase key to continue";
-    statusll = strlen(statusline);
+    statusline = ZWS("press a lowercase key to continue");
+    statusll = ZS_strlen(statusline);
     zrefresh();
 #ifdef ZLE_UNICODE_SUPPORT
     while (!iswlower(getfullchar(0)));

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


**********************************************************************
This email and any files transmitted with it are confidential and
intended solely for the use of the individual or entity to whom they
are addressed. If you have received this email in error please notify
the system manager.

**********************************************************************

