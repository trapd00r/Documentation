From mason@werple.net.au Wed Mar 13 01:20:56 1996
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by melb.werple.net.au (8.7.4/8.7.3) with ESMTP id BAA19651 for <mason@werple.mira.net.au>; Wed, 13 Mar 1996 01:20:52 +1100 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id IAA06560; Tue, 12 Mar 1996 08:54:36 -0500 (EST)
Resent-Date: Tue, 12 Mar 1996 08:54:36 -0500 (EST)
From: Geoff Wing <mason@werple.net.au>
Message-Id: <199603121353.AAA22875@werple.net.au>
Subject: zle_refresh trial patch
To: zsh-workers@math.gatech.edu (zsh-list)
Date: Wed, 13 Mar 1996 00:53:45 +1100 (EST)
X-Mailer: ELM [version 2.4 PL23]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"tO6Ab3.0.Qc1.S8OHn"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/810
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu
Content-Length: 7838
Status: OR

This is a patch for beta13 (Don't patch on top of my previous patch in
message 742.  (I lost that message, so I can't produce a successive patch)).  
The zle_refresh() code should hopefully produce {less,hardly any} redundant
output.  I'm still unhappy with some of the code but it probably won't 
undergo any changes soon unless necessary (so find those bugs, please).

Hacked from Zoltan's message 809: 
:Type ^V^J^V^J1234567890^A- at a prompt.  You get:

Shouldn't appear.

:The other bug is probably the same but I can only reproduce is on a Linux
:console.  If a line wraps and there are at most 10 characters between the
:cursor and the right edge of the screen and least 10 characters wraps to the
:next screen line and a character is inserted, the first character on the
:wrapped line will be duplicated.

Sorry, I didn't understand this.

:tries to ensure that cut & paste in xterm works for wrapped lines so that no
:bogous newline will be added to the clipboard.  But zsh overdoes that even
:multiline buffers will be cut as a single line.  This does not happen when a
:multi-line buffer is directly typed in a buffer but only when such a
:multiline structure comes readily e.g. from the history when using the
:up-arrow key or in vared (zed).

Haven't checked this yet. (It's probably {in,}directly my fault anyway)

BTW, anyone get annoyed by this: when at the bottom of the screen
% rubbishrubbishrubbishrubbishrubbishrubbishrubbishrubbishrubbishrubbishrubbis*
rubbish      #don't press return, delete back to *

There is an extra line scrolled.  I'll look into it (soon).

Anyway:


*** zle_refresh.c.~1~	Fri Dec 22 09:44:43 1995
--- zle_refresh.c	Wed Mar 13 00:24:34 1996
***************
*** 41,47 ****
  /* Oct/Nov 94: <mason> some code savagely redesigned to fix several bugs -
     refreshline() & tc_rightcurs() majorly rewritten; refresh() fixed -
     I've put my fingers into just about every routine in here -
!    any queries about updates to mason@werple.apana.org.au */
  
  char **nbuf = NULL,		/* new video buffer line-by-line char array */
      **obuf = NULL;		/* old video buffer line-by-line char array */
--- 41,47 ----
  /* Oct/Nov 94: <mason> some code savagely redesigned to fix several bugs -
     refreshline() & tc_rightcurs() majorly rewritten; refresh() fixed -
     I've put my fingers into just about every routine in here -
!    any queries about updates to mason@werple.net.au */
  
  char **nbuf = NULL,		/* new video buffer line-by-line char array */
      **obuf = NULL;		/* old video buffer line-by-line char array */
***************
*** 56,62 ****
      winpos;			/* singlelinezle: line's position in window */
  static unsigned pmpt_attr = 0,	/* text attributes after displaying prompt  */
      rpmpt_attr = 0;		/* text attributes after displaying rprompt */
- static char am_char = ' ';	/* first col char if needed for automargin  */
  
  /**/
  void
--- 56,61 ----
***************
*** 103,109 ****
  
      vcs = pptw;
      olnct = nlnct = 0;
!     if(showinglist > 0)
  	showinglist = -2;
  }
  
--- 102,108 ----
  
      vcs = pptw;
      olnct = nlnct = 0;
!     if (showinglist > 0)
  	showinglist = -2;
  }
  
***************
*** 172,178 ****
       * that was called from the end of refresh(), then we don't need to do   *
       * anything.  All this `inlist' code is actually unnecessary, but it     *
       * improves speed a little in a common case.                             */
!     if(inlist)
  	return;
  
  #ifdef HAVE_SELECT
--- 171,177 ----
       * that was called from the end of refresh(), then we don't need to do   *
       * anything.  All this `inlist' code is actually unnecessary, but it     *
       * improves speed a little in a common case.                             */
!     if (inlist)
  	return;
  
  #ifdef HAVE_SELECT
***************
*** 366,372 ****
  individually */
  
      if (olnct > nlnct) {
! 	cleareol = 1;
  	for (ln = nlnct; ln < olnct; ln++)
  	    refreshline(ln);
      }
--- 365,371 ----
  individually */
  
      if (olnct > nlnct) {
! 	cleareol = clearf;
  	for (ln = nlnct; ln < olnct; ln++)
  	    refreshline(ln);
      }
***************
*** 407,419 ****
  
      /* if we have a new list showing, note it; if part of the list has been
      overwritten, redisplay it. */
!     if(showinglist == -2 || (showinglist > 0 && showinglist < nlnct)) {
  	inlist = 1;
  	listmatches();
  	inlist = 0;
  	refresh();
      }
!     if(showinglist == -1)
  	showinglist = nlnct;
  }
  
--- 406,418 ----
  
      /* if we have a new list showing, note it; if part of the list has been
      overwritten, redisplay it. */
!     if (showinglist == -2 || (showinglist > 0 && showinglist < nlnct)) {
  	inlist = 1;
  	listmatches();
  	inlist = 0;
  	refresh();
      }
!     if (showinglist == -1)
  	showinglist = nlnct;
  }
  
***************
*** 437,442 ****
--- 436,446 ----
  	i, j,			/* tmp					 */
  	nllen, ollen;		/* new and old line buffer lengths	 */
  
+ /* -1: this is a mini-kludge */
+     if (!nllen && !clearf)	/* ha ha: all done */
+ 	return;
+ 
+ /* 0: setup */
      nl = nbuf[ln];
      nllen = nl ? strlen(nl) : 0;
      ol = obuf[ln] ? obuf[ln] : "";
***************
*** 470,476 ****
     case it messes up cut and paste. */
  
      col_cleareol = -1;
!     if (tccan(TCCLEAREOL) && (!hasam || ln == nlnct - 1) && 
  	(nllen == winw ||	/* new buffer goes to the end of the line */
  	put_rpmpt != oput_rpmpt)) {
  	for (i = nllen; i && nl[i - 1] == ' '; i--);
--- 474,480 ----
     case it messes up cut and paste. */
  
      col_cleareol = -1;
!     if (tccan(TCCLEAREOL) && !clearf && (!hasam || ln == nlnct - 1) && 
  	(nllen == winw ||	/* new buffer goes to the end of the line */
  	put_rpmpt != oput_rpmpt)) {
  	for (i = nllen; i && nl[i - 1] == ' '; i--);
***************
*** 480,500 ****
  	    col_cleareol = i;
      }
  
! /* 3: set character for first column, in case automargin stuff needs doing:
!    to begin with, this is the first char of the old screen line, if any. */
!     am_char = *ol ? *ol : *nl;
! 
! /* 4: main display loop - write out the buffer using whatever tricks we can */
  
      for (;;) {
      /* skip past all matching characters */
  	for (; *nl && (*nl == *ol); nl++, ol++, ccs++) ;
  
  	if (!*nl) {
! 	    if ((char_ins <= 0)	|| (ccs >= winw))  /* written everything */
  		return;
  	    else		/* we've got junk on the right yet to clear */
! 		if (tccan(TCCLEAREOL) && (char_ins >= tclen[TCCLEAREOL]))
  		    col_cleareol = 0;	/* force a clear to end of line */
  	}
  
--- 484,502 ----
  	    col_cleareol = i;
      }
  
! /* 3: main display loop - write out the buffer using whatever tricks we can */
  
      for (;;) {
      /* skip past all matching characters */
  	for (; *nl && (*nl == *ol); nl++, ol++, ccs++) ;
  
  	if (!*nl) {
! 	    if ((char_ins <= 0)	|| (ccs >= winw)    /* written everything */
! 		|| (!clearf))
  		return;
  	    else		/* we've got junk on the right yet to clear */
! 		if (tccan(TCCLEAREOL) && (char_ins >= tclen[TCCLEAREOL]) &&
! 	    	    (!hasam || ln == nlnct -1))
  		    col_cleareol = 0;	/* force a clear to end of line */
  	}
  
***************
*** 602,614 ****
  	    putc('\n', shout);
  	    SELECT_ADD_COST(2);
  	} else {
! 	    putc(am_char, shout);
! 	    tcout(TCLEFT);
! 	    SELECT_ADD_COST(1 + tclen[TCLEFT]);
  	}
  	vln++, vcs = 0;
      }
-     am_char = ' ';
  
  /* move up */
      if (ln < vln) {
--- 604,618 ----
  	    putc('\n', shout);
  	    SELECT_ADD_COST(2);
  	} else {
! 	    if ((vln < nlnct - 1) && *nbuf[vln + 1])
! 		putc(*nbuf[vln + 1], shout);
! 	    else
! 		putc(' ', shout);
! 	    putc('\r', shout);
! 	    SELECT_ADD_COST(2);
  	}
  	vln++, vcs = 0;
      }
  
  /* move up */
      if (ln < vln) {

-- 
Mason [G.C.W]  mason@werple.mira.net.au    "Hurt...Agony...Pain...LOVE-IT"


