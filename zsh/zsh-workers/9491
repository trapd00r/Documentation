From zsh-workers-return-9491-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Jan 31 10:48:11 2000
Return-Path: <zsh-workers-return-9491-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11338 invoked from network); 31 Jan 2000 10:48:06 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 31 Jan 2000 10:48:06 -0000
Received: (qmail 18870 invoked by alias); 31 Jan 2000 10:48:00 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9491
Received: (qmail 18861 invoked from network); 31 Jan 2000 10:47:59 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000131104748.ZM32056@candle.brasslantern.com>
Date: Mon, 31 Jan 2000 10:47:48 +0000
In-Reply-To: <200001311000.LAA29263@beta.informatik.hu-berlin.de>
Comments: In reply to Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
        "Re: PATCH: job-control" (Jan 31, 11:00am)
References: <200001311000.LAA29263@beta.informatik.hu-berlin.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>,
        zsh-workers@sunsite.auc.dk
Subject: Re: PATCH: job-control
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Jan 31, 11:00am, Sven Wischnowsky wrote:
} Subject: Re: PATCH: job-control
}
} Bart Schaefer wrote:
} 
} > If it really is somehow the case the "it found out that the pipe-leader
} > was suspended too late," then it seems to me that the while() condition
} > in waitjob() is what needs fixing, or we still have a race condition:
} > the ^Z could suspend the pipe-leader between the child_block() and the
} > while() test within waitjob().  All that this change has done is shrink
} > the window.
} 
} No, the important bit is the child_unblock() which makes the signal
} handler be run for all pending signals (we are blocking child signals
} during most of the execution code), so that the job and process
} infos are updated.

Yes, that's exactly my point.  waitjob() should enter the body of the
while() loop -- thus calling child_suspend() and allowing the job and
process info to be updated -- when there are any jobs that the shell
"believes" are still in a runnable state.  It should never be the case
that the job info has to be updated by a signal handler in order for
the shell to discover that there may be runnable jobs; in that case it
can mean only that (a) the setup of the info for those jobs is wrong
to begin with, or (b) there's a condition in which the loop should be 
entered but that is not tested.

The other possibility is that child_suspend() isn't sufficient to get
the job info updated, but that would imply a much more serious problem.

} Without the patch this happened only when a
} execpline() finished (shortly before that). In the test case there
} were two of them active and we need to know that the leader was
} suspended in the inner one but since child-signals were only delivered 
} after the call to waitjobs(), we could see that only in the outer
} execpline().

When you say "we need to know that the leader was suspended in the
inner one," what does that mean code-wise?  What is it that we "see
only in the outer execpline()"?

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

