From zsh-users-return-14413-mason-zsh=primenet.com.au@sunsite.dk Sat Sep 19 05:23:49 2009
Return-Path: <zsh-users-return-14413-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9480 invoked from network); 19 Sep 2009 05:23:36 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.4 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from new-brage.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.254.104)
  by ns1.primenet.com.au with SMTP; 19 Sep 2009 05:23:36 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 13027 invoked from network); 19 Sep 2009 05:23:25 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 19 Sep 2009 05:23:25 -0000
Received: (qmail 27591 invoked by alias); 19 Sep 2009 05:23:08 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 14413
Received: (qmail 27541 invoked from network); 19 Sep 2009 05:23:08 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 19 Sep 2009 05:23:08 -0000
Received: from old-tantale.fifi.org (old-tantale.fifi.org [64.81.30.200])
	by bifrost.dotsrc.org (Postfix) with ESMTP id DB45C801E2BF
	for <zsh-users@sunsite.dk>; Sat, 19 Sep 2009 07:23:00 +0200 (CEST)
Received: (from phil@localhost)
	by old-tantale.fifi.org (8.9.3p2/8.9.3/Debian 8.9.3-21) id WAA05216;
	Fri, 18 Sep 2009 22:22:57 -0700
Sender: phil@fifi.org
To: Christopher Browne <cbbrowne@gmail.com>
Cc: zsh-users@sunsite.dk
Subject: Re: Possibly dumb question... Constructing PATH
References: <d6d6637f0909141811q1fbf3f0fs3f3af6904d78d7b@mail.gmail.com>
Mail-Copies-To: nobody
From: Philippe Troin <phil@fifi.org>
Date: 18 Sep 2009 22:22:57 -0700
In-Reply-To: <d6d6637f0909141811q1fbf3f0fs3f3af6904d78d7b@mail.gmail.com>
Message-ID: <87vdjfa4pa.fsf@old-tantale.fifi.org>
Lines: 52
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.2
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="=-=-="
X-Virus-Scanned: ClamAV 0.94.2/9815/Fri Sep 18 18:24:45 2009 on bifrost
X-Virus-Status: Clean

--=-=-=

Christopher Browne <cbbrowne@gmail.com> writes:

> I'm redoing some of my .rc files, and was wondering if there's a
> common idiom for "add that path to PATH, if it's missing"?
> 
> In my .emacs/init.el, I have this concept...
> (defun add-extra-path (raw-proposal)
>     (let ((proposal (expand-file-name raw-proposal)))
>       (if (not (member proposal load-path))
> 	  (setq load-path (cons proposal load-path)))))
> 
> I have a number of paths I add to the Emacs load-path using the above,
> by looping across them and adding the ones that aren't already there.
> 
> What I'm thinking of is something like..
> 
> for pathproposal in ${HOME}/bin /usr/bin /bin /usr/local/bin [cast of
> additional "teeming masses"]; do
>    if [path-proposal is not in $PATH]
>    PATH=$path-proposal:$PATH
>    fi
> done
> 
> Is there any funky slick way to do that check?  Or might I just as
> well do an "echo | egrep"?

May I offer addtopath?

It's a function that allows you to append or prepend a path to a "path
variable" (eg. path, manpath).

Drop addtopath into a file and autoload it.

Use it as:

  addtopath -a path /usr/bin /usr/sbin /sbin

Also, addtopath dedupes entries based on their block-device/inode
pair.  Eg., in the above example, if /sbin is a symlink to /usr/sbin,
then path will contain (/usr/bin /usr/sbin), but not /sbin.

I'm not sure if this optimization is worth the trouble ;)

I also have attached the completion function (_addtopath).

Phil.


--=-=-=
Content-Disposition: inline; filename=addtopath

# -*- shell-script -*-
# Standard function to change a path
zmodload -ab -i zsh/stat stat
if (( $# <= 2 ))
then
	echo "usage: $0 <-a|-p> <variable> <paths...>" 1>&2
	return 1
fi
local pos type pathvar i j stats key nelts statres
local -A inums
type=$1
pathvar=$2
shift 2

nelts=${#${(P)pathvar}}
for (( i=1; $i <= $nelts; i++))
do
    stat -H stats ${${(P)pathvar}[$i]} 2> /dev/null
    statres=$?
    key="$stats[device]:$stats[inode]"
    if (( $+inums[$key] || $statres != 0 ))
    then
	set -A "$pathvar" ${${(P)pathvar}[1,$i-1]} \
			  ${${(P)pathvar}[$i+1,-1]}
	(( nelts-- ))
	(( i-- ))
    else
	inums[$key]=$i
    fi
done

for i in $@
do
    stat -H stats $i 2> /dev/null || continue
    [[ -d $i ]] && i=$(cd $i && pwd)
    key="$stats[device]:$stats[inode]"
    pos=${inums[$key]-0}
    if [[ $pos != 0 ]]
    then
	set -A "$pathvar" ${${(P)pathvar}[1,$pos-1]} \
			  ${${(P)pathvar}[$pos+1,-1]}
	for j in ${(k)inums}
	do
	    (( $inums[$j] > $pos )) && (( inums[$j]-- ))
	done
    fi
    case $type in
	(-p)
	    set -A "$pathvar" $i ${${(P)pathvar}[@]}
	    for j in ${(k)inums}
	    do
		(( inums[$j]++ ))
	    done
	    inums[$key]=1
	    ;;
	(-a)
	    set -A "$pathvar" ${${(P)pathvar}[@]} $i
	    inums[$key]=${#${(P)pathvar}}
	    ;;
	(*)
	    echo "$0: bad flag, should be -a or -p, not $type" 1>&2
	    return 1 ;;
    esac
    # # Debugging code
    # echo "ASSERT CHECK AT END OF PASS"
    # for i in ${(k)inums}
    # do
    #	pos=${inums[$i]}
    #	stat -H stats ${${(P)pathvar}[$pos]}
    #	key="$stats[device]:$stats[inode]"
    #	if [[ $key != $i ]]
    #	then
    #	    echo "ASSERT FAILS:"
    #	    echo "  key   $key"
    #	    echo "  path " ${${(P)pathvar}[$pos]}
    #	    echo "  index $pos"
    #	fi
    # done
    # # End debugging code
done

--=-=-=
Content-Disposition: inline; filename=_fi_addtopath

#compdef addtopath
_arguments \
    '1:insertion position:((-a\:append -p\:prepend))' \
    '2:variable name:_arrays' \
    '*:directory:_directories'

--=-=-=--

