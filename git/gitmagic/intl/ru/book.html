<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>Волшебство Git</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
alink="#0000FF">
  <div lang="ru" class="book" title="Волшебство Git">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="idp150320" id=
          "idp150320"></a>Волшебство Git</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="firstname">Ben</span>
            <span class="surname">Lynn</span></h3>
          </div>
        </div>

        <div>
          <div class="revhistory">
            <table border="1" width="100%" summary=
            "Revision history">
              <tr>
                <th align="left" valign="top" colspan="3">
                <b>История переиздания</b></th>
              </tr>

              <tr>
                <td align="left"></td>

                <td align="left">Август 2007</td>

                <td align="left">BL</td>
              </tr>
            </table>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Содержание</b></p>

      <dl>
        <dt><span class="preface"><a href=
        "#_%D0%BE%D1%82_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D0%B0">
        От редактора перевода</a></span></dt>

        <dt><span class="preface"><a href=
        "#_%D0%BF%D1%80%D0%B5%D0%B4%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">
        Предисловие</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D0%B1%D0%BB%D0%B0%D0%B3%D0%BE%D0%B4%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D0%B8">
            Благодарности</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BB%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F">Лицензия</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">1.
        Введение</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0_%D1%8D%D1%82%D0%BE_%D0%B8%D0%B3%D1%80%D0%B0">
            Работа - это игра</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
            Управление версиями</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">
            Распределенное управление</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B3%D0%BB%D1%83%D0%BF%D1%8B%D0%B5_%D0%BF%D1%80%D0%B5%D0%B4%D1%80%D0%B0%D1%81%D1%81%D1%83%D0%B4%D0%BA%D0%B8">
            Глупые предрассудки</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D1%8B_%D0%BF%D1%80%D0%B8_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B8">
            Конфликты при слиянии</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8">
        2. Базовые операции</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F">
            Сохранение состояния</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
            Добавление, удаление, переименование</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D0%B0_%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82">
            Расширенные отмена/возврат</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BE%D1%82%D0%BA%D0%B0%D1%82%D1%8B">Откаты</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
            Создание списка изменений</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%81%D0%BA%D0%B0%D1%87%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2">
            Скачивание файлов</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B4%D0%B5%D1%80%D0%B6%D0%B0_%D1%80%D1%83%D0%BA%D1%83_%D0%BD%D0%B0_%D0%BF%D1%83%D0%BB%D1%8C%D1%81%D0%B5">
            Держа руку на пульсе</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B1%D0%B5%D0%B7%D0%BE%D1%82%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F">
            Безотлагательная публикация</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%87%D1%82%D0%BE_%D1%8F_%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D0%BB">
            Что я сделал?</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B6%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
            Упражнение</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D0%B2%D1%81%D0%B5_%D0%BE_%D0%BA%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8">
        3. Все о клонировании</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2">
            Синхронизация компьютеров</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%BC_%D0%BA%D0%BE%D0%B4%D0%BE%D0%BC">
            Классическое управление исходным кодом</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B3%D0%BE%D0%BB%D1%8B%D0%B5_bare_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0">
            Голые (bare) хранилища</a></span></dt>

            <dt><span class="section"><a href=
            "#_push_%D0%B8%D0%BB%D0%B8_pull">Push или
            pull?</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%BE%D1%80%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0">
            Создание форка проекта</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B1%D1%8D%D0%BA%D0%B0%D0%BF%D1%8B">
            Максимальные бэкапы</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D1%81%D0%BE_%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%D1%8E_%D1%81%D0%B2%D0%B5%D1%82%D0%B0">
            Многозадачность со скоростью света</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D0%B0%D1%80%D1%82%D0%B8%D0%B7%D0%B0%D0%BD%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
            Партизанское управление версиями</a></span></dt>

            <dt><span class="section"><a href=
            "#_mercurial">Mercurial</a></span></dt>

            <dt><span class="section"><a href=
            "#_bazaar">Bazaar</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83_%D1%8F_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E_git">
            Почему я использую Git</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D1%87%D1%83%D0%B4%D0%B5%D1%81%D0%B0_%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
        4. Чудеса ветвления</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B0_%D0%B1%D0%BE%D1%81%D1%81%D0%B0">
            Кнопка босса</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B3%D1%80%D1%8F%D0%B7%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0">
            Грязная работа</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B5_%D0%B8%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
            Быстрые исправления</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F">Слияния</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D1%8B%D0%B9_%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81">
            Непрерывный рабочий процесс</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC_%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2_%D1%81%D0%BC%D0%B5%D1%81%D0%B8">
            Изменяем состав смеси</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8">
            Управление Ветками</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
            Временные Ветки</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B9%D1%82%D0%B5_%D0%BA%D0%B0%D0%BA_%D0%B2%D0%B0%D0%BC_%D0%BD%D1%80%D0%B0%D0%B2%D0%B8%D1%82%D1%81%D1%8F">
            Работайте как вам нравится</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D1%83%D1%80%D0%BE%D0%BA%D0%B8_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8">
        5. Уроки истории</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B0%D1%8F%D1%81%D1%8C_%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%BC">
            Оставаясь корректным</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8_%D0%BA%D0%BE%D0%B5_%D1%87%D1%82%D0%BE_%D0%B5%D1%89%D0%B5">
            …И кое-что еще</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%8E%D1%82%D1%81%D1%8F">
            Локальные изменения сохраняются</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
            Переписывая историю</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
            Создавая Историю</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0_%D0%B6%D0%B5_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
            Когда же все пошло не так?</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%B7_%D0%B7%D0%B0_%D0%BA%D0%BE%D0%B3%D0%BE_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
            Из-за кого все пошло не так?</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D1%8B%D1%82">
            Личный опыт</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B9_git">
        6. Многопользовательский Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D0%BA%D1%82%D0%BE_%D1%8F">Кто я?</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_ssh_http">Git
            через SSH, HTTP</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%87%D1%82%D0%BE_%D1%83%D0%B3%D0%BE%D0%B4%D0%BD%D0%BE">
            Git через что угодно</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D0%B0%D1%82%D1%87%D0%B8_%D0%BE%D0%B1%D1%89%D0%B5%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
            Патчи: общее применение</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D1%80%D0%B8%D0%BD%D0%BE%D1%81%D0%B8%D0%BC_%D0%B8%D0%B7%D0%B2%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B_%D0%BF%D0%B5%D1%80%D0%B5%D0%B5%D1%85%D0%B0%D0%BB%D0%B8">
            Приносим извинения, мы переехали</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
            Удаленные ветки</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89">
            Несколько удаленных хранилищ</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BC%D0%BE%D0%B8_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8">
            Мои Настройки</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D0%B3%D1%80%D0%BE%D1%81%D1%81%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B5%D1%80%D1%81%D1%82%D0%B2%D0%BE_git">
        7. Гроссмейстерство Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D1%80%D0%B5%D0%BB%D0%B8%D0%B7%D1%8B_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2">
            Релизы исходников</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
            Коммит изменений</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BC%D0%BE%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC_%D0%B2%D0%B5%D0%BB%D0%B8%D0%BA">
            Мой коммит слишком велик</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B7%D0%BE%D0%BD%D0%B0_git">
            Индекс — буферная зона Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5_%D1%82%D0%B5%D1%80%D1%8F%D0%B9_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D1%8B">
            Не теряй «головы»</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BE%D1%85%D0%BE%D1%82%D0%B0_%D0%B7%D0%B0_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8">
            Охота за «головами»</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_%D0%BA%D0%B0%D0%BA_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B0">
            Git как основа</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%80%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%82%D1%80%D1%8E%D0%BA%D0%B8">
            Рискованные трюки</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%82%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC_%D0%BF%D0%BB%D0%BE%D1%85%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B">
            Предотвращаем плохие коммиты</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_%D1%80%D0%B0%D1%81%D0%BA%D1%80%D1%8B%D0%B2%D0%B0%D0%B5%D0%BC_%D1%82%D0%B0%D0%B9%D0%BD%D1%8B">
        8. Раскрываем тайны</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C">
            Невидимость</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">
            Целостность</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82">
            Интеллект</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%D1%86%D0%B8%D1%8F">
            Индексация</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_git">
            Происхождение Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B1%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">
            База данных объектов</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B1%D0%BB%D0%BE%D0%B1%D1%8B">Блобы</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F">Деревья</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B">Коммиты</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D0%BE_%D0%BE%D1%82_%D0%B2%D0%BE%D0%BB%D1%88%D0%B5%D0%B1%D1%81%D1%82%D0%B2%D0%B0">
            Неотличимо от волшебства</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href=
        "#_%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8_git">
        A. Недостатки Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_%D1%81%D0%BB%D0%B0%D0%B1%D0%BE%D1%81%D1%82%D0%B8_sha1">
            Слабости SHA1</a></span></dt>

            <dt><span class="section"><a href=
            "#_microsoft_windows">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B5%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D1%8B">
            Несвязанные файлы</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BA%D1%82%D0%BE_%D0%B8_%D1%87%D1%82%D0%BE_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BB">
            Кто и что редактировал ?</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0">
            История файла</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BA%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
            Начальное Клонирование</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%87%D0%B8%D0%B2%D1%8B%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B">
            Изменчивые Проекты</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%81%D1%87%D0%B5%D1%82%D1%87%D0%B8%D0%BA">
            Глобальный счетчик</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D1%83%D1%81%D1%82%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B8">
            Пустые подкаталоги</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82">
            Первоначальный коммит</a></span></dt>

            <dt><span class="section"><a href=
            "#_%D0%BF%D1%80%D0%B8%D1%87%D1%83%D0%B4%D1%8B_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0">
            Причуды интерфейса</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href=
        "#_%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4_%D1%8D%D1%82%D0%BE%D0%B3%D0%BE_%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0">
        B. Перевод этого руководства</a></span></dt>
      </dl>
    </div>

    <div class="preface" title="От редактора перевода">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%BE%D1%82_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4%D0%B0">
            </a>От редактора перевода</h2>
          </div>
        </div>
      </div>

      <p>Не буду долго вас задерживать перед интересным чтением,
      лишь дам небольшие пояснения по переводу терминологии.</p>

      <p>Приводя текст к единому стилю, я старался в первую очередь
      сохранить его цельность и легкость восприятия, а уже затем
      следовать чистоте языка. Поэтому на русский переведены лишь
      устоявшиеся термины; в тех случаях, когда общепринятого
      русского слова нет, была оставлена калька с английского.
      Например, используется слово «каталог» вместо «директория»;
      «хранилище» вместо «репозиторий» или «репозитарий»; «слияние»
      вместо «мерж»; и «ветка» вместо «бранч». Обратные примеры:
      «коммит», а не «фиксация»; «хук», а не «крюк»; «патч», а не
      «заплатка». Единственное исключение сделано для фразы
      «буферная зона» вместо «область стейджинг» и, соответственно,
      слова «буфер» вместо «стейдж»: поскольку здесь уже не только
      перевод, но и калька не есть общеупотребительные термины, то
      лучше было попытаться объяснить смысл понятия.</p>

      <p>Надеюсь, эти краткие пояснения не оставят для вас
      неровностей в переводе и позволят погрузиться в текст книги
      без помех. Приятного чтения.</p>
    </div>

    <div class="preface" title="Предисловие">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%BF%D1%80%D0%B5%D0%B4%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5">
            </a>Предисловие</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D0%B1%D0%BB%D0%B0%D0%B3%D0%BE%D0%B4%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D0%B8">
          Благодарности</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BB%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F">Лицензия</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target=
      "_top">Git</a> это швейцарский нож управления версиями —
      надежный универсальный многоцелевой инструмент, чья
      черезвычайная гибкость делает его сложным в изучении даже для
      многих профессионалов.</p>

      <p>Как говорил Артур Кларк, любая достаточно развитая
      технология неотличима от волшебства. Это отличный подход к
      Git: новички могут игнорировать принципы его внутренней
      работы и рассматривать Git как нечто восхищающее друзей и
      приводящее в бешенство врагов своими чудесными
      способностями.</p>

      <p>Вместо того, чтобы вдаваться в подробности, мы предоставим
      приблизительные инструкции для получения конкретных
      результатов. При частом использовании вы постепенно поймете,
      как работает каждый трюк и как приспосабливать рецепты под
      ваши нужды.</p>

      <div class="itemizedlist" title="Переводы">
        <p class="title"><b>Переводы</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href=
          "http://docs.google.com/View?id=dfwthj68_675gz3bw8kj"
          target="_top">Китайский (упрощенный)</a>: JunJie, Meng и
          JiangWei.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/es/" target="_top">Испанский</a>:
          Rodrigo Toledo.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/de/" target="_top">Немецкий</a>:
          Benjamin Bellee и Armin Stebich. Armin также разместил
          <a class="ulink" href="http://gitmagic.lordofbikes.de/"
          target="_top">немецкий перевод на его сайте</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/ru/" target="_top">Русский</a>:
          Тихон Тарнавский, Михаил Дымсков и другие.</li>

          <li class="listitem"><a class="ulink" href=
          "/~blynn/gitmagic/intl/fr/" target=
          "_top">Французский</a>: Alexandre Garel. Также размещён
          на <a class="ulink" href="http://tutoriels.itaapy.com/"
          target="_top">itaapy</a>.</li>

          <li class="listitem"><a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git" target=
          "_top">Португальский</a>: Leonardo Siqueira Rodrigues
          [<a class="ulink" href=
          "http://www.slideshare.net/slide_user/magia-git-verso-odt"
          target="_top">в формате ODT</a>].</li>
        </ul>
      </div>

      <div class="itemizedlist" title="Другие варианты">
        <p class="title"><b>Другие варианты</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href="book.html"
          target="_top">HTML одной страницей</a>: чистый HTML без
          CSS.</li>

          <li class="listitem"><a class="ulink" href="book.pdf"
          target="_top">PDF файл</a>: для печати.</li>

          <li class="listitem"><a class="ulink" href=
          "http://packages.debian.org/gitmagic" target="_top">Пакет
          Debian</a>, <a class="ulink" href=
          "http://packages.ubuntu.com/gitmagic" target="_top">пакет
          Ubuntu</a>: получите локальную копию этого сайта.
          Придется кстати, <a class="ulink" href=
          "http://csdcf.stanford.edu/status/" target="_top">если
          этот сервер будет недоступен</a>.</li>
        </ul>
      </div>

      <div class="section" title="Благодарности">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B1%D0%BB%D0%B0%D0%B3%D0%BE%D0%B4%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D0%B8">
              </a>Благодарности</h2>
            </div>
          </div>
        </div>

        <p>Я очень ценю, что столь многие люди работали над
        переводами этих строк. Я благодарен названным выше людям за
        их усилия, расширившие мою аудиторию.</p>

        <p>Dustin Sallings, Alberto Bertogli, James Cameron,
        Douglas Livingstone, Michael Budde, Richard Albury,
        Tarmigan, Derek Mahar, Frode Aannevik, Keith Rarick, Andy
        Somerville, Ralf Recker, Øyvind A. Holm, Miklos Vajna,
        Sébastien Hinderer, Thomas Miedema, Joe Malin и Tyler
        Breisacher содействовали в правках и доработках.</p>

        <p>François Marier сопровождает пакет Debian, изначально
        созданный Daniel Baumann.</p>

        <p>Мои благодарности остальным за вашу поддержку и похвалы.
        Мне очень хотелось процитировать вас здесь, но это могло бы
        возвысить ваше тщеславие до невообразимых высот.</p>

        <p>Если я случайно забыл упомянуть вас, пожалуйста,
        напомните мне или просто вышлите патч.</p>

        <div class="itemizedlist" title="Бесплатные хостинги Git">
          <p class="title"><b>Бесплатные хостинги Git</b></p>

          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://repo.or.cz/" target=
            "_top">http://repo.or.cz/</a> хостинг свободных
            проектов. Первый сайт Git-хостинга. Основан и
            поддерживается одним из первых разработчиков Git.</li>

            <li class="listitem"><a class="ulink" href=
            "http://gitorious.org/" target=
            "_top">http://gitorious.org/</a> другой сайт
            Git-хостинга, нацеленный на проекты с открытым
            кодом.</li>

            <li class="listitem"><a class="ulink" href=
            "http://github.com/" target=
            "_top">http://github.com/</a> хостинг для проектов с
            открытым кодом; а также для закрытых проектов (на
            платной основе).</li>
          </ul>
        </div>

        <p>Большое спасибо каждому из этих сайтов за размещение
        этого руководства.</p>
      </div>

      <div class="section" title="Лицензия">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BB%D0%B8%D1%86%D0%B5%D0%BD%D0%B7%D0%B8%D1%8F"></a>Лицензия</h2>
            </div>
          </div>
        </div>

        <p>Это руководство выпущено под <a class="ulink" href=
        "http://www.gnu.org/licenses/gpl-3.0.html" target=
        "_top">GNU General Public License 3-й версии</a>.
        Естественно, исходный текст находится в хранилище Git и
        может быть получен командой:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git  # Создаст каталог "gitmagic".
</pre>

        <p>или с одного из зеркал:</p>
        <pre class="literallayout">
$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git
</pre>
      </div>
    </div>

    <div class="chapter" title="Глава 1. Введение">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5"></a>Глава
            1. Введение</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0_%D1%8D%D1%82%D0%BE_%D0%B8%D0%B3%D1%80%D0%B0">
          Работа - это игра</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
          Управление версиями</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">
          Распределенное управление</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B3%D0%BB%D1%83%D0%BF%D1%8B%D0%B5_%D0%BF%D1%80%D0%B5%D0%B4%D1%80%D0%B0%D1%81%D1%81%D1%83%D0%B4%D0%BA%D0%B8">
          Глупые предрассудки</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D1%8B_%D0%BF%D1%80%D0%B8_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B8">
          Конфликты при слиянии</a></span></dt>
        </dl>
      </div>

      <p>Чтобы объяснить, что такое управление версиями, я буду
      использовать аналогии. Если нужно более точное объяснение,
      обратитесь к <a class="ulink" href=
      "http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8"
      target="_top">статье википедии</a>.</p>

      <div class="section" title="Работа - это игра">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0_%D1%8D%D1%82%D0%BE_%D0%B8%D0%B3%D1%80%D0%B0">
              </a>Работа - это игра</h2>
            </div>
          </div>
        </div>

        <p>Я играл в компьютерные игры почти всю свою жизнь. А вот
        использовать системы управления версиями начал уже будучи
        взрослым. Полагаю, я такой не один, и сравнение этих двух
        занятий может помочь объяснению и пониманию концепции.</p>

        <p>Представьте, что редактирование кода или документа —
        игра. Далеко продвинувшись, вы захотите сохраниться. Для
        этого вы нажмете на кнопку «Сохранить» в вашем любимом
        редакторе.</p>

        <p>Но это перезапишет старую версию. Это как в древних
        играх, где был только один слот для сохранения: конечно, вы
        можете сохраниться, но вы больше никогда не сможете
        вернуться к более раннему состоянию. Это досадно, так как
        прежнее сохранение могло указывать на одно из очень
        интересных мест в игре, и может быть, однажды вы захотите
        вернуться к нему. Или, что еще хуже, вы сейчас находитесь в
        безвыигрышном положении и вынуждены начинать заново.</p>
      </div>

      <div class="section" title="Управление версиями">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
              </a>Управление версиями</h2>
            </div>
          </div>
        </div>

        <p>Во время редактирования вы можете «Сохранить как…» в
        другой файл, или скопировать файл куда-нибудь перед
        сохранением, чтобы уберечь более старые версии. Может быть,
        заархивировав их для экономии места на диске. Это самый
        примитивный вид управления версиями, к тому же требующий
        интенсивной ручной работы. Компьютерные игры прошли этот
        этап давным-давно, в большинстве из них есть множество
        слотов для сохранения с автоматическими временны́ми
        метками.</p>

        <p>Давайте немного усложним условия. Пусть у вас есть
        несколько файлов, используемых вместе, например, исходный
        код проекта или файлы для вебсайта. Теперь, чтобы сохранить
        старую версию, вы должны скопировать весь каталог.
        Поддержка множества таких версий вручную неудобна и быстро
        становится дорогим удовольствием.</p>

        <p>В некоторых играх сохранение — это и есть каталог с
        кучей файлов внутри. Игры скрывают детали от игрока и
        предоставляют удобный интерфейс для управления различными
        версиям этого каталога.</p>

        <p>В системах управления версиями всё точно так же. У них у
        всех есть приятный интерфейс для управления каталогом с
        вашим скарбом. Можете сохранять состояние каталога так
        часто, как пожелаете, а затем восстановить любую из
        предыдущих сохраненных версий. Но, в отличие от
        компьютерных игр, они существенно экономят дисковое
        пространство. Обычно от версии к версии изменяется только
        несколько файлов, и то ненамного. Хранение лишь различий
        вместо полных копий требует меньше места.</p>
      </div>

      <div class="section" title="Распределенное управление">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">
              </a>Распределенное управление</h2>
            </div>
          </div>
        </div>

        <p>А теперь представьте очень сложную компьютерную игру. Ее
        настолько сложно пройти, что множество опытных игроков по
        всему миру решили объединиться и использовать общие
        сохранения, чтобы попытаться выиграть. Прохождения на
        скорость — живой пример. Игроки, специализирующиеся на
        разных уровнях игры, объединяются, чтобы в итоге получить
        потрясающий результат.</p>

        <p>Как бы вы организовали такую систему, чтобы игроки
        смогли легко получать сохранения других? А загружать
        свои?</p>

        <p>В былые времена каждый проект использовал
        централизованное управление версиями. Какой-нибудь сервер
        хранил все сохраненные игры. И никто больше. Каждый держал
        лишь несколько сохранений на своей машине. Когда игрок
        хотел пройти немного дальше, он выкачивал самое последнее
        сохранение с главного сервера, играл немного, сохранялся и
        закачивал уже свое сохранение обратно на сервер, чтобы
        остальные могли им воспользоваться.</p>

        <p>А что если игрок по какой-то причине захотел
        использовать более старую сохраненную игру? Возможно,
        нынешнее сохранение безвыигрышно, потому что кто-то забыл
        взять некий игровой предмет еще на третьем уровне, и нужно
        найти последнее сохранение, где игру всё еще можно
        закончить. Или, может быть, хочется сравнить две более
        старые сохраненные игры, чтобы установить вклад конкретного
        игрока.</p>

        <p>Может быть много причин вернуться к более старой версии,
        но выход один: нужно запросить ту старую сохраненную игру у
        центрального сервера. Чем больше сохраненных игр требуется,
        тем больше понадобится связываться с сервером.</p>

        <p>Системы управления версиями нового поколения, к которым
        относится Git, известны как распределенные системы, их
        можно понимать как обобщение централизованных систем. Когда
        игроки загружаются с главного сервера, они получают каждую
        сохраненную игру, а не только последнюю. Они как бы
        зеркалируют центральный сервер.</p>

        <p>Эти первоначальные операции клонирования могут быть
        ресурсоемкими, особенно при длинной истории, но сполна
        окупаются при длительной работе. Наиболее очевидная прямая
        выгода состоит в том, что если вам зачем-то потребуется
        более старая версия, взаимодействие с сервером не
        понадобится.</p>
      </div>

      <div class="section" title="Глупые предрассудки">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B3%D0%BB%D1%83%D0%BF%D1%8B%D0%B5_%D0%BF%D1%80%D0%B5%D0%B4%D1%80%D0%B0%D1%81%D1%81%D1%83%D0%B4%D0%BA%D0%B8">
              </a>Глупые предрассудки</h2>
            </div>
          </div>
        </div>

        <p>Широко распространенное заблуждение состоит в том, что
        распределенные системы непригодны для проектов, требующих
        официального централизованного хранилища. Ничто не может
        быть более далеким от истины. Получение фотоснимка не
        приводит к тому, что мы крадем чью-то душу. Точно так же
        клонирование главного хранилища не уменьшает его
        важность.</p>

        <p>В первом приближении можно сказать, что все, что делает
        централизованная система управления версиями, хорошо
        сконструированная распределенная система может сделать
        лучше. Сетевые ресурсы просто дороже локальных. Хотя дальше
        мы увидим, что в распределенном подходе есть свои
        недостатки, вы вряд ли ошибетесь в выборе, руководствуясь
        этим приближенным правилом.</p>

        <p>Небольшому проекту может понадобиться лишь частица
        функционала, предлагаемого такой системой. Но использование
        плохо масштабируемой системы для маленьких проектов подобно
        использованию римских цифр в расчетах с небольшими
        числами.</p>

        <p>Кроме того, проект может вырасти сверх первоначальных
        ожиданий. Использовать Git с самого начала — это как
        держать наготове швейцарский нож, даже если вы всего лишь
        открываете им бутылки. Однажды вам безумно понадобится
        отвертка и вы будете рады, что под рукой есть нечто
        большее, чем простая открывалка.</p>
      </div>

      <div class="section" title="Конфликты при слиянии">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D1%8B_%D0%BF%D1%80%D0%B8_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B8">
              </a>Конфликты при слиянии</h2>
            </div>
          </div>
        </div>

        <p>Для этой темы аналогия с компьютерной игрой становится
        слишком натянутой. Вместо этого, давайте вернемся к
        редактированию документа.</p>

        <p>Итак, допустим, что Алиса вставила строчку в начале
        файла, а Боб — в конце. Оба они закачивают свои изменения.
        Большинство систем автоматически сделает разумный вывод:
        принять и соединить их изменения так, чтобы обе правки — и
        Алисы, и Боба — были применены.</p>

        <p>Теперь предположим, что и Алиса, и Боб внесли разные
        изменения в одну и ту же строку. В этом случае невозможно
        продолжить без человеческого вмешательства. Тот из них, кто
        вторым закачает на сервер изменения, будет информирован о
        <span class="emphasis"><em>конфликте слияния</em></span>
        (merge conflict), и должен либо предпочесть одно изменение
        другому, либо скорректировать всю строку.</p>

        <p>Могут случаться и более сложные ситуации. Системы
        управления версиями разрешают простые ситуации сами и
        оставляют сложные для человека. Обычно такое их поведение
        поддается настройке.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 2. Базовые операции">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8">
            </a>Глава 2. Базовые операции</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F">
          Сохранение состояния</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
          Добавление, удаление, переименование</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D0%B0_%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82">
          Расширенные отмена/возврат</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BE%D1%82%D0%BA%D0%B0%D1%82%D1%8B">Откаты</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
          Создание списка изменений</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%81%D0%BA%D0%B0%D1%87%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2">
          Скачивание файлов</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B4%D0%B5%D1%80%D0%B6%D0%B0_%D1%80%D1%83%D0%BA%D1%83_%D0%BD%D0%B0_%D0%BF%D1%83%D0%BB%D1%8C%D1%81%D0%B5">
          Держа руку на пульсе</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B1%D0%B5%D0%B7%D0%BE%D1%82%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F">
          Безотлагательная публикация</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%87%D1%82%D0%BE_%D1%8F_%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D0%BB">
          Что я сделал?</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B6%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
          Упражнение</a></span></dt>
        </dl>
      </div>

      <p>Прежде чем погружаться в дебри многочисленных команд Git,
      попробуйте воспользоваться приведенными ниже простыми
      примерами, чтобы немного освоиться. Каждый из них полезен,
      несмотря на свою простоту. На самом деле первые месяцы
      использования Git я не выходил за рамки материала этой
      главы.</p>

      <div class="section" title="Сохранение состояния">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F">
              </a>Сохранение состояния</h2>
            </div>
          </div>
        </div>

        <p>Собираетесь попробовать внести некие радикальные
        изменения? Предварительно создайте снимок всех файлов в
        текущем каталоге с помощью команд</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Моя первая резервная копия"
</pre>

        <p>Теперь, если новые правки всё испортили, можно
        восстановить первоначальную версию:</p>
        <pre class="literallayout">
$ git reset --hard
</pre>

        <p>Чтобы вновь сохранить состояние:</p>
        <pre class="literallayout">
$ git commit -a -m "Другая резервная копия"
</pre>
      </div>

      <div class="section" title=
      "Добавление, удаление, переименование">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
              </a>Добавление, удаление, переименование</h2>
            </div>
          </div>
        </div>

        <p>Приведенный выше пример отслеживает только те файлы,
        которые существовали при первом запуске <span class=
        "strong"><strong>git add</strong></span>. Если вы создали
        новые файлы или подкаталоги, придется сказать Git'у:</p>
        <pre class="literallayout">
$ git add readme.txt Documentation
</pre>

        <p>Аналогично, если хотите, чтобы Git забыл о некоторых
        файлах:</p>
        <pre class="literallayout">
$ git rm ляп.h старье.c
$ git rm -r улики/
</pre>

        <p>Git удалит эти файлы, если вы не удалили их сами.</p>

        <p>Переименование файла — это то же, что удаление старого
        имени и добавления нового. Для этого есть <span class=
        "strong"><strong>git mv</strong></span>, которая имеет тот
        же синтаксис, что и команда <span class=
        "strong"><strong>mv</strong></span>. Например:</p>
        <pre class="literallayout">
$ git mv bug.c feature.c
</pre>
      </div>

      <div class="section" title="Расширенные отмена/возврат">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BE%D1%82%D0%BC%D0%B5%D0%BD%D0%B0_%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82">
              </a>Расширенные отмена/возврат</h2>
            </div>
          </div>
        </div>

        <p>Иногда просто хочется вернуться назад и забыть все
        изменения до определенного момента, потому что все они были
        неправильными. В таком случае</p>
        <pre class="literallayout">
$ git log
</pre>

        <p>покажет список последних коммитов и их хеши SHA1:</p>
        <pre class="screen">
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob &lt;bob@example.com&gt;
Date:   Tue Mar 14 01:59:26 2000 -0800

    Заменил printf() на write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice &lt;alice@example.com&gt;
Date:   Thu Jan 1 00:00:00 1970 +0000

    Начальный коммит.
</pre>

        <p>Для указания коммита достаточно первых нескольких
        символов его хеша, но можете скопировать и весь хеш.
        Наберите:</p>
        <pre class="literallayout">
$ git reset --hard 766f
</pre>

        <p>для восстановления состояния до указанного коммита и
        удаления всех последующих безвозвратно.</p>

        <p>Возможно, в другой раз вы захотите быстро перескочить к
        старому состоянию. В этом случае наберите</p>
        <pre class="literallayout">
$ git checkout 82f5
</pre>

        <p>Эта команда перенесет вас назад во времени, сохранив при
        этом более новые коммиты. Однако, как и в фантастических
        фильмах о путешествиях во времени, если теперь вы
        отредактируете и закоммитите код, то попадете в
        альтернативную реальность, потому что ваши действия
        отличаются от тех, что были в прошлый раз.</p>

        <p>Эта альтернативная реальность называется «веткой»
        (branch, прим. пер.), и <a class="link" href="#branch">чуть
        позже мы поговорим об этом подробнее</a>. А сейчас просто
        запомните, что команда</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>вернет вас обратно в настоящее. Кроме того, чтобы не
        получать предупреждений от Git, всегда делайте commit или
        сбрасывайте изменения перед запуском checkout.</p>

        <p>Еще раз воспользуемся аналогией с компьютерными
        играми:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><span class="strong"><strong>git
            reset --hard</strong></span>: загружает ранее
            сохраненную игру и удаляет все версии, сохраненные
            после только что загруженной.</li>

            <li class="listitem"><span class="strong"><strong>git
            checkout</strong></span>: загружает старую игру, но
            если вы продолжаете играть, состояние игры будет
            отличаться от более новых сохранений, которые вы
            сделали в первый раз. Любая игра, которую вы теперь
            сохраняете, попадает в отдельную ветку, представляющую
            альтенативную реальность, в которую вы попали.
            <a class="link" href="#branch">Мы обсудим это
            позже</a>.</li>
          </ul>
        </div>

        <p>Можно также восстановить только определенные файлы и
        подкаталоги, перечислив их имена после команды:</p>
        <pre class="literallayout">
$ git checkout 82f5 какой-то.файл другой.файл
</pre>

        <p>Будьте внимательны: такая форма <span class=
        "strong"><strong>checkout</strong></span> может молча
        перезаписать файлы. Чтобы избежать неприятных
        неожиданностей, выполняйте commit перед checkout, особенно
        если вы только изучаете Git. Вообще, если вы не уверены в
        какой-либо операции, будь то команда Git или нет, выполните
        предварительно <span class="strong"><strong>git commit
        -a</strong></span>.</p>

        <p>Не любите копировать и вставлять хеши? Используйте</p>
        <pre class="literallayout">
$ git checkout :/"Моя первая р"
</pre>

        <p>для перехода на коммит, чье описание начинается с
        приведенной строки.</p>

        <p>Можно также запросить 5-ое с конца сохраненное
        состояние:</p>
        <pre class="literallayout">
$ git checkout master~5
</pre>
      </div>

      <div class="section" title="Откаты">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BE%D1%82%D0%BA%D0%B0%D1%82%D1%8B"></a>Откаты</h2>
            </div>
          </div>
        </div>

        <p>В зале суда пункты протокола могут вычеркиваться прямо
        во время слушания. Подобным образом и вы можете выбирать
        коммиты для отмены.</p>
        <pre class="literallayout">
$ git commit -a
$ git revert 1b6d
</pre>

        <p>отменит коммит с заданным хешем. Откат будет сохранен в
        виде нового коммита. Можете запустить <span class=
        "strong"><strong>git log</strong></span>, чтобы убедиться в
        этом.</p>
      </div>

      <div class="section" title="Создание списка изменений">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
              </a>Создание списка изменений</h2>
            </div>
          </div>
        </div>

        <p>Некоторым проектам нужен <a class="ulink" href=
        "http://en.wikipedia.org/wiki/Changelog" target=
        "_top">список изменений</a> (changelog, прим. пер.).
        Создайте его такой командой:</p>
        <pre class="literallayout">
$ git log &gt; ChangeLog
</pre>
      </div>

      <div class="section" title="Скачивание файлов">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BA%D0%B0%D1%87%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2">
              </a>Скачивание файлов</h2>
            </div>
          </div>
        </div>

        <p>Получить копию проекта под управлением Git можно,
        набрав</p>
        <pre class="literallayout">
$ git clone git://сервер/путь/до/файлов
</pre>

        <p>Например, чтобы получить все файлы, которые я
        использовал для создания этого документа,</p>
        <pre class="literallayout">
$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>Позже мы поговорим о команде <span class=
        "strong"><strong>clone</strong></span> подробнее.</p>
      </div>

      <div class="section" title="Держа руку на пульсе">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B4%D0%B5%D1%80%D0%B6%D0%B0_%D1%80%D1%83%D0%BA%D1%83_%D0%BD%D0%B0_%D0%BF%D1%83%D0%BB%D1%8C%D1%81%D0%B5">
              </a>Держа руку на пульсе</h2>
            </div>
          </div>
        </div>

        <p>Если вы уже загрузили копию проекта с помощью
        <span class="strong"><strong>git clone</strong></span>,
        можете обновить ее до последней версии, используя</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Безотлагательная публикация">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B1%D0%B5%D0%B7%D0%BE%D1%82%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F">
              </a>Безотлагательная публикация</h2>
            </div>
          </div>
        </div>

        <p>Допустим, вы написали скрипт, которым хотите поделиться
        с другими. Можно просто предложить им скачивать его с
        вашего компьютера, но если они будут делать это когда вы
        дорабатываете его или добавляете экспериментальную
        функциональность, у них могут возникнуть проблемы.
        Очевидно, поэтому и существуют циклы разработки.
        Разработчики могут постоянно работать над проектом, но
        общедоступным они делают свой код только после того, как
        приведут его в приличный вид.</p>

        <p>Чтобы сделать это с помощью Git, выполните в каталоге,
        где лежит ваш скрипт,</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Первый релиз"
</pre>

        <p>Затем скажите вашим пользователям запустить</p>
        <pre class="literallayout">
$ git clone ваш.компьютер:/путь/до/скрипта
</pre>

        <p>чтобы загрузить ваш скрипт. Здесь подразумевается, что у
        них есть доступ по ssh. Если нет, запустите <span class=
        "strong"><strong>git daemon</strong></span> и скажите
        пользователям запустить эту команду вместо
        вышеприведенной:</p>
        <pre class="literallayout">
$ git clone git://ваш.компьютер/путь/до/скрипта
</pre>

        <p>С этих пор всякий раз, когда ваш скрипт готов к релизу,
        выполняйте</p>
        <pre class="literallayout">
$ git commit -a -m "Следующий релиз"
</pre>

        <p>и ваши пользователи смогут обновить свои версии, перейдя
        в каталог, с вашим скриптом и набрав</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Ваши пользователи никогда не наткнутся на версию
        скрипта, которую вы не хотите им показывать.</p>
      </div>

      <div class="section" title="Что я сделал?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%87%D1%82%D0%BE_%D1%8F_%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D0%BB">
              </a>Что я сделал?</h2>
            </div>
          </div>
        </div>

        <p>Выясните, какие изменения вы сделали со времени
        последнего коммита:</p>
        <pre class="literallayout">
$ git diff
</pre>

        <p>Или со вчерашнего дня:</p>
        <pre class="literallayout">
$ git diff "@{yesterday}"
</pre>

        <p>Или между определенной версией и версией, сделанной 2
        коммита назад:</p>
        <pre class="literallayout">
$ git diff 1b6d "master~2"
</pre>

        <p>В каждом случае на выходе будет патч, который может быть
        применен с помощью <span class="strong"><strong>git
        apply</strong></span>. Попробуйте также:</p>
        <pre class="literallayout">
$ git whatchanged --since="2 weeks ago"
</pre>

        <p>Часто вместо этого я использую для просмотра истории
        <a class="ulink" href=
        "http://sourceforge.net/projects/qgit" target=
        "_top">qgit</a>, из-за приятного интерфейса, или <a class=
        "ulink" href="http://jonas.nitro.dk/tig" target=
        "_top">tig</a> с текстовым интерфейсом, который хорошо
        работает через медленное соединение. Как вариант,
        установите веб-сервер, введите <span class=
        "strong"><strong>git instaweb</strong></span> и запустите
        любой веб-браузер.</p>
      </div>

      <div class="section" title="Упражнение">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%83%D0%BF%D1%80%D0%B0%D0%B6%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
              </a>Упражнение</h2>
            </div>
          </div>
        </div>

        <p>Пусть A, B, C, D — четыре последовательных коммита, где
        В отличается от A лишь несколькими удаленными файлами. Мы
        хотим вернуть эти файлы в D. Как мы можем это сделать?</p>

        <p>Существует как минимум три решения. Предположим, что мы
        находимся на D.</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">Разница между A и B — удаленные
              файлы. Мы можем создать патч, отражающий эти
              изменения, и применить его:</p>
              <pre class="literallayout">
$ git diff B A | git apply
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Поскольку в коммите A мы сохранили
              файлы, то можем восстановить их:</p>
              <pre class="literallayout">
$ git checkout A foo.c bar.h
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Мы можем рассматривать переход от
              A к B как изменения, которые хотим отменить:</p>
              <pre class="literallayout">
$ git revert B
</pre>
            </li>
          </ol>
        </div>

        <p>Какой способ лучше? Тот, который вам больше нравится. С
        помощью Git легко получить желаемое, и часто существует
        много способов это сделать.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 3. Все о клонировании">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%B2%D1%81%D0%B5_%D0%BE_%D0%BA%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8">
            </a>Глава 3. Все о клонировании</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2">
          Синхронизация компьютеров</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%BC_%D0%BA%D0%BE%D0%B4%D0%BE%D0%BC">
          Классическое управление исходным кодом</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B3%D0%BE%D0%BB%D1%8B%D0%B5_bare_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0">
          Голые (bare) хранилища</a></span></dt>

          <dt><span class="section"><a href=
          "#_push_%D0%B8%D0%BB%D0%B8_pull">Push или
          pull?</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%BE%D1%80%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0">
          Создание форка проекта</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B1%D1%8D%D0%BA%D0%B0%D0%BF%D1%8B">
          Максимальные бэкапы</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D1%81%D0%BE_%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%D1%8E_%D1%81%D0%B2%D0%B5%D1%82%D0%B0">
          Многозадачность со скоростью света</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D0%B0%D1%80%D1%82%D0%B8%D0%B7%D0%B0%D0%BD%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
          Партизанское управление версиями</a></span></dt>

          <dt><span class="section"><a href=
          "#_mercurial">Mercurial</a></span></dt>

          <dt><span class="section"><a href=
          "#_bazaar">Bazaar</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83_%D1%8F_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E_git">
          Почему я использую Git</a></span></dt>
        </dl>
      </div>

      <p>В старых системах управления версиями стандартная операция
      для получения файлов — это checkout. Вы получаете набор
      файлов в конкретном сохраненном состоянии.</p>

      <p>В Git и других распределенных системах управления версиями
      стандартный способ — клонирование. Для получение файлов вы
      создаете «клон» всего хранилища. Другими словами, вы
      фактически создаете зеркало центрального сервера. При этом
      всё, что можно делать с основным хранилищем, можно делать и с
      локальным.</p>

      <div class="section" title="Синхронизация компьютеров">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2">
              </a>Синхронизация компьютеров</h2>
            </div>
          </div>
        </div>

        <p>Я вполне приемлю создание архивов или использование
        <span class="strong"><strong>rsync</strong></span> для
        резервного копирования и простейшей синхронизации. Но я
        работаю то на ноутбуке, то на стационарном компьютере,
        которые могут никак между собой не взаимодействовать между
        этим.</p>

        <p>Создайте хранилище Git и закоммитьте файлы на одном
        компьютере. А потом выполните на другом</p>
        <pre class="literallayout">
$ git clone первый.компьютер:/путь/к/файлам
</pre>

        <p>для создания второго экземпляра файлов и хранилища Git.
        С этого момента команды</p>
        <pre class="literallayout">
$ git commit -a
$ git pull другой.компьютер:/путь/к/файлам HEAD
</pre>

        <p>будут «втягивать» состояние файлов с другого компьютера
        на тот, где вы работаете. Если вы недавно внесли
        конфликтующие изменения в один и тот же файл, Git даст вам
        знать, и нужно будет сделать коммит заново после разрешения
        ситуации.</p>
      </div>

      <div class="section" title=
      "Классическое управление исходным кодом">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%BC_%D0%BA%D0%BE%D0%B4%D0%BE%D0%BC">
              </a>Классическое управление исходным кодом</h2>
            </div>
          </div>
        </div>

        <p>Создайте хранилище Git для ваших файлов:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Начальный коммит"
</pre>

        <p>На центральном сервере создайте так называемое «голое»
        (bare) хранилище Git в неком каталоге:</p>
        <pre class="literallayout">
$ mkdir proj.git
$ cd proj.git
$ git init --bare
$  # вариант «в одну строчку»: GIT_DIR=proj.git git init
</pre>

        <p>Запустите Git-демон, если необходимо:</p>
        <pre class="literallayout">
$ git daemon --detach # возможно уже запущен
</pre>

        <p>Для создания нового пустого хранилища Git на публичных
        серверах следуйте их инструкциям. Обычно, нужно заполнить
        форму на веб-странице.</p>

        <p>Отправьте ваши изменения в центральное хранилище вот
        так:</p>
        <pre class="literallayout">
$ git push git://центральный.сервер/путь/к/proj.git HEAD
</pre>

        <p>Для получения ваших исходников разработчик вводит</p>
        <pre class="literallayout">
$ git clone git://центральный.сервер/путь/к/proj.git
</pre>

        <p>После внесения изменений разработчик сохраняет изменения
        локально:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Для обновления до последней версии:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Любые конфликты слияния нужно разрешить и
        закоммитить:</p>
        <pre class="literallayout">
$ git commit -a
</pre>

        <p>Для выгрузки локальных изменений в центральное
        хранилище:</p>
        <pre class="literallayout">
$ git push
</pre>

        <p>Если на главном сервере были новые изменения, сделанные
        другими разработчиками, команда push не сработает. В этом
        случае разработчику нужно будет вытянуть к себе (pull)
        последнюю версию, разрешить возможные конфликты слияний и
        попробовать еще раз.</p>
      </div>

      <div class="section" title="Голые (bare) хранилища">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B3%D0%BE%D0%BB%D1%8B%D0%B5_bare_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0">
              </a>Голые (bare) хранилища</h2>
            </div>
          </div>
        </div>

        <p>Голое (bare) хранилище называются так потому, что у него
        нет рабочего каталога. Оно содержит только файлы, которые
        обычно скрыты в подкаталоге .git. Другими словами, голое
        хранилище содержит историю изменений, но не содержит снимка
        какой-либо определенной версии.</p>

        <p>Голое хранилище играет роль, похожую на роль основного
        сервера в централизованной системе управления версиями: это
        дом вашего проекта. Разработчики клонируют из него проект и
        закачивают в него свежие официальные изменения. Как
        правило, оно располагается на сервере, который не делает
        почти ничего кроме раздачи данных. Разработка идет в
        клонах, поэтому домашнее хранилище может обойтись и без
        рабочего каталога.</p>

        <p>Многие команды Git не работают в голых хранилищах, если
        переменная среды GIT_DIR не содержит путь до хранилища и не
        указан параметр --bare.</p>
      </div>

      <div class="section" title="Push или pull?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_push_%D0%B8%D0%BB%D0%B8_pull"></a>Push или
              pull?</h2>
            </div>
          </div>
        </div>

        <p>Зачем вводится команда push, вместо использования уже
        знакомой pull? Прежде всего, pull не работает в голых
        хранилищах, вместо нее нужно использовать команду fetch,
        которая будет рассмотрена позже. Но даже если держать на
        центральном сервере нормальное хранилище, использование
        команды pull в нем будет затруднительным. Нужно будет
        сначала войти на сервер интерактивно и сообщить команде
        pull адрес машины, с которой мы хотим забрать изменения.
        Этому могут мешать сетевые брандмауэры (firewall), но в
        первую очередь: что если у нас нет интерактивного доступа к
        серверу?</p>

        <p>Тем не менее, не рекомендутся push-ить в хранилище
        помимо этого случая — из-за путаницы, которая может
        возникнуть, если у целевого хранилища есть рабочий
        каталог.</p>

        <p>Короче говоря, пока изучаете Git, push-те только в голые
        хранилища. В остальных случаях pull-те.</p>
      </div>

      <div class="section" title="Создание форка проекта">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%BE%D1%80%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0">
              </a>Создание форка проекта</h2>
            </div>
          </div>
        </div>

        <p>Не нравится путь развития проекта? Думаете, можете
        сделать лучше? Тогда на вашем сервере выполните</p>
        <pre class="literallayout">
$ git clone git://основной.сервер/путь/к/файлам
</pre>

        <p>Теперь расскажите всем о форке (ответвлении, прим. пер.)
        проекта на вашем сервере.</p>

        <p>Позже вы сможете в любой момент втянуть к себе изменения
        из первоначального проекта:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Максимальные бэкапы">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B1%D1%8D%D0%BA%D0%B0%D0%BF%D1%8B">
              </a>Максимальные бэкапы</h2>
            </div>
          </div>
        </div>

        <p>Хотите иметь множество защищенных, географически
        разнесенных запасных архивов? Если в вашем проекте много
        разработчиков, ничего делать не нужно! Каждый клон — это и
        есть резервная копия; не только текущего состояния, но и
        всей истории изменений проекта. Благодаря
        криптографическому хешированию, повреждение какого-либо из
        клонов будет обнаружено при первой же попытке
        взаимодействия с другими клонами.</p>

        <p>Если ваш проект не такой популярный, найдите как можно
        больше серверов для размещения клонов.</p>

        <p>Особо беспокоящимся рекомендуется всегда записывать
        самый последний 20-байтный SHA1 хеш HEAD в каком-нибудь
        безопасном месте. Оно должно быть безопасным, а не тайным.
        Например, хороший вариант — публикация в газете, потому что
        атакующему сложно изменить каждый экземпляр газеты.</p>
      </div>

      <div class="section" title=
      "Многозадачность со скоростью света">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D1%81%D0%BE_%D1%81%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%D1%8E_%D1%81%D0%B2%D0%B5%D1%82%D0%B0">
              </a>Многозадачность со скоростью света</h2>
            </div>
          </div>
        </div>

        <p>Скажем, вы хотите работать над несколькими функциями
        параллельно. Тогда закоммитьте ваши изменения и
        запустите</p>
        <pre class="literallayout">
$ git clone . /некий/новый/каталог
</pre>

        <p>Благодаря <a class="ulink" href=
        "http://ru.wikipedia.org/wiki/%D0%B6%D1%91%D1%81%D1%82%D0%BA%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0"
        target="_top">жёстким ссылкам</a> создание локального клона
        требует меньше времени и места, чем простое
        копирование.</p>

        <p>Теперь вы можете работать с двумя независимыми функциями
        одновременно. Например, можно редактировать один клон, пока
        другой компилируется. В любой момент можно сделать коммит и
        вытянуть изменения из другого клона:</p>
        <pre class="literallayout">
$ git pull /другой/клон HEAD
</pre>
      </div>

      <div class="section" title=
      "Партизанское управление версиями">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D0%B0%D1%80%D1%82%D0%B8%D0%B7%D0%B0%D0%BD%D1%81%D0%BA%D0%BE%D0%B5_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">
              </a>Партизанское управление версиями</h2>
            </div>
          </div>
        </div>

        <p>Вы работаете над проектом, который использует другую
        систему управления версиями, и вам очень не хватает Git?
        Тогда создайте хранилище Git в своем рабочем каталоге:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Начальный коммит"
</pre>

        <p>затем склонируйте его:</p>
        <pre class="literallayout">
$ git clone . /некий/новый/каталог
</pre>

        <p>Теперь перейдите в этот новый каталог и работайте в нем
        вместо основного, используя Git в свое удовольствие. В
        какой-то момент вам понадобиться синхронизировать изменения
        со всеми остальными — тогда перейдите в изначальный
        каталог, синхронизируйте его с помощью другой системы
        управления версиями и наберите</p>
        <pre class="literallayout">
$ git add .
$ git commit -m "Синхронизация с остальными"
</pre>

        <p>Теперь перейдите в новый каталог и запустите</p>
        <pre class="literallayout">
$ git commit -a -m "Описание моих изменений"
$ git pull
</pre>

        <p>Процедура передачи изменений остальным зависит от другой
        системы управления версиями. Новый каталог содержит файлы с
        вашими изменениями. Запустите команды другой системы
        управления версиями, необходимые для загрузки файлов в
        центральное хранилище.</p>

        <p>Subversion (вероятно, наилучшая централизованная система
        управления версиями) используется неисчислимым множеством
        проектов. Команда <span class="strong"><strong>git
        svn</strong></span> автоматизирует описанный процесс для
        хранилищ Subversion, а также может быть использована для
        <a class="ulink" href=
        "http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html"
        target="_top">экспорта проекта Git в хранилище
        Subversion</a>.</p>
      </div>

      <div class="section" title="Mercurial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mercurial"></a>Mercurial</h2>
            </div>
          </div>
        </div>

        <p>Mercurial — похожая система управления версиями, которая
        может работать в паре с Git практически без накладок. С
        расширением hg-git пользователь Mercurial может без каких
        либо потерь push-ить и pull-ить из хранилища Git.</p>

        <p>Получить hg-git можно с помощью Git:</p>
        <pre class="literallayout">
$ git clone git://github.com/schacon/hg-git.git
</pre>

        <p>или Mercurial:</p>
        <pre class="literallayout">
$ hg clone http://bitbucket.org/durin42/hg-git/
</pre>

        <p>К сожалению, мне неизвестен аналогичное расширение для
        Git. Поэтому я рекомендую использовать Git, а не Mercurial,
        для центрального хранилища, даже если вы предпочитаете
        Mercurial. Для проектов, использующих Mercurial, обычно
        какой-нибудь доброволец поддерживает параллельное хранилище
        Git для привлечения пользователей последнего, тогда как
        проекты, использующие Git, благодаря hg-git автоматически
        доступны пользователям Mercurial.</p>

        <p>Хотя расширение может сконвертировать хранилище
        Mercurial в Git путем push'а в пустое хранилище, эту задачу
        легче решить, используя сценарий hg-fast-export.sh,
        доступный как</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/fast-export.git
</pre>

        <p>Для преобразования выполните в пустом каталоге</p>
        <pre class="literallayout">
$ git init
$ hg-fast-export.sh -r /hg/repo
</pre>

        <p>после добавления сценария в ваш $PATH.</p>
      </div>

      <div class="section" title="Bazaar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bazaar"></a>Bazaar</h2>
            </div>
          </div>
        </div>

        <p>Упомянем вкратце Bazaar, так как это самая популярная
        свободная распределенная система управления версиями после
        Git и Mercurial.</p>

        <p>Bazaar относительно молод, поэтому у него есть
        преимущество идущего следом. Его проектировщики могут
        учиться на ошибках предшественников и избавиться от
        исторически сложившихся неровностей. Кроме того, его
        разработчики заботятся о переносимости и взаимодействии с
        другими системами управления версиями.</p>

        <p>Расширение bzr-git позволяет (в какой-то степени)
        пользователям Bazaar работать с хранилищами Git. Программа
        tailor конвертирует хранилища Bazaar в Git и может делать
        это с накоплением, тогда как bzr-fast-export хорошо
        приспособлена для разовых преобразований.</p>
      </div>

      <div class="section" title="Почему я использую Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83_%D1%8F_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E_git">
              </a>Почему я использую Git</h2>
            </div>
          </div>
        </div>

        <p>Изначально я выбрал Git потому, что слышал, что он в
        состоянии справиться с совершенно неуправляемыми исходными
        текстами ядра Linux. Я никогда не ощущал потребности
        сменить его на что-то другое. Git работает замечательно и
        мне еще только предстоит напороться на его недостатки. Так
        как я в основном использую Linux, проблемы на других
        системах меня не касаются.</p>

        <p>Я также предпочитаю программы на C и сценарии на bash
        исполняемым файлам вроде сценариев на Python-е: у них
        меньше зависимостей, и я привык к быстрому выполнению.</p>

        <p>Я думал о том, как можно улучшить Git, вплоть до того,
        чтобы написать собственный инструмент, похожий на Git; но
        только как академическое упражнение. Завершив проект, я бы
        все равно продолжил пользоваться Git, потому что выигрыш
        слишком мал, чтобы оправдать использование самодельной
        системы.</p>

        <p>Естественно, ваши потребности и пожелания вероятно
        отличаются от моих и вы, возможно, лучше уживетесь с другой
        системой. И всё же вы не слишком ошибетесь, используя
        Git.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 4. Чудеса ветвления">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D1%87%D1%83%D0%B4%D0%B5%D1%81%D0%B0_%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
            </a>Глава 4. Чудеса ветвления</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B0_%D0%B1%D0%BE%D1%81%D1%81%D0%B0">
          Кнопка босса</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B3%D1%80%D1%8F%D0%B7%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0">
          Грязная работа</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B5_%D0%B8%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
          Быстрые исправления</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F">Слияния</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D1%8B%D0%B9_%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81">
          Непрерывный рабочий процесс</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC_%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2_%D1%81%D0%BC%D0%B5%D1%81%D0%B8">
          Изменяем состав смеси</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8">
          Управление Ветками</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
          Временные Ветки</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B9%D1%82%D0%B5_%D0%BA%D0%B0%D0%BA_%D0%B2%D0%B0%D0%BC_%D0%BD%D1%80%D0%B0%D0%B2%D0%B8%D1%82%D1%81%D1%8F">
          Работайте как вам нравится</a></span></dt>
        </dl>
      </div>

      <p>Возможности мгновенного ветвления и слияния — самые
      замечательный особенности Git.</p>

      <p><span class="strong"><strong>Задача</strong></span>:
      внешние факторы неизбежно влекут переключение внимания.
      Серьезная ошибка в уже выпущенной версии обнаруживается без
      предупреждения. Срок сдачи конкретного функционала
      приближается. Разработчик, помощь которого нужна вам в работе
      над ключевой частью проекта, собирается в отпуск. Одним
      словом, вам нужно срочно бросить все, над чем вы трудитесь в
      настоящий момент, и переключиться на совершенно другие
      задачи.</p>

      <p>Прерывание хода ваших мыслей может серьезно снизить
      эффективность работы, и чем сложнее переключение между
      процессами, тем больше будет потеря. При централизованном
      управлении версиями мы вынуждены скачивать свежую рабочую
      копию с центрального сервера. Распределенная система лучше:
      мы можем клонировать нужную версию локально.</p>

      <p>Однако клонирование все же предполагает копирование всего
      рабочего каталога, как и всей истории изменений до настоящего
      момента. Хотя Git и снижает затратность этого действия за
      счет возможности совместного использования файлов и жестких
      ссылок, но все файлы проекта придется полностью воссоздать в
      новом рабочем каталоге.</p>

      <p><span class="strong"><strong>Решение</strong></span>: у
      Git есть более удобный инструмент для таких случаев, который
      сэкономит и время, и дисковое пространство по сравнению с
      клонированием — это <span class="strong"><strong>git
      branch</strong></span> (branch — ветка, прим. пер.).</p>

      <p>Этим волшебным словом файлы в вашем каталоге мгновенно
      преобразуются от одной версии к другой. Это изменение
      позволяет сделать намного больше, чем просто вернуться назад
      или продвинуться вперед в истории. Ваши файлы могут изменится
      с последней выпущенной версии на экспериментальную, с
      экспериментальной — на текущую версию в разработке, с нее —
      на версию вашего друга и так далее.</p>

      <div class="section" title="Кнопка босса">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B0_%D0%B1%D0%BE%D1%81%D1%81%D0%B0">
              </a>Кнопка босса</h2>
            </div>
          </div>
        </div>

        <p>Играли когда-нибудь в одну из таких игр, где при нажатии
        определеной клавиши («кнопки босса»), на экране мгновенно
        отображается таблица или что-то вроде того? То есть, если в
        офис зашел начальник, а вы играете в игру, вы можете быстро
        ее скрыть.</p>

        <p>В каком-нибудь каталоге:</p>
        <pre class="literallayout">
$ echo "Я хитрее моего босса" &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Начальный коммит"
</pre>

        <p>Мы создали хранилище Git, содержащее один текстовый файл
        с определенным сообщением. Теперь выполните</p>
        <pre class="literallayout">
$ git checkout -b boss # вероятно, это последнее изменение
$ echo "Мой босс умнее меня" &gt; myfile.txt
$ git commit -a -m "Другой коммит"
</pre>

        <p>Это выглядит так, будто мы только что перезаписали файл
        и сделали коммит. Но это иллюзия. Наберите</p>
        <pre class="literallayout">
$ git checkout master # переключиться на оригинальную версию файла
</pre>

        <p>Вуаля! Текстовый файл восстановлен. А если босс решить
        сунуть нос в этот каталог, запустите</p>
        <pre class="literallayout">
$ git checkout boss # перейти на версию, подходящую для глаз босса
</pre>

        <p>Вы можете переключаться между двумя версиями этого файла
        так часто, как вам хочется и делать коммиты каждой из них
        независимо.</p>
      </div>

      <div class="section" title="Грязная работа">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B3%D1%80%D1%8F%D0%B7%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0">
              </a>Грязная работа</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a>Допустим, вы работаете
        над некой функцией, и вам зачем-то понадобилось вернуться
        на три версии назад и временно добавить несколько
        операторов вывода, чтобы посмотреть как что-либо работает.
        Тогда введите</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout HEAD~3
</pre>

        <p>Теперь вы можете добавлять временный черновой код в
        любых местах. Можно даже закоммитить эти изменения. Когда
        закончите, выполните</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>чтобы вернуться к исходной работе. Заметьте, что любые
        изменения, не внесенные в коммит, будут перенесены.</p>

        <p>А что, если вы все-таки хотели сохранить временные
        изменения? Запросто:</p>
        <pre class="literallayout">
$ git checkout -b dirty
</pre>

        <p>а затем сделайте коммит перед возвращением в ветку
        master. Всякий раз, когда вы захотите вернуться к черновым
        изменениям, просто выполните</p>
        <pre class="literallayout">
$ git checkout dirty
</pre>

        <p>Мы говорили об этой команде в одной из предыдущих глав,
        когда обсуждали загрузку старых состояний. Теперь у нас
        перед глазами полная картина: файлы изменились к нужному
        состоянию, но мы должны покинуть главную ветку. Любые
        коммиты, сделанные с этого момента, направят файлы по
        другому пути, к которому можно будет вернуться позже.</p>

        <p>Другими словами, после переключения на более старое
        состояние Git автоматически направляет вас по новой
        безымянной ветке, которой можно дать имя и сохранить ее с
        помощью <span class="strong"><strong>git checkout
        -b</strong></span>.</p>
      </div>

      <div class="section" title="Быстрые исправления">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B1%D1%8B%D1%81%D1%82%D1%80%D1%8B%D0%B5_%D0%B8%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">
              </a>Быстрые исправления</h2>
            </div>
          </div>
        </div>

        <p>Ваша работа в самом разгаре, когда вдруг выясняется, что
        нужно все бросить и исправить только что обнаруженную
        ошибку в коммите «1b6d…»:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout -b fixes 1b6d
</pre>

        <p>После исправления ошибки сделайте</p>
        <pre class="literallayout">
$ git commit -a -m "Ошибка исправлена"
$ git checkout master
</pre>

        <p>и вернитесь к работе над вашими исходными задачами.</p>

        <p>Вы можете даже «влить» только что сделанное исправление
        ошибки в основную ветку:</p>
        <pre class="literallayout">
$ git merge fixes
</pre>
      </div>

      <div class="section" title="Слияния">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F"></a>Слияния</h2>
            </div>
          </div>
        </div>

        <p>В некоторых системах управления версиями создавать ветки
        легко, а вот сливать их воедино трудно. В Git слияние столь
        тривиально, что вы можете его не заметить.</p>

        <p>На самом деле мы сталкивались со слияниями уже давно.
        Команда <span class="strong"><strong>pull</strong></span>
        по сути получает коммиты, а затем сливает их с вашей
        текущей веткой. Если у вас нет локальных изменений, слияние
        произойдет само собой, как вырожденный случай вроде
        получения последней версии в централизованной системе
        управления версиями. Если же у вас есть локальные
        изменения, Git автоматически произведет слияние и сообщит о
        любых конфликтах.</p>

        <p>Обычно у коммита есть один «родитель», а именно
        предыдущий коммит. Слияние веток приводит к коммиту как
        минимум с двумя родителями. Отсюда возникает вопрос: к
        какому коммиту на самом деле отсылает HEAD~10? Коммит может
        иметь несколько родителей, так за которым из них следовать
        далее?</p>

        <p>Оказывается, такая запись всегда выбирает первого
        родителя. Это хороший выбор, потому что текущая ветка
        становятся первым родителем во время слияния. Часто вас
        интересуют только изменения, сделанные вами в текущей
        ветке, а не те, которые влились из других веток.</p>

        <p>Вы можете обращаться к конкретному родителю с помощью
        символа «^». Например, чтобы показать запись в журнале от
        второго родителя, наберите</p>
        <pre class="literallayout">
$ git log HEAD^2
</pre>

        <p>Для первого родителя номер можно опустить. Например,
        чтобы показать разницу с первым родителем, введите</p>
        <pre class="literallayout">
$ git diff HEAD^
</pre>

        <p>Вы можете сочетать такую запись с другими. Например,</p>
        <pre class="literallayout">
$ git checkout 1b6d^^2~10 -b ancient
</pre>

        <p>создаст новую ветку «ancient» («древняя», прим. пер.),
        отражающую состояние на десять коммитов назад от второго
        родителя первого родителя коммита, начинающегося с
        1b6d.</p>
      </div>

      <div class="section" title="Непрерывный рабочий процесс">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%BD%D1%8B%D0%B9_%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81">
              </a>Непрерывный рабочий процесс</h2>
            </div>
          </div>
        </div>

        <p>В производстве техники часто бывает, что второй шаг
        плана должен ждать завершения первого шага. Автомобиль,
        нуждающийся в ремонте, может тихо стоять в гараже до
        прибытия с завода конкретной детали. Прототип может ждать
        производства чипа, прежде чем разработка будет
        продолжена.</p>

        <p>И в разработке ПО может быть то же. Вторая часть нового
        функционала может быть вынуждена ожидать выпуска и
        тестирования первой части. Некоторые проекты требуют
        проверки вашего кода перед его принятием, так что вы должны
        дождаться утверждения первой части, прежде чем начинать
        вторую.</p>

        <p>Благодаря безболезненным ветвлению и слиянию, мы можем
        изменить правила и работать над второй частью до того, как
        первая официально будет готова. Допустим, вы закоммитили
        первую часть и выслали ее на проверку. Скажем, вы в ветке
        master. Теперь смените ветку:</p>
        <pre class="literallayout">
$ git checkout -b part2 # часть2
</pre>

        <p>Затем работайте над второй частью, попутно внося коммиты
        ваших изменений. Человеку свойственно ошибаться, и часто вы
        хотите вернуться и поправить что-то в первой части. Если вы
        везучи или очень искусны, можете пропустить эти строки.</p>
        <pre class="literallayout">
$ git checkout master  # Возвращаемся к первой части.
$ вносим_исправления
$ git commit -a        # Фиксируем изменения
$ git checkout part2   # Возвращаемся ко второй части.
$ git merge master     # Вливаем сделанные исправления.
</pre>

        <p>В конечном счете, первая часть утверждена:</p>
        <pre class="literallayout">
$ git checkout master  # Возвращаемся к первой части.
$ отправка файлов        # Выпускаем в мир!
$ git merge part2      # Вливаем вторую часть.
$ git branch -d part2  # Удаляем ветку part2.
</pre>

        <p>Теперь вы снова в ветке master, а вторая часть — в вашем
        рабочем каталоге.</p>

        <p>Этот прием легко расширить на любое количество частей.
        Столь же легко сменить ветку задним числом. Предположим, вы
        слишком поздно обнаружили, что должны были создать ветку
        семь коммитов назад. Тогда введите:</p>
        <pre class="literallayout">
$ git branch -m master part2 # Переименовываем ветку master в part2.
$ git branch master HEAD~7   # Создаем новую ветку master семью коммитами выше.
</pre>

        <p>Теперь ветка master содержит только первую часть, а
        ветка part2 — всё остальное. В последней мы и находимся. Мы
        создали ветку master, не переключаясь на нее, потому что
        хотим продолжить работу над part2. Это непривычно: до сих
        пор мы переключались на ветки сразу же после их создания,
        вот так:</p>
        <pre class="literallayout">
$ git checkout HEAD~7 -b master  # Создаем ветку и переключаемся на нее.
</pre>
      </div>

      <div class="section" title="Изменяем состав смеси">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC_%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2_%D1%81%D0%BC%D0%B5%D1%81%D0%B8">
              </a>Изменяем состав смеси</h2>
            </div>
          </div>
        </div>

        <p>Предположим, вам нравится работать над всеми аспектами
        проекта в одной и той же ветке. Вы хотите закрыть свой
        рабочий процесс от других, чтобы все видели ваши коммиты
        только после того, как они будут хорошо оформлены. Создайте
        пару веток:</p>
        <pre class="literallayout">
$ git branch sanitized    # Создаем ветку для очищенных коммитов.
$ git checkout -b medley  # Создаем ветку для работы и переключаемся на нее.
</pre>

        <p>Далее делайте всё что нужно: исправляйте ошибки,
        добавляйте новые функции, добавляйте временный код и так
        далее, при этом почаще выполняя коммиты. После этого</p>
        <pre class="literallayout">
$ git checkout sanitized
$ git cherry-pick medley^^
</pre>

        <p>применит коммит «пра-родителя» головы ветки «medley» к
        ветке «sanitized». Правильно подбирая элементы, вы сможете
        создать ветку, в которой будет лишь окончательный код, а
        связанные между собой коммиты будут собраны вместе.</p>
      </div>

      <div class="section" title="Управление Ветками">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8">
              </a>Управление Ветками</h2>
            </div>
          </div>
        </div>

        <p>Для просмотра списка всех веток наберите</p>
        <pre class="literallayout">
$ git branch
</pre>

        <p>По умолчанию вы начинаете с ветки под названием
        «master». Кому-то нравится оставлять ветку «master»
        нетронутой и создавать новые ветки со своими
        изменениями.</p>

        <p>Опции <span class="strong"><strong>-d</strong></span> и
        <span class="strong"><strong>-m</strong></span> позволяют
        удалять и перемещать (переименовывать) ветки. Смотрите
        <span class="strong"><strong>git help
        branch</strong></span>.</p>

        <p>Ветка «master» — это удобная традиция. Другие могут
        предполагать, что в вашем хранилище есть ветка с таким
        именем и что она содержит официальную версию проекта. Хотя
        вы можете переименовать или уничтожить ветку «master»,
        лучше соблюсти общее соглашение.</p>
      </div>

      <div class="section" title="Временные Ветки">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
              </a>Временные Ветки</h2>
            </div>
          </div>
        </div>

        <p>Через какое-то время вы можете обнаружить, что создаете
        множество временных веток для одной и той же краткосрочной
        цели: каждая такая ветка всего лишь сохраняет текущее
        состояние, чтобы вы могли вернуться назад и исправить
        серьезную ошибку или сделать что-то еще.</p>

        <p>Это похоже на то, как вы переключаете телевизионные
        каналы, чтобы посмотреть что показывают по другим. Но
        вместо того, чтобы нажать на пару кнопок, вам нужно
        создавать, выбирать (checkout), сливать (merge) а затем
        удалять временные ветки. К счастью, в Git есть сокращенная
        команда, столь же удобная, как пульт дистанционного
        управления.</p>
        <pre class="literallayout">
$ git stash
</pre>

        <p>Эта команда сохранит текущее состояние в во временном
        месте («тайнике», stash) и востановит предыдущее состояние.
        Ваш каталог становиться точно таким, каким был до начала
        редактирования, и вы можете исправить ошибки, загрузить
        удаленные изменения и тому подобное. Когда вы хотите
        вернуться назад в состояние «тайника», наберите:</p>
        <pre class="literallayout">
$ git stash apply # Возможно, понадобится устранить возникшие конфликты.
</pre>

        <p>Можно создавать несколько тайников, используя их
        по-разному. Смотрите <span class="strong"><strong>git help
        stash</strong></span>. Как вы могли догадаться, Git
        оставляет ветки «за кадром» при выполнении этого чудесного
        приема.</p>
      </div>

      <div class="section" title="Работайте как вам нравится">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B9%D1%82%D0%B5_%D0%BA%D0%B0%D0%BA_%D0%B2%D0%B0%D0%BC_%D0%BD%D1%80%D0%B0%D0%B2%D0%B8%D1%82%D1%81%D1%8F">
              </a>Работайте как вам нравится</h2>
            </div>
          </div>
        </div>

        <p>Возможно, вы сомневаетесь, стоят ли ветки таких хлопот.
        В конце концов, клоны почти столь же быстрые и вы можете
        переключаться между ними с помощью <span class=
        "strong"><strong>cd</strong></span> вместо загадочных
        команд Git.</p>

        <p>Посмотрим на веб-браузеры. Зачем нужна поддержка вкладок
        вдобавок к окнам? Поддержка и тех, и других позволяет
        приспособиться к широкому разнообразию стилей работы.
        Некоторым пользователям нравится держать открытым
        единственное окно и использовать вкладки для множества
        веб-страниц. Другие могут впасть в другую крайность:
        множество окон без вкладок вообще. Третьи предпочтут нечто
        среднее.</p>

        <p>Ветки похожи на вкладки для рабочего каталога, а клоны —
        на новые окна браузера. Эти операции быстры и выполняются
        локально, так почему бы не поэкспериментировать и не найти
        наиболее удобную для себя комбинацию? Git позволяет
        работать в точности так, как вам нравится.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 5. Уроки истории">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D1%83%D1%80%D0%BE%D0%BA%D0%B8_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8">
            </a>Глава 5. Уроки истории</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B0%D1%8F%D1%81%D1%8C_%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%BC">
          Оставаясь корректным</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8_%D0%BA%D0%BE%D0%B5_%D1%87%D1%82%D0%BE_%D0%B5%D1%89%D0%B5">
          …И кое-что еще</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%8E%D1%82%D1%81%D1%8F">
          Локальные изменения сохраняются</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
          Переписывая историю</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
          Создавая Историю</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0_%D0%B6%D0%B5_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
          Когда же все пошло не так?</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%B7_%D0%B7%D0%B0_%D0%BA%D0%BE%D0%B3%D0%BE_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
          Из-за кого все пошло не так?</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D1%8B%D1%82">
          Личный опыт</a></span></dt>
        </dl>
      </div>

      <p>Вследствие распределенной природы Git, историю изменений
      можно легко редактировать. Однако, если вы вмешиваетесь в
      прошлое, будьте осторожны: изменяйте только ту часть истории,
      которой владеете вы и только вы. Иначе, как народы вечно
      выясняют, кто же именно совершил и какие бесчинства, так и у
      вас будут проблемы с примирением при попытке совместить
      разные деревья истории.</p>

      <p>Некоторые разработчики убеждены, что история должна быть
      неизменна со всеми огрехами и прочим. Другие считают, что
      деревья нужно делать презентабельными перед выпуском их в
      публичный доступ. Git учитывает оба мнения. Переписывание
      истории, как и клонирование, ветвление и слияние, — лишь еще
      одна возможность, которую дает вам Git. Разумное ее
      использование зависит только от вас.</p>

      <div class="section" title="Оставаясь корректным">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B0%D1%8F%D1%81%D1%8C_%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%BC">
              </a>Оставаясь корректным</h2>
            </div>
          </div>
        </div>

        <p>Только что сделали коммит и поняли, что должны были
        ввести другое описание? Запустите</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>чтобы изменить последнее описание. Осознали, что забыли
        добавить файл? Запустите <span class="strong"><strong>git
        add</strong></span>, чтобы это сделать, затем выполните
        вышеуказанную команду.</p>

        <p>Захотелось добавить еще немного изменений в последний
        коммит? Так сделайте их и запустите</p>
        <pre class="literallayout">
$ git commit --amend -a
</pre>
      </div>

      <div class="section" title="…И кое-что еще">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8_%D0%BA%D0%BE%D0%B5_%D1%87%D1%82%D0%BE_%D0%B5%D1%89%D0%B5">
              </a>…И кое-что еще</h2>
            </div>
          </div>
        </div>

        <p>Давайте представим, что предыдущая проблема на самом
        деле в десять раз хуже. После длительной работы вы сделали
        ряд коммитов; но вы не очень-то довольны тем, как они
        организованы, и кое-какие описания коммитов надо бы слегка
        переформулировать. Тогда запустите</p>
        <pre class="literallayout">
$ git rebase -i HEAD~10
</pre>

        <p>и последние десять коммитов появятся в вашем любимом
        редакторе (задается переменной окружения $EDITOR).
        Например:</p>
        <pre class="literallayout">
pick 5c6eb73 Добавил ссылку repo.or.cz
pick a311a64 Переставил аналогии в «Работай как хочешь»
pick 100834f Добавил цель для push в Makefile
</pre>

        <p>Теперь вы можете:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">Убирать коммиты, удаляя
            строки.</li>

            <li class="listitem">Менять порядок коммитов,
            переставляя строки.</li>

            <li class="listitem">
              <p class="simpara">Заменять «pick» на:</p>

              <div class="itemizedlist">
                <ul class="itemizedlist" type="circle">
                  <li class="listitem">«edit» для внесения правок в
                  коммиты;</li>

                  <li class="listitem">«reword» для изменения
                  описания в журнале;</li>

                  <li class="listitem">«squash» для слияния коммита
                  с предыдущим;</li>

                  <li class="listitem">«fixup», чтобы слить коммит
                  с предыдущим, отбросив его описание.</li>
                </ul>
              </div>
            </li>
          </ul>
        </div>

        <p>Сохраните файл и закройте редактор. Если вы отметили
        коммит для исправлений, запустите</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>Если нет, запустите</p>
        <pre class="literallayout">
$ git rebase --continue
</pre>

        <p>Одним словом, делайте коммиты как можно раньше и как
        можно чаще — вы всегда сможете навести порядок при помощи
        rebase.</p>
      </div>

      <div class="section" title="Локальные изменения сохраняются">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%8E%D1%82%D1%81%D1%8F">
              </a>Локальные изменения сохраняются</h2>
            </div>
          </div>
        </div>

        <p>Предположим, вы работаете над активным проектом. За
        какое-то время вы делаете несколько коммитов, затем
        синхронизируетесь с официальным деревом через слияние. Цикл
        повторяется несколько раз, пока вы не будете готовы влить
        изменения в центральное дерево.</p>

        <p>Однако теперь история изменений в локальном клоне Git
        представляет собой кашу из ваших и официальных изменений.
        Вам бы хотелось видеть все свои изменения непрерывной
        линией, а затем — все официальные изменения.</p>

        <p>Это работа для команды <span class="strong"><strong>git
        rebase</strong></span>, описанной выше. Зачастую, имеет
        смысл использовать флаг <span class=
        "strong"><strong>--onto</strong></span> и убрать
        переплетения.</p>

        <p>Также смотрите <span class="strong"><strong>git help
        rebase</strong></span> для получения подробных примеров
        использования этой замечательной команды. Вы можете
        расщеплять коммиты. Вы можете даже переупорядочивать
        ветки.</p>
      </div>

      <div class="section" title="Переписывая историю">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
              </a>Переписывая историю</h2>
            </div>
          </div>
        </div>

        <p>Время от времени вам может понадобиться в системе
        управления версиями аналог «замазывания» людей на
        официальных фотографиях, как бы стирающего их из истории в
        духе сталинизма. Например, предположим, что мы уже
        собираемся выпустить релиз проекта, но он содержит файл,
        который не должен стать достоянием общественности по
        каким-то причинам. Возможно, я сохранил номер своей
        кредитки в текстовый файл и случайно добавил его в проект.
        Удалить файл недостаточно: он может быть доступен из старых
        коммитов. Нам надо удалить файл из всех ревизий:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'rm совершенно/секретный/файл' HEAD
</pre>

        <p>Смотрите <span class="strong"><strong>git help
        filter-branch</strong></span>, где обсуждается этот пример
        и предлагается более быстрый способ решения. Вообще,
        <span class="strong"><strong>filter-branch</strong></span>
        позволяет изменять существенные части истории при помощи
        одной-единственной команды.</p>

        <p>После этой команды каталог <code class=
        "literal">.git/refs/original</code> будет описывать
        состояние, которое было до ее вызова. Убедитесь, что
        команда filter-branch сделала то, что вы хотели, и если
        хотите опять использовать эту команду, удалите этот
        каталог.</p>

        <p>И, наконец, замените клоны вашего проекта исправленной
        версией, если собираетесь в дальнейшем с ними
        взаимодействовать.</p>
      </div>

      <div class="section" title="Создавая Историю">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%8F_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8E">
              </a>Создавая Историю</h2>
            </div>
          </div>
        </div>

        <p><a name="makinghistory" id="makinghistory"></a>Хотите
        перевести проект под управление Git? Если сейчас он
        находится под управлением какой-либо из хорошо известных
        систем управления версиями, то вполне вероятно, что
        кто-нибудь уже написал необходимые скрипты для экспорта
        всей истории проекта в Git.</p>

        <p>Если нет, то смотрите в сторону команды <span class=
        "strong"><strong>git fast-import</strong></span>, которая
        считывает текстовый ввод в специальном формате для создания
        истории Git с нуля. Обычно скрипт, использующий эту
        команду, бывает слеплен наспех для единичного запуска,
        переносящего весь проект за один раз.</p>

        <p>В качестве примера вставьте такие строки во временный
        файл, вроде <span class=
        "emphasis"><em>/tmp/history</em></span>:</p>
        <pre class="screen">
commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Начальный коммит.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT

commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Заменен printf() на write()
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Затем создайте хранилище Git из этого временного файла
        при помощи команд:</p>

        <p>$ mkdir project; cd project; git init $ git fast-import
        --date-format=rfc2822 &lt; /tmp/history</p>

        <p>Вы можете извлечь последнюю версию проекта с помощью</p>
        <pre class="literallayout">
$ git checkout master .
</pre>

        <p>Команда <span class="strong"><strong>git
        fast-export</strong></span> преобразует любое хранилище в
        формат, понятныый команде <span class="strong"><strong>git
        fast-import</strong></span>. Ее вывод можно использовать
        как образец для написания скриптов преобразования, или для
        переноса хранилищ в понятном человеку формате. Конечно, с
        помощью этих команд можно пересылать хранилища текстовых
        файлов через каналы передачи текста.</p>
      </div>

      <div class="section" title="Когда же все пошло не так?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0_%D0%B6%D0%B5_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
              </a>Когда же все пошло не так?</h2>
            </div>
          </div>
        </div>

        <p>Вы только что обнаружили, что кое-какой функционал вашей
        программы не работает, но вы совершенно отчетливо помните,
        что он работал всего несколько месяцев назад. Ох… Откуда же
        взялась ошибка? Вы же это проверяли сразу как
        разработали.</p>

        <p>В любом случае, уже слишком поздно. Однако, если вы
        фиксировали свои изменения достаточно часто, то Git сможет
        точно указать проблему:</p>
        <pre class="literallayout">
$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d
</pre>

        <p>Git извлечет состояние ровно посередине. Проверьте
        работает ли то, что сломалось, и если все еще нет,</p>
        <pre class="literallayout">
$ git bisect bad
</pre>

        <p>Если же работает, то замените «bad» на «good». Git снова
        переместит вас в состояние посередине между «хорошей» и
        «плохой» ревизиями, сужая круг поиска. После нескольких
        итераций, этот двоичный поиск приведет вас к тому коммиту,
        на котором возникла проблема. После окончания
        расследования, вернитесь в исходное состояние командой</p>
        <pre class="literallayout">
$ git bisect reset
</pre>

        <p>Вместо ручного тестирования каждого изменения
        автоматизируйте поиск, запустив</p>
        <pre class="literallayout">
$ git bisect run my_script
</pre>

        <p>По возвращаемому значению заданной команды, обычно
        одноразового скрипта, Git будет отличать хорошее состояние
        от плохого. Скрипт должен вернуть 0, если нынешний коммит
        хороший; 125, если его надо пропустить; и любое другое
        число от 1 до 127, если он плохой. Отрицательное
        возвращаемое значение прерывает команду bisect.</p>

        <p>Вы можете сделать многим больше: страница помощи
        поясняет, как визуализировать bisect, проанализировать или
        воспроизвести ее журнал, или исключить заведомо хорошие
        изменения для ускорения поиска.</p>
      </div>

      <div class="section" title="Из-за кого все пошло не так?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%B7_%D0%B7%D0%B0_%D0%BA%D0%BE%D0%B3%D0%BE_%D0%B2%D1%81%D0%B5_%D0%BF%D0%BE%D1%88%D0%BB%D0%BE_%D0%BD%D0%B5_%D1%82%D0%B0%D0%BA">
              </a>Из-за кого все пошло не так?</h2>
            </div>
          </div>
        </div>

        <p>Как и во многих других системах управления версиями, в
        Git есть команда blame (ответственность, прим. пер.):</p>
        <pre class="literallayout">
$ git blame bug.c
</pre>

        <p>Она снабжает каждую строку выбранного файла
        примечаниями, раскрывающими, кто и когда последним ее
        редактировал. В отличие же от многих других систем
        управления версиями, эта операция происходит без соединения
        с сетью, выбирая данные с локального диска.</p>
      </div>

      <div class="section" title="Личный опыт">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D1%8B%D1%82">
              </a>Личный опыт</h2>
            </div>
          </div>
        </div>

        <p>В централизованных системах управления версиями
        изменения истории — достаточно сложная операция, и доступна
        она лишь администраторам. Клонирование, ветвление и слияние
        невозможны без взаимодействия по сети. Так же обстоят дела
        и с базовыми операциями, такими как просмотр истории или
        фиксация изменений. В некоторых системах сетевое соединение
        требуется даже для просмотра собственных изменений, или
        открытия файла для редактирования.</p>

        <p>Централизованные системы исключают возможность работы
        без сети и требуют более дорогой сетевой инфраструктуры,
        особенно с увеличением количества разработчиков. Что
        важнее, все операции происходят медленнее, обычно до такой
        степени, что пользователи избегают пользоваться
        «продвинутыми» командами без крайней необходимости. В
        радикальных случаях это касается даже большинства базовых
        команд. Когда пользователи вынуждены запускать медленные
        команды, производительность страдает из-за прерываний
        рабочего процесса.</p>

        <p>Я испытал этот феномен на себе. Git был моей первой
        системой управления версиями. Я быстро привык к нему и стал
        относится к его возможностям как к должному. Я предполагал,
        что и другие системы похожи на него: выбор системы
        управления версиями не должен отличаться от выбора
        текстового редактора или браузера.</p>

        <p>Когда немного позже я был вынужден использовать
        централизованную систему управления версиями, я был
        шокирован. Ненадежное интернет-соединение не имеет большого
        значения при использовании Git, но делает разработку
        невыносимой, когда от него требуют надежности как у
        жесткого диска. Вдобавок я обнаружил, что стал избегать
        некоторых команд из-за задержек в их выполнении, что
        помешало мне следовать предпочтительному рабочему
        процессу.</p>

        <p>Когда мне было нужно запустить медленную команду,
        нарушение хода моих мыслей оказывало несоизмеримый ущерб
        разработке. Ожидая окончания связи с сервером, я вынужден
        был заниматься чем-то другим, чтобы скоротать время;
        например, проверкой почты или написанием документации. К
        тому времени, как я возвращался к первоначальной задаче,
        выполнение команды было давно закончено, но мне приходилось
        тратить уйму времени, чтоб вспомнить, что именно я делал.
        Люди не очень приспособлены для переключения между
        задачами.</p>

        <p>Кроме того, есть интересный эффект «трагедии
        общественных ресурсов»: предвидя будущую перегруженность
        сети, некоторые люди в попытке предотвратить грядущие
        задержки начинают использовать более широкие каналы, чем им
        реально требуется для текущих задач. Суммарная активность
        увеличивает загрузку сети, поощряя людей задействовать всё
        более высокоскоростные каналы для предотвращения еще
        больших задержек.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Глава 6. Многопользовательский Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B9_git">
            </a>Глава 6. Многопользовательский Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D0%BA%D1%82%D0%BE_%D1%8F">Кто я?</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_ssh_http">Git через
          SSH, HTTP</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%87%D1%82%D0%BE_%D1%83%D0%B3%D0%BE%D0%B4%D0%BD%D0%BE">
          Git через что угодно</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D0%B0%D1%82%D1%87%D0%B8_%D0%BE%D0%B1%D1%89%D0%B5%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
          Патчи: общее применение</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D1%80%D0%B8%D0%BD%D0%BE%D1%81%D0%B8%D0%BC_%D0%B8%D0%B7%D0%B2%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B_%D0%BF%D0%B5%D1%80%D0%B5%D0%B5%D1%85%D0%B0%D0%BB%D0%B8">
          Приносим извинения, мы переехали</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
          Удаленные ветки</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89">
          Несколько удаленных хранилищ</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BC%D0%BE%D0%B8_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8">
          Мои Настройки</a></span></dt>
        </dl>
      </div>

      <p>Сначала я использовал Git для личного проекта, в котором
      был единственным разработчиком. Среди команд, относящихся к
      распределенным свойствам Git, мне были нужны только
      <span class="strong"><strong>pull</strong></span> и
      <span class="strong"><strong>clone</strong></span>, чтобы
      хранить один и тот же проект в разных местах.</p>

      <p>Позднее я захотел опубликовать свой код при помощи Git и
      включать изменения помощников. Мне пришлось научиться
      управлять проектами, в которых участвуют многие люди по всему
      миру. К счастью, в этом сильная сторона Git и, возможно, сам
      смысл его существования.</p>

      <div class="section" title="Кто я?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D1%82%D0%BE_%D1%8F"></a>Кто я?</h2>
            </div>
          </div>
        </div>

        <p>Каждый коммит содержит имя автора и адрес электронной
        почты, которые выводятся командой <span class=
        "strong"><strong>git log</strong></span>. По умолчанию Git
        использует системные настройки для заполнения этих полей.
        Чтобы установить их явно, введите</p>
        <pre class="literallayout">
  $ git config --global user.name "John
Doe"
  $ git config --global user.email
johndoe@example.com
</pre>

        <p>Чтобы установить эти параметры только для текущего
        хранилища, опустите флаг --global.</p>
      </div>

      <div class="section" title="Git через SSH, HTTP">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_ssh_http"></a>Git
              через SSH, HTTP</h2>
            </div>
          </div>
        </div>

        <p>Предположим, у вас есть SSH доступ к веб-серверу, но Git
        не установлен. Git может связываться через HTTP, хотя это и
        менее эффективно, чем его собственный протокол.</p>

        <p>Скачайте, скомпилируйте, установите Git в вашем
        аккаунте; создайте хранилище в каталоге, доступном через
        web:</p>
        <pre class="literallayout">
 $ GIT_DIR=proj.git git init
 $ cd proj.git
 $ git --bare update-server-info
 $ cp hooks/post-update.sample
hooks/post-update
</pre>

        <p>Для старых версий Git команда копирования не сработает,
        и вы должны будете запустить</p>
        <pre class="literallayout">
$ chmod a+x hooks/post-update
</pre>

        <p>Теперь вы можете публиковать свои последние правки через
        SSH с любого клона:</p>
        <pre class="literallayout">
 $ git push
веб.сервер:/путь/к/proj.git master
</pre>

        <p>и кто угодно сможет взять ваш проект с помощью</p>
        <pre class="literallayout">
$ git clone http://веб.сервер/proj.git
</pre>
      </div>

      <div class="section" title="Git через что угодно">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%87%D1%82%D0%BE_%D1%83%D0%B3%D0%BE%D0%B4%D0%BD%D0%BE">
              </a>Git через что угодно</h2>
            </div>
          </div>
        </div>

        <p>Хотите синхронизировать хранилища без серверов или
        вообще без сетевого подключения? Вынуждены импровизировать
        на ходу в непредвиденной ситуации? Мы видели, как <a class=
        "link" href="#makinghistory"><span class=
        "strong"><strong>git fast-export</strong></span> и
        <span class="strong"><strong>git
        fast-import</strong></span> могут преобразовать хранилища в
        один файл и обратно</a>. Посредством обмена такими файлами
        мы можем переносить хранилища git любыми доступными
        средствами, но есть более эффективный инструмент:
        <span class="strong"><strong>git
        bundle</strong></span>.</p>

        <p>Отправитель создает пакет (bundle):</p>
        <pre class="literallayout">
$ git bundle create некий-файл HEAD
</pre>

        <p>Затем передает «пакет», <code class=
        "literal">некий-файл</code>, другой команде любыми
        средствами, как то: электронная почта, флешка, <span class=
        "strong"><strong>xxd</strong></span> печать и последующее
        распознавание текста, надиктовка битов по телефону, дымовые
        сигналы и так далее. Получатель восстанавливает коммиты из
        пакета, введя</p>
        <pre class="literallayout">
$ git pull некий-файл
</pre>

        <p>Получатель может сделать это даже в пустом хранилище.
        Несмотря на свой небольшой размер, <code class=
        "literal">некий-файл</code> содержит всё исходное хранилище
        Git.</p>

        <p>В больших проектах для устранения излишков объема
        пакетируют только изменения, которых нет в других
        хранилищах. К примеру, пусть коммит «1b6d…» — последний
        общий для обеих групп:</p>
        <pre class="literallayout">
$ git bundle create некий-файл HEAD ^1b6d
</pre>

        <p>Если это делается часто, можно легко забыть, какой
        коммит был отправлен последним. Справка предлагает для
        решения этой проблемы использовать теги. А именно, после
        передачи пакета введите</p>
        <pre class="literallayout">
$ git tag -f последний-пакет HEAD
</pre>

        <p>и создавайте обновленные пакеты с помощью</p>
        <pre class="literallayout">
$ git bundle create новый-пакет HEAD ^последний-пакет
</pre>
      </div>

      <div class="section" title="Патчи: общее применение">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D0%B0%D1%82%D1%87%D0%B8_%D0%BE%D0%B1%D1%89%D0%B5%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">
              </a>Патчи: общее применение</h2>
            </div>
          </div>
        </div>

        <p>Патчи это тексты изменений, вполне понятные как
        человеку, так и компьютеру. Это делает их очень
        привлекательным форматом обмена. Патч можно послать
        разработчикам по электронной почте, независимо от того,
        какую систему управления версиями они используют. Вашим
        корреспондентам достаточно возможности читать электронную
        почту, чтобы увидеть ваши изменения. Точно так же, с Вашей
        стороны требуется лишь адрес электронной почты: нет нужды в
        настройке онлайн хранилища Git.</p>

        <p>Вспомним из первой главы:</p>
        <pre class="literallayout">
$ git diff 1b6d
</pre>

        <p>выводит патч, который может быть вставлен в письмо для
        обсуждения. В Git хранилище введите</p>
        <pre class="literallayout">
$ git apply &lt; мой.patch
</pre>

        <p>для применения патча.</p>

        <p>В более формальных случаях , когда нужно сохранить имя
        автора и подписи, создавайте соответствующие патчи с
        заданной точки, набрав</p>
        <pre class="literallayout">
$ git format-patch 1b6d
</pre>

        <p>Полученные файлы могут быть отправлены с помощью
        <span class="strong"><strong>git-send-email</strong></span>
        или вручную. Вы также можете указать диапазон коммитов:</p>
        <pre class="literallayout">
$ git format-patch 1b6d..HEAD^^
</pre>

        <p>На принимающей стороне сохраните письмо в файл и
        введите:</p>
        <pre class="literallayout">
$ git am &lt; email.txt
</pre>

        <p>Это применит входящие исправления и создаст коммит,
        включающий имя автора и другую информацию.</p>

        <p>С web-интерфейсом к электронной почте вам, возможно,
        потребуется нажать кнопку, чтобы посмотреть электронную
        почту в своем первоначальном виде перед сохранением патча в
        файл.</p>

        <p>Для клиентов электронной почты, использующих mbox, есть
        небольшие отличия; но если вы используете один из них, то
        вы, по всей видимости, можете легко разобраться в этом без
        чтения описаний!</p>
      </div>

      <div class="section" title=
      "Приносим извинения, мы переехали">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D1%80%D0%B8%D0%BD%D0%BE%D1%81%D0%B8%D0%BC_%D0%B8%D0%B7%D0%B2%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D1%8B_%D0%BF%D0%B5%D1%80%D0%B5%D0%B5%D1%85%D0%B0%D0%BB%D0%B8">
              </a>Приносим извинения, мы переехали</h2>
            </div>
          </div>
        </div>

        <p>После клонирования хранилища команды <span class=
        "strong"><strong>git push</strong></span> или <span class=
        "strong"><strong>git pull</strong></span> автоматически
        отправляют и получают его по первоначальному адресу. Каким
        образом Git это делает? Секрет кроется в настройках,
        заданных при создании клона. Давайте взглянем:</p>
        <pre class="literallayout">
$ git config --list
</pre>

        <p>Опция <code class="literal">remote.origin.url</code>
        задает исходный адрес; origin — имя первоначального
        хранилища. Как и имя ветки master, это соглашение. Мы можем
        изменить или удалить это сокращённое имя, но как правило,
        нет причин для этого.</p>

        <p>Если оригинальное хранилище переехало, можно обновить
        его адрес командой</p>
        <pre class="literallayout">
$ git config remote.origin.url git://новый.url/proj.git
</pre>

        <p>Опция <code class="literal">branch.master.merge</code>
        задает удаленную ветку по умолчанию для <span class=
        "strong"><strong>git pull</strong></span>. В ходе
        первоначального клонирования она устанавливается на текущую
        ветку исходного хранилища, так что даже если HEAD исходного
        хранилища впоследствии переместится на другую ветку, pull
        будет верно следовать изначальной ветке.</p>

        <p>Этот параметр обращается только к хранилищу, которое мы
        изначально клонировали и которое записано в параметре
        <code class="literal">branch.master.remote</code>. При
        выполнении pull из других хранилищ мы должны указать нужную
        ветку:</p>
        <pre class="literallayout">
$ git pull git://пример.com/other.git master
</pre>

        <p>Это объясняет, почему некоторых из наших предыдущих
        примеров push и pull не имели аргументов.</p>
      </div>

      <div class="section" title="Удаленные ветки">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B2%D0%B5%D1%82%D0%BA%D0%B8">
              </a>Удаленные ветки</h2>
            </div>
          </div>
        </div>

        <p>При клонировании хранилища вы также клонируете все его
        ветки. Вы можете не заметить этого, потому что Git скрывает
        их: вы должны запросить их явно. Это предотвращает
        противоречие между ветками в удаленном хранилище и вашими
        ветками, а также делает Git проще для начинающих.</p>

        <p>Список удаленных веток можно посмотреть командой</p>
        <pre class="literallayout">
$ git branch -r
</pre>

        <p>Вы должны увидеть что-то вроде</p>
        <pre class="literallayout">
origin/HEAD
origin/master
origin/experimental
</pre>

        <p>Эти имена отвечают веткам и «голове» в удаленном
        хранилище; их можно использовать в обычных командах Git.
        Например, вы сделали много коммитов, и хотели бы сравнить
        текущее состояние с последней загруженной версией. Вы
        можете искать в журналах нужный SHA1 хеш, но гораздо легче
        набрать</p>
        <pre class="literallayout">
$ git diff origin/HEAD
</pre>

        <p>Также можно увидеть, для чего была создана ветка
        experimental:</p>
        <pre class="literallayout">
$ git log origin/experimental
</pre>
      </div>

      <div class="section" title="Несколько удаленных хранилищ">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89">
              </a>Несколько удаленных хранилищ</h2>
            </div>
          </div>
        </div>

        <p>Предположим, что над нашим проектом работают еще два
        разработчика, и мы хотим следить за обоими. Мы можем
        наблюдать более чем за одним хранилищем одновременно, вот
        так:</p>
        <pre class="literallayout">
$ git remote add other git://пример.com/некое_хранилище.git
$ git pull other некая_ветка
</pre>

        <p>Сейчас мы сделали слияние с веткой из второго хранилища.
        Теперь у нас есть легкий доступ ко всем веткам во всех
        хранилищах:</p>
        <pre class="literallayout">
 $ git diff origin/experimental^
other/некая_ветка~5
</pre>

        <p>Но что если мы просто хотим сравнить их изменения, не
        затрагивая свою работу? Иными словами, мы хотим изучить
        чужие ветки, не давая их изменениям вторгаться в наш
        рабочий каталог. Тогда вместо pull наберите</p>
        <pre class="literallayout">
 $ git fetch # Перенести из origin, по
умолчанию.
 $ git fetch other # Перенести от
второго программиста.
</pre>

        <p>Так мы лишь переносим их историю. Хотя рабочий каталог
        остается нетронутыми, мы можем обратиться к любой ветке в
        любом хранилище команды, работающей с Git, так как теперь у
        нас есть локальная копия.</p>

        <p>Держим в уме, что pull это просто <span class=
        "strong"><strong>fetch</strong></span>, а затем
        <span class="strong"><strong>merge</strong></span>. Обычно
        мы используем <span class=
        "strong"><strong>pull</strong></span>, потому что мы хотим
        влить к себе последний коммит после получения чужой ветки.
        Описанная ситуация — примечательное исключение.</p>

        <p>О том, как отключить удаленные хранилища, игнорировать
        отдельные ветки и многом другом смотрите в <span class=
        "strong"><strong>git help remote</strong></span>.</p>
      </div>

      <div class="section" title="Мои Настройки">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BC%D0%BE%D0%B8_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8">
              </a>Мои Настройки</h2>
            </div>
          </div>
        </div>

        <p>Я предпочитаю, чтобы люди, присоединяющиеся к моим
        проектам, создавали хранилища, из которых я смогу получать
        изменения с помощью pull. Некоторые хостинги Git позволяют
        создавать собственные форки проекта в одно касание.</p>

        <p>После получения дерева из удаленного хранилища я
        запускаю команды Git для навигации и изучения изменений, в
        идеале хорошо организованных и описанных. Я делаю слияние
        со своими изменения и возможно вношу дальнейшие правки.
        Когда я доволен результатом, я заливаю изменения в главное
        хранилище.</p>

        <p>Хотя со мной мало сотрудничают, я верю, что этот подход
        хорошо масштабируется. Смотрите <a class="ulink" href=
        "http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html"
        target="_top">эту запись в блоге Линуса Торвальдса</a>.</p>

        <p>Оставаться в мире Git несколько удобнее, чем
        использовать файлы патчей, так как это избавляет меня от
        преобразования их в коммиты Git. Кроме того, Git управляет
        деталями вроде сохранения имени автора и адреса электронной
        почты, а также даты и времени, и просит авторов описывать
        свои изменения.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 7. Гроссмейстерство Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%B3%D1%80%D0%BE%D1%81%D1%81%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B5%D1%80%D1%81%D1%82%D0%B2%D0%BE_git">
            </a>Глава 7. Гроссмейстерство Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D1%80%D0%B5%D0%BB%D0%B8%D0%B7%D1%8B_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2">
          Релизы исходников</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
          Коммит изменений</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BC%D0%BE%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC_%D0%B2%D0%B5%D0%BB%D0%B8%D0%BA">
          Мой коммит слишком велик</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B7%D0%BE%D0%BD%D0%B0_git">
          Индекс — буферная зона Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5_%D1%82%D0%B5%D1%80%D1%8F%D0%B9_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D1%8B">
          Не теряй «головы»</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BE%D1%85%D0%BE%D1%82%D0%B0_%D0%B7%D0%B0_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8">
          Охота за «головами»</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_%D0%BA%D0%B0%D0%BA_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B0">
          Git как основа</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%80%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%82%D1%80%D1%8E%D0%BA%D0%B8">
          Рискованные трюки</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%82%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC_%D0%BF%D0%BB%D0%BE%D1%85%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B">
          Предотвращаем плохие коммиты</a></span></dt>
        </dl>
      </div>

      <p>Теперь вы уже должны уметь ориентироваться в страницах
      <span class="strong"><strong>git help</strong></span> и
      понимать почти всё. Однако точный выбор команды, необходимой
      для решения конкретной проблемы, может быть утомительным.
      Возможно, я сберегу вам немного времени: ниже приведены
      рецепты, пригодившиеся мне в прошлом.</p>

      <div class="section" title="Релизы исходников">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B5%D0%BB%D0%B8%D0%B7%D1%8B_%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%BD%D0%B8%D0%BA%D0%BE%D0%B2">
              </a>Релизы исходников</h2>
            </div>
          </div>
        </div>

        <p>В моих проектах Git управляет в точности теми файлами,
        которые я собираюсь архивировать и пускать в релиз. Чтобы
        создать тарбол с исходниками, я выполняю:</p>
        <pre class="literallayout">
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" title="Коммит изменений">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9">
              </a>Коммит изменений</h2>
            </div>
          </div>
        </div>

        <p>В некоторых проектах может быть трудоемко оповещать Git
        о каждом добавлении, удалении и переименовании файла.
        Вместо этого вы можете выполнить команды</p>
        <pre class="literallayout">
$ git add .
$ git add -u
</pre>

        <p>Git просмотрит файлы в текущем каталоге и сам
        позаботится о деталях. Вместо второй команды add, выполните
        <span class="strong"><strong>git commit -a</strong></span>,
        если вы собираетесь сразу сделать коммит. Смотрите
        <span class="strong"><strong>git help
        ignore</strong></span>, чтобы узнать как указать файлы,
        которые должны игнорироваться.</p>

        <p>Вы можете выполнить все это одним махом:</p>
        <pre class="literallayout">
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>Опции <span class="strong"><strong>-z</strong></span> и
        <span class="strong"><strong>-0</strong></span>
        предотвращают неверную обработку файловых имен, содержащих
        специальные символы. Поскольку эта команда добавляет
        игнорируемые файлы, вы возможно захотите использовать опции
        -x или -X.</p>
      </div>

      <div class="section" title="Мой коммит слишком велик">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BC%D0%BE%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82_%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC_%D0%B2%D0%B5%D0%BB%D0%B8%D0%BA">
              </a>Мой коммит слишком велик</h2>
            </div>
          </div>
        </div>

        <p>Вы пренебрегали коммитами слишком долго? Яростно писали
        код и вспомнили об управлении исходниками только сейчас?
        Внесли ряд несвязанных изменений, потому что это ваш
        стиль?</p>

        <p>Нет поводов для беспокойства. Выполните</p>
        <pre class="literallayout">
$ git add -p
</pre>

        <p>Для каждой сделанной вами правки Git покажет измененный
        участок кода и спросит, должно ли это изменение попасть в
        следующий коммит. Отвечайте «y» (да) или «n» (нет). У вас
        есть и другие варианты, например отложить выбор; введите
        «?» чтобы узнать больше.</p>

        <p>Когда закончите, выполните</p>
        <pre class="literallayout">
$ git commit
</pre>

        <p>для внесения именно тех правок, что вы выбрали
        («буферизованных» изменений). Убедитесь, что вы не указали
        опцию <span class="strong"><strong>-a</strong></span>,
        иначе Git закоммитит все правки.</p>

        <p>Что делать, если вы изменили множество файлов во многих
        местах? Проверка каждого отдельного изменения становится
        удручающей рутиной. В этом случае используйте <span class=
        "strong"><strong>git add -i</strong></span>. Ее интерфейс
        не так прост, но более гибок. В несколько нажатий кнопок
        можно добавить или убрать из буфера несколько файлов
        одновременно, либо просмотреть и выбрать изменения лишь в
        отдельных файлах. Как вариант, запустите <span class=
        "strong"><strong>git commit --interactive</strong></span>,
        которая автоматически сделает коммит когда вы
        закончите.</p>
      </div>

      <div class="section" title="Индекс — буферная зона Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%B7%D0%BE%D0%BD%D0%B0_git">
              </a>Индекс — буферная зона Git</h2>
            </div>
          </div>
        </div>

        <p>До сих пор мы избегали знаменитого «индекса» Git, но
        теперь мы должны рассмотреть его, для пояснения
        вышесказанного. Индекс это временный буфер. Git редко
        перемещает данные непосредственно между вашим проектом и
        его историей. Вместо этого Git сначала записывает данные в
        индекс, а уж затем копирует их из индекса по месту
        назначения.</p>

        <p>Например, <span class="strong"><strong>commit
        -a</strong></span> на самом деле двухэтапный процесс.
        Сначала слепок текущего состояния каждого из отслеживаемых
        файлов помещается в индекс. Затем слепок, находящийся в
        индексе, записывается в историю. Коммит без опции
        <span class="strong"><strong>-a</strong></span> выполняет
        только второй шаг, и имеет смысл только после выполнения
        команд, изменяющих индекс, таких как <span class=
        "strong"><strong>git add</strong></span>.</p>

        <p>Обычно мы можем не обращать внимания на индекс и делать
        вид, что взаимодействуем напрямую с историей. Но в данном
        случае мы хотим более тонкого контроля, поэтому управляем
        индексом. Мы помещаем слепок некоторых (но не всех) наших
        изменений в индекс, после чего окончательно записываем этот
        аккуратно сформированный слепок.</p>
      </div>

      <div class="section" title="Не теряй «головы»">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5_%D1%82%D0%B5%D1%80%D1%8F%D0%B9_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D1%8B">
              </a>Не теряй «головы»</h2>
            </div>
          </div>
        </div>

        <p>Тег HEAD (англ. «голова», прим. пер.) — как курсор,
        который обычно указывает на последний коммит, продвигаясь с
        каждым новым коммитом. Некоторые команды Git позволяют
        перемещать этот курсор. Например,</p>
        <pre class="literallayout">
$ git reset HEAD~3
</pre>

        <p>переместит HEAD на три коммита назад. Теперь все команды
        Git будут работать так, как будто вы не делали последних
        трех коммитов, хотя файлы останутся в текущем состоянии. В
        справке описано несколько способов использования этого
        приема.</p>

        <p>Но как вернуться назад в будущее? Ведь предыдущие
        коммиты о нем ничего не знают.</p>

        <p>Если у вас есть SHA1 изначальной «головы», то:</p>
        <pre class="literallayout">
$ git reset 1b6d
</pre>

        <p>Но допустим, вы его не записывали. Не беспокойтесь: для
        комнад такого рода Git сохраняет оригинальную «голову» как
        тег под названием ORIG_HEAD, и вы можете вернуться надежно
        и безопасно:</p>
        <pre class="literallayout">
$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" title="Охота за «головами»">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BE%D1%85%D0%BE%D1%82%D0%B0_%D0%B7%D0%B0_%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%B0%D0%BC%D0%B8">
              </a>Охота за «головами»</h2>
            </div>
          </div>
        </div>

        <p>Предположим ORIG_HEAD недостаточно. К примеру, вы только
        что осознали, что допустили громадную ошибку, и вам нужно
        вернуться к древнему коммиту в давно забытой ветке.</p>

        <p>По умолчанию Git хранит коммиты не меньше двух недель,
        даже если вы приказали уничтожить содержащую их ветку.
        Проблема в нахождении соответствующего хеша. Вы можете
        просмотреть все значения хешей в .git/objects и методом
        проб и ошибок найти нужный. Но есть путь значительно
        легче.</p>

        <p>Git записывает каждый подсчитанный им хеш коммита в
        .git/logs. В подкатлоге refs содержится полная история
        активности на всех ветках, а файл HEAD содержит каждое
        значение хеша, которое когда-либо принимал HEAD. Последнее
        можно использовать чтобы найти хеши коммитов на случайно
        обрубленных ветках.</p>

        <p>Команда reflog предоставляет удобный интерфейс работы с
        этими журналами. Используйте</p>
        <pre class="literallayout">
$ git reflog
</pre>

        <p>Вместо копирования хешей из reflog, попробуйте</p>
        <pre class="literallayout">
$ git checkout "@{10 minutes ago}" # 10 минут назад, прим. пер.
</pre>

        <p>Или сделайте чекаут пятого с конца из посещенных
        коммитов с помощью</p>
        <pre class="literallayout">
$ git checkout "@{5}"
</pre>

        <p>Смотрите раздел «Specifying Revisions» в <span class=
        "strong"><strong>git help rev-parse</strong></span> для
        дополнительной информации.</p>

        <p>Вы можете захотеть удлинить отсрочку для коммитов,
        обреченных на удаление. Например,</p>
        <pre class="literallayout">
$ git config gc.pruneexpire "30 days"
</pre>

        <p>означает, что удаляемые коммиты будут окончательно
        исчезать только по прошествии 30 дней и после запуска
        <span class="strong"><strong>git gc</strong></span>.</p>

        <p>Также вы можете захотеть отключить автоматический вызов
        <span class="strong"><strong>git gc</strong></span>:</p>
        <pre class="literallayout">
$ git config gc.auto 0
</pre>

        <p>В этом случае коммиты будут удаляться только когда вы
        будете запускать <span class="strong"><strong>git
        gc</strong></span> вручную.</p>
      </div>

      <div class="section" title="Git как основа">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_%D0%BA%D0%B0%D0%BA_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B0">
              </a>Git как основа</h2>
            </div>
          </div>
        </div>

        <p>Дизайн Git, в истинном духе UNIX, позволяет легко
        использовать его как низкоуровневый компонент других
        программ: графических и веб-интерфейсов; альтернативных
        интерфейсов командной строки; инструментов управления
        патчами; средств импорта или конвертации, и так далее.
        Многие команды Git на самом деле — скрипты, стоящие на
        плечах гигантов. Небольшой доработкой вы можете переделать
        Git на свой вкус.</p>

        <p>Простейший трюк — использование алиасов Git для
        сокращения часто используемых команд:</p>
        <pre class="literallayout">
$ git config --global alias.co checkout
$ git config --global --get-regexp alias       # отображает текущие алиасы
alias.co checkout
$ git co foo # то-же, что и «git checkout foo»
</pre>

        <p>Другой пример: можно выводить текущую ветку в
        приглашении командной строки или заголовке окна терминала.
        Запуск</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD
</pre>

        <p>выводит название текущей ветки. На практике вы скорее
        всего захотите убрать «refs/heads/» и сообщения об
        ошибках:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>Подкаталог <code class="literal">contrib</code> это
        целая сокровищница инструментов, построенных на Git. Со
        временем некоторые из них могут становиться официальными
        командами. В Debian и Ubuntu этот каталог находится в
        <code class=
        "literal">/usr/share/doc/git-core/contrib</code>.</p>

        <p>Один популярный инструмент из этого каталога —
        <code class="literal">workdir/git-new-workdir</code>. Этот
        скрипт создает с помощью символических ссылок новый рабочий
        каталог, имеющий общую историю с оригинальным
        хранилищем:</p>
        <pre class="literallayout">
$ git-new-workdir существующее/хранилище новый/каталог
</pre>

        <p>Новый каталог и файлы в нем можно воспринимать как клон,
        с той разницей, что два дерева автоматически остаются
        синхронизированными ввиду общей истории. Нет необходимости
        в merge, push и pull.</p>
      </div>

      <div class="section" title="Рискованные трюки">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%80%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%82%D1%80%D1%8E%D0%BA%D0%B8">
              </a>Рискованные трюки</h2>
            </div>
          </div>
        </div>

        <p>Нынешний Git делает случайное уничтожение данных очень
        сложным. Но если вы знаете, что делаете, вы можете обойти
        защиту для распространенных команд.</p>

        <p><span class="strong"><strong>Checkout</strong></span>:
        Наличие незакоммиченных изменений прерывает выполнение
        checkout. Чтобы перейти к нужному коммиту, даже уничтожив
        свои изменения, используйте «принуждающий» (force, прим.
        пер.) флаг <span class=
        "strong"><strong>-f</strong></span>:</p>
        <pre class="literallayout">
$ git checkout -f HEAD^
</pre>

        <p>С другой стороны, если вы укажете checkout конкретные
        пути, проверки на безопасность не будет: указанные файлы
        молча перезапишутся. Будьте осторожны при таком
        использовании checkout.</p>

        <p><span class="strong"><strong>Reset</strong></span>:
        сброс также прерывается при наличии незакоммиченных
        изменений. Чтобы заставить его сработать, запустите</p>
        <pre class="literallayout">
$ git reset --hard 1b6d
</pre>

        <p><span class="strong"><strong>Branch</strong></span>:
        Удаление ветки прервётся, если оно привело бы к потере
        изменений. Для принудительного удаления введите</p>
        <pre class="literallayout">
$ git branch -D мертвая_ветка # вместо -d
</pre>

        <p>Аналогично, попытка перезаписи ветки путем перемещения
        будет прервана, если может привести к потере данных. Для
        принудительного перемещений ветки введите</p>
        <pre class="literallayout">
$ git branch -M источник цель # вместо -m
</pre>

        <p>В отличии от checkout и reset, эти две команды дают
        отсрочку в удалении данных. Изменения остаются в каталоге
        .git и могут быть возвращены восстановлением нужного хеша
        из .git/logs (смотрите выше раздел «Охота за „головами“»).
        По умолчанию они будут храниться по крайней мере две
        недели.</p>

        <p><span class="strong"><strong>Clean</strong></span>:
        Некоторые команды могут не сработать из опасений повредить
        неотслеживаемые файлы. Если вы уверены, что все
        неотслеживаемые файлы и каталоги не нужны, то безжалостно
        удаляйте их командой</p>
        <pre class="literallayout">
$ git clean -f -d
</pre>

        <p>В следующий раз эта досадная команда сработает!</p>
      </div>

      <div class="section" title="Предотвращаем плохие коммиты">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%82%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC_%D0%BF%D0%BB%D0%BE%D1%85%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B">
              </a>Предотвращаем плохие коммиты</h2>
            </div>
          </div>
        </div>

        <p>Глупые ошибки загрязняют мои хранилища. Самое ужасное
        это проблема недостающих файлов, вызванная забытым
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Примеры менее серьезных проступков: завершающие пробелы
        и неразрешённые конфликты слияния. Несмотря на
        безвредность, я не хотел бы, чтобы это появлялось в
        публичных записях.</p>

        <p>Если бы я только поставил защиту от дурака, используя
        <span class="emphasis"><em>хук</em></span>, который бы
        предупреждал меня об этих проблемах:</p>
        <pre class="literallayout">
$ cd .git/hooks
$ cp pre-commit.sample pre-commit # В старых версиях Git: chmod +x pre-commit
</pre>

        <p>Теперь Git отменит коммит, если обнаружит лишние пробелы
        или неразрешенные конфликты.</p>

        <p>Для этого руководства я в конце концов добавил следующее
        в начало хука <span class=
        "strong"><strong>pre-commit</strong></span>, чтобы
        защититься от своей рассеянности:</p>

        <p>if git ls-files -o | grep <span class=
        "emphasis"><em>\.txt$</em></span>; then echo ПРЕРВАНО!
        Неотслеживаемые .txt файлы. exit 1 fi</p>

        <p>Хуки поддерживаются несколькими различными операциями
        Git, смотрите <span class="strong"><strong>git help
        hooks</strong></span>. Мы использовали пример хука
        <span class="strong"><strong>post-update</strong></span>
        раньше, при обсуждении использования Git через http. Он
        запускался при каждом перемещении «головы». Пример скрипта
        <span class="strong"><strong>post-update</strong></span>
        обновляет файлы, которые нужны Git для связи через не
        считающиеся с ним средства сообщения, такие как HTTP.</p>
      </div>
    </div>

    <div class="chapter" title="Глава 8. Раскрываем тайны">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D1%80%D0%B0%D1%81%D0%BA%D1%80%D1%8B%D0%B2%D0%B0%D0%B5%D0%BC_%D1%82%D0%B0%D0%B9%D0%BD%D1%8B">
            </a>Глава 8. Раскрываем тайны</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C">
          Невидимость</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">
          Целостность</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82">
          Интеллект</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%D1%86%D0%B8%D1%8F">
          Индексация</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_git">
          Происхождение Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B1%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">
          База данных объектов</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B1%D0%BB%D0%BE%D0%B1%D1%8B">Блобы</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F">Деревья</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B">Коммиты</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D0%BE_%D0%BE%D1%82_%D0%B2%D0%BE%D0%BB%D1%88%D0%B5%D0%B1%D1%81%D1%82%D0%B2%D0%B0">
          Неотличимо от волшебства</a></span></dt>
        </dl>
      </div>

      <p>Мы заглянем под капот и объясним, как Git творит свои
      чудеса. Я опущу излишние детали. За более детальными
      описаниями обратитесь к <a class="ulink" href=
      "http://www.kernel.org/pub/software/scm/git/docs/user-manual.html"
      target="_top">руководству пользователя</a>.</p>

      <div class="section" title="Невидимость">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C">
              </a>Невидимость</h2>
            </div>
          </div>
        </div>

        <p>Как Git может быть таким ненавязчивым? За исключением
        периодических коммитов и слияний, вы можете работать так,
        как будто и не подозреваете о каком-то управлении версиями.
        Так происходит до того момента, когда Git вам понадобится,
        и тогда вы с радостью увидите, что он наблюдал за вами все
        это время.</p>

        <p>Другие системы управления версиями вынуждают вас
        постоянно бороться с загородками и бюрократией. Файлы могут
        быть доступны только для чтения, пока вы явно не укажете
        центральному серверу, какие файлы вы намереваетесь
        редактировать. С увеличением количества пользователей
        большинство базовых команд начинают выполняться всё
        медленнее. Неполадки с сетью или с центральным сервером
        полностью останавливают работу.</p>

        <p>В противоположность этому, Git просто хранит историю
        проекта в подкаталоге .git вашего рабочего каталога. Это
        ваша личная копия истории, поэтому вы можете оставаться вне
        сети, пока не захотите взаимодействовать с остальными. У
        вас есть полный контроль над судьбой ваших файлов,
        поскольку Git в любое время может легко восстановить
        сохраненное состояние из .git.</p>
      </div>

      <div class="section" title="Целостность">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">
              </a>Целостность</h2>
            </div>
          </div>
        </div>

        <p>Большинство людей ассоциируют криптографию с содержанием
        информации в секрете, но другой столь же важной задачей
        является содержание ее в сохранности. Правильное
        использование криптографических хеш-функций может
        предотвратить случайное или злонамеренное повреждение
        данных.</p>

        <p>SHA1 хеш можно рассматривать как уникальный 160-битный
        идентификатор для каждой строки байт, с которой вы
        сталкиваетесь в вашей жизни. Даже больше того: для каждой
        строки байтов, которую любой человек когда-либо будет
        использовать в течение многих жизней.</p>

        <p>Так как SHA1 хеш сам является последовательностью
        байтов, мы можем получить хеш строки байтов, содержащей
        другие хеши. Это простое наблюдение на удивление полезно:
        ищите «hash chains» (цепочки хешей). Позднее мы увидим, как
        Git использует их для эффективного обеспечения целостности
        данных.</p>

        <p>Говоря кратко, Git хранит ваши данные в подкаталоге
        ".git/objects", где вместо нормальных имен файлов вы
        найдете только идентификаторы. Благодаря использованию
        идентификаторов в качестве имен файлов, а также некоторым
        хитростям с файлами блокировок и временны́ми метками, Git
        преобразует любую скромную файловую систему в эффективную и
        надежную базу данных.</p>
      </div>

      <div class="section" title="Интеллект">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82">
              </a>Интеллект</h2>
            </div>
          </div>
        </div>

        <p>Как Git узнаёт, что вы переименовали файл, даже если вы
        никогда не упоминали об этом явно? Конечно, вы можете
        запустить <span class="strong"><strong>git
        mv</strong></span>; но это то же самое, что <span class=
        "strong"><strong>git rm</strong></span>, а затем
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git эвристически находит файлы, которые были
        переименованы или скопированы между соседними версиями. На
        деле он может обнаружить, что участки кода были перемещены
        или скопированы между файлами! Хотя Git не может охватить
        все случаи, он всё же делает достойную работу, и эта
        функция постоянно улучшается. Если она не сработала,
        попробуйте опции, включающие более ресурсоемкое обнаружение
        копирования и подумайте об обновлении.</p>
      </div>

      <div class="section" title="Индексация">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%D1%86%D0%B8%D1%8F">
              </a>Индексация</h2>
            </div>
          </div>
        </div>

        <p>Для каждого отслеживаемого файла, Git записывает такую
        информацию, как размер, время создания и время последнего
        изменения, в файле, известном как «индекс». Чтобы
        определить, был ли файл изменен, Git сравнивает его текущие
        характеристики с сохраненными в индексе. Если они
        совпадают, то Git не станет перечитывать файл заново.</p>

        <p>Поскольку считывание этой информации значительно
        быстрее, чем чтение всего файла, то если вы редактировали
        лишь несколько файлов, Git может обновить свой индекс почти
        мгновенно.</p>

        <p>Мы отмечали ранее, что индекс это буферная зона. Почему
        набор свойств файлов выступает таким буфером? Потому что
        команда add помещает файлы в базу данных Git и в
        соответствии с этим обновляет эти свойства; тогда как
        команда commit без опций создает коммит, основанный только
        на этих свойствах и файлах, которые уже в базе данных.</p>
      </div>

      <div class="section" title="Происхождение Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_git">
              </a>Происхождение Git</h2>
            </div>
          </div>
        </div>

        <p>Это <a class="ulink" href=
        "http://lkml.org/lkml/2005/4/6/121" target="_top">сообщение
        в почтовой рассылке ядра Linux</a> описывает
        последовательность событий, которые привели к появлению
        Git. Весь этот тред — привлекательный археологический
        раскоп для историков Git.</p>
      </div>

      <div class="section" title="База данных объектов">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B1%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">
              </a>База данных объектов</h2>
            </div>
          </div>
        </div>

        <p>Каждая версия ваших данных хранится в «базе данных
        объектов», живущей в подкаталоге .git/objects. Другие
        «жители» .git/ содержат вторичные данные: индекс, имена
        веток, теги, параметры настройки, журналы, нынешнее
        расположение «головного» коммита и так далее. База объектов
        проста и элегантна, и в ней источник силы Git.</p>

        <p>Каждый файл внутри .git/objects это «объект». Нас
        интересуют три типа объектов: объекты «блобов», объекты
        деревьев и объекты коммитов.</p>
      </div>

      <div class="section" title="Блобы">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B1%D0%BB%D0%BE%D0%B1%D1%8B"></a>Блобы</h2>
            </div>
          </div>
        </div>

        <p>Для начала один фокус. Выберите имя файла — любое имя
        файла. В пустом каталоге:</p>
        <pre class="literallayout">
$ echo sweet &gt; ВАШЕ_ИМЯ_ФАЙЛА
$ git init
$ git add .
$ find .git/objects -type f
</pre>

        <p>Вы увидите <code class=
        "literal">.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d</code>.</p>

        <p>Откуда я знаю это, не зная имени файла? Это потому, что
        SHA1 хеш строки</p>
        <pre class="literallayout">
«blob» SP «6» NUL «sweet» LF
</pre>

        <p>равен aa823728ea7d592acc69b36875a482cdf3fd5c8d, где SP
        это пробел, NUL — нулевой байт и LF — перевод строки. Вы
        можете проверить это, набрав</p>
        <pre class="literallayout">
$ printf "blob 6\000sweet\n" | sha1sum
</pre>

        <p>Git использует «адресацию по содержимому»: файлы
        хранятся в соответствии не с именами, а с хешами
        содержимого, — в файле, который мы называем
        «блоб-объектом». Хеш можно понимать как уникальный
        идентификатор содержимого файла, что означает обращение к
        файлам по их содержимому. Начальный «blob 6» — лишь
        заголовок, состоящий из типа объекта и его длины в байтах и
        упрощающий внутренний учет.</p>

        <p>Таким образом, я могу легко предсказать, что вы увидите.
        Имя файла не имеет значения: для создания блоб-объекта
        используется только его содержимое.</p>

        <p>Вам может быть интересно, что происходит с одинаковыми
        файлами. Попробуйте добавить копии своего файла с какими
        угодно именами. Содержание <code class=
        "literal">.git/objects</code> останется тем же независимо
        от того, сколько копий вы добавите. Git хранит данные лишь
        единожды.</p>

        <p>Кстати, файлы в каталоге <code class=
        "literal">.git/objects</code> сжимаются с помощью zlib
        поэтому вы не сможете просмотреть их напрямую. Пропустите
        их через фильтр <a class="ulink" href=
        "http://www.zlib.net/zpipe.c" target="_top">zpipe -d</a>,
        или введите</p>
        <pre class="literallayout">
$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>что выведет указанный объект в читаемом виде.</p>
      </div>

      <div class="section" title="Деревья">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F"></a>Деревья</h2>
            </div>
          </div>
        </div>

        <p>Но где же имена файлов? Они должны храниться на каком-то
        уровне. Git обращается за именами во время коммита:</p>
        <pre class="literallayout">
$ git commit  # Введите какое-нибудь описание
$ find .git/objects -type f
</pre>

        <p>Теперь вы должны увидеть три объекта. На этот раз я не
        могу сказать вам, что из себя представляют два новых файла,
        так как это частично зависит от выбранного вами имени
        файла. Далее будем предполагать, что вы назвали его «rose».
        Если это не так, то вы можете переписать историю, чтобы она
        выглядела как будто вы это сделали:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'mv ВАШЕ_ИМЯ_ФАЙЛА rose'
$ find .git/objects -type f
</pre>

        <p>Теперь вы должны увидеть файл <code class=
        "literal">.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9</code>,
        так как это SHA1 хеш его содержимого:</p>
        <pre class="literallayout">
«tree» SP «32» NUL «100644 rose» NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>Проверьте, что этот файл действительно содержит
        указанную строку, набрав</p>
        <pre class="literallayout">
$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
</pre>

        <p>С zpipe легко проверить хеш:</p>
        <pre class="literallayout">
$ zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
</pre>

        <p>Проверка хеша с помощью cat-file сложнее, поскольку ее
        вывод содержит не только «сырой» распакованный файл
        объекта.</p>

        <p>Этот файл — объект «дерево» (tree, прим. пер.): список
        цепочек, состоящих из типа, имени файла и его хеша. В нашем
        примере: тип файла — 100644, что означает, что «rose» это
        обычный файл; а хеш — блоб-объект, в котором находится
        содержимое «rose». Другие возможные типы файлов:
        исполняемые файлы, символические ссылки или каталоги. В
        последнем случае, хеш указывает на объект «дерево».</p>

        <p>Если вы запускали filter-branch, у вас есть старые
        объекты которые вам больше не нужны. Хотя по окончании
        срока хранения они будут выброшены автоматически, мы удалим
        их сейчас, чтобы было легче следить за нашим игрушечным
        примером:</p>
        <pre class="literallayout">
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
</pre>

        <p>Для реальных проектов обычно лучше избегать таких
        команд, поскольку вы уничтожаете резервные копии. Если вы
        хотите иметь чистое хранилище, то обычно лучше сделать
        свежий клон. Кроме того, будьте осторожны при
        непосредственном вмешательстве в каталог <code class=
        "literal">.git</code>: что если другая команда Git работает
        в это же время, или внезапно произойдет отключение питания?
        Вообще говоря, ссылки нужно удалять с помощью <span class=
        "strong"><strong>git update-ref -d</strong></span>, хотя
        обычно ручное удаление <code class=
        "literal">refs/original</code> безопасно.</p>
      </div>

      <div class="section" title="Коммиты">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%8B"></a>Коммиты</h2>
            </div>
          </div>
        </div>

        <p>Мы рассмотрели два из трех объектов. Третий объект —
        «коммит» (commit). Его содержимое зависит от описания
        коммита, как и от даты и времени его создания. Для
        соответстия тому, что мы имеем, мы должны немного
        «подкрутить» Git:</p>
        <pre class="literallayout">
$ git commit --amend -m Shakespeare  # Изменим описание коммита.
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # Подделаем временные метки и авторов.
$ find .git/objects -type f
</pre>

        <p>Теперь вы должны увидеть <code class=
        "literal">.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187</code>
        который является SHA1 хешем его содержимого:</p>
        <pre class="literallayout">
«commit 158» NUL
«tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9» LF
«author Alice &lt;alice@example.com&gt; 1234567890 -0800» LF
«committer Bob &lt;bob@example.com&gt; 1234567890 -0800» LF
LF
«Shakespeare» LF
</pre>

        <p>Как и раньше, вы сами можете запустить zpipe или
        cat-file, чтобы увидить это.</p>

        <p>Это первый коммит, поэтому здесь нет родительских
        коммитов, но последующие коммиты всегда будет содержать
        хотя бы одну строку, идентифицирующую родительский
        коммит.</p>
      </div>

      <div class="section" title="Неотличимо от волшебства">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D0%BE_%D0%BE%D1%82_%D0%B2%D0%BE%D0%BB%D1%88%D0%B5%D0%B1%D1%81%D1%82%D0%B2%D0%B0">
              </a>Неотличимо от волшебства</h2>
            </div>
          </div>
        </div>

        <p>Секреты Git выглядят слишком простыми. Похоже, что вы
        могли бы объединить несколько shell-скриптов и добавить
        немного кода на C, чтобы сделать всё это в считанные часы:
        смесь базовых операций с файлами и SHA1-хеширования,
        приправленная блокировочными файлами и fsync для
        надеждности. По сути, это точное описание ранних версий
        Git. Тем не менее, помимо гениальных трюков с упаковкой для
        экономии места и с индексацией для экономии времени, мы
        теперь знаем, как ловко Git преображает файловую систему в
        базу данных, идеально подходящую для управления
        версиями.</p>

        <p>Например, если какой-либо файл в базе данных объектов
        поврежден из-за ошибки диска, то его хеш теперь не
        совпадет, что привлечет наше внимание к проблеме. С помощью
        хеширования хешей других объектов, мы поддерживаем
        целостность на всех уровнях. Коммиты атомарны, так что в
        них никогда нельзя записать лишь часть изменений: мы можем
        вычислить хеш коммита и сохранить его в базу данных только
        сохранив все соответствующие деревья, блобы и родительские
        коммиты. База данных объектов нечувствительна к
        непредвиденным прерываниям работы, таких как перебои с
        питанием.</p>

        <p>Мы наносим поражение даже самым хитрым противникам.
        Предположим, кто-то пытается тайно изменить содержимое
        файла в древней версии проекта. Чтобы база объектов
        выглядела неповрежденной, он также должен изменить хеш
        соответствующего блоб-объекта, поскольку это теперь другая
        последовательность байтов. Это означает, что нужно поменять
        хеши всех объектов деревьев, ссылающихся на этот файл; что
        в свою очередь изменит хеши всех объектов коммитов с
        участием таких деревьев; а также и хеши всех потомков этих
        коммитов. Вследствие этого хеш официальной головной ревизии
        будет отличаться от аналогичного хеша в этом испорченном
        хранилище. По цепочке несовпадающих хешей мы можем точно
        вычислить искаженный файл, как и коммит, где он изначально
        был поврежден.</p>

        <p>Одним словом, невозможно подделать хранилище Git,
        оставив невредимыми двадцать байт, отвечающие последнему
        коммиту.</p>

        <p>Как насчет известных характерных особенностей Git?
        Ветвление? Слияние? Теги? Очевидные подробности. Текущая
        «голова» хранится в файле <code class=
        "literal">.git/HEAD</code>, содержащем хеш объекта коммита.
        Хеш обновляется во время коммита, а также при выполнении
        многих других команд. С ветками всё аналогично: это файлы в
        <code class="literal">.git/refs/heads</code>. То же и
        тегами: они живут в <code class=
        "literal">.git/refs/tags</code>, но их обновляет другой
        набор команд.</p>
      </div>
    </div>

    <div class="appendix" title="Приложение A. Недостатки Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8_git">
            </a>Приложение A. Недостатки Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Содержание</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_%D1%81%D0%BB%D0%B0%D0%B1%D0%BE%D1%81%D1%82%D0%B8_sha1">
          Слабости SHA1</a></span></dt>

          <dt><span class="section"><a href=
          "#_microsoft_windows">Microsoft Windows</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B5%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D1%8B">
          Несвязанные файлы</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BA%D1%82%D0%BE_%D0%B8_%D1%87%D1%82%D0%BE_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BB">
          Кто и что редактировал ?</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0">
          История файла</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BA%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
          Начальное Клонирование</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%87%D0%B8%D0%B2%D1%8B%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B">
          Изменчивые Проекты</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%81%D1%87%D0%B5%D1%82%D1%87%D0%B8%D0%BA">
          Глобальный счетчик</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D1%83%D1%81%D1%82%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B8">
          Пустые подкаталоги</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82">
          Первоначальный коммит</a></span></dt>

          <dt><span class="section"><a href=
          "#_%D0%BF%D1%80%D0%B8%D1%87%D1%83%D0%B4%D1%8B_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0">
          Причуды интерфейса</a></span></dt>
        </dl>
      </div>

      <p>Есть некоторые проблемы Git, которые я спрятал под сукно.
      Некоторые из них можно легко решить с помощью скриптов и
      хуков, некоторые требуют реорганизации или пересмотра
      проекта, а несколько оставшихся неприятностей придется
      потерпеть. А еще лучше — взяться за них и решить!</p>

      <div class="section" title="Слабости SHA1">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D1%81%D0%BB%D0%B0%D0%B1%D0%BE%D1%81%D1%82%D0%B8_sha1">
              </a>Слабости SHA1</h2>
            </div>
          </div>
        </div>

        <p>Со временем криптографы обнаруживают всё больше и больше
        слабостей в SHA1. Уже сейчас обнаружение коллизий хешей
        осуществимо для хорошо финансируемой организации. Спустя
        годы, возможно, даже типичный ПК будет иметь достаточную
        вычислительную мощность, чтобы незаметно испортить
        хранилище Git.</p>

        <p>Надеюсь, Git перейдет на лучшую хеш-функцию прежде чем
        дальнейшие исследования уничтожат SHA1.</p>
      </div>

      <div class="section" title="Microsoft Windows">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_microsoft_windows"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Git на Microsoft Windows может быть громоздким:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://cygwin.com/" target="_top">Cygwin</a>,
            Linux-подобная среда для Windows, содержащая <a class=
            "ulink" href="http://cygwin.com/packages/git/" target=
            "_top">порт Git на Windows</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://code.google.com/p/msysgit/" target="_top">Git
            на MSys</a>, вариант, требующий минимальной рантайм
            поддержки, хотя некоторые комманды нуждаются в
            доработке.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Несвязанные файлы">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B5%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D1%84%D0%B0%D0%B9%D0%BB%D1%8B">
              </a>Несвязанные файлы</h2>
            </div>
          </div>
        </div>

        <p>Если ваш проект очень велик и содержит много несвязанных
        файлов, которые постоянно изменяются, Git может оказаться в
        невыгодном положении по сравнению с другими системами,
        поскольку отдельные файлы не отслеживаются. Git отслеживает
        изменения всего проекта, что обычно бывает выгодным.</p>

        <p>Решение — разбить проект на части, каждая из которых
        состоит из взаимосвязанных файлов. Используйте <span class=
        "strong"><strong>git submodule</strong></span> если вы все
        же хотите держать все в одном хранилище.</p>
      </div>

      <div class="section" title="Кто и что редактировал ?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BA%D1%82%D0%BE_%D0%B8_%D1%87%D1%82%D0%BE_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BB">
              </a>Кто и что редактировал ?</h2>
            </div>
          </div>
        </div>

        <p>Некоторые системы управления версиями вынуждают вас
        явным образом пометить файл перед редактированием. Хотя
        такой подход особенно раздражает, когда подразумевает
        работу с центральным сервером, однако он имеет два
        преимущества:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">Diff'ы быстры, так как нужно
            проверить только отмеченные файлы.</li>

            <li class="listitem">Можно обнаружить, кто еще работает
            с этим файлом, спросив центральный сервер, кто отметил
            его для редактирования.</li>
          </ol>
        </div>

        <p>С помощью соответствующих скриптов, вы можете добиться
        того же с Git. Это требует сотрудничества со стороны
        другого программиста, который должен запускать определенный
        скрипт при редактировании файла.</p>
      </div>

      <div class="section" title="История файла">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0">
              </a>История файла</h2>
            </div>
          </div>
        </div>

        <p>Поскольку Git записывает изменения всего проекта,
        воссоздание истории единичного файла требует больше работы,
        чем в системах управления версиями, следящими за отдельными
        файлами.</p>

        <p>Потери как правило незначительны, и это неплохая цена за
        то, что другие операции невероятно эффективны. Например,
        git checkout быстрее, чем cp -a, а дельта всего проекта
        сжимается лучше, чем коллекция по-файловых дельт.</p>
      </div>

      <div class="section" title="Начальное Клонирование">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BA%D0%BB%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">
              </a>Начальное Клонирование</h2>
            </div>
          </div>
        </div>

        <p>Создание клона хранилища дороже обычного чекаута в
        других системах управления версиями при длинной
        истории.</p>

        <p>Первоначальная цена окупается в долгосрочной
        перспективе, так как большинство последующих операций будут
        быстрыми и автономными. Однако в некоторых ситуациях может
        быть предпочтительным создание мелких клонов с опцией
        --depth. Это намного быстрее, но у полученного клона будет
        урезанная функциональность.</p>
      </div>

      <div class="section" title="Изменчивые Проекты">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%87%D0%B8%D0%B2%D1%8B%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%8B">
              </a>Изменчивые Проекты</h2>
            </div>
          </div>
        </div>

        <p>Git был написан, чтобы быть быстрым при относительно
        небольших изменениях. Люди вносят незначительные правки от
        версии к версии. Однострочное исправление ошибки здесь,
        новая функция там, исправленные комментарии и тому
        подобное. Но если ваши файлы радикально различаются в
        соседних ревизиях, то с каждым коммитом ваша история
        неизбежно увеличится на размер всего проекта.</p>

        <p>Никакая система управления версиями ничего не может с
        этим сделать, но пользователи Git страдают больше,
        поскольку обычно истории клонируются.</p>

        <p>Причины, по которым эти изменения столь велики, нужно
        изучить. Возможно, надо изменить форматы файлов. Небольшие
        правки должны приводить к небольшим изменений не более чем
        в нескольких файлах.</p>

        <p>Возможно, вам была нужна база данных или система
        резервного/архивного копирования, а не система управления
        версиями. Например, управление версиями может быть плохо
        приспособлено для обращения с фотографиями периодически
        получаемыми с веб-камеры.</p>

        <p>Если файлы действительно должны постоянно изменяться и
        при этом версироваться, может иметь смысл использовать Git
        централизованным образом. Можно создавать мелкие клоны, с
        небольшой историей или без истории вообще. Конечно, многие
        инструменты Git будут недоступны, и исправления придется
        представлять в виде патчей. Возможно, это и хорошо, так как
        неясно, зачем кому-либо понадобится история крайне
        нестабильных файлов.</p>

        <p>Другой пример — это проект, зависимый от прошивки,
        принимающей форму огромного двоичного файла. Ее история
        неинтересна пользователям, а обновления плохо сжимаются,
        потому ревизии прошивки будут неоправдано раздувать размер
        хранилища.</p>

        <p>В этом случае исходный код стоит держать в хранилище
        Git, а бинарные файлы — отдельно. Для упрощения жизни можно
        распространять скрипт, использующий Git для клонирования
        кода и rsync или мелкий клон Git для прошивки.</p>
      </div>

      <div class="section" title="Глобальный счетчик">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%81%D1%87%D0%B5%D1%82%D1%87%D0%B8%D0%BA">
              </a>Глобальный счетчик</h2>
            </div>
          </div>
        </div>

        <p>Некоторые централизованные системы управления версиями
        содержат натуральное число, увеличивающееся при поступлении
        нового коммита. Git идентифицирует изменения по их хешам,
        что лучше во многих обстоятельствах.</p>

        <p>Но некоторым людям нравятся эти целые числа повсюду. К
        счастью, легко написать такой скрипт, чтобы при каждом
        обновлении центральное хранилище Git увеличивало целое
        число, возможно, в теге, и связывало его с хешем последнего
        коммита.</p>

        <p>Каждый клон может поддерживать такой счетчик, но это,
        видимо, будет бесполезным, поскольку только центральное
        хранилище и его счетчик имеет значение для всех.</p>
      </div>

      <div class="section" title="Пустые подкаталоги">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D1%83%D1%81%D1%82%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%B8">
              </a>Пустые подкаталоги</h2>
            </div>
          </div>
        </div>

        <p>Пустые подкаталоги не могут отслеживаться. Создавайте
        подставные файлы, чтобы обойти эту проблему.</p>

        <p>В этом виноват не дизайн Git, а его текущая реализация.
        Если повезет и пользователи Git будут поднимать больше шума
        вокруг этой функции, возможно она будет реализована.</p>
      </div>

      <div class="section" title="Первоначальный коммит">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82">
              </a>Первоначальный коммит</h2>
            </div>
          </div>
        </div>

        <p>Шаблонный компьютерщик считает с 0, а не с 1. К
        сожалению, в отношении коммитов Git не придерживается этого
        соглашения. Многие команды недружелюбны до первоначального
        коммита. Кроме того, некоторые частные случаи требуют
        специальной обработки, к примеру rebase ветки с другим
        начальным коммитом.</p>

        <p>Git'у было бы выгодно определить нулевой коммит: при
        создании хранилища HEAD был бы установлен в строку,
        состоящую из 20 нулевых байтов. Этот специальный коммит
        представлял бы собой пустое дерево, без родителей, которое
        предшествует каждому хранилищу Git.</p>

        <p>Тогда запуск <span class="strong"><strong>git
        log</strong></span>, например, показывал бы пользователю,
        что коммиты еще не были сделаны, вместо того чтобы
        завершаться с фатальной ошибкой. Аналогично для других
        инструментов.</p>

        <p>Каждый первоначальный коммит — неявный потомок этого
        нулевого коммита.</p>

        <p>Однако здесь, к сожалению, есть некоторые проблемные
        случаи. Если несколько ветвей с различными начальными
        коммитами сливаются, то rebase результата требует
        значительного ручного вмешательства.</p>
      </div>

      <div class="section" title="Причуды интерфейса">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_%D0%BF%D1%80%D0%B8%D1%87%D1%83%D0%B4%D1%8B_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0">
              </a>Причуды интерфейса</h2>
            </div>
          </div>
        </div>

        <p>Для коммитов А и Б значения выражений «А..Б» и «А…Б»
        зависят от того, ожидает ли команда указания двух конечных
        точек или промежутка. Смотрите <span class=
        "strong"><strong>git help diff</strong></span> и
        <span class="strong"><strong>git help
        rev-parse</strong></span>.</p>
      </div>
    </div>

    <div class="appendix" title=
    "Приложение B. Перевод этого руководства">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4_%D1%8D%D1%82%D0%BE%D0%B3%D0%BE_%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0">
            </a>Приложение B. Перевод этого руководства</h2>
          </div>
        </div>
      </div>

      <p>Я советую следующий способ для перевода этого руководства,
      чтобы мои скрипты могли быстро создавать HTML и PDF версии, а
      все переводы находились в одном хранилище.</p>

      <p>Клонируйте исходные тексты, затем создайте каталог,
      отвечающий тегу IETF целевого языка: смотрите <a class=
      "ulink" href=
      "http://www.w3.org/International/articles/language-tags/Overview.en.php"
      target="_top">статью W3C по интернационализации</a>. К
      примеру, английский язык это «en», а японский — «ja».
      Скопируйте в каталог файлы <code class="literal">txt</code>
      из каталога «en» и переведите их.</p>

      <p>К примеру, для перевода руководства на <a class="ulink"
      href=
      "http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%BD%D0%B3%D0%BE%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA"
      target="_top">клингонский язык</a>, вы можете набрать:</p>
      <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh # «tlh» — языковой код IETF клингонского языка.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Переведите файл.
</pre>

      <p>и так с каждым файлом.</p>

      <p>Отредактируйте Makefile и добавьте код языка в переменную
      TRANSLATIONS. Теперь вы сможете просматривать вашу работу по
      ходу дела:</p>
      <pre class="literallayout">
$ make tlh
$ firefox book.html
</pre>

      <p>Почаще делайте коммиты, а когда ваш перевод будет готов,
      сообщите мне об этом. На GitHub есть веб-интерфейс,
      облегчающий описанные действия: сделайте форк проекта
      «gitmagic», залейте ваши изменения и попросите меня сделать
      слияние.</p>
    </div>
  </div>
</body>
</html>
