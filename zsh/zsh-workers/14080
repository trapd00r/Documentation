From zsh-workers-return-14080-mason-zsh=primenet.com.au@sunsite.dk Tue Apr 24 05:35:25 2001
Return-Path: <zsh-workers-return-14080-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23020 invoked from network); 24 Apr 2001 05:35:23 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Apr 2001 05:35:23 -0000
Received: (qmail 5591 invoked by alias); 24 Apr 2001 05:35:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14080
Received: (qmail 5575 invoked from network); 24 Apr 2001 05:35:16 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1010424053322.ZM26794@candle.brasslantern.com>
Date: Tue, 24 Apr 2001 05:33:22 +0000
In-Reply-To: <1010423182211.ZM15013@candle.brasslantern.com>
Comments: In reply to "Bart Schaefer" <schaefer@candle.brasslantern.com>
        "Re: What about this? (was: RE: Zsh broken after the latest build patches)" (Apr 23,  6:22pm)
References: <Tc0a88d015318f0cec2@mailsweeper01.cambridgesiliconradio.com> 
	<Pine.SV4.4.33.0104232156250.13064-100000@itsrm2.mow.siemens.ru> 
	<1010423182211.ZM15013@candle.brasslantern.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH:  The last, I really hope, subscripting tweak for a long while
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Apr 23,  6:22pm, Bart Schaefer wrote:
}
} On Apr 23,  6:58pm, Peter Stephenson wrote:
} }
} } You mean a PM_ flag that doesn't get stored with parameters, just used when
} } substituting?  It could certainly be useful.
} 
} Yes, like SCANPM_MATCHMANY and friends.

OK, here's that patch.  It eliminates the extra strchr() at the top of
getindex(), which is very nice.

I fixed a couple of comments and a couple of error messages, and also
figured out why `typeset -A A; A[*]=star' failed silently (and made it
fail noisily instead).  And I added a test of ${(P)...} combined with
wacky associative array quoting.

I really want to stop working on this now.

diff -ru -x CVS zsh-forge/current/Src/glob.c zsh-4.0/Src/glob.c
--- zsh-forge/current/Src/glob.c	Tue Jan 16 05:44:20 2001
+++ zsh-4.0/Src/glob.c	Mon Apr 23 08:57:14 2001
@@ -1344,7 +1344,7 @@
 			    v.pm = NULL;
 			    v.end = -1;
 			    v.inv = 0;
-			    if (getindex(&s, &v) || s == os) {
+			    if (getindex(&s, &v, 0) || s == os) {
 				zerr("invalid subscript", NULL, 0);
 				restore_globstate(saved);
 				return;
diff -ru -x CVS zsh-forge/current/Src/params.c zsh-4.0/Src/params.c
--- zsh-forge/current/Src/params.c	Mon Apr 23 08:20:23 2001
+++ zsh-4.0/Src/params.c	Mon Apr 23 22:09:21 2001
@@ -845,7 +845,8 @@
 		sep = "\n";
 		break;
 	    case 'e':
-		/* obsolate compatibility flag without any real effect */
+		/* Compatibility flag with no effect except to prevent *
+		 * special interpretation by getindex() of `*' or `@'. */
 		break;
 	    case 'n':
 		t = get_strarg(++s);
@@ -876,7 +877,7 @@
 		break;
 	    case 's':
 		/* This gives the string that separates words *
-		 * (for use with the `w' flag.                */
+		 * (for use with the `w' flag).               */
 		t = get_strarg(++s);
 		if (!*t)
 		    goto flagerr;
@@ -1177,11 +1178,10 @@
 
 /**/
 int
-getindex(char **pptr, Value v)
+getindex(char **pptr, Value v, int dq)
 {
     int start, end, inv = 0;
     char *s = *pptr, *tbrack;
-    int dq = !!strchr(s, Dnull);
 
     *s++ = '[';
     s = parse_subscript(s, dq);	/* Error handled after untokenizing */
@@ -1358,7 +1358,7 @@
 	v->start = 0;
 	v->end = -1;
 	if (bracks > 0 && (*s == '[' || *s == Inbrack)) {
-	    if (getindex(&s, v)) {
+	    if (getindex(&s, v, (flags & SCANPM_DQUOTED))) {
 		*pptr = s;
 		return v;
 	    }
@@ -1409,7 +1409,7 @@
 	/* (!v->isarr) should be impossible unless emulating ksh */
 	if (!v->isarr && emulation == EMULATE_KSH) {
 	    s = dupstring("[0]");
-	    if (getindex(&s, v) == 0)
+	    if (getindex(&s, v, 0) == 0)
 		s = getstrvalue(v);
 	    return s;
 	} /* else fall through */
@@ -1575,6 +1575,10 @@
 	zsfree(val);
 	return;
     }
+    if (v->pm->flags & PM_HASHED) {
+	zerr("%s: attempt to set slice of associative array", v->pm->nam, 0);
+	return;
+    }
     v->pm->flags &= ~PM_UNSET;
     switch (PM_TYPE(v->pm->flags)) {
     case PM_SCALAR:
@@ -1698,7 +1702,8 @@
     }
     if (!(PM_TYPE(v->pm->flags) & (PM_ARRAY|PM_HASHED))) {
 	freearray(val);
-	zerr("attempt to assign array value to non-array", NULL, 0);
+	zerr("%s: attempt to assign array value to non-array",
+	     v->pm->nam, 0);
 	return;
     }
     if (v->start == 0 && v->end == -1) {
@@ -1712,7 +1717,8 @@
 
 	if ((PM_TYPE(v->pm->flags) == PM_HASHED)) {
 	    freearray(val);
-	    zerr("attempt to set slice of associative array", NULL, 0);
+	    zerr("%s: attempt to set slice of associative array",
+		 v->pm->nam, 0);
 	    return;
 	}
 	if (v->inv && unset(KSHARRAYS))
@@ -1906,7 +1912,8 @@
 	*ss = '[';
 	if (v && PM_TYPE(v->pm->flags) == PM_HASHED) {
 	    unqueue_signals();
-	    zerr("attempt to set slice of associative array", NULL, 0);
+	    zerr("%s: attempt to set slice of associative array",
+		 v->pm->nam, 0);
 	    freearray(val);
 	    errflag = 1;
 	    return NULL;
diff -ru -x CVS zsh-forge/current/Src/subst.c zsh-4.0/Src/subst.c
--- zsh-forge/current/Src/subst.c	Fri Feb 16 09:16:14 2001
+++ zsh-4.0/Src/subst.c	Mon Apr 23 20:20:42 2001
@@ -1068,7 +1068,7 @@
 	    s++;
 	v = (Value) NULL;
     } else if (aspar) {
-	if ((v = getvalue(&vbuf, &s, 1))) {
+	if ((v = fetchvalue(&vbuf, &s, 1, (qt ? SCANPM_DQUOTED : 0)))) {
 	    val = idbeg = getstrvalue(v);
 	    subexp = 1;
 	} else
@@ -1080,7 +1080,9 @@
 	if (!(v = fetchvalue(&vbuf, (subexp ? &ov : &s),
 			     (wantt ? -1 :
 			      ((unset(KSHARRAYS) || inbrace) ? 1 : -1)),
-			     hkeys|hvals|(arrasg ? SCANPM_ASSIGNING : 0))) ||
+			     hkeys|hvals|
+			     (arrasg ? SCANPM_ASSIGNING : 0)|
+			     (qt ? SCANPM_DQUOTED : 0))) ||
 	    (v->pm && (v->pm->flags & PM_UNSET)))
 	    vunset = 1;
 
@@ -1151,7 +1153,7 @@
 	    v->isarr = isarr;
 	    v->pm = pm;
 	    v->end = -1;
-	    if (getindex(&s, v) || s == os)
+	    if (getindex(&s, v, qt) || s == os)
 		break;
 	}
 	if ((isarr = v->isarr)) {
diff -ru -x CVS zsh-forge/current/Src/zsh.h zsh-4.0/Src/zsh.h
--- zsh-forge/current/Src/zsh.h	Tue Mar 13 07:32:43 2001
+++ zsh-4.0/Src/zsh.h	Mon Apr 23 20:11:24 2001
@@ -1148,6 +1148,7 @@
 #define SCANPM_MATCHMANY  (1<<5)
 #define SCANPM_ASSIGNING  (1<<6)
 #define SCANPM_KEYMATCH   (1<<7)
+#define SCANPM_DQUOTED    (1<<8)
 #define SCANPM_ISVAR_AT   ((-1)<<15)	/* Only sign bit is significant */
 
 /*
diff -ru -x CVS zsh-forge/current/Test/D06subscript.ztst zsh-4.0/Test/D06subscript.ztst
--- zsh-forge/current/Test/D06subscript.ztst	Mon Apr 23 08:20:23 2001
+++ zsh-4.0/Test/D06subscript.ztst	Mon Apr 23 22:20:13 2001
@@ -93,14 +93,15 @@
 >\? \2 \? \?
 >\\]
 
+  eval 'A[*]=star'
+1:Illegal associative array assignment
+?ZTST_execchunk:2: A: attempt to set slice of associative array
+
   x='*'
   A[$x]=xstar
   A[${(q)x}]=qxstar
   print -R ${(k)A[(r)xstar]} $A[$x]
   print -R ${(k)A[(r)qxstar]} $A[${(q)x}]
-  # A[*] is interpreted specially, assignment to it fails silently (oops)
-  A[*]=star
-  print -R ${(k)A[(r)star]} $A[$x]
   A[(e)*]=star
   A[\*]=backstar
   print -R ${(k)A[(r)star]} $A[(e)*]
@@ -108,7 +109,6 @@
 0:Associative array assignment
 >* xstar
 >\* qxstar
->xstar
 >* star
 >\* backstar
 
@@ -160,3 +160,21 @@
 >QqQq
 >qqq
 >QQQ
+
+  print ${x::=$A[$A[(i)one\"two\"three\"quotes]]}
+  print $x
+  print ${x::="$A[$A[(i)one\"two\"three\"quotes]]"}
+  print $x
+0:More keys with double quotes, used in assignment-expansion
+>qqq
+>qqq
+>QQQ
+>QQQ
+
+  qqq=lower
+  QQQ=upper
+  print ${(P)A[one\"two\"three\"quotes]}
+  print "${(P)A[$A[(i)one\"two\"three\"quotes]]}"
+0:Keys with double quotes and the (P) expansion flag
+>lower
+>upper

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

