From zsh-workers-request@math.gatech.edu Mon Dec 14 22:23:53 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24775 invoked from network); 14 Dec 1998 22:23:51 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 14 Dec 1998 22:23:51 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id RAA20413;
	Mon, 14 Dec 1998 17:22:29 -0500 (EST)
Resent-Date: Mon, 14 Dec 1998 17:22:29 -0500 (EST)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <981214142123.ZM28733@candle.brasslantern.com>
Date: Mon, 14 Dec 1998 14:21:23 -0800
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: zsh-workers@math.gatech.edu
Subject: 3.1.5-pws-3: Assorted minor patches
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"VtErC3.0.r-4.b-OTs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4788
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Includes:
 * Documentation for one of Sven's patches (not sure how it got missed)
 * Remove useless `if' branch in Functions/multicomp (a much better rewrite
   of multicomp is now possible with case-insensitive globbing, but I have
   not yet attempted that)
 * The latest version of lete2ctl (that this one is missing surprised me)
 * Canonicalize whitespace in Src/Zle/comp.h

Index: Doc/Zsh/compctl.yo
===================================================================
diff -u -r1.1.1.3 -r1.15
--- compctl.yo	1998/12/14 16:58:51	1.1.1.3
+++ compctl.yo	1998/11/06 08:31:12	1.15
@@ -348,8 +348,9 @@
 item(tt(-q))(
 If used with a suffix as specified by the tt(-S) option, this
 causes the suffix to be removed if the next character typed is a blank
-or does not insert anything (the same rule as used for the
-tt(AUTO_REMOVE_SLASH) option).  The option is most useful for list
+or does not insert anything or if the suffix consists of only one character
+and the next character typed is the same character (the same rule as used
+for the tt(AUTO_REMOVE_SLASH) option).  The option is most useful for list
 separators (comma, colon, etc.).
 )
 item(tt(-l) var(cmd))(
Index: Functions/multicomp
===================================================================
RCS file: /extra/cvsroot/zsh/zsh-3.1/Functions/multicomp,v
retrieving revision 1.1.1.3
retrieving revision 1.5
diff -u -r1.1.1.3 -r1.5
--- multicomp	1998/12/14 16:59:43	1.1.1.3
+++ multicomp	1998/10/30 17:52:42	1.5
@@ -45,13 +45,8 @@
   if [[ "$head" = *[\[\(\*\?\$\~]* ]]; then
     wild=$head
   else
-    [[ -z "$pref" ]] && globdir=
-    # if path segment contains wildcards, don't add another.
-    if [[ "$head" = *[\[\(\*\?\$\~]* || -z "$head" ]]; then
-      wild=$head
-    else
     # Simulate case-insensitive globbing for ASCII characters
-    wild="[${(j(][))${(s())head:l}}]*" # :gs/a/[a]/ etc.
+    wild="[${(j(][))${(s())head:l}}]*"	# :gs/a/[a]/ etc.
     # The following could all be one expansion, but for readability:
     wild=$wild:gs/a/aA/:gs/b/bB/:gs/c/cC/:gs/d/dD/:gs/e/eE/:gs/f/fF/
     wild=$wild:gs/g/gG/:gs/h/hH/:gs/i/iI/:gs/j/jJ/:gs/k/kK/:gs/l/lL/
Index: Misc/lete2ctl
===================================================================
RCS file: /extra/cvsroot/zsh/zsh-3.1/Misc/lete2ctl,v
retrieving revision 1.1.1.4
retrieving revision 1.4
diff -u -r1.1.1.4 -r1.4
--- lete2ctl	1998/12/14 17:00:24	1.1.1.4
+++ lete2ctl	1998/10/31 10:26:39	1.4
@@ -9,6 +9,7 @@
 # Runs as a filter.  Should ignore anything which isn't a "complete".
 # It expects each "complete" statement to be the first thing on a line.
 # All the examples in the tcsh manual give sensible results.
+# Author:  Peter Stephenson <pws@ibmth.df.unipi.it>
 #
 # Option:
 # -x (exact): only applies in the case of command disambiguation (is
@@ -38,6 +39,11 @@
 # (5) Make sure all command names with wildcards are processed together --
 #     they need to be lumped into one "compctl -C" or "compctl -D"
 #     statement for zsh.
+# (6) Group completion (complete's g flag) is not built into zsh, so
+#     you need perl to be available to generate the groups.  If this
+#     script is useful, I assume that's not a problem.
+# (7) I don't know what `completing completions' means, so the X
+#     flag to complete is not handled.
 
 # Handle options
 if (@ARGV) {
@@ -113,6 +119,13 @@
 # Nothing (n) can be handled by returning nothing.  (C.f. King Lear, I.i.)
     if ($c =~ /[abcjuv]/) {
 	$ret = "-$c";
+    } elsif ($c eq 'C') {
+	if (defined($glob)) {
+	    $ret = "-W $glob -/g '*(.*)'";
+	    undef($glob);
+	} else {
+	    $ret = '-c';
+	}
     } elsif ($c eq 'S') {
 	$ret = '-k signals';
     } elsif ($c eq 'd') {
@@ -121,18 +134,42 @@
 	} else {
 	    $ret = '-/';
 	}
+    } elsif ($c eq 'D') {
+	if (defined($glob)) {
+	    $ret = "-W $glob -/";
+	    undef($glob);
+	} else {
+	    $ret = '-/';
+	}
     } elsif ($c eq 'e') {
 	$ret = '-E';
     } elsif ($c eq 'f' && !$glob) {
 	$ret = '-f';
+    } elsif ($c eq 'F') {
+	if (defined($glob)) {
+	    $ret = "-W $glob -f";
+	    undef($glob);
+	} else {
+	    $ret = '-f';
+	}
+    } elsif ($c eq 'g') {
+	$ret = "-s '\$(perl -e '\\''while ((\$name) = getgrent)\n" .
+	    "{ print \$name, \"\\n\"; }'\\'')'";
     } elsif ($c eq 'l') {
 	$ret = q!-k "(`limit | awk '{print $1}'`)"!;
     } elsif ($c eq 'p') {
-	$ret = "-W $glob -f", undef($glob) if defined($glob);
+        $ret = "-W $glob -f", undef($glob) if defined($glob);
     } elsif ($c eq 's') {
-	$ret = '-p';
+        $ret = '-p';
     } elsif ($c eq 't') {
 	$qual = '.';
+    } elsif ($c eq 'T') {
+        if (defined($glob)) {
+            $ret = "-W $glob -g '*(.)'";
+            undef($glob);
+        } else {
+            $ret = "-g '*(.)'";
+        }
     } elsif ($c eq 'x') {
 	$glob =~ s/'/'\\''/g;
 	$ret = "-X '$glob'";
@@ -190,7 +227,7 @@
 
 while (<>) {
     if (/^\s*complete\s/) {
-	undef(@stuff); 
+	undef(@stuff);
 	$default = '';
 	$_ = $';
 	while (/\\$/) {
@@ -211,7 +248,7 @@
 	    # Loop over remaining arguments to "complete".
 	    $sep = substr($word,1,1);
 	    $sep =~ s/(\W)/\\$1/g;
-	    @split = split(/$sep/,$word);
+	    @split = split(/$sep/,$word,4);
 	    for ($i = 0; $i < 3; $i++) {
 		while ($split[$i] =~ /\\$/) {
 		    substr($split[$i],-1,1) = "";
@@ -225,7 +262,9 @@
 		 # The "complete" catch-all:  treat this as compctl\'s
 		 # default (requiring no pattern matching).
 		$default .= &gettype($type) . ' ';
-		defined($suffix) && ($defsuf .= $suffix);
+		defined($suffix) &&
+		    (defined($defsuf) ? ($defsuf .= $suffix)
+		     : ($defsuf = $suffix));
 	    } else {
 		$pat = &getpat($pat,$arg);
 		$type = &gettype($type);
Index: Src/.cvsignore
===================================================================
diff -u -r1.1.1.1 -r1.2
--- .cvsignore	1998/06/01 17:08:44	1.1.1.1
+++ .cvsignore	1998/12/14 22:04:53	1.2
@@ -19,6 +19,7 @@
 libzsh.so*
 sigcount.h
 signames.c
+version.h
 zshpaths.h
 zshxmods.h
 bltinmods.list
Index: Src/Zle/comp.h
===================================================================
RCS file: /extra/cvsroot/zsh/zsh-3.1/Src/Zle/comp.h,v
retrieving revision 1.1.1.2
retrieving revision 1.5
diff -u -r1.1.1.2 -r1.5
--- comp.h	1998/12/14 16:59:07	1.1.1.2
+++ comp.h	1998/11/06 08:18:30	1.5
@@ -98,7 +98,7 @@
 struct compctl {
     int refc;			/* reference count                         */
     Compctl next;		/* next compctl for -x                     */
-    unsigned long mask, mask2;		/* mask of things to complete (CC_*)       */
+    unsigned long mask, mask2;	/* masks of things to complete (CC_*)      */
     char *keyvar;		/* for -k (variable)                       */
     char *glob;			/* for -g (globbing)                       */
     char *str;			/* for -s (expansion)                      */
@@ -110,7 +110,7 @@
     char *withd;		/* for -w (with directory                  */
     char *hpat;			/* for -H (history pattern)                */
     int hnum;			/* for -H (number of events to search)     */
-    char *gname;
+    char *gname;		/* for -J and -V (group name)              */
     Compctl ext;		/* for -x (first of the compctls after -x) */
     Compcond cond;		/* for -x (condition for this compctl)     */
     Compctl xor;		/* for + (next of the xor'ed compctls)     */
@@ -169,7 +169,6 @@
     char *str;			/* the string */
     int count;			/* the number of matches */
     int fcount;			/* number of matches with fignore ignored */
-
 };
 
 /* This describes a group of matches. */

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

