From zsh-workers-return-14105-mason-zsh=primenet.com.au@sunsite.dk Thu Apr 26 12:11:13 2001
Return-Path: <zsh-workers-return-14105-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 26812 invoked from network); 26 Apr 2001 12:11:07 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Apr 2001 12:11:07 -0000
Received: (qmail 14620 invoked by alias); 26 Apr 2001 12:11:02 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14105
Received: (qmail 14607 invoked from network); 26 Apr 2001 12:11:01 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Thu, 26 Apr 2001 14:10:54 +0200 (MET DST)
Message-Id: <200104261210.OAA04730@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: problem with _arguments exclusion lists
In-Reply-To: <20010426110039.34689.qmail@web9305.mail.yahoo.com>

Oliver Kiddle wrote:

> ...
> 
> >   [[ -n "$PREFIX$SUFFIX" ]] 
> 
> I'm not sure about this line at the end. It is not a likely option name
> but, using the usual example, this would prevent a -c0nf option being
> completed from -c0<tab>. In what sort of case did you see it as being
> useful?

In the case you described next: If the word to complete is empty I want
it to both display the message and complete options.  I noticed that
only when I had implemented (before, we were discussing only two cases:
message *or* options).

We could make that optional by giving _guard an option, but I'd still
prefer this as the default behaviour.

> > It might be called as in:
> >   _arguments  -s '(-conf)-c+:numeric value:prop "[0-9]#"' '-conf'
> > '-f'
> 
> Testing this, I get what I thought was -w behaviour only: -c<tab>
> offers:
>   numeric value
>   option
>   -conf   -f
> I thought that it was only going to offer -f if _arguments was passed
> the -w option.

No, -w (now -W since I swapped them), makes it complete options
regardless of the return value of the action.  What you're seeing here
is the new default behaviour of trying to complete options if the
action returns non-zero.

> ...
> 
> I didn't have much in mind. The best I can think of is _guard. I'd
> prefer something short because it will be most used in the generally
> long _arguments specs so I'm not too keen on something like
> _messsage_guarded. Other ideas are _block, _pattern, _failpat.

I was hoping for something short, but still alluding to `matching', in
case we come up with other kinds of tests by which we want to `guard'.
But maybe those could then be integrated into _guard and selected via
options or something.


Bye
  Sven

Index: Completion/Base/Utility/_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/Utility/_arguments,v
retrieving revision 1.3
diff -u -r1.3 _arguments
--- Completion/Base/Utility/_arguments	2001/04/05 12:12:47	1.3
+++ Completion/Base/Utility/_arguments	2001/04/26 12:10:16
@@ -4,7 +4,7 @@
 # descriptions given as arguments to this function.
 
 local long cmd="$words[1]" descr mesg subopts opt usecc autod
-local oldcontext="$curcontext" hasopts rawret optarg singopt
+local oldcontext="$curcontext" hasopts rawret optarg singopt alwopt
 
 long=$argv[(I)--]
 if (( long )); then
@@ -174,21 +174,22 @@
 
 subopts=()
 singopt=()
-while [[ "$1" = -(O*|[CRWs]) ]]; do
+while [[ "$1" = -(O*|[CRWsw]) ]]; do
   case "$1" in
   -C)  usecc=yes; shift ;;
   -O)  subopts=( "${(@P)2}" ); shift 2 ;;
   -O*) subopts=( "${(@P)1[3,-1]}" ); shift ;;
   -R)  rawret=yes; shift;;
-  -W)  optarg=yes; shift;;
+  -w)  optarg=yes; shift;;
   -s)  singopt=(-s); shift;;
+  -W)  alwopt=yes; shift;;
   esac
 done
 
 zstyle -s ":completion:${curcontext}:options" auto-description autod
 
 if (( $# )) && comparguments -i "$autod" "$singopt[@]" "$@"; then
-  local action noargs aret expl local tried
+  local action noargs aret expl local tried ret=1
   local next direct odirect equal single matcher matched ws tmp1 tmp2 tmp3
   local opts subc tc prefix suffix descrs actions subcs anum
   local origpre="$PREFIX" origipre="$IPREFIX" nm="$compstate[nmatches]"
@@ -280,7 +281,8 @@
 
               eval ws\=\( "${action[3,-3]}" \)
 
-              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]"
+              _describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]" ||
+                  alwopt=yes
 	      tried=yes
 
             elif [[ "$action" = \(*\) ]]; then
@@ -289,15 +291,17 @@
 
               eval ws\=\( "${action[2,-2]}" \)
 
-              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws
+              _all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws ||
+                  alwopt=yes
 	      tried=yes
             elif [[ "$action" = \{*\} ]]; then
 
               # A string in braces is evaluated.
 
               while _next_label "$subc" expl "$descr"; do
-                eval "$action[2,-2]"
+                eval "$action[2,-2]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             elif [[ "$action" = \ * ]]; then
 
@@ -305,8 +309,9 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[@]"
+                "$action[@]" && ret=0
               done
+              (( ret )) && alwopt=yes
 	      tried=yes
             else
 
@@ -314,15 +319,17 @@
 
 	      eval "action=( $action )"
               while _next_label "$subc" expl "$descr"; do
-                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}"
+                "$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}" && ret=0
 	      done
+              (( ret )) && alwopt=yes
 	      tried=yes
             fi
           fi
         fi
       done
-
-      if [[ -z "$matched$hasopts" && ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
+      if [[ -z "$hasopts" &&
+            ( -z "$matched" || -n "$alwopt" ) &&
+            ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] &&
           _requested options &&
           { ! zstyle -T ":completion:${curcontext}:options" prefix-needed ||
             [[ "$origpre" = [-+]* || -z "$aret$mesg$tried" ]] } ; then
@@ -378,9 +385,10 @@
 	PREFIX="$prevpre"
 	IPREFIX="$previpre"
       fi
-      [[ -n "$tried" && "$PREFIX" != [-+]* ]] && break
+      [[ -n "$tried" && "${${alwopt:+$origpre}:-$PREFIX}" != [-+]* ]] && break
     done
-    if [[ -n "$opts" && -z "$aret$matched$mesg" &&
+    if [[ -n "$opts" && -z "$aret" &&
+          ( -z "$matched$mesg" || -n "$alwopt" ) &&
           nm -eq compstate[nmatches] ]]; then
 
       PREFIX="$origpre"
Index: Completion/Base/Utility/_guard
===================================================================
RCS file: _guard
diff -N _guard
--- /dev/null	Mon Dec 11 17:26:27 2000
+++ _guard	Thu Apr 26 05:10:16 2001
@@ -0,0 +1,17 @@
+#autoload
+
+local mesg pat garbage
+
+mesg=()
+zparseopts -K -D -a garbage M: J: V: 1 2 n F: X:=mesg 
+
+[[ "$PREFIX$SUFFIX" != $~1 ]] && return 1
+
+if [[ $# -gt 1 || $#mesg -eq 0 ]]; then
+  shift
+  _message "$*"
+else
+  _message -r "$mesg[2]"
+fi
+
+[[ -n "$PREFIX$SUFFIX" ]]
Index: Completion/X/Utility/_x_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_x_arguments,v
retrieving revision 1.2
diff -u -r1.2 _x_arguments
--- Completion/X/Utility/_x_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_x_arguments	2001/04/26 12:10:16
@@ -17,7 +17,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Completion/X/Utility/_xt_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/X/Utility/_xt_arguments,v
retrieving revision 1.2
diff -u -r1.2 _xt_arguments
--- Completion/X/Utility/_xt_arguments	2001/04/04 11:29:22	1.2
+++ Completion/X/Utility/_xt_arguments	2001/04/26 12:10:16
@@ -53,7 +53,7 @@
 fi
 
 opts=()
-while [[ $1 = -(O*|[CRWs]) ]]; do
+while [[ $1 = -(O*|[CRWsw]) ]]; do
   opts=($opts $1)
   [[ $1 = -R ]] && rawret=yes
   shift
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.117
diff -u -r1.117 compsys.yo
--- Doc/Zsh/compsys.yo	2001/04/04 11:29:22	1.117
+++ Doc/Zsh/compsys.yo	2001/04/26 12:10:21
@@ -2930,13 +2930,25 @@
 one option name.  This allows the use of the `tt(-s)' option to describe
 single-letter options together with such long option names.
 
-The tt(-s) option may be combined with the option tt(-W) to say that more
+The tt(-s) option may be combined with the option tt(-w) to say that more
 option characters are to be expected even after an option that takes an
 argument.  For example, if a command takes the options `tt(a)' and `tt(b)',
 where `tt(a)' takes an argument in the next word, tt(_arguments) would
 normally not complete the other option directly after `tt(-a)', but it would
-allow that if given the tt(-W) option.
+allow that if given the tt(-w) option.
 
+Similarly, the option tt(-W) may be given to force completion of options
+even after options that get an argument in the same word.  For example,
+if a command takes the options `tt(a)' and `tt(b)', where `tt(a)' needs
+an argument in the same word, directly after the option character,
+tt(_arguments) would normally only execute the action for that argument
+and not offer other options as possible completions.  If given the
+tt(-W) option, it will offer other options as possible completions after
+executing the action for the argument.  Note that, depending on the
+action, this may mean that the other options can't really be completed,
+but at least they will be listed.  For more control, use an utility
+function like tt(_guard) in the argument's action.
+
 The forms of var(optspec) are:
 
 startitem()
@@ -3498,6 +3510,38 @@
 from the called function is stored in it.
 The return value of tt(_call_function) itself is zero if the function
 var(name) exists and was called and non-zero otherwise.
+)
+findex(_guard)
+item(tt(_guard) [ var(options) ] var(pattern) [ var(descr) ])(
+This function is intended to be used in an action of functions like
+tt(_arguments).  It returns immediately with a non-zero return value if
+the string to be completed does not match the var(pattern).  If the
+pattern matches, the var(descr) is displayed and the function returns
+zero if the word to complete is not empty and non-zero otherwise.
+
+The var(pattern) may be preceded by those options understood by
+tt(compadd) that are passed down from tt(_description), namely tt(-M),
+tt(-J), tt(-V), tt(-1), tt(-2), tt(-n), tt(-F) and tt(-X).  All of these
+options, except tt(-X), will be ignored.  If the tt(-X) option appears,
+the description following it will be used as the string to display if
+the var(pattern) matches, unless the option var(descr) is given to
+tt(_guard) itself, which will then take precedence.
+
+As an example, consider a command taking the options tt(-n) and
+tt(-none), where tt(-n) has to be followed by a numeric value in the
+same word.  By using either of:
+
+example(_argument '-n-:numeric value:_guard "[0-9]#"' '-none')
+
+or
+
+example(_argument '-n-: :_guard "[0-9]#" "numeric value"' '-none')
+
+tt(_arguments) can be made to both display the message `tt(numeric
+value)' and complete options after `tt(-n<TAB>)'.  If the `tt(-n)' is
+already followed by one or more digits (matching the pattern given to
+tt(_guard)), only the message will be displayed and if the `tt(-n)' is
+followed by another character, only options are completed.
 )
 findex(_message)
 item(tt(_message) [ -r ] var(descr))(
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.49
diff -u -r1.49 computil.c
--- Src/Zle/computil.c	2001/04/25 09:05:12	1.49
+++ Src/Zle/computil.c	2001/04/26 12:10:27
@@ -1941,7 +1941,12 @@
     case 's':
 	for (; lstate; lstate = lstate->snext)
 	    if (lstate->d->single && lstate->singles &&
-		lstate->actopts && lstate->opt) {
+		lstate->actopts
+#if 0
+                /* let's try without, for the -W option of _arguments */
+                && lstate->opt
+#endif
+                ) {
 		setsparam(args[1],
 			  ztrdup((lstate->ddef && lstate->dopt) ?
 				 (lstate->dopt->type == CAO_DIRECT ?

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

