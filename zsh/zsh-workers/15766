From zsh-workers-return-15766-mason-zsh=primenet.com.au@sunsite.dk Sun Sep 09 09:37:14 2001
Return-Path: <zsh-workers-return-15766-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29319 invoked from network); 9 Sep 2001 09:37:12 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Sep 2001 09:37:12 -0000
Received: (qmail 18846 invoked by alias); 9 Sep 2001 09:37:02 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15766
Received: (qmail 18832 invoked from network); 9 Sep 2001 09:37:01 -0000
Date: Sun, 9 Sep 2001 05:36:55 -0400
From: Clint Adams <clint@zsh.org>
To: zsh-workers@sunsite.dk
Subject: PATCH: ztcp -l
Message-ID: <20010909053655.A5133@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i

This is riddled with problems, but now you can listen on a tcp port
by doing

ztcp -l 1234

ztcp will wait for the first connection to that port and
then try to stop listening.

Index: Src/Modules/tcp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.c,v
retrieving revision 1.6
diff -u -r1.6 tcp.c
--- Src/Modules/tcp.c	2001/09/08 22:08:05	1.6
+++ Src/Modules/tcp.c	2001/09/09 09:31:39
@@ -89,11 +89,11 @@
 mod_export char const *
 zsh_inet_ntop(int af, void const *cp, char *buf, size_t len)
 {       
-    if(af != AF_INET) {
+    if (af != AF_INET) {
 	errno = EAFNOSUPPORT;
 	return NULL;
     } 
-    if(len < INET_ADDRSTRLEN) {
+    if (len < INET_ADDRSTRLEN) {
 	errno = ENOSPC;
 	return NULL;
     }
@@ -111,14 +111,11 @@
 #endif /* !HAVE_INET_NTOP */
 
 /**/
-#ifndef HAVE_INET_PTON
-
-/**/
-# ifndef HAVE_INET_ATON
+#ifndef HAVE_INET_ATON
 
-#  ifndef INADDR_NONE
-#   define INADDR_NONE 0xffffffffUL
-#  endif
+# ifndef INADDR_NONE
+#  define INADDR_NONE 0xffffffffUL
+# endif
 
 /**/
 mod_export int zsh_inet_aton(char const *src, struct in_addr *dst)
@@ -133,13 +130,16 @@
 # define zsh_inet_aton inet_aton
 
 /**/
-# endif /* !HAVE_INET_ATON */
+#endif /* !HAVE_INET_ATON */
 
 /**/
+#ifndef HAVE_INET_PTON
+
+/**/
 mod_export int
 zsh_inet_pton(int af, char const *src, void *dst)
 {
-    if(af != AF_INET) {
+    if (af != AF_INET) {
 	errno = EAFNOSUPPORT;
 	return -1;
     }
@@ -163,7 +163,7 @@
 mod_export struct hostent *
 zsh_gethostbyname2(char const *name, int af)
 {
-    if(af != AF_INET) {
+    if (af != AF_INET) {
 	h_errno = NO_RECOVERY;
 	return NULL;
     }
@@ -196,7 +196,7 @@
     static char pbuf[INET_ADDRSTRLEN];
 # endif
     struct hostent *he;
-    if(zsh_inet_pton(af, name, nbuf) == 1) {
+    if (zsh_inet_pton(af, name, nbuf) == 1) {
 	zsh_inet_ntop(af, nbuf, pbuf, sizeof(pbuf));
 	ahe.h_name = pbuf;
 	ahe.h_aliases = addrlist+1;
@@ -206,7 +206,7 @@
 	return &ahe;
     }
     he = zsh_gethostbyname2(name, af);
-    if(!he)
+    if (!he)
 	*errorp = h_errno;
     return he;
 }
@@ -247,12 +247,12 @@
     Tcp_session sess;
 
     sess = (Tcp_session)zcalloc(sizeof(struct tcp_session));
-    if(!sess) return NULL;
+    if (!sess) return NULL;
     sess->fd=-1;
     sess->next=NULL;
     sess->flags=ztflags;
 
-    if(!zts_head()) {
+    if (!zts_head()) {
 	ztcp_head = ztcp_tail = sess;
     }
     else {
@@ -268,7 +268,7 @@
     Tcp_session sess;
 
     sess = zts_alloc(ztflags);
-    if(!sess) return NULL;
+    if (!sess) return NULL;
 
     sess->fd = socket(domain, type, protocol);
     return sess;
@@ -281,7 +281,7 @@
 
     tsess = zts_head();
 
-    if(tsess == sess)
+    if (tsess == sess)
     {
 	ztcp_head = sess->next;
 	free(sess);
@@ -293,7 +293,7 @@
 	tsess = zts_next(tsess);
     }
 
-    if(!tsess->next) return 1;
+    if (!tsess->next) return 1;
 
     tsess->next = tsess->next->next;
     free(tsess->next);
@@ -309,7 +309,7 @@
     tsess = zts_head();
 
     do {
-	if(tsess->fd == fd)
+	if (tsess->fd == fd)
 	    return tsess;
 
 	tsess = zts_next(tsess);
@@ -338,10 +338,10 @@
 {
     int err;
     
-    if(sess->fd != -1)
+    if (sess->fd != -1)
     {  
 	err = close(sess->fd);
-	if(err)
+	if (err)
 	{
 	    zwarn("connection close failed: %e", NULL, errno);
 	    return -1;
@@ -358,7 +358,7 @@
 {
     int salen;
 #ifdef SUPPORT_IPV6
-    if(zhost->h_addrtype==AF_INET6) {
+    if (zhost->h_addrtype==AF_INET6) {
 	memcpy(&(sess->peer.in6.sin6_addr), addrp, zhost->h_length);
 	sess->peer.in6.sin6_port = d_port;
 	sess->peer.in6.sin6_flowinfo = 0;
@@ -381,9 +381,9 @@
 static int
 bin_ztcp(char *nam, char **args, char *ops, int func)
 {
-    int herrno, err=1, destport, force=0, verbose=0, len;
-    char **addrp, *desthost;
-    struct hostent *zthost = NULL;
+    int herrno, err=1, destport, force=0, verbose=0, len, rfd;
+    char **addrp, *desthost, *localname, *remotename;
+    struct hostent *zthost = NULL, *ztpeer = NULL;
     Tcp_session sess;
 
     if (ops['f'])
@@ -400,9 +400,9 @@
 	    int targetfd = atoi(args[0]);
 	    sess = zts_byfd(targetfd);
 
-	    if(sess)
+	    if (sess)
 	    {
-		if((sess->flags & ZTCP_ZFTP) && !force)
+		if ((sess->flags & ZTCP_ZFTP) && !force)
 		{
 		    zwarnnam(nam, "use -f to force closure of a zftp control connection", NULL, 0);
 		    return 1;
@@ -418,16 +418,93 @@
 	    }
 	}
     }
+    else if (ops['l']) {
+	int lport;
+
+	if (!args[0]) {
+	    zwarnnam(nam, "-l requires an argument", NULL, 0);
+	    return 1;
+	}
+	lport = atoi(args[0]);
+	if (!lport) {
+	    zwarnnam(nam, "bad port number", NULL, 0);
+	    return 1;
+	}
+	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, 0);
+
+	if (!sess) {
+	    zwarnnam(nam, "unable to allocate a TCP session slot", NULL, 0);
+	    return 1;
+	}
+#ifdef SO_OOBINLINE
+	len = 1;
+	setsockopt(sess->fd, SOL_SOCKET, SO_OOBINLINE, (char *)&len, sizeof(len));
+#endif
+	if (!zsh_inet_aton("0.0.0.0", &(sess->sock.in.sin_addr)))
+	{
+	    zwarnnam(nam, "bad address: %s", "0.0.0.0", 0);
+	    return 1;
+	}
+
+	sess->sock.in.sin_family = AF_INET;
+	sess->sock.in.sin_port = htons(lport);
+
+
+	if (bind(sess->fd, (struct sockaddr *)&sess->sock.in, sizeof(struct sockaddr_in)))
+	{
+	    zwarnnam(nam, "could not bind to %s: %e", "0.0.0.0", errno);
+	    tcp_close(sess);
+	    return 1;
+	}
+
+	if (listen(sess->fd, 1))
+	{
+	    zwarnnam(nam, "could not listen on socket: %e", NULL, errno);
+	    tcp_close(sess);
+	    return 1;
+	}
+
+	if ((rfd = accept(sess->fd, (struct sockaddr *)&sess->peer.in, &len)) == -1)
+	{
+	    zwarnnam(nam, "could not accept connection: %e", NULL, errno);
+	    tcp_close(sess);
+	    return 1;
+	}
+
+	/* move the fd since it doesn't seem to be closing well */
+	sess->fd = movefd(sess->fd);
+
+	err = close(sess->fd);
+	if (err)
+	{
+	    zwarn("listener close failed: %e", NULL, errno);
+	    return -1;
+	}
+	sess->fd = rfd;
+
+	fprintf(shout, "%d is on fd %d\n", ntohs(sess->peer.in.sin_port), sess->fd);
+
+	return 0;
+
+    }
     else {
 	
 	if (!args[0]) {
 	    for(sess = zts_head(); sess != NULL; sess = zts_next(sess))
 	    {
-		if(sess->fd != -1)
+		if (sess->fd != -1)
 		{
-		    zthost = gethostbyaddr(&(sess->peer.in.sin_addr), sizeof(struct sockaddr_in), AF_INET);
-		    if(zthost) fprintf(shout, "%s:%d is on fd %d%s\n", zthost->h_name, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "");
-		    else fprintf(shout, "%s:%d is on fd %d%s\n", "UNKNOWN", sess->peer.in.sin_port, sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "");
+		    zthost = gethostbyaddr(&(sess->sock.in.sin_addr), sizeof(struct sockaddr_in), AF_INET);
+		    if (zthost)
+			localname = zthost->h_name;
+		    else
+			localname = ztrdup(inet_ntoa(sess->sock.in.sin_addr));
+		    ztpeer = gethostbyaddr(&(sess->peer.in.sin_addr), sizeof(struct sockaddr_in), AF_INET);
+		    if (ztpeer)
+			remotename = ztpeer->h_name;
+		    else
+			remotename = ztrdup(inet_ntoa(sess->sock.in.sin_addr));
+		    fprintf(shout, "%s:%d -> %s:%d is on fd %d%s%s\n", localname, ntohs(sess->sock.in.sin_port), remotename, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "", (sess->flags & ZTCP_INBOUND) ? "INBOUND" : "");
 		}
 	    }
 	    return 0;
@@ -448,15 +525,17 @@
 	}
 	
 	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, 0);
+
+	if (!sess) {
+	    zwarnnam(nam, "unable to allocate a TCP session slot", NULL, 0);
+	    return 1;
+	}
+
 #ifdef SO_OOBINLINE
 	len = 1;
 	setsockopt(sess->fd, SOL_SOCKET, SO_OOBINLINE, (char *)&len, sizeof(len));
 #endif
 
-	if(!sess) {
-	    zwarnnam(nam, "unable to allocate a TCP session slot", NULL, 0);
-	    return 1;
-	}
 	if (sess->fd < 0) {
 	    zwarnnam(nam, "socket creation failed: %e", NULL, errno);
 	    zsfree(desthost);
@@ -465,18 +544,18 @@
 	}
 	
 	for (addrp = zthost->h_addr_list; err && *addrp; addrp++) {
-	    if(zthost->h_length != 4)
+	    if (zthost->h_length != 4)
 		zwarnnam(nam, "address length mismatch", NULL, 0);
 	    do {
 		err = tcp_connect(sess, *addrp, zthost, htons(destport));
 	    } while (err && errno == EINTR && !errflag);
 	}
 	
-	if(err)
+	if (err)
 	    zwarnnam(nam, "connection failed: %e", NULL, errno);
 	else
 	{
-	    if(verbose)
+	    if (verbose)
 		fprintf(shout, "%s:%d is now on fd %d\n", desthost, destport, sess->fd);
 	    else
 		fprintf(shout, "%d\n", sess->fd);
@@ -490,7 +569,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("ztcp", 0, bin_ztcp, 0, 2, 0, "c", NULL),
+    BUILTIN("ztcp", 0, bin_ztcp, 0, 2, 0, "cflv", NULL),
 };
 
 /* The load/unload routines required by the zsh library interface */
Index: Src/Modules/tcp.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.h,v
retrieving revision 1.3
diff -u -r1.3 tcp.h
--- Src/Modules/tcp.h	2001/09/08 21:09:56	1.3
+++ Src/Modules/tcp.h	2001/09/09 09:31:39
@@ -72,6 +72,7 @@
 
 typedef struct tcp_session *Tcp_session;
 
+#define ZTCP_INBOUND 1
 #define ZTCP_ZFTP 16
 
 struct tcp_session {

