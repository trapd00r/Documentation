From zsh-users-return-14764-mason-zsh=primenet.com.au@zsh.org Sun Jan 31 23:43:18 2010
Return-Path: <zsh-users-return-14764-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21689 invoked by alias); 31 Jan 2010 23:43:18 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14764
Received: (qmail 14029 invoked from network); 31 Jan 2010 23:43:17 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100131154300.ZM4019@torch.brasslantern.com>
Date: Sun, 31 Jan 2010 15:43:00 -0800
In-reply-to: <87iqaikkfv.fsf@ft.bewatermyfriend.org>
Comments: In reply to Frank Terbeck <ft@bewatermyfriend.org>
 "Re: Binding Home and End" (Jan 31, 10:56pm)
References: <20100127165843.GA4832@fermat.math.technion.ac.il>
	<20100128213354.0dd08dd2@pws-pc>	<87mxzwsi54.fsf@ft.bewatermyfriend.org>
	<237967ef1001291351h6ce2d3b4o8204833df57e2ccb@mail.gmail.com>
	<87iqajsulg.fsf@ft.bewatermyfriend.org>	<20100131201022.3a71d672@pws-pc>
	<87iqaikkfv.fsf@ft.bewatermyfriend.org>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Binding Home and End
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Jan 31, 10:56pm, Frank Terbeck wrote:
}
} Does somebody on the list actually know why such a distinction was made
} at all? And why it would make sense to have a key like `HOME' send
} different bytes depending on which mode is active?

I'm probably propagating a bit of hearsay here, so don't take this as
gospel ... I haven't been able to confirm any of it by Google search,
but haven't been able to refute it either ...

Way back in the '80s when the unix terminal drivers and the original
"curses" packages were being invented, graphical windowing systems were
rare to non-existent.  Most computers were time-sharing systems accessed
via big cathode-ray-tube TV-set-like devices with built in keyboards,
which were called "terminals".  These were the same "terminals" that
were used for doing all kinds of data-entry and lookup tasks on mainframe 
computers running Unisys and IBM operating systems and other things most
of you probably never heard of and will never see.

There were no such things as mice; all cursor motion had to be controlled
with arrow keys on the keyboard or coded sequences from the application.

Data entry was often done using forms that filled the entire screen (all
80 columns and 24 lines of it, sometimes less, sometimes as many as 132
columns), laid out something like HTML forms, with labeled input fields;
but the application had to track the location of the cursor to know what
data was being entered in what field.

In other cases the application didn't really care where the cursor was,
the user of the terminal could move it around for his own purposes.

Consequently keyboards frequently had two operation modes:  One in which
the key press would cause the terminal's internal hardware to move the
cursor as well as send a sequence, and one where the character sequence
left the cursor unmoved but sent codes meant to be trapped so that the
application could later control the movement of the cursor.  When you
only had a few hundred baud of bandwidth to work with, moving the
cursor without having to transmit data in both directions might be a
huge benefit.

An application that needed to map the entire screen for data entry would
put the terminal in "application transmit mode" so that it could control
the cursor placement, and possibly optimize the instructions that it had
to send back to the terminal to move the cusor from field to field rather
than just one character up/down/left/right, again in the name of saving
precious bandwidth.

On top of this, many terminals had keypads that could be turned on and
off, the kind you still see on most PC keyboards with numbers and arrow
(and home/end/pgup/pgdn) keys overlaid.  "Newer" keyboards that had both
a separate set of arrow and paging keys along with a keypad could be
switched to have all the keys send distinct codes or to have the keypad
arrows send the same codes as the stand-alone arrow keys.  Others had
whole additional keypads for text editing operations, function key labels
overlaid on the paging keys, etc.  So there were all sorts of control
sequences that changed which keys sent what codes in what circumstances.
Sometimes there were custom hardware terminals for specific software
applications.

The termcap and terminfo databases and eventually a standard were all
developed to try to keep track of and make sensible use of all of this
complexity, and by now some of the distinctions and special cases have
mostly fallen into disuse ... but we're still left with emulators that
employ the standards and support the quirks of those old terminals.

