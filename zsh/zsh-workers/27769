From zsh-workers-return-27769-mason-zsh=primenet.com.au@zsh.org Thu Mar 04 00:00:31 2010
Return-Path: <zsh-workers-return-27769-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 14186 invoked by alias); 4 Mar 2010 00:00:31 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 27769
Received: (qmail 19481 invoked from network); 4 Mar 2010 00:00:20 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at brasslantern.com does not designate permitted sender hosts)
Date: Wed, 3 Mar 2010 15:00:12 -0800 (PST)
From: Bart Schaefer <schaefer@brasslantern.com>
Reply-To: Bart Schaefer <schaefer@brasslantern.com>
To: zsh-workers@zsh.org
Subject: Re: Re: variable expansion and "word"s (fwd)
Message-ID: <alpine.LRH.2.00.1003031458070.8102@toltec.zanshin.com>
User-Agent: Alpine 2.00 (LRH 1167 2008-08-23)
X-Face: "f/X=UCVgd*^c>+x(gMq0at?e:woX+;'snkkRzc3SX<0AZ (/PS4.M2hzGS9X:Qj]at_H/%a9K}:-eS<"v_7vX84PG9Bf Zpb`wI!I4geY=or+nWq`3CX`oq&TJR;g^ps|7(MH?jh;bs %vHJfCh5>a*6Re5m|Bidja\\o]>n\A)ib1:yX*T`zR(*h~ %tOw<~!D9{e6h!8M2:d8G2@K>y^1I_Vdy\d\MYe]z7c
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

Discussion about how ${...} behaves with respect to quotes.  The direction
being chosen here may disagree with what zsh implements.  (I think it's
insane that "${var-"*} would ever have been syntactically sensible, but
oh well.)


---------- Forwarded message ----------
Date: Wed, 3 Mar 2010 10:41:01 -0500
From: David Korn <dgk@research.att.com>
To: austin-group-l@opengroup.org
Subject: Re: Re: variable expansion and "word"s
Resent-Date: 3 Mar 2010 15:41:38 -0000
Resent-From: austin-group-l@opengroup.org
Resent-To: austin-group-l@opengroup.org

Subject: Re: Re: variable expansion and "word"s
--------

> I'm working on a new proposal for this section, but I've hit a
> stumbling block over single-quotes.  There are two possible
> behaviours (remember this is the case where the whole expansion
> is within double-quotes):
>
> 1. Single-quotes are not special.  In this case, there should
> be no need to disallow unmatched single-quotes.  (Unless they
> are within nested double-quotes, but my proposal will say the
> behaviour is unspecified if there are nested double-quotes.)
>
> 2. Single-quotes are special.  In this case they must match,
> but since they are special they must also be removed during
> quote removal.
>
> I believe all the modern shells exhibit one or other of these
> behaviours with one exception: bash.  In some situations it
> treats single-quotes as special but it doesn't remove them
> during quote removal.  E.g. here the single-quotes quote
> the } inside them but they are not removed:
>
> $ printf '%s\n' "${IFS+a'}'b}"
> a'}'b
>
> The choices for updating the standard are either to allow both
> behaviours 1 and 2 or to require behaviour 1.  Since bash will
> need to change either way, my inclination is that we should
> require behaviour 1.
>
> --
> Geoff Clare <g.clare@opengroup.org>
> The Open Group, Thames Tower, Station Road, Reading, RG1 1LX, England
>
>

I don't think that either of these are correct.

First of all there are two issues:
1.	How is the closing brace found when tokenizing.
	I think that this should be independent of whether the ${} is inside
	"" or not.  Rule 2 should be used and braces must nest unless quoted
	or escaped.
2.	How are quote characters treated when the expansion occurs.
	I think that in this case +, - = and ? have to be treated differently
	than %, %%, # and ##.
	 %, %%, # and ## should follow rule 2.
The other operators need to be treated differently for backward compatibility.

In the Bourne Shell,
	"${var op word}"
was treated as if it was
	"${var}" op "word"
where op determined whether word was was used or skipped.  In other words
implied double quotes was placed around word.  Bourne did not require matching
quotes inside ${} (unlike the standard), so that
	"${var-"*}
would be used to get either
	"${var}" or *
with file name generation performed on *.

Therefore, for the operators + - ? and =, word should be treated with
the double quote rules except that \ can be used to esacpe a brace
character that is not a closing brace.

For the example you gave,
	printf '%s\n' "${IFS+a'}'b}"
the Bourne shell would give
	a''b}

Since the first } would terminate the ${} and the 'b} would just be
part of the quoted string.

ksh88 and ksh93 are compatible with Bourne shell.

It uses rule 2 for parsing so that it thinks that the last } terminates
${...}, but when it goes to expand, it finds the first brace and uses
that as the terminator.

My recommendation is to adopt rule 1 as far as tokenizing is concerned
and for the operators + - = ?, leave it unspecified as to whether
' is special or not.

David Korn
dgk@research.att.com

