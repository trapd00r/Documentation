From zsh-workers-return-10641-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Apr 11 09:37:39 2000
Return-Path: <zsh-workers-return-10641-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3302 invoked from network); 11 Apr 2000 09:37:21 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Apr 2000 09:37:21 -0000
Received: (qmail 26945 invoked by alias); 11 Apr 2000 09:37:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10641
Received: (qmail 26928 invoked from network); 11 Apr 2000 09:37:08 -0000
Date: Tue, 11 Apr 2000 11:36:59 +0200 (MET DST)
Message-Id: <200004110936.LAA04342@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 11 Apr 2000 00:49:41 +0000
Subject: Re: Time for an obscure completion question


Bart Schaefer wrote:

> Given the completion styles (straight out of compinstall except for moving
> the _ignored completer):
> 
> zstyle ':completion:*' completer _oldlist _expand _complete _match _ignored _approximate _prefix
> zstyle ':completion:*' match-original both
> zstyle ':completion:*' matcher-list '' 'r:|[._-,]=* r:|=*' 'm:{a-zA-Z}={A-Za-z} r:|[._-,]=* r:|=*' 'r:|[._-,]=* r:|=* l:|=*'
> zstyle ':completion:*' max-errors 2 numeric
> zstyle ':completion:*' original true
> 
> If I have a directory named "foodatthe/Bar" (to borrow from PWS) and I type:
> 
> zsh% cd *at/ba<TAB>
> 
> I'm offered the two completions
> 
> foodatthe/    *at/ba
> 
> This is apparently what I asked for, but it's not what I want. I want the
> "original" as considered by _approximate to be the output (for lack of a
> better word) of _expand _complete _match.  That is, if there's exactly one
> possible expansion of the part with the pattern, then I want that accepted
> so that the menu becomes:
> 
> foodatthe/Bar   foodatthe/ba

[ Aside: whenever I see such requests I wonder what comes next... ;-]

The `foodatthe/' comes from _approximate. Bummer. _match kept itself
from being called more than once (for different matchers), even though 
I changed the completion code to at least partly handle the mixture of 
pattern-matching and match-specs some time ago. The patch comments out 
the match-spec-number test in _match. With that you get `foodatthe/ba' 
on the line. The reason that it doesn't complete the `ba' to `Bar' is
that _path_files stops when the first component with a pattern is
reached and that adding the whole string, with one part needing
pattern matching and the other part needing the match spec can't
behandled by the completion code. But the next TAB gives you
`foodatthe/Bar/'.

Hm.

> Ignoring that for the moment ... if I type
> 
> zsh% cd *at/ba<C-x h>
> 
> i.e., invoke completion help, I see a set of contexts and then the possible
> completions at the end.  So far so good, 

No, the completions (corrections) shouldn't be shown. I'm a bit
confused why I didn't see that before. The patch makes _approximate
don't redefine compadd() if it is already a function. This is ok for
_complete_help, if we ever come up with another function that defines
a compadd() function, we'll have to rethink this.

> but now if I hit TAB the argument
> gets erased and I'm left with
> 
> zsh% cd 
>         ^ cursor here
> 
> A similar thing happens here:
> 
> zsh% cd *at/ba<TAB><C-e><TAB><TAB><TAB>
> zsh% cd  
>          ^cursor
> 
> The first TAB gives "foodatthe/ba" and lists two completions; I hit C-e to
> break out of menu completion (is there a better way?) and TAB again which
> gives me the correction "foodatthe/Bar/" and again lists two completions.
> Hit TAB again and there's a feep; hit TAB a third time and the argument
> vanishes, replaced by a space.  I would have expected it to just keep on
> feeping at me for as long as I bang on tab.

Both should be fixed now. The first one was caused by _oldlist which
took the list from _complete_help. For now I made _oldlist test if the 
last widget was _complete_help and ignore the list in that case. It
was already testing widget names, but for a somewhat cleaner solution
we probably should use a new element in $_lastcomp that is set if the
list is generated by some `special' function and should not be used by 
any other completion function.
The second one I couldn't reproduce after having fixed the other
things...

Bye
 Sven

Index: Completion/Core/_approximate
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_approximate,v
retrieving revision 1.2
diff -u -r1.2 _approximate
--- Completion/Core/_approximate	2000/04/01 20:43:43	1.2
+++ Completion/Core/_approximate	2000/04/11 09:35:42
@@ -10,7 +10,7 @@
 
 [[ _matcher_num -gt 1 || "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1
 
-local _comp_correct _correct_expl comax cfgacc
+local _comp_correct _correct_expl comax cfgacc redef
 local oldcontext="${curcontext}" opm="$compstate[pattern_match]"
 
 zstyle -s ":completion:${curcontext}:" max-errors cfgacc || cfgacc='2 numeric'
@@ -40,17 +40,20 @@
 # to stick the `(#a...)' in the right place (after an
 # ignored prefix).
 
-compadd() {
-  [[ ${argv[(I)-[a-zA-Z]#U[a-zA-Z]#]} -eq 0 &&
-     "${#:-$PREFIX$SUFFIX}" -le _comp_correct ]] && return
-
-  if [[ "$PREFIX" = \~*/* ]]; then
-    PREFIX="${PREFIX%%/*}/(#a${_comp_correct})${PREFIX#*/}"
-  else
-    PREFIX="(#a${_comp_correct})$PREFIX"
-  fi
-  builtin compadd "$_correct_expl[@]" "$@"
-}
+if (( ! $+functions[compadd] )); then
+  redef=yes
+  compadd() {
+    [[ ${argv[(I)-[a-zA-Z]#U[a-zA-Z]#]} -eq 0 &&
+       "${#:-$PREFIX$SUFFIX}" -le _comp_correct ]] && return
+
+    if [[ "$PREFIX" = \~*/* ]]; then
+      PREFIX="${PREFIX%%/*}/(#a${_comp_correct})${PREFIX#*/}"
+    else
+      PREFIX="(#a${_comp_correct})$PREFIX"
+    fi
+    builtin compadd "$_correct_expl[@]" "$@"
+  }
+fi
 
 _comp_correct=1
 
@@ -81,7 +84,7 @@
       [[ "$compstate[list]" != list* ]] &&
           compstate[list]="$compstate[list] force"
     fi
-    unfunction compadd
+    [[ -n "$redef" ]] && unfunction compadd
     compstate[pattern_match]="$opm"
 
     return 0
@@ -91,7 +94,7 @@
   (( _comp_correct++ ))
 done
 
-unfunction compadd
+[[ -n "$redef" ]] && unfunction compadd
 compstate[pattern_match]="$opm"
 
 return 1
Index: Completion/Core/_match
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_match,v
retrieving revision 1.2
diff -u -r1.2 _match
--- Completion/Core/_match	2000/04/01 20:43:43	1.2
+++ Completion/Core/_match	2000/04/11 09:35:42
@@ -9,7 +9,7 @@
 # expand-or-complete function because otherwise the pattern will
 # be expanded using globbing.
 
-[[ _matcher_num -gt 1 ]] && return 1
+### Shouldn't be needed any more: [[ _matcher_num -gt 1 ]] && return 1
 
 local tmp opm="$compstate[pattern_match]" ret=0 orig ins
 
Index: Completion/Core/_oldlist
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_oldlist,v
retrieving revision 1.2
diff -u -r1.2 _oldlist
--- Completion/Core/_oldlist	2000/04/01 20:43:43	1.2
+++ Completion/Core/_oldlist	2000/04/11 09:35:42
@@ -13,7 +13,8 @@
 # Do this also if there is an old list and it was generated by the
 # completer named by the oldlist_list key.
 
-if [[ -n $compstate[old_list] && $list != never ]]; then
+if [[ -n $compstate[old_list] && $list != never &&
+      $LASTWIDGET != _complete_help ]]; then
   if [[ $WIDGET = *list* && ( $list = always || $list != shown ) ]]; then
     compstate[old_list]=keep
     return 0
@@ -33,8 +34,10 @@
 # and the style :oldlist:old-menu is `true', then we cycle through the
 # existing list (even if it was generated by another widget).
 
-if [[ -z $compstate[old_insert] && -n $compstate[old_list] ]]; then
+if [[ -z $compstate[old_insert] && -n $compstate[old_list] &&
+      $LASTWIDGET != _complete_help ]]; then
   compstate[old_list]=keep
+  return 0
 elif [[ $WIDGET = *complete(|-prefix|-word) ]] &&
      zstyle -t ":completion:${curcontext}:" old-menu; then
   if [[ -n $compstate[old_insert] ]]; then

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

