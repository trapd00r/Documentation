From zsh-workers-return-7038-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Jul 08 12:28:22 1999
Return-Path: <zsh-workers-return-7038-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3868 invoked from network); 8 Jul 1999 12:28:20 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Jul 1999 12:28:20 -0000
Received: (qmail 3176 invoked by alias); 8 Jul 1999 12:28:12 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7038
Received: (qmail 3169 invoked from network); 8 Jul 1999 12:28:11 -0000
Message-Id: <9907081159.AA09256@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk
Subject: Re: PATCH: pws-25: _read_comp, again 
In-Reply-To: "Sven Wischnowsky"'s message of "Thu, 08 Jul 1999 13:48:37 DFT."
             <199907081148.NAA12179@beta.informatik.hu-berlin.de> 
Date: Thu, 08 Jul 1999 13:59:29 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

Sven Wischnowsky wrote:
> For me it correctly returns `1' as the return status. The problem is
> that the signal handler for SIGINT sets `breaks=loops' and since the
> second read is in a loop the then-clause will never be executed
> (because of the test of the while-loop in `execlist()').

You're right, I realised eventually it was doing something fishier, but I
didn't get as far as finding out what.

> Hm. What are we to do here -- should we reset some of the things
> changed by the signal handler in bin_read()? Do we always want that?

I don't think an ordinary read is affected, since that would leave errflag
as 1 and hence abort the whole function, which is correct in that case ---
though I think we can take it as a feature that reading a key via zle
doesn't abort the function on a keyboard interrupt.  The problem is the way
it does it: zleread() sets errflag only back to zero.  Presumably it
should also restore breaks as well when it does that.  Is it that simple?
The second chunk is for vared, which does the same thing --- chances are
any interrupt occurred in the read, so that restoring breaks is already
covered, but this is safer.

--- Src/Zle/zle_main.c.bks	Wed Jul  7 09:32:05 1999
+++ Src/Zle/zle_main.c	Thu Jul  8 13:44:22 1999
@@ -307,7 +307,7 @@
     unsigned int ret;
     long exp100ths;
     int die = 0, r, icnt = 0;
-    int old_errno = errno;
+    int old_errno = errno, obreaks = breaks;
 
 #ifdef HAVE_SELECT
     fd_set foofd;
@@ -397,6 +397,7 @@
 		if (!errflag && !retflag && !breaks)
 		    continue;
 		errflag = 0;
+		breaks = obreaks;
 		errno = old_errno;
 		return EOF;
 	    } else if (errno == EWOULDBLOCK) {
@@ -717,7 +718,7 @@
     Value v;
     Param pm = 0;
     int create = 0;
-    int type = PM_SCALAR;
+    int type = PM_SCALAR, obreaks = breaks;
     char *p1 = NULL, *p2 = NULL;
 
     if (zleactive) {
@@ -809,6 +810,7 @@
     if (!t || errflag) {
 	/* error in editing */
 	errflag = 0;
+	breaks = obreaks;
 	return 1;
     }
     /* strip off trailing newline, if any */

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

