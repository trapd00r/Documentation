From zsh-workers-return-9058-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Dec 15 15:26:54 1999
Return-Path: <zsh-workers-return-9058-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17767 invoked from network); 15 Dec 1999 15:26:51 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Dec 1999 15:26:51 -0000
Received: (qmail 727 invoked by alias); 15 Dec 1999 15:26:39 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9058
Received: (qmail 720 invoked from network); 15 Dec 1999 15:26:38 -0000
Date: Wed, 15 Dec 1999 16:26:37 +0100 (MET)
Message-Id: <199912151526.QAA07059@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: cleanup


This is mainly a reply to Peter's...

The less interesting things first:

- Fix for the docs: the `complete' style is really named `completions' 
  (as noted by Peter).
- A small fix for the comment in _combination ($opt_args instead of
  $options).
- A fix for _cd: if $cdpath contained `.', the directories in the cwd
  were listed twice.
- (It gets more interesting now...) The prefix-needed style is ignored 
  now when it seems sensible, i.e. it inhibits generation of the
  matches with the prefix only if there are no other matches
  generated. For _jobs this meant to make it be always tried last (and 
  to give it a new option `-t' that says if the test is to be
  performed at all).
  I haven't changed _apt and _socket yet. The former because I don't
  know enough about it to be sure that a simple test of the form
  [[ nm -eq compstate[nmatches] ]] is enough to be sure that there are 
  other matches, etc. In _socket there is another problem, because a
  additional option is generated explicitly. But that isn't that
  dramatic given the fact that this option is `-version'. Maybe we
  should just change the argument-list for _arguments under the
  condition which now triggers adding the `-version'.
- I replaced the `strings' style with `numbers'. As a reminder: this
  says if jobs are to be completed as %1 or %foo. This also means that 
  the default is now to complete them as %foo. To get numbers, one can 
  set the style to true.
  But there is some more trickery: if the value of the style is a
  number, %foo is only used if the longest string needed for any job
  contains at most N words. E.g. if the style is set to `1' you get
  %foo only if all jobs differ in the first word of their command
  lines.
  I hope this makes everybody happy.
- The tag stuff. First of all, I changed the name of the style to
  `tag-order' to make it more consistent with `group-order'. I hope
  this is ok, or should we rename both to `sort-{groups,tags}'?
  Then I moved the test for the style to _tags. This makes things
  faster, of course, and I don't see any reason to call an extra
  function if that is intended to onlytest one style (and Peter's
  changes to the docs suggested to use the style instead).
  Then I change the interpretion of the value of the style a bit. For
  one, the code will normally add all offered tags as a default. But
  you can turn that off by explicitly adding a string consisting of
  only a minus sign to the value. This is important, I think, because
  it can be quite tedious to always have to list all tags that are
  used in particular contexts.
  And then there is another special value-string format: a string of
  the form `foo()' says that the function `foo' should be called,
  which can then use comptry. I also removed the normal call to
  _sort_tags, so that serves only as an example of how such functions
  can be written.
  Ok, this should give us maximum flexibility. One of the many
  questions is: is `foo()' a nice syntax or are there better ones?


Bye
 Sven

diff -ru ../z.old/Completion/Base/_arguments Completion/Base/_arguments
--- ../z.old/Completion/Base/_arguments	Wed Dec 15 09:58:09 1999
+++ Completion/Base/_arguments	Wed Dec 15 10:31:53 1999
@@ -259,7 +259,8 @@
 
       if [[ -z "$matched" ]] && _requested options &&
           { ! zstyle -t ":completion${curcontext}:options" prefix-needed ||
-            [[ "$origpre" = [-+]* ]] } ; then
+            [[ "$origpre" = [-+]* ||
+               ( -z "$aret$mesg" && nm -eq compstate[nmatches] ) ]] } ; then
 	local prevpre="$PREFIX" previpre="$IPREFIX"
 
 	PREFIX="$origpre"
diff -ru ../z.old/Completion/Base/_combination Completion/Base/_combination
--- ../z.old/Completion/Base/_combination	Wed Dec 15 09:58:09 1999
+++ Completion/Base/_combination	Wed Dec 15 10:25:56 1999
@@ -21,7 +21,7 @@
 #  `_telnet' completes hosts as:
 #
 #    _combination my-accounts hosts-ports-users \
-#      ${options[-l]:+users=${options[-l]:q}} \
+#      ${opt_args[-l]:+users=${opt_args[-l]:q}} \
 #      hosts "$expl[@]"
 #
 #  This completes `host1', `host2', `mail-server', `news-server' and
@@ -31,7 +31,7 @@
 #  `_telnet' completes ports as:
 #
 #    _combination my-accounts hosts-ports-users \
-#      ${options[-l]:+users=${options[-l]:q}} \
+#      ${opt_args[-l]:+users=${opt_args[-l]:q}} \
 #      hosts="${line[2]:q}" \
 #      ports "$expl[@]"
 #
diff -ru ../z.old/Completion/Base/_command_names Completion/Base/_command_names
--- ../z.old/Completion/Base/_command_names	Wed Dec 15 09:58:09 1999
+++ Completion/Base/_command_names	Wed Dec 15 10:34:55 1999
@@ -17,11 +17,11 @@
   [[ "$1" = - ]] && shift
 
   defs=( "$defs[@]"
-    'jobs:: _jobs'
     'builtins:builtin command:compadd - ${(@k)builtins}'
     'functions:shell function:compadd - ${(@k)functions}'
     'aliases:alias:compadd - ${(@k)aliases}'
     'reserved-words:reserved word:compadd - ${(@k)reswords}'
+    'jobs:: _jobs -t'
   )
 fi
 
diff -ru ../z.old/Completion/Base/_jobs Completion/Base/_jobs
--- ../z.old/Completion/Base/_jobs	Wed Dec 15 09:58:10 1999
+++ Completion/Base/_jobs	Wed Dec 15 15:50:57 1999
@@ -1,11 +1,14 @@
 #autoload
 
-local expl disp jobs job jids pfx='%' desc
+local expl disp jobs job jids pfx='%' desc how
 
 _tags jobs || return 1
 
-zstyle -t ":completion${curcontext}:jobs" prefix-needed &&
-    [[ "$PREFIX" != %* ]] && return 1
+if [[ "$1" = -t ]]; then
+  zstyle -t ":completion${curcontext}:jobs" prefix-needed &&
+      [[ "$PREFIX" != %* || compstate[nmatches] -eq 0 ]] && return 1
+  shift
+fi
 zstyle -t ":completion${curcontext}:jobs" prefix-hidden && pfx=''
 zstyle -t ":completion${curcontext}:jobs" verbose       && desc=yes
 
@@ -31,8 +34,12 @@
   done
 fi
 
-if zstyle -t ":completion${curcontext}:jobs" strings; then
-  local texts i text str tmp
+zstyle -s ":completion${curcontext}:jobs" numbers how
+
+if [[ "$how" = (yes|true|on|1) ]]; then
+  jobs=( "$jids[@]" )
+else
+  local texts i text str tmp num max=0
 
   # Find shortest unambiguous strings.
 
@@ -47,6 +54,7 @@
       text=""
     fi
     tmp=( "${(@M)texts:#${str}*}" )
+    num=1
     while [[ -n "$text" && $#tmp -ge 2 ]]; do
       str="${str} ${text%% *}"
       if [[ "$text" = *\ * ]]; then
@@ -55,14 +63,19 @@
         text=""
       fi
       tmp=( "${(@M)texts:#${str}*}" )
+      (( num++ ))
     done
 
+    [[ num -gt max ]] && max="$num"
+
     jobs=( "$jobs[@]" "$str" )
   done
 
-  [[ -n "$pfx" && -n "$desc" ]] && disp=( "${(@)disp#%}" )
-else
-  jobs=( "$jids[@]" )
+  if [[ "$how" = [0-9]## && max -gt how ]]; then
+    jobs=( "$jids[@]" )
+  else
+    [[ -z "$pfx" && -n "$desc" ]] && disp=( "${(@)disp#%}" )
+  fi
 fi
 
 if [[ -n "$desc" ]]; then
diff -ru ../z.old/Completion/Base/_tilde Completion/Base/_tilde
--- ../z.old/Completion/Base/_tilde	Wed Dec 15 09:58:10 1999
+++ Completion/Base/_tilde	Wed Dec 15 10:38:23 1999
@@ -4,7 +4,7 @@
 # for you or if there are too many of them, you may want to use
 # `compadd -qS/ - "$friends[@]"' or something like that.
 
-local expl suf dirs list lines revlines i ret disp
+local expl suf dirs list lines revlines i ret disp nm="$compstate[nmatches]"
 
 if [[ "$SUFFIX" = */* ]]; then
   ISUFFIX="/${SUFFIX#*/}$ISUFFIX"
@@ -23,7 +23,7 @@
 
   if _requested -V directory-stack expl 'directory stack' &&
      { ! zstyle -t ":completion${curcontext}:directory-stack" prefix-needed ||
-       [[ "$PREFIX" = [-+]* ]] }; then
+       [[ "$PREFIX" = [-+]* || nm -eq compstate[nmatches] ]] }; then
     if zstyle -t ":completion${curcontext}:directory-stack" verbose; then
       integer i
 
diff -ru ../z.old/Completion/Builtins/_cd Completion/Builtins/_cd
--- ../z.old/Completion/Builtins/_cd	Wed Dec 15 09:58:12 1999
+++ Completion/Builtins/_cd	Wed Dec 15 15:14:07 1999
@@ -39,7 +39,7 @@
   else
     _alternative \
         'local-directories:local directories:_path_files -/' \
-	'path-directories: directories in cdpath:_path_files -W \(${cdpath:#.}\) -/'
+	"path-directories: directories in cdpath:_path_files -W \\(${${(@)cdpath:#.}}\\) -/"
   fi
 else
   _path_files -/
diff -ru ../z.old/Completion/Builtins/_kill Completion/Builtins/_kill
--- ../z.old/Completion/Builtins/_kill	Wed Dec 15 09:58:13 1999
+++ Completion/Builtins/_kill	Wed Dec 15 10:36:19 1999
@@ -2,5 +2,5 @@
 
 _alternative \
     'signals:: _signals -p' \
-    'jobs:: _jobs' \
-    'processes:: _pids'
+    'processes:: _pids' \
+    'jobs:: _jobs -t'
diff -ru ../z.old/Completion/Builtins/_stat Completion/Builtins/_stat
--- ../z.old/Completion/Builtins/_stat	Wed Dec 15 09:58:13 1999
+++ Completion/Builtins/_stat	Wed Dec 15 10:42:35 1999
@@ -1,19 +1,19 @@
 #compdef stat
 
-local expl
+local expl ret=1
 
 if [[ "$words[CURRENT-1]" = -[AH] ]]; then
   _arrays
 else
-  _tags options files || return 1
+  _tags files options || return 1
 
   while _tags; do
+    _requested files && _files && ret=0
     _requested options expl 'inode element' &&
         { ! zstyle -t ":completion${curcontext}:options" prefix-needed ||
-          [[ "$PREFIX[1]" = + ]] } &&
+          [[ "$PREFIX[1]" = + || ret -eq 1 ]] } &&
         compadd "$expl[@]" - +device +inode +mode +nlink +uid +gid +rdev \
                              +size +atime +mtime +ctime +blksize +block +link
     fi
-    _requested files && _files
   done
 fi
diff -ru ../z.old/Completion/Builtins/_wait Completion/Builtins/_wait
--- ../z.old/Completion/Builtins/_wait	Wed Dec 15 09:58:14 1999
+++ Completion/Builtins/_wait	Wed Dec 15 10:36:40 1999
@@ -1,3 +1,3 @@
 #compdef wait
 
-_alternative 'jobs:: _jobs' 'processes:: _pids'
+_alternative 'processes:: _pids' 'jobs:: _jobs -t'
diff -ru ../z.old/Completion/Core/_path_files Completion/Core/_path_files
--- ../z.old/Completion/Core/_path_files	Wed Dec 15 09:58:19 1999
+++ Completion/Core/_path_files	Wed Dec 15 13:06:00 1999
@@ -4,7 +4,7 @@
 # to complete to `/usr/local/bin'.
 
 local linepath realpath donepath prepath testpath exppath
-local tmp1 tmp2 tmp3 tmp4 i orig pre suf tpre tsuf opre osuf cpre
+local tmp1 tmp2 tmp3 tmp4 i orig eorig pre suf tpre tsuf opre osuf cpre
 local pats haspats=no ignore group expl addpfx addsfx remsfx
 local nm=$compstate[nmatches] menu match matcher mopts atmp
 
@@ -108,6 +108,7 @@
 opre="$PREFIX"
 osuf="$SUFFIX"
 orig="${PREFIX}${SUFFIX}"
+eorig="$orig"
 
 [[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" ||
    ( $#compstate[pattern_match] -ne 0 &&
@@ -265,7 +266,11 @@
 	  if [[ "$tmp2[1]" = */* ]]; then
 	    tmp2=( "${(@)tmp2:h}" )
 	    compquote tmp2
-	    exppaths=( "$exppaths[@]" ${^tmp2}/${tpre}${tsuf} )
+	    if [[ "$tmp2" = */ ]]; then
+	      exppaths=( "$exppaths[@]" ${^tmp2}${tpre}${tsuf} )
+	    else
+	      exppaths=( "$exppaths[@]" ${^tmp2}/${tpre}${tsuf} )
+	    fi
           else
 	    exppaths=( "$exppaths[@]" ${tpre}${tsuf} )
 	  fi
@@ -453,7 +458,7 @@
 # expanded paths that are different from the string on the line, we add
 # them as possible matches.
 
-exppaths=( "${(@)exppaths:#$orig}" )
+exppaths=( "${(@)exppaths:#$eorig}" )
 
 if zstyle -t ":completion${curcontext}:paths" expand prefix &&
    [[ $#exppaths -gt 0 && nm -eq compstate[nmatches] ]]; then
diff -ru ../z.old/Completion/Core/_sort_tags Completion/Core/_sort_tags
--- ../z.old/Completion/Core/_sort_tags	Wed Dec 15 09:58:20 1999
+++ Completion/Core/_sort_tags	Wed Dec 15 15:15:11 1999
@@ -1,39 +1,28 @@
 #autoload
 
-local stags tag
+comptry arguments values
+comptry options
 
-if zstyle -a ":completion${curcontext}" sort-tags stags; then
+case "$curcontext" in
+# Some silly examples commented out:
+#
+# *::*p[bgpn]m:*)           # change the order for file-completion
+#   comptry globbed-files directories
+#   comptry all-files
+#   ;;
+# *::dvips::-o*)            # automatic context set by _arguments
+#   comptry all-files
+#   return
+#   ;;
+# *::kill:*)
+#   comptry processes
+#   return                  # this return ensures that we use only processes
+#   ;;
+*)
+  comptry globbed-files
+  comptry directories
+  comptry all-files
+  ;;
+esac
 
-  for tag in $stags; do
-    [[ $tag != '' ]] && comptry ${=tag}
-  done
-
-else
-
-  comptry arguments values
-  comptry options
-
-  case "$curcontext" in
-  # Some silly examples commented out:
-  #
-  # *::*p[bgpn]m:*)           # change the order for file-completion
-  #   comptry globbed-files directories
-  #   comptry all-files
-  #   ;;
-  # *::dvips::-o*)            # automatic context set by _arguments
-  #   comptry all-files
-  #   return
-  #   ;;
-  # *::kill:*)
-  #   comptry processes
-  #   return                  # this return ensures that we use only processes
-  #   ;;
-  *)
-    comptry globbed-files
-    comptry directories
-    comptry all-files
-    ;;
-  esac
-
-  comptry "$@"
-fi
+comptry "$@"
diff -ru ../z.old/Completion/Core/_tags Completion/Core/_tags
--- ../z.old/Completion/Core/_tags	Wed Dec 15 09:58:19 1999
+++ Completion/Core/_tags	Wed Dec 15 15:41:00 1999
@@ -4,7 +4,7 @@
 
   # We have arguments: the tags supported in this context.
 
-  local curcontext="$curcontext" order
+  local curcontext="$curcontext" order tag nodef
 
   if [[ "$1" = -C?* ]]; then
     curcontext="${curcontext}:${1[3,-1]}"
@@ -38,9 +38,24 @@
   _offered_tags=( "$_offered_tags[@]" "$@" )
   _last_tags=()
 
-  # Call the function that sorts the tags into sets.
+  # Sort the tags.
 
-  "${_sort_tags:-_sort_tags}" "$@"
+  if [[ -n "$_sort_tags" ]]; then
+    "$_sort_tags" "$@"
+  elif zstyle -a ":completion${curcontext}" tag-order order; then
+
+    for tag in $order; do
+      case $tag in
+      -)     nodef=yes;;
+      *\(\)) "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@";;
+      ?*)    comptry ${=tag};;
+      esac
+    done
+
+    [[ -z "$nodef" ]] && comptry "$@"
+  else
+    comptry "$@"
+  fi
 
   # Return non-zero if at least one set of tags should be used.
 
diff -ru ../z.old/Completion/Core/compinit Completion/Core/compinit
--- ../z.old/Completion/Core/compinit	Wed Dec 15 09:58:19 1999
+++ Completion/Core/compinit	Wed Dec 15 15:41:56 1999
@@ -479,6 +479,8 @@
 zstyle ':completion:correct'  prompt        'correct to:'
 zstyle ':completion:*'        completer     '_complete'
 zstyle ':completion*:default' list-colors   no=0 fi=0 di=0 ln=0 pi=0 so=0 bd=0 cd=0 ex=0
+zstyle ':completion:*' tag-order 'arguments values' options \
+                                 globbed-files directories all-files
 
 # Now we automatically make the definition files autoloaded.
 
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Wed Dec 15 09:57:54 1999
+++ Doc/Zsh/compsys.yo	Wed Dec 15 15:36:26 1999
@@ -302,13 +302,11 @@
 matches, often multiple types of matches.  These types are represented as
 simple names called `tags'.  The completion system will decide internally
 what sort of tags are allowed; a list of the standard possibilities is given
-below.  The list of tags is passed as the arguments of the function
-(tt(_sort_tags)), which can then determine the order in which the  tags are
-to be used by the completion function.  Only those types of matches whose
-tags were selected by the tt(_sort_tags) function will be produced, and in
-the order given.  Instead of altering tt(_sort_tags), you may define
-a `tt(sort-tags)' style for the appropriate context, as described in the
-list of standard styles below.
+below.  To determine in which order the tags are to be used by the
+completion function, the `tt(tag-order)' style for the appropriate
+context may be set, as described in the list of standard styles below.
+Only those types of matches whose tags were selected by this style
+will be produced, and in the order given.
 
 The tt(_complete_help) bindable command described in 
 ifzman(the section `Bindable Commands' below)\
@@ -317,8 +315,8 @@
 point in completion.  It shows a list of context names and the 
 tag names used in those contexts if completion were tried at the
 current cursor position.  Hence one can easily find out all the
-information needed to change the behaviour of the tt(_sort_tags) function
-or the tt(sort_tags) style for a particular context.
+information needed to change the behaviour of the tt(tag-order) style
+for a particular context.
 
 Completion behaviour can be modified by various other
 `styles' defined with the tt(zstyle) builtin command
@@ -756,9 +754,9 @@
 .
 )
 item(tt(glob))(
-Like tt(complete), this is used by the tt(_expand) completer.
+Like tt(completions), this is used by the tt(_expand) completer.
 
-The value is used like the one for tt(complete) and if it evaluates to 
+The value is used like the one for tt(completions) and if it evaluates to 
 `tt(1)', globbing will be attempted on the words resulting from
 substitution (see the tt(substitute) style) or the original string
 from the line.
@@ -819,7 +817,7 @@
 
 Note that the matches will still be completed, they are just not shown 
 in the list. To avoid having matches considered as possible
-completions at all the tt(_sort_tags) function can be modified as described
+completions at all the tt(tag-order) style can be modified as described
 below.
 )
 item(tt(hosts))(
@@ -1012,6 +1010,15 @@
 appears.  With tt(_oldlist), it will instead continue to cycle through the
 list of completions.
 )
+item(tt(numbers))(
+This is used with the tt(jobs) tag. If it is `true', the completions
+will use the job numbers instead of the shortest unambiguous strings
+of the jobs' command lines. If the value is a number, job numbers will 
+only be used if for at least one of the jobs that many (or more) words 
+from the command line string have to be used to make the strings
+unambiguous. E.g. if it is set to `tt(1)', strings will only be used
+if all jobs differ in the first word on their command lines.
+)
 item(tt(original))(
 This is used by the tt(_approximate), tt(_correct) and tt(_match)
 completers. The first two use it to decide if the original string should
@@ -1096,10 +1103,9 @@
 as single strings (not in the string containing all possible
 expansions).
 )
-item(tt(sort-tags))(
+item(tt(tag-order))(
 This provides a mechanism for sorting how the tags available in a
-particular context will be used.  It assumes you have not redefined the
-standard tt(_sort_tags) function.
+particular context will be used.
 
 The values for the style are sets of space-separated lists of tags.
 The tags in each value will be tried at the same time; if no match is
@@ -1108,18 +1114,27 @@
 For example,
 
 example(
-  zstyle :completion:complete::gunzip: sort-tags \ 
+  zstyle :completion:complete::gunzip: tag-order \ 
     'globbed-files directories' all-files
 )
 
 specifies that, when completing arguments of the command tt(gunzip),
 files generated by patterns (in this case, those ending in tt(.gz)) and
 any directories will be presented first, and if that fails, any other files
-will be tried.  If no valid tags are present, nothing will be completed. so
-this can be used to turn off completion in a particular context.
+will be tried.  If any string in the value consists of only a hyphen
+(`tt(-)'), then only the tags selected by the other strings will be
+generated. Normally all tags not explicitly selected will be tried at
+the end if the selected tags did not generate any matches.  This means 
+that a value of only one hyphen turns off completion in a particular
+context.
+
+Strings in the value may also be of the form `var(func)tt(())'. In
+this case the function var(func) will be called which can then define
+in which order tags are to be used based on additional context
+information. See the tt(_sort_tags) function below for a description
+of how such functions can be implemented.
 
-If no style has been defined for a context, the tt(_sort_tags) function
-provides defaults, as given below.
+If no style has been defined for a context, all tags will be used.
 )
 item(tt(special-dirs))(
 Normally, the completion code will not produce the directory names
@@ -1133,11 +1148,6 @@
 and it will stop when the last match is inserted. If this style is set
 to tt(verbose) a message will be displayed when the last match is reached.
 )
-item(tt(strings))(
-This is used with the tt(jobs) tag. If it is `true', the completions
-will use the shortest unambiguous strings of the jobs' command lines
-instead of the job numbers.
-)
 item(tt(substitute))(
 If this is unset or set to the empty string, the tt(_expand) completer
 will first try to expand all substitutions in the string (such as
@@ -1399,7 +1409,7 @@
 adding the original string from the line. In which order these strings 
 are generated and which of these strings are generated at all can be
 controlled by using the tt(group-order) style and by modifying the
-tt(sort-tags) style or tt(_sort_tags) function, as usual.
+tt(tag-order) style, as usual.
 
 The format string for tt(all-expansions) and for tt(expansions) may
 contain the sequence `tt(%o)' which will be replaced by the original
@@ -1642,7 +1652,7 @@
 If called with arguments, these are taken as the names of the tags for 
 the types of matches the calling completion function can generate in
 the current context. These tags are stored internally and sorted by
-calling the tt(_sort_tags) function. Following calls to this function
+using the tt(tag-order) style. Following calls to this function
 without arguments from the same function will then select the first,
 second, etc. set of tags requested by the user. To test if a certain
 tag should be tried, the tt(_requested) function has to be called (see 
@@ -1654,10 +1664,9 @@
 This function also accepts the tt(-C) option followed by a
 var(name). This name is temporarily (i.e. not visible outside
 tt(_tags)) appended (with a colon before it) to the contents of the
-tt(curcontext) parameter. This allows to make tt(_tags) and
-tt(_sort_tags) use a more specific context name without having to
-change and reset the tt(curcontext) parameter (which would otherwise
-have the same effect).
+tt(curcontext) parameter. This allows to make tt(_tags) use a more
+specific context name without having to change and reset the
+tt(curcontext) parameter (which would otherwise have the same effect).
 )
 findex(_requested)
 item(tt(_requested) [ tt(-12VJ) ] var(tag) var(name) var(descr) [ var(specs) ... ])(
@@ -2313,12 +2322,10 @@
 )
 findex(_sort_tags)
 item(tt(_sort_tags) var(tag) ...)(
-As described above, this may be redefined by the user, although a default
-implementation is provided.  In most cases, you will probably find it
-easier to define a tt(sort-tags) style for the context whose behaviour you
-wish to alter.
+As described above for the tt(tag-order) style, this is only provided
+to show how functions that sort tags can be implemented.
 
-Inside the tt(_sort_tags) function the name of the current context can
+Inside such functions the name of the current context can
 be accessed using the tt(curcontext) parameter. For example, the
 function generating file names (called tt(_files)) in the completion
 system is often called to generate only filenames matching a given
@@ -2357,7 +2364,7 @@
 any matches, names of directories are generated, and if that doesn't
 yield any matching names either, all filenames will be generated.
 
-In every context the tt(_sort_tags) function may call tt(comptry) as
+In every context the function may call tt(comptry) as
 often as it wants. Also, every string may be given as argument, even
 if no tag with such a name was offered by the completion
 function. This allows one to give a preferred ordering for some common 
@@ -2365,7 +2372,7 @@
 names. For example, many completion functions can generate both
 arguments and option names for commands. These functions normally use
 the tags tt(arguments) and tt(options). Depending on your preference
-you may write in your tt(_sort_tags) function:
+you may write in your sorting function:
 
 example(_sort_tags() {
   comptry arguments options
@@ -2395,8 +2402,8 @@
 Since the completion functions are free to choose the tag names they
 use, there can't be a complete list. So to make sure that all types of 
 matches are eventually tried as completions, one should  use a call to 
-tt(comptry) with all arguments at the end of tt(_sort_tags). For those
-contexts where one really wants to make sure that certain tags are
+tt(comptry) with all arguments at the end of the sorting function. For
+those contexts where one really wants to make sure that certain tags are
 never used one can then use a call to tt(return) to circumvent that
 last tt(comptry). For example:
 
@@ -2419,30 +2426,6 @@
 tt(processes) tag in a call to tt(comptry). The immediate call to
 tt(return) then makes sure that the default tt(comptry) at the end is
 not executed.
-
-The default implementation of tt(_sort_tags) is the following:
-
-example(_sort_tags() {
-  local stags tag
-
-  if zstyle -a ":completion${curcontext}" sort-tags stags; then
-    for tag in $stags; do
-      [[ $tags != '' ]] && comptry ${=tag}
-    done
-
-  else		   
-    comptry arguments values
-    comptry options
-    case "$curcontext" in
-      (*) comptry globbed-files
-  	  comptry directories
-  	  comptry all-files
-          ;;
-    esac
-    comptry "$@"
-  fi
-})
-
 )
 
 enditem()
diff -ru ../z.old/Src/Makemod.in Src/Makemod.in
--- ../z.old/Src/Makemod.in	Wed Dec 15 09:57:40 1999
+++ Src/Makemod.in	Wed Dec 15 15:08:14 1999
@@ -7,12 +7,12 @@
 dir_top = ..
 subdir = Src
 
-MODOBJS = modobjs.zsh
+MODOBJS =
 MODULES =
-MDDS    = zsh.mdd
-MDHS    = zsh.mdh
-PROTOS  = proto.zsh
-SUBDIRS = Builtins Modules Zle
+MDDS    =
+MDHS    =
+PROTOS  =
+SUBDIRS =
 
 ENTRYOBJ = $(dir_src)/modentry..o
 NNTRYOBJ =
@@ -151,20 +151,7 @@
 uninstall.modules: uninstall.modules-here
 
 install.bin-here uninstall.bin-here:
-
-install.modules-here:
-	modules='$(MODULES)'; \
-	if test -n "$$modules"; then $(sdir_top)/mkinstalldirs $(DESTDIR)$(MODDIR); fi; \
-	for mod in $$modules; do \
-	    $(INSTALL_PROGRAM) $$mod $(DESTDIR)$(MODDIR)/$$mod; \
-	done
-
-uninstall.modules-here:
-	modules='$(MODULES)'; for mod in $$modules; do \
-	    if test -f $(DESTDIR)$(MODDIR)/$$mod; then \
-		rm -f $(DESTDIR)$(MODDIR)/$$mod; \
-	    else :; fi; \
-	done
+install.modules-here uninstall.modules-here:
 
 # ========== DEPENDENCIES FOR CLEANUP ==========
 
@@ -213,140 +200,5 @@
 
 $(dir_src)/modules-bltin:
 	@cd $(dir_src) && $(MAKE) $(MAKEDEFS) modules-bltin
-
-##### ===== DEPENDENCIES GENERATED FROM zsh.mdd ===== #####
-
-MODOBJS_zsh = builtin.o compat.o cond.o exec.o glob.o hashtable.o hist.o init.o input.o jobs.o lex.o linklist.o loop.o math.o mem.o module.o options.o params.o parse.o pattern.o prompt.o signals.o signames.o subst.o text.o utils.o watch.o
-MODDOBJS_zsh = builtin..o compat..o cond..o exec..o glob..o hashtable..o hist..o init..o input..o jobs..o lex..o linklist..o loop..o math..o mem..o module..o options..o params..o parse..o pattern..o prompt..o signals..o signames..o subst..o text..o utils..o watch..o  $(@E@NTRYOBJ)
-SYMS_zsh = builtin.syms compat.syms cond.syms exec.syms glob.syms hashtable.syms hist.syms init.syms input.syms jobs.syms lex.syms linklist.syms loop.syms math.syms mem.syms module.syms options.syms params.syms parse.syms pattern.syms prompt.syms signals.syms signames.syms subst.syms text.syms utils.syms watch.syms 
-EPRO_zsh = builtin.epro compat.epro cond.epro exec.epro glob.epro hashtable.epro hist.epro init.epro input.epro jobs.epro lex.epro linklist.epro loop.epro math.epro mem.epro module.epro options.epro params.epro parse.epro pattern.epro prompt.epro signals.epro signames.epro subst.epro text.epro utils.epro watch.epro
-INCS_zsh = $(EPRO_zsh) 
-EXPIMP_zsh =  $(EXPOPT)zsh.export
-NXPIMP_zsh =
-
-proto.zsh: $(EPRO_zsh)
-$(SYMS_zsh): $(PROTODEPS)
-
-zsh.export: $(SYMS_zsh)
-	( echo '#!'; cat $(SYMS_zsh) | sed -n '/^X/{s/^X//;p;}' | sort -u ) > $@
-
-modobjs.zsh: $(MODOBJS_zsh)
-	echo '' $(MODOBJS_zsh) >> $(dir_src)/stamp-modobjs.tmp
-
-zsh.mdhi: zsh.mdhs $(INCS_zsh)
-	@test -f $@ || echo 'do not delete this file' > $@
-
-zsh.mdhs: zsh.mdd
-	@$(MAKE) -f $(makefile) $(MAKEDEFS) zsh.mdh.tmp
-	@if cmp -s zsh.mdh zsh.mdh.tmp; then \
-	    rm -f zsh.mdh.tmp; \
-	    echo "\`zsh.mdh' is up to date."; \
-	else \
-	    mv -f zsh.mdh.tmp zsh.mdh; \
-	    echo "Updated \`zsh.mdh'."; \
-	fi
-	echo 'timestamp for zsh.mdh against zsh.mdd' > $@
-
-zsh.mdh:  ../config.h system.h zsh.h sigcount.h signals.h prototypes.h hashtable.h ztype.h  zsh.mdhi
-	@$(MAKE) -f $(makefile) $(MAKEDEFS) zsh.mdh.tmp
-	@mv -f zsh.mdh.tmp zsh.mdh
-	@echo "Updated \`zsh.mdh'."
-
-zsh.mdh.tmp:
-	@( \
-	    echo '#ifndef have_zsh_module'; \
-	    echo '#define have_zsh_module'; \
-	    echo; \
-	    echo '/* Extra headers for this module */'; \
-	    for hdr in ../config.h system.h zsh.h sigcount.h signals.h prototypes.h hashtable.h ztype.h; do \
-		if test -f $$hdr; then \
-		    echo '# include "'$$hdr'"'; \
-		else \
-		    echo '# include "$(sdir)/'$$hdr'"'; \
-		fi; \
-	    done; \
-	    echo; \
-	    for epro in $(EPRO_zsh); do \
-		echo '# include "'$$epro'"'; \
-	    done; \
-	    echo; \
-	    echo '#endif /* !have_zsh_module */'; \
-	) > $@
-
-$(MODOBJS_zsh) $(MODDOBJS_zsh): zsh.mdh
-
-@CONFIG_MK@
-
-signames.c: signames1.awk signames2.awk ../config.h @SIGNAL_H@
-	$(AWK) -f $(sdir)/signames1.awk @SIGNAL_H@ >sigtmp.c
-	$(CPP) sigtmp.c >sigtmp.out
-	$(AWK) -f $(sdir)/signames2.awk sigtmp.out > $@
-	rm -f sigtmp.c sigtmp.out
-
-sigcount.h: signames.c
-	grep 'define.*SIGCOUNT' signames.c > $@
-
-init.o: bltinmods.list zshpaths.h zshxmods.h
-
-params.o: version.h
-
-version.h: $(sdir_top)/Config/version.mk
-	echo '#define ZSH_VERSION "'$(VERSION)'"' > $@
-
-zshpaths.h: Makemod $(CONFIG_INCS)
-	@echo '#define MODULE_DIR "'$(MODDIR)'"' > zshpaths.h.tmp
-	@if test x$(fndir) != xno; then \
-	  echo '#define FPATH_DIR "'$(fndir)'"' >> zshpaths.h.tmp; \
-	  if test x$(FUNCTIONS_SUBDIRS) != x -a \
-	  x$(FUNCTIONS_SUBDIRS) != xno; then \
-	    fpath_tmp="`for f in $$FUNCTIONS_INSTALL; do \
-	      echo $$f | sed s%/.*%%; \
-	    done | sort | uniq`"; \
-	    fpath_tmp="`echo $$fpath_tmp | sed 's/ /\", \"/g'`"; \
-	    echo "#define FPATH_SUBDIRS { \"$$fpath_tmp\" }" \
-	    >>zshpaths.h.tmp; \
-	  fi; \
-	fi
-	@if cmp -s zshpaths.h zshpaths.h.tmp; then \
-	    rm -f zshpaths.h.tmp; \
-	    echo "\`zshpaths.h' is up to date." ; \
-	else \
-	    mv -f zshpaths.h.tmp zshpaths.h; \
-	    echo "Updated \`zshpaths.h'." ; \
-	fi
-
-bltinmods.list: modules.stamp modules-bltin xmods.conf mkbltnmlst.sh
-	srcdir='$(sdir)' MODBINS='modules-bltin' \
-	XMODCF='$(sdir)/xmods.conf' $(SHELL) $(sdir)/mkbltnmlst.sh $@
-
-zshxmods.h: modules-bltin xmods.conf
-	@echo "Creating \`$@'."
-	@( \
-	    binmods=`sed 's/^/ /;s/$$/ /' modules-bltin`; \
-	    for mod in `cat $(sdir_src)/xmods.conf`; do \
-		case $$binmods in \
-		    *" $$mod "*) \
-			echo "#define    LINKED_XMOD_$$mod 1" ;; \
-		    *)  echo "#ifdef DYNAMIC"; \
-			echo "# define UNLINKED_XMOD_$$mod 1"; \
-			echo "#endif" ;; \
-		esac; \
-	    done; \
-	    echo; \
-	    for mod in $$binmods; do \
-		echo "int boot_$$mod _((Module));"; \
-	    done; \
-	) > $@
-
-clean-here: clean.zsh
-clean.zsh:
-	rm -f sigcount.h signames.c bltinmods.list version.h zshpaths.h zshxmods.h
-
-# This is not properly part of this module, but it is built as if it were.
-main.o: main.c zsh.mdh main.epro
-	$(CC) -c -I. $(CPPFLAGS) $(DEFS) $(CFLAGS) -o $@ $(sdir)/main.c
-
-main.syms: $(PROTODEPS)
-proto.zsh: main.epro
 
 ##### End of Makemod.in

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

