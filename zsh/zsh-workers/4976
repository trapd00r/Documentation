Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Mon, 25 Jan 1999 11:12:18 +0100 (MET)
Message-Id: <199901251012.LAA14249@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: compadd-fix and examples (new completion)
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 4976


The builtin compadd didn't accept only options (with no following
matches). Making it accept that can simplify the shell functions where 
it is used (one hasn't have to check if there are matches).

The patch also contains many changes to the new-completion-examples
file:

  - files() and pfiles() now skip over existing pth name components.
  - They accept `-W spec' as their optional first two arguments, where
    spec may look like the one for compctl/complist.
  - defcomp() and defpatcomp() now accept the option `-a' which makes
    them automatically define the completion function as
    autoloaded. This isn't used yet, though.
  - I re-implemented several of the examples from the old-style
    completion example file (that's what makes the patch large). Not
    all of them are available yet, only the ones for the builtins and
    those I had in prior versions of this file.

Now, this patch will only work for pws-5.

Bye
 Sven

diff -c os/Zle/compctl.c Src/Zle/compctl.c
*** os/Zle/compctl.c	Mon Jan 25 10:23:14 1999
--- Src/Zle/compctl.c	Mon Jan 25 10:27:01 1999
***************
*** 1792,1801 ****
  	}
      }
   ca_args:
!     if (!*argv) {
! 	zerrnam(name, "missing completions", NULL, 0);
  	return 1;
!     }
      addmatchesptr(ipre, ppre, psuf, prpre, pre, suf, group,
  		  f, q, m, ns, a, argv);
      return 0;
--- 1792,1800 ----
  	}
      }
   ca_args:
!     if (!*argv)
  	return 1;
! 
      addmatchesptr(ipre, ppre, psuf, prpre, pre, suf, group,
  		  f, q, m, ns, a, argv);
      return 0;
diff -c os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
*** os/Zle/zle_tricky.c	Mon Jan 25 10:23:16 1999
--- Src/Zle/zle_tricky.c	Mon Jan 25 10:26:51 1999
***************
*** 2509,2514 ****
--- 2482,2488 ----
  		if (!ai->firstm)
  		    ai->firstm = cm;
  	    }
+ 	    compnmatches = mnum;
  	} LASTALLOC;
      } SWITCHBACKHEAPS;
  }
diff -c om/new-completion-examples Misc/new-completion-examples
*** om/new-completion-examples	Mon Jan 25 10:21:54 1999
--- Misc/new-completion-examples	Mon Jan 25 10:39:41 1999
***************
*** 19,38 ****
  # With only one argument the function/variable-name __$1 is used.
  
  defcomp() {
!   local v
  
    if [[ $# -eq 1 ]] then
      comps[$1]="__$1"
    else
      v="$1"
      shift
      for i; do
        comps[$i]="$v"
      done
    fi
  }
  
  defpatcomp() {
    if [[ ${+patcomps} == 1 ]] then
      patcomps=("$patcomps[@]" "$2 $1" )
    else
--- 19,48 ----
  # With only one argument the function/variable-name __$1 is used.
  
  defcomp() {
!   local v a=''
  
+   if [[ "$1" = -a ]] then
+     shift
+     a=yes
+   fi
    if [[ $# -eq 1 ]] then
      comps[$1]="__$1"
+     [[ -z "$a" ]] || autoload "__$1"
    else
      v="$1"
      shift
      for i; do
        comps[$i]="$v"
      done
+     [[ -z "$a" ]] || autoload "$v"
    fi
  }
  
  defpatcomp() {
+   if [[ "$1" = -a ]] then
+     shift
+     autoload "$1"
+   fi
    if [[ ${+patcomps} == 1 ]] then
      patcomps=("$patcomps[@]" "$2 $1" )
    else
***************
*** 82,87 ****
--- 92,98 ----
  main-complete() {
    emulate -R zsh
    local comp
+ 
    setopt localoptions nullglob rcexpandparam globdots
    unsetopt markdirs globsubst shwordsplit nounset
  
***************
*** 164,184 ****
    [[ -z "$comp" ]] || call-complete "$comp" "$@" || return 1
  }
  
- # Do sub-completion for pre-command modifiers.
- 
- defcomp __precmd - noglob nocorrect exec command builtin
- __precmd() {
-   COMMAND="$1"
-   shift
-   (( CURRENT-- ))
-   if [[ CURRENT -eq 0 ]] then
-     CONTEXT=command
-   else
-     CONTEXT=argument
-   fi
-   compsub
- }
- 
  # Utility function for in-path completion.
  # First argument should be an complist-option (e.g. -f, -/, -g). The other
  # arguments should be glob patterns, one per argument.
--- 175,180 ----
***************
*** 190,279 ****
  # so you may want to modify this.
  
  pfiles() {
!   local nm str pa pre epre a b c s rest
  
    setopt localoptions nullglob rcexpandparam globdots extendedglob
    unsetopt markdirs globsubst shwordsplit nounset
  
    nm=$NMATCHES
    if [[ $# -eq 0 ]] then
!     complist -f
    elif [[ "$1" = -g ]] then
!     complist -g "$argv[2,-1]"
      shift
    else
!     complist $1
      shift
    fi
    [[ -nmatches nm ]] || return
  
-   str="$PREFIX*$SUFFIX"
- 
    [[ -z "$1" ]] && 1='*'
!   if [[ $str[1] = \~ ]] then
      pre="${str%%/*}/"
      eval epre\=$pre
      str="${str#*/}"
!     pa=''
    else
      pre=''
      epre=''
!     if [[ $str[1] = / ]] then
        str="$str[2,-1]"
!       pa='/'
      else
!       pa=''
      fi
    fi
-   str="$str:gs/,/*,/:gs/_/*_/:gs./.*/.:gs/-/*[-_]/:gs/./*[.,]/:gs-*[.,]*[.,]*/-../-:gs.**.*."
    while [[ "$str" = */* ]] do
!     rest="${str#*/}"
!     a="${epre}${pa}(#l)${str%%/*}(-/)"
!     a=( $~a )
!     if [[ $#a -eq 0 ]] then
!       return
!     elif [[ $#a -gt 1 ]] then
!       c=()
!       s=( $rest$@ )
!       s=( "${(@)s:gs.**.*.}" )
!       for i in $a; do
!         b=( $~i/(#l)$~s )
!         eval b\=\( \$\{b:/\*\(${(j:|:)fignore}\)\} \)
!         [[ $#b -ne 0 ]] && c=( $c $i )
!       done
!       if [[ $#c -eq 0 ]] then
!         return
!       elif [[ $#c -ne 1 ]] then
!         a="$epre$pa"
!         c=( $~c/(#l)$~s )
!         eval c\=\( \$\{c:/\*\(${(j:|:)fignore}\)\} \)
! 	c=( ${c#$a} )
!         for i in $c; do
!           compadd -p "$pre$pa" -W "$a" -s "/${i#*/}" -f "${i%%/*}"
          done
! 	return
        fi
!       a=( "$c[1]" )
!     fi
!     a="$a[1]"
!     pa="$pa${a##*/}/"
!     str="$rest"
    done
-   a="$epre$pa"
-   s=( $str$@ )
-   s=( "${(@)s:gs.**.*.}" )
-   b=( $~a(#l)$~s )
-   eval b\=\( \$\{b:/\*\(${(j:|:)fignore}\)\} \)
-   compadd -p "$pre$pa" -W "$epre$pa" -f ${b#$a}
  }
  
  # Utility function for completing files of a given type or any file.
  # In many cases you will want to call this one instead of pfiles().
  
  files() {
!   local nm
  
-   nm=$NMATCHES
    pfiles "$@"
  
    [[ $# -ne 0 && -nmatches nm ]] && pfiles
--- 186,308 ----
  # so you may want to modify this.
  
  pfiles() {
!   local nm ostr opa pre epre a b c s rest ppres
  
    setopt localoptions nullglob rcexpandparam globdots extendedglob
    unsetopt markdirs globsubst shwordsplit nounset
  
+   if [[ "$1" = -W ]] then
+     a="$2"
+     if [[ "$a[1]" = '(' ]] then
+       ppres=( $a[2,-2]/ )
+     else
+       eval ppres\=\( \$$a/ \)
+       [[ $#ppres -eq 0 ]] && ppres=( $a/ )
+     fi
+     [[ $#ppres -eq 0 ]] && ppres=( '' )
+     shift 2
+   else
+     ppres=( '' )
+   fi
+ 
+   str="$PREFIX*$SUFFIX"
+ 
+   if [[ -z "$a[1]" || "$str[1]" = [~/] || "$str" = (.|..)/* ]] then
+     a=()
+   else
+     a=(-W "( $ppres )")
+   fi
    nm=$NMATCHES
    if [[ $# -eq 0 ]] then
!     complist "$a[@]" -f
    elif [[ "$1" = -g ]] then
!     complist "$a[@]" -g "$argv[2,-1]"
      shift
    else
!     complist "$a[@]" $1
      shift
    fi
    [[ -nmatches nm ]] || return
  
    [[ -z "$1" ]] && 1='*'
! 
!   if [[ "$str[1]" = \~ ]] then
      pre="${str%%/*}/"
      eval epre\=$pre
      str="${str#*/}"
!     opa=''
!     ppres=( '' )
    else
      pre=''
      epre=''
!     if [[ "$str[1]" = / ]] then
        str="$str[2,-1]"
!       opa='/'
!       ppres=( '' )
      else
!       [[ "$str" = (.|..)/* ]] && ppres=( '' )
!       opa=''
      fi
    fi
    while [[ "$str" = */* ]] do
!     [[ -e "$epre$opa${str%%/*}" ]] || break
!     opa="$opa${str%%/*}/"
!     str="${str#*/}"
!   done
! 
!   ostr="$str:gs/,/*,/:gs/_/*_/:gs./.*/.:gs/-/*[-_]/:gs/./*[.,]/:gs-*[.,]*[.,]*/-../-:gs.**.*."
! 
!   for ppre in "$ppres[@]"; do
!     str="$ostr"
!     pa="$opa"
!     while [[ "$str" = */* ]] do
!       rest="${str#*/}"
!       a="${ppre}${epre}${pa}(#l)${str%%/*}(-/)"
!       a=( $~a )
!       if [[ $#a -eq 0 ]] then
!         continue 2
!       elif [[ $#a -gt 1 ]] then
!         c=()
!         s=( $rest$@ )
!         s=( "${(@)s:gs.**.*.}" )
!         for i in $a; do
!           b=( $~i/(#l)$~s )
!           eval b\=\( \$\{b:/\*\(${(j:|:)fignore}\)\} \)
!           [[ $#b -ne 0 ]] && c=( $c $i )
          done
!         if [[ $#c -eq 0 ]] then
!           continue 2
!         elif [[ $#c -ne 1 ]] then
!           a="$ppre$epre$pa"
!           c=( $~c/(#l)$~s )
!           eval c\=\( \$\{c:/\*\(${(j:|:)fignore}\)\} \)
!   	  c=( ${c#$a} )
!           for i in $c; do
!             compadd -p "$pre$pa" -W "$a" -s "/${i#*/}" -f "${i%%/*}"
!           done
!   	  continue 2
!         fi
!         a=( "$c[1]" )
        fi
!       a="$a[1]"
!       pa="$pa${a##*/}/"
!       str="$rest"
!     done
!     a="$ppre$epre$pa"
!     s=( $str$@ )
!     s=( "${(@)s:gs.**.*.}" )
!     b=( $~a(#l)$~s )
!     eval b\=\( \$\{b:/\*\(${(j:|:)fignore}\)\} \)
!     compadd -p "$pre$pa" -W "$ppre$epre$pa" -f ${b#$a}
    done
  }
  
  # Utility function for completing files of a given type or any file.
  # In many cases you will want to call this one instead of pfiles().
  
  files() {
!   local nm=$NMATCHES
  
    pfiles "$@"
  
    [[ $# -ne 0 && -nmatches nm ]] && pfiles
***************
*** 289,296 ****
  defcomp __command --command--
  __command=( -c )
  
! defcomp __math --math--
! __math=( -v )
  
  defcomp __subscr --subscr--
  __subscr() {
--- 318,325 ----
  defcomp __command --command--
  __command=( -c )
  
! defcomp __vars --math--
! __vars=( -v )
  
  defcomp __subscr --subscr--
  __subscr() {
***************
*** 298,339 ****
    # ...probably other stuff
  }
  
! # A simple pattern completion, just as an example.
  
! defpatcomp __x_options '*/X11/*'
! __x_options() {
!   complist -J options -k '(-display -name -xrm)'
  }
  
! # A better example: completion for `find'.
  
! defcomp find
! __find() {
!   compsave
  
!   if [[ -mbetween -(ok|exec) \\\; ]] then
      compsub
!   elif [[ -iprefix - ]] then
!     complist -s 'daystart {max,min,}depth follow noleaf version xdev \
! 	{a,c,}newer {a,c,m}{min,time} empty false {fs,x,}type gid inum links \
! 	{i,}{l,}name {no,}{user,group} path perm regex size true uid used \
! 	exec {f,}print{f,0,} ok prune ls'
!     compreset
!   elif [[ -position 1 ]] then
!     complist -g '. ..'
!     files -g '(-/)'
!   elif [[ -mcurrent -1 -((a|c|)newer|fprint(|0|f)) ]] then
      files
-   elif [[ -current -1 -fstype ]] then
-     complist -k '(ufs 4.2 4.3 nfs tmp mfs S51K S52K)'
-   elif [[ -current -1 -group ]] then
-     complist -k groups
-   elif [[ -current -1 -user ]] then
-     complist -u
    fi
  }
  
! # Various completions...
  
  defcomp __gunzip gunzip zcat
  __gunzip() {
--- 327,558 ----
    # ...probably other stuff
  }
  
! # Do sub-completion for pre-command modifiers.
  
! defcomp __precmd - nohup nice eval time rusage noglob nocorrect exec
! __precmd() {
!   COMMAND="$1"
!   shift
!   (( CURRENT-- ))
!   if [[ CURRENT -eq 0 ]] then
!     CONTEXT=command
!   else
!     CONTEXT=argument
!   fi
!   compsub
  }
  
! defcomp builtin
! __builtin() {
!   if [[ -position 2 -1 ]] then
!     compsub
!   else
!     complist -eB
!   fi
! }
  
! defcomp command
! __command() {
!   if [[ -position 2 -1 ]] then
!     compsub
!   else
!     complist -em
!   fi
! }
!   
! # Various completions...
  
! defcomp __jobs fg jobs
! __jobs=(-j -P '%')
! 
! defcomp __bjobs bg
! __bjobs=(-z -P '%')
! 
! defcomp wait
! __wait=(-j -P '%' + -s '`ps -x | tail +2 | cut -c1-5`')
! 
! defcomp __arrays shift
! __arrays=(-A)
! 
! defcomp __which which whence where type
! __which=( -caF )
! 
! defcomp unhash
! __unhash() {
!   [[ -mword 1 -*d* ]] && complist -n
!   [[ -mword 1 -*a* ]] && complist -a
!   [[ -mword 1 -*f* ]] && complist -F
!   [[ ! -mword 1 -* ]] && complist -m
! }
! 
! defcomp hash
! __hash() {
!   if [[ -mword 1 -*d* ]] then
!     if [[ -string 1 '=' ]] then
!       pfiles -g '*(-/)'
!     else
!       complist -n -q -S '='
!     fi
!   elif [[ -string 1 '=' ]] then
!     files -g '*(*)' '*(-/)'
!   else
!     complist -m -q -S '='
!   fi
! }
! 
! defcomp __funcs unfunction
! __funcs=(-F)
! 
! defcomp echotc
! __echotc=(-k '(al dc dl do le up al bl cd ce cl cr dc dl do ho is le ma nd nl se so up)')
! 
! defcomp __aliases unalias
! __aliases=(-a)
! 
! defcomp __vars getopts read unset vared
! 
! defcomp __varseq declare export integer local readonly typeset
! __varseq=(-v -S '=')
! 
! defcomp disable
! __disable() {
!   [[ -mcurrent -1 -*a* ]] && complist -ea
!   [[ -mcurrent -1 -*f* ]] && complist -eF
!   [[ -mcurrent -1 -*r* ]] && complist -ew
!   [[ ! -mcurrent -1 -* ]] && complist -eB
! }
! 
! defcomp enable
! __enable() {
!   [[ -mcurrent -1 -*a* ]] && complist -da
!   [[ -mcurrent -1 -*f* ]] && complist -dF
!   [[ -mcurrent -1 -*r* ]] && complist -dw
!   [[ ! -mcurrent -1 -* ]] && complist -dB
! }
! 
! defcomp __limits limit unlimit
! __limits=(-k "(${(j: :)${(f)$(limit)}%% *})")
! 
! defcomp source
! __source() {
!   if [[ -position 2 -1 ]] then
      compsub
!   else
      files
    fi
  }
  
! defcomp setopt
! __setopt() {
!   local nm=$NMATCHES
! 
!   complist -M 'L:|[nN][oO]= M:_= M:{A-Z}={a-z}' \
!            -s '$({ unsetopt kshoptionprint; unsetopt } 2>/dev/null)'
!   [[ -nmatches nm ]] && complist -M 'L:|[nN][oO]= M:_= M:{A-Z}={a-z}' -o
! }
! 
! defcomp unsetopt
! __unsetopt() {
!   local nm=$NMATCHES
! 
!   complist -M 'L:|[nN][oO]= M:_= M:{A-Z}={a-z}' \
!            -s '$({ unsetopt kshoptionprint; setopt } 2>/dev/null)'
!   [[ -nmatches nm ]] && complist -M 'L:|[nN][oO]= M:_= M:{A-Z}={a-z}' -o
! }
! 
! defcomp autoload
! __autoload=(-s '${^fpath}/*(N:t)')
! 
! defcomp bindkey
! __bindkey() {
!   if [[ -mword 1 -*[DAN]* || -mcurrent -1 -*M ]] then
!     complist -s '$(bindkey -l)'
!   else
!     complist -b
!   fi
! }
! 
! defcomp fc
! __fc() {
!   if [[ -mcurrent -1 -*e ]] then
!     complist -c
!   elif [[ -mcurrent -1 -[ARWI]## ]] then
!     files
!   fi
! }
! 
! defcomp sched
! __sched() {
!   [[ -position 2 -1 ]] && compsub
! }
! 
! defcomp set
! __set() {
!   if [[ -mcurrent -1 [-+]o ]] then
!     complist -o
!   elif [[ -current -1 -A ]] then
!     complist -A
!   fi
! }
! 
! defcomp zle
! __zle() {
!   if [[ -word 1 -N && -position 3 ]] then
!     complist -F
!   else
!     complist -b
!   fi
! }
! 
! defcomp zmodload
! __zmodload() {
!   if [[ -mword 1 -*(a*u|u*a)* || -mword 1 -*a* && -position 3 -1 ]] then
!     complist -B
!   elif [[ -mword 1 -*u* ]] then
!     complist -s '$(zmodload)'
!   else
!     complist -s '${^module_path}/*(N:t:r)'
!   fi
! }
! 
! defcomp trap
! __trap() {
!   if [[ -position 1 ]] then
!     complist -c
!   else
!     complist -k signals
!   fi
! }
! 
! killfunc() {
!   reply=( "$(ps -x 2>/dev/null)" )
! }
! 
! defcomp kill
! __kill() {
!   if [[ -iprefix '-' ]] then
!     complist -k "($signals[1,-3])"
!   else
!     complist -P '%' -j
!     complist -y killfunc -s '`ps -x 2>/dev/null | tail +2 | cut -c1-5`'
!   fi
! }
! 
! defcomp cd
! __cd() {
!   files -W cdpath -g '*(-/)'
! }
! 
! defcomp __rlogin rlogin rsh ssh
! __rlogin() {
!   if [[ -position 1 ]] then
!     complist -k hosts
!   elif [[ -position 2 ]] then
!     complist -k '(-l)'
!   elif [[ -position 3 && -word 1 artus ]] then
!     complist -k '(puck root)'
!   fi
! }
  
  defcomp __gunzip gunzip zcat
  __gunzip() {
***************
*** 350,356 ****
    files -g '*.fig'
  }
  
! defcomp __make make gmake
  __make() {
    complist -s "\$(awk '/^[a-zA-Z0-9][^/ 	]+:/ {print \$1}' FS=: [mM]akefile)"
  }
--- 569,575 ----
    files -g '*.fig'
  }
  
! defcomp __make make gmake pmake
  __make() {
    complist -s "\$(awk '/^[a-zA-Z0-9][^/ 	]+:/ {print \$1}' FS=: [mM]akefile)"
  }
***************
*** 360,401 ****
    files -g '*([pP][sS]|eps)'
  }
  
- defcomp __which which whence
- __which=( -caF )
- 
- defcomp __rlogin rlogin rsh ssh
- __rlogin() {
-   if [[ -position 1 ]] then
-     complist -k hosts
-   elif [[ -position 2 ]] then
-     complist -k '(-l)'
-   elif [[ -position 3 && -word 1 artus ]] then
-     complist -k '(puck root)'
-   fi
- }
- 
  defcomp __dvi xdvi dvips dvibook dviconcat dvicopy dvidvi dviselect dvitodvi dvitype
  __dvi() {
    files -g '*.(dvi|DVI)'
  }
  
! defcomp __dirs rmdir df du dircmp cd
  __dirs() {
    files -/ '*(-/)'
  }
  
- defcomp __jobs fg bg jobs
- __jobs=(-j -P '%?')
- 
- defcomp kill
- __kill() {
-   if [[ -iprefix '-' ]] then
-     complist -k signals
-   else
-     complist -P '%?' -j
-   fi
- }
- 
  defcomp __uncompress uncompress zmore
  __uncompress() {
    files -g '*.Z'
--- 579,594 ----
    files -g '*([pP][sS]|eps)'
  }
  
  defcomp __dvi xdvi dvips dvibook dviconcat dvicopy dvidvi dviselect dvitodvi dvitype
  __dvi() {
    files -g '*.(dvi|DVI)'
  }
  
! defcomp __dirs rmdir df du dircmp
  __dirs() {
    files -/ '*(-/)'
  }
  
  defcomp __uncompress uncompress zmore
  __uncompress() {
    files -g '*.Z'
***************
*** 406,434 ****
    files -g '*~*.Z'
  }
  
! defcomp __tex tex latex glatex slitex gslitex
  __tex() {
    files -g '*.(tex|TEX|texinfo|texi)'
  }
  
- defcomp __options setopt unsetopt
- __options=(-M 'L:|[nN][oO]= M:_= M:{A-Z}={a-z}' -o)
- 
- defcomp __funcs unfunction
- __funcs=(-F)
- 
- defcomp __aliases unalias
- __aliases=(-a)
- 
- defcomp __vars unset
- __vars=(-v)
- 
- defcomp __enabled disable
- __enabled=(-FBwa)
- 
- defcomp __disabled enable
- __disabled=(-dFBwa)
- 
  defcomp __pdf acroread
  __pdf() {
    files -g '*.(pdf|PDF)'
--- 599,609 ----
    files -g '*~*.Z'
  }
  
! defcomp __tex tex latex slitex
  __tex() {
    files -g '*.(tex|TEX|texinfo|texi)'
  }
  
  defcomp __pdf acroread
  __pdf() {
    files -g '*.(pdf|PDF)'
***************
*** 436,446 ****
  
  defcomp tar
  __tar() {
!   local nm tf
    compsave
  
-   tf="$2"
-   nm=$NMATCHES
    if [[ ( -mword 1 *t*f* || -mword 1 *x*f* ) && -position 3 100000 ]] then
      complist -k "( $(tar tf $tf) )"
      compreset
--- 611,619 ----
  
  defcomp tar
  __tar() {
!   local nm=$NMATCHES tf="$2"
    compsave
  
    if [[ ( -mword 1 *t*f* || -mword 1 *x*f* ) && -position 3 100000 ]] then
      complist -k "( $(tar tf $tf) )"
      compreset
***************
*** 450,453 ****
--- 623,659 ----
    elif [[ -mcurrent -1 *f* && -position 2 ]] then
      files -g '*.(tar|TAR)'
    fi
+ }
+ 
+ defcomp find
+ __find() {
+   compsave
+ 
+   if [[ -mbetween -(ok|exec) \\\; ]] then
+     compsub
+   elif [[ -iprefix - ]] then
+     complist -s 'daystart {max,min,}depth follow noleaf version xdev \
+ 	{a,c,}newer {a,c,m}{min,time} empty false {fs,x,}type gid inum links \
+ 	{i,}{l,}name {no,}{user,group} path perm regex size true uid used \
+ 	exec {f,}print{f,0,} ok prune ls'
+     compreset
+   elif [[ -position 1 ]] then
+     complist -g '. ..'
+     files -g '(-/)'
+   elif [[ -mcurrent -1 -((a|c|)newer|fprint(|0|f)) ]] then
+     files
+   elif [[ -current -1 -fstype ]] then
+     complist -k '(ufs 4.2 4.3 nfs tmp mfs S51K S52K)'
+   elif [[ -current -1 -group ]] then
+     complist -k groups
+   elif [[ -current -1 -user ]] then
+     complist -u
+   fi
+ }
+ 
+ # A simple pattern completion, just as an example.
+ 
+ defpatcomp __x_options '*/X11/*'
+ __x_options() {
+   complist -J options -k '(-display -name -xrm)'
  }

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

