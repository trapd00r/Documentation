From zsh-workers-return-7106-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Jul 13 09:28:37 1999
Return-Path: <zsh-workers-return-7106-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16275 invoked from network); 13 Jul 1999 09:28:35 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 13 Jul 1999 09:28:35 -0000
Received: (qmail 11491 invoked by alias); 13 Jul 1999 09:28:21 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7106
Received: (qmail 11484 invoked from network); 13 Jul 1999 09:28:21 -0000
Date: Tue, 13 Jul 1999 11:28:18 +0200 (MET DST)
Message-Id: <199907130928.LAA24572@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: incremental completion


As promised, the patch for incremental-complete-word. The default
prompt has changed and there are two new %-sequences usable in
prompts: %s for the `state' and `%c' for the name of the completer
function that generated the matches.

Bye
 Sven

diff -u of/Zle/incremental-complete-word Functions/Zle/incremental-complete-word
--- of/Zle/incremental-complete-word	Tue Jul 13 11:04:45 1999
+++ Functions/Zle/incremental-complete-word	Tue Jul 13 11:25:14 1999
@@ -4,23 +4,41 @@
 # to a key.
 
 # This allows incremental completion of a word.  After starting this
-# command, a list of completion choices is shown after every character you
-# type, which you can delete with ^h or DEL.  RET will accept the
-# completion so far.  You can hit TAB to do normal completion and ^g to
-# abort back to the state when you started.
-#
-# Completion keys:
-#   incremental_prompt   Prompt to show in status line during icompletion;
-#                        the sequence `%u' is replaced by the unambiguous
-#                        part of all matches if there is any and it is
-#                        different from the word on the line
-# incremental_stop       Pattern matching keys which will cause icompletion
-#                         to stop and the key to be re-executed
-# incremental_break      Pattern matching keys which will cause icompletion
-#                         to stop and the key to be discarded
-# incremental_completer  Set of completers, like the `completer' key
-#   incremental_list     If set to a non-empty string, the matches will be
-#                        listed on every key-press
+# command, a list of completion choices can be shown after every character
+# you type, which you can delete with ^h or DEL.  RET will accept the
+# completion so far.  You can hit TAB to do normal completion, ^g to
+# abort back to the state when you started, and ^d to list the matches.
+#
+# This works best with the new function based completion system.
+#
+# Configuration keys:
+#
+#  incremental_prompt
+#    Prompt to show in status line during icompletion. The sequence `%u'
+#    is replaced by the unambiguous part of all matches if there is any
+#    and it is different from the word on the line. A `%s' is replaced
+#    with `-no match-', `-no prefix-', or an empty string if there is
+#    no completion matching the word on the line, if the matches have 
+#    no common prefix different from the word on the line or if there is
+#    such a common prefix, respectively. Finally, the sequence `%c' is
+#    replaced by the name of the completer function that generated the
+#    matches (without the leading underscore).
+#
+#  incremental_stop
+#    Pattern matching keys which will cause icompletion to stop and the
+#    key to be re-executed.
+#
+#  incremental_break
+#    Pattern matching keys which will cause icompletion to stop and the
+#    key to be discarded.
+#
+#  incremental_completer
+#    Set of completers, like the `completer' key for normal completion.
+#
+#  incremental_list
+#    If set to a non-empty string, the matches will be listed on every
+#    key-press.
+
 
 emulate -L zsh
 unsetopt autolist menucomplete automenu # doesn't work well
@@ -28,8 +46,8 @@
 local key lbuf="$LBUFFER" rbuf="$RBUFFER" pmpt word lastl lastr wid twid
 
 [[ -n "$compconfig[incremental_completer]" ]] &&
-set ${(s.:.)compconfig[incremental_completer]}
-pmpt="${compconfig[incremental_prompt]-incremental completion...}"
+    set ${(s.:.)compconfig[incremental_completer]}
+pmpt="${compconfig[incremental_prompt]-incremental (%c): %u%s}"
 
 if [[ -n "$compconfig[incremental_list]" ]]; then
   wid=list-choices
@@ -40,12 +58,17 @@
 zle $wid "$@"
 LBUFFER="$lbuf"
 RBUFFER="$rbuf"
-if [[ "${LBUFFER}${RBUFFER}" = *${_lastcomp[unambiguous]}* ]]; then
+if (( ! _lastcomp[nmatches] )); then
   word=''
+  state='-no match-'
+elif [[ "${LBUFFER}${RBUFFER}" = *${_lastcomp[unambiguous]}* ]]; then
+  word=''
+  state='-no prefix-'
 else
   word="${_lastcomp[unambiguous]}"
+  state=''
 fi
-zle -R "${pmpt//\\%u/$word}"
+zle -R "${${${pmpt//\\%u/$word}//\\%s/$state}//\\%c/${_lastcomp[completer][2,-1]}}"
 read -k key
 
 while [[ '#key' -ne '#\\r' && '#key' -ne '#\\n' &&
@@ -72,12 +95,17 @@
   zle $twid "$@"
   LBUFFER="$lastl"
   RBUFFER="$lastr"
-  if [[ "${LBUFFER}${RBUFFER}" = *${_lastcomp[unambiguous]}* ]]; then
+  if (( ! _lastcomp[nmatches] )); then
+    word=''
+    state='-no match-'
+  elif [[ "${LBUFFER}${RBUFFER}" = *${_lastcomp[unambiguous]}* ]]; then
     word=''
+    state='-no prefix-'
   else
     word="${_lastcomp[unambiguous]}"
+    state=''
   fi
-  zle -R "${pmpt//\\%u/$word}"
+  zle -R "${${${pmpt//\\%u/$word}//\\%s/$state}//\\%c/${_lastcomp[completer][2,-1]}}"
   read -k key
 done
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

