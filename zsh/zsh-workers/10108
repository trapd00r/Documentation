From zsh-workers-return-10108-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 13 10:16:27 2000
Return-Path: <zsh-workers-return-10108-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20048 invoked from network); 13 Mar 2000 10:16:25 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 13 Mar 2000 10:16:25 -0000
Received: (qmail 29646 invoked by alias); 13 Mar 2000 10:16:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10108
Received: (qmail 29630 invoked from network); 13 Mar 2000 10:16:17 -0000
Date: Mon, 13 Mar 2000 11:13:48 +0100 (MET)
Message-Id: <200003131013.LAA18248@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Fri, 10 Mar 2000 14:04:50 +0300
Subject: RE: Matching against file suffix


[ the last of my weekend patches ;-]

Andrej Borsenkow wrote:

> ...
> 
> > Or maybe you want to have a way to switch from one type of matches to
> > the `next'.
> 
> Yes. Intent was to see "the most probable" matches first to keep list small, but still be
> able to select more general ones.
> 
> Setting tag "in one string" completes both, but it also lists both.

Here is my first attempt at this... the _next_tags bindable command
(and completer).

Normally it is bound to ^Xn, but to make it really work, _next_tags
should also be included as the (first) entry in your completer list.

Then it should be possible, to hit ^Xn (directly) after you have tried 
completion to get at the next set of tags (and the next and the next
and... with wrap-around). The matches for the new set will be shown
and then you can just hit tab to complete from that set.

Again, I haven't tested it too much, especially with things like
menu-completion.

There are also things we might want to make configurable. For example, 
currently it keeps the restricted set of tags even we you edit the
word we are on (i.e. after you hit ^Xn you can backspace, insert,
etc. and hitting TAB will still complete from the set of matches
selected with ^Xn). This is also connected to the test used to find
out when to stop using the restricted set -- maybe that needs to be
improved.

Bye
 Sven

P.S.: This also contains the .distfiles change for zrecompile. Sorry,
      forgot it again.

diff -ru ../z.old/Completion/Commands/.distfiles Completion/Commands/.distfiles
--- ../z.old/Completion/Commands/.distfiles	Mon Mar 13 11:02:23 2000
+++ Completion/Commands/.distfiles	Mon Mar 13 11:12:28 2000
@@ -2,4 +2,5 @@
     .distfiles
     _bash_completions _correct_filename _correct_word _expand_word 
     _history_complete_word _read_comp _most_recent_file _complete_help
+    _next_tags
 '
diff -ru ../z.old/Completion/Commands/_next_tags Completion/Commands/_next_tags
--- ../z.old/Completion/Commands/_next_tags	Mon Mar 13 11:04:04 2000
+++ Completion/Commands/_next_tags	Mon Mar 13 11:04:17 2000
@@ -0,0 +1,70 @@
+#compdef -k complete-word \C-xn
+
+# Main widget/completer.
+
+_next_tags() {
+
+  if [[ $#funcstack -gt 1 ]]; then
+
+    # Called as completer, probably `remove' our helper function. A better
+    # test would be nice, but I think one should still be able to edit the
+    # current word between attempts to complete it.
+
+    [[ $_next_tags_pre != ${LBUFFER%${PREFIX}} ]] && unset _sort_tags
+
+    return 1
+  else
+    local comp
+
+    if [[ -z $compstate[old_list] ]]; then
+      comp=()
+    else
+      comp=(_next_tags _complete)
+    fi
+
+    (( $+_sort_tags )) || _next_tags_not=
+
+    _sort_tags=_next_tags_sort
+    _next_tags_pre="${LBUFFER%${PREFIX}}"
+    _next_tags_not="$_next_tags_not $_lastcomp[tags]"
+
+    _main_complete "$comp[@]"
+
+    [[ $compstate[insert] = automenu ]] &&
+       compstate[insert]=automenu-unambiguous
+
+    compstate[insert]=''
+    compstate[list]='list force'
+  fi
+}
+
+# Helper function for sorting tags. Most of this is copied from _tags.
+
+_next_tags_sort() {
+  local order tags tag nodef
+
+  zstyle -a ":completion:${curcontext}:" tag-order order ||
+    order=( 'arguments values' options globbed-files directories all-files )
+
+  # But we also remove the tags we've already tried...
+
+  tags=( "${(@)order:#(${(j:|:)~${=_next_tags_not}})}" )
+
+  # ... unless that would remove all offered tags.
+
+  [[ $#tags -ne $#order && "$tags" != *(${(j:|:)~argv})* ]] &&
+    tags=( $order ) _next_tags_not=
+
+  for tag in $tags; do
+    case $tag in
+    -)     nodef=yes;;
+    *\(\)) "${${tag%%[ 	]#\(\)}##[ 	]#}" "$@";;
+    \!*)   comptry "${(@)argv:#(${(j:|:)~${=tag[2,-1]}})}";;
+    ?*)    comptry ${=tag};;
+    esac
+  done
+
+  [[ -z "$nodef" ]] && comptry "$@"
+}
+
+[[ -o kshautoload ]] || _next_tags "$@"
diff -ru ../z.old/Completion/Core/_files Completion/Core/_files
--- ../z.old/Completion/Core/_files	Mon Mar 13 11:02:25 2000
+++ Completion/Core/_files	Mon Mar 13 11:04:14 2000
@@ -33,7 +33,7 @@
     type="${type}/"
   fi
 else
-  dopts=()
+  dopts=(-/)
 fi
 if zstyle -s ":completion:${curcontext}:globbed-files" file-patterns tmp &&
    [[ -n "$tmp" ]]; then
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Mon Mar 13 11:02:25 2000
+++ Completion/Core/_main_complete	Mon Mar 13 11:04:17 2000
@@ -21,7 +21,7 @@
 
 local ctxt post ret=1 tmp _compskip format _comp_ignore \
       _completers _completer _completer_num \
-      _matchers _matcher _matcher_num \
+      _matchers _matcher _matcher_num _comp_tags \
       context state line opt_args val_args curcontext="$curcontext" \
       _last_nmatches=-1 _last_menu_style _def_menu_style _menu_style sel \
       _saved_exact="${compstate[exact]}" \
@@ -193,12 +193,13 @@
 comppostfuncs=()
 
 _lastcomp=( "${(@kv)compstate}" )
-_lastcomp[completer]="$comp"
+_lastcomp[completer]="$_completer"
 _lastcomp[prefix]="$PREFIX"
 _lastcomp[suffix]="$SUFFIX"
 _lastcomp[iprefix]="$IPREFIX"
 _lastcomp[isuffix]="$ISUFFIX"
 _lastcomp[qiprefix]="$QIPREFIX"
 _lastcomp[qisuffix]="$QISUFFIX"
+_lastcomp[tags]="$_comp_tags"
 
 return ret
diff -ru ../z.old/Completion/Core/_requested Completion/Core/_requested
--- ../z.old/Completion/Core/_requested	Mon Mar 13 11:02:26 2000
+++ Completion/Core/_requested	Mon Mar 13 11:04:15 2000
@@ -8,7 +8,7 @@
   tag="$1"
 fi
 
-comptags -R "$tag" &&
+comptags -R "$tag" && _comp_tags="$_comp_tags $tag" &&
     if [[ $# -gt 1 ]]; then
       _description "$@"
       return 0
diff -ru ../z.old/Completion/Core/_wanted Completion/Core/_wanted
--- ../z.old/Completion/Core/_wanted	Mon Mar 13 11:02:26 2000
+++ Completion/Core/_wanted	Mon Mar 13 11:04:15 2000
@@ -19,7 +19,8 @@
 fi
 
 if [[ $# -gt 1 ]]; then
-  _tags "$targs[@]" "$tag" && _description "$@"
+  _tags "$targs[@]" "$tag" && _comp_tags="$_comp_tags $tag" &&
+    _description "$@"
 else
-  _tags "$targs[@]" "$tag"
+  _tags "$targs[@]" "$tag" && _comp_tags="$_comp_tags $tag"
 fi
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Mon Mar 13 11:02:05 2000
+++ Doc/Zsh/compsys.yo	Mon Mar 13 11:04:15 2000
@@ -1861,6 +1861,18 @@
 var(N), complete the var(N)th most recently modified file.  Note the
 completion, if any, is always unique.
 )
+findex(_next_tags (^Xn))
+item(tt(_next_tags (^Xn)))(
+This allows to complete types of matches that are not immediately
+offered because of the setting of the tt(tag-order) style. After a
+normal completion was tried, invoking this command makes the matches
+for the next tag (or set of tags) be used. Repeatedly invoking this
+command makes the following tags be used. To be able to complete the
+matches selected by tt(_next_tags), the tt(completer) style should
+contain tt(_next_tags) as its first string. With that, the normal key
+binding (normally tt(TAB)) can be used to complete the matches shown
+after the call to tt(_next_tags).
+)
 findex(_read_comp (^X^R))
 item(tt(_read_comp (^X^R)))(
 Prompt the user for a string, and use that to perform completion on the
diff -ru ../z.old/Functions/Misc/.distfiles Functions/Misc/.distfiles
--- ../z.old/Functions/Misc/.distfiles	Mon Mar 13 11:02:45 2000
+++ Functions/Misc/.distfiles	Mon Mar 13 11:12:41 2000
@@ -2,5 +2,5 @@
     .distfiles
     acx allopt cat cdmatch cdmatch2 checkmail colors cx harden 
     is-at-least mere multicomp nslookup proto pushd randline
-    run-help yp yu zed zless zls zmv
+    run-help yp yu zed zless zls zmv zrecompile
 '

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

