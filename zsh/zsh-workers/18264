From zsh-workers-return-18264-mason-zsh=primenet.com.au@sunsite.dk Wed Feb 19 21:39:51 2003
Return-Path: <zsh-workers-return-18264-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27282 invoked from network); 19 Feb 2003 21:39:50 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 19 Feb 2003 21:39:50 -0000
Received: (qmail 5799 invoked by alias); 19 Feb 2003 21:39:41 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 18264
Received: (qmail 5789 invoked from network); 19 Feb 2003 21:39:40 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 19 Feb 2003 21:39:40 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [195.92.193.210] by sunsite.dk (MessageWall 1.0.8) with SMTP; 19 Feb 2003 21:39:40 -0000
Received: from modem-21.green-mandarin.dialup.pol.co.uk ([62.137.23.21] helo=pwstephenson.fsnet.co.uk)
	by cmailm2.svr.pol.co.uk with esmtp (Exim 3.35 #1)
	id 18lbwM-0007RY-00
	for zsh-workers@sunsite.dk; Wed, 19 Feb 2003 21:39:42 +0000
Received: by pwstephenson.fsnet.co.uk (Postfix, from userid 501)
	id 8B8B81B76A; Wed, 19 Feb 2003 21:40:58 +0000 (GMT)
Received: from pwstephenson.fsnet.co.uk (localhost [127.0.0.1])
	by pwstephenson.fsnet.co.uk (Postfix) with ESMTP id 6DE6B1B769
	for <zsh-workers@sunsite.dk>; Wed, 19 Feb 2003 21:40:58 +0000 (GMT)
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: job table in subshells
Date: Wed, 19 Feb 2003 21:40:53 +0000
From: Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Message-Id: <20030219214058.8B8B81B76A@pwstephenson.fsnet.co.uk>

This was my go at trying not to leak memory when entering subshells in
response to the valgrind reports produced by Felix.

The completion one is going to be difficult.

The termcap one may not strictly be a bug: from the line numbers, it is
being told to allocate its own buffer, and the interface doesn't provide
any way to free it.

The remaining one (spaceinline()) is probably going to require some work
to find: the message is from when the line allocated by zle for editing
is reallocated to increase its size.  If it's real, I suspect it's a
symptom of something going wrong somewhere else which uses the pointer.
(Presumably we would know fairly soon if realloc() was broken.)

Index: Src/jobs.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/jobs.c,v
retrieving revision 1.18
diff -u -r1.18 jobs.c
--- Src/jobs.c	27 Aug 2002 21:10:34 -0000	1.18
+++ Src/jobs.c	17 Feb 2003 22:28:05 -0000
@@ -789,30 +789,28 @@
 
 /**/
 void
-deletejob(Job jn)
+freejob(Job jn, int deleting)
 {
     struct process *pn, *nx;
 
-    if (jn->stat & STAT_ATTACH) {
-	attachtty(mypgrp);
-	adjustwinsize(0);
-    }
-
     pn = jn->procs;
     jn->procs = NULL;
     for (; pn; pn = nx) {
 	nx = pn->next;
 	zfree(pn, sizeof(struct process));
     }
-    deletefilelist(jn->filelist);
 
     if (jn->ty)
 	zfree(jn->ty, sizeof(struct ttyinfo));
     if (jn->pwd)
 	zsfree(jn->pwd);
     jn->pwd = NULL;
-    if (jn->stat & STAT_WASSUPER)
-	deletejob(jobtab + jn->other);
+    if (jn->stat & STAT_WASSUPER) {
+	if (deleting)
+	    deletejob(jobtab + jn->other);
+	else
+	    freejob(jobtab + jn->other, 0);
+    }
     jn->gleader = jn->other = 0;
     jn->stat = jn->stty_in_env = 0;
     jn->procs = NULL;
@@ -820,6 +818,24 @@
     jn->ty = NULL;
 }
 
+/*
+ * We are actually finished with this job, rather
+ * than freeing it to make space.
+ */
+
+/**/
+void
+deletejob(Job jn)
+{
+    deletefilelist(jn->filelist);
+    if (jn->stat & STAT_ATTACH) {
+	attachtty(mypgrp);
+	adjustwinsize(0);
+    }
+
+    freejob(jn, 1);
+}
+
 /* add a process to the current job */
 
 /**/
@@ -975,24 +991,16 @@
     int i;
 
     for (i = 1; i < MAXJOB; i++) {
-	if (jobtab[i].ty) {
-	    zfree(jobtab[i].ty, sizeof(struct ttyinfo));
-	    jobtab[i].ty = NULL;
-	}
-	if (jobtab[i].pwd) {
-	    zsfree(jobtab[i].pwd);
-	    jobtab[i].pwd = NULL;
-	}
-	if (monitor) {
-	    /*
-	     * See if there is a jobtable worth saving.
-	     * We never free the saved version; it only happens
-	     * once for each subshell of a shell with job control,
-	     * so doesn't create a leak.
-	     */
-	    if (jobtab[i].stat)
-		oldmaxjob = i+1;
-	}
+	/*
+	 * See if there is a jobtable worth saving.
+	 * We never free the saved version; it only happens
+	 * once for each subshell of a shell with job control,
+	 * so doesn't create a leak.
+	 */
+	if (monitor && jobtab[i].stat)
+	    oldmaxjob = i+1;
+	else if (jobtab[i].stat & STAT_INUSE)
+	    freejob(jobtab + i, 0);
     }
 
     if (monitor && oldmaxjob) {

-- 
Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Work: pws@csr.com
Web: http://www.pwstephenson.fsnet.co.uk

