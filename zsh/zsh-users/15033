From zsh-users-return-15033-mason-zsh=primenet.com.au@zsh.org Fri Apr 30 09:32:28 2010
Return-Path: <zsh-users-return-15033-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15753 invoked by alias); 30 Apr 2010 09:32:28 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15033
Received: (qmail 12631 invoked from network); 30 Apr 2010 09:32:16 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_LOW,
	SPF_HELO_PASS autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at csr.com does not designate permitted sender hosts)
Date: Fri, 30 Apr 2010 09:32:51 +0100
From: Peter Stephenson <pws@csr.com>
To: zsh-users@zsh.org
Subject: Re: Zsh autocompletion with no access to a parent directory
Message-ID: <20100430093251.4fcd8c45@csr.com>
In-Reply-To: <04C31B8F-4588-4DA0-93E6-EB175CEFA6F6@sysctl.co.uk>
References: <3663DC29-7A8F-4A0C-8262-5FFE701C8E3A@sysctl.co.uk>
	<20100413174533.5a15043a@news01>
	<361816B9-75B6-4C88-8BE9-097B33CA2283@sysctl.co.uk>
	<201004140914.o3E9EPkL009936@news01.csr.com>
	<201004140947.o3E9llgG010201@news01.csr.com>
	<C1A23A01-1F48-4C3B-9232-C44EC0AA7C6F@sysctl.co.uk>
	<20100423224428.7479faa8@pws-pc>
	<20100429223850.14143862@pws-pc>
	<04C31B8F-4588-4DA0-93E6-EB175CEFA6F6@sysctl.co.uk>
Organization: Cambridge Silicon Radio
X-Mailer: Claws Mail 3.7.5 (GTK+ 2.18.9; i686-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="MP_/y_/HczNgPTB/lzE5DQPOeC2"
X-OriginalArrivalTime: 30 Apr 2010 08:32:51.0731 (UTC) FILETIME=[B8F7C630:01CAE83F]
X-Scanned-By: MailControl A_09_40_00 (www.mailcontrol.com) on 10.71.0.138

--MP_/y_/HczNgPTB/lzE5DQPOeC2
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

On Thu, 29 Apr 2010 15:14:33 -0700
Matt Wright <matt@sysctl.co.uk> wrote:
> > Matt, could you make sure this doesn't break anything?  Of course,
> > with code this trivial it's hard to make a mistake.  Sob.
> 
> Tried to at work and git-apply hates the patch format. Not sure why.
> Also patch -p0 wouldn't apply it cleanly to the current top-of-git.

It should apply OK to what's in the archive (and does here), but I did
change the previous patch from what I gave you before, so it would be
problematic with anything not under revision control...

Here's a patch against what was in the archive before I started tinkering
with it so it should apply to something older, as well as the new
patch.

pws


Member of the CSR plc group of companies. CSR plc registered in England and Wales, registered number 4187346, registered office Churchill House, Cambridge Business Park, Cowley Road, Cambridge, CB4 0WZ, United Kingdom

--MP_/y_/HczNgPTB/lzE5DQPOeC2
Content-Type: application/x-diff
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename="path_files_against_old.dif"

Index: Completion/Unix/Type/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_path_files,v
retrieving revision 1.49
retrieving revision 1.51
diff -p -u -r1.49 -r1.51
--- Completion/Unix/Type/_path_files	14 Sep 2009 08:40:49 -0000	1.49
+++ Completion/Unix/Type/_path_files	23 Apr 2010 21:52:00 -0000	1.51
@@ -32,6 +32,7 @@ local tmp1 tmp2 tmp3 tmp4 i orig eorig p
 local pats haspats ignore pfx pfxsfx sopt gopt opt sdirs ignpar cfopt listsfx
 local nm=$compstate[nmatches] menu matcher mopts sort mid accex fake
 local listfiles listopts tmpdisp origtmp1 Uopt
+local accept_exact_dirs path_completion
 integer npathcheck
 local -a Mopts
 
@@ -191,6 +192,11 @@ zstyle -a ":completion:${curcontext}:" f
 
 zstyle -s ":completion:${curcontext}:" ignore-parents ignpar
 
+zstyle -t ":completion:${curcontext}:paths" accept-exact-dirs &&
+  accept_exact_dirs=1
+zstyle -T ":completion:${curcontext}:paths" path-completion &&
+  path_completion=1
+
 if [[ -n "$compstate[pattern_match]" ]]; then
   if { [[ -z "$SUFFIX" ]] && _have_glob_qual "$PREFIX" complete } ||
     _have_glob_qual "$SUFFIX" complete; then
@@ -350,16 +356,17 @@ for prepath in "$prepaths[@]"; do
   skipped=
   cpre=
 
-  if zstyle -t ":completion:${curcontext}:paths" accept-exact-dirs &&
-    [[ $pre = (#b)(*)/([^/]#) ]]; then
-    # We've been told that we can accept an exact directory
-    # prefix immediately.  Try this with the longest path prefix
-    # first:  this saves stats in the simple case and may get around
-    # automount behaviour if early components don't yet exist.
+  if [[ ( -n $accept_exact_dirs || -z $path_completion ) && \
+        ${(Q)pre} = (#b)(*)/([^/]#) ]]; then
+    # We've been told either that we can accept an exact directory prefix
+    # immediately, or that path expansion is inhibited.  Try the longest
+    # path prefix first: in the first case, this saves stats in the simple
+    # case and may get around automount behaviour if early components don't
+    # yet exist, and in the second case this is the prefix we want to keep.
     tmp1=$match[1]
     tpre=$match[2]
     while true; do
-      if [[ -d $prepath$realpath$donepath$tmp1 ]]; then
+      if [[ -z $path_completion || -d $prepath$realpath$donepath$tmp1 ]]; then
 	donepath=$donepath$tmp1/
 	pre=$tpre
 	break

--MP_/y_/HczNgPTB/lzE5DQPOeC2
Content-Type: application/x-diff
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename="path_files_against_new.dif"

? 11626.1.txt
? 11680.txt
? _redirect.dif
? globsubst.dif
? modules
? path-completion.dif
? path_files_against_new.dif
? path_files_against_old.dif
Index: Completion/Unix/Type/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_path_files,v
retrieving revision 1.51
diff -p -u -r1.51 _path_files
--- Completion/Unix/Type/_path_files	23 Apr 2010 21:52:00 -0000	1.51
+++ Completion/Unix/Type/_path_files	30 Apr 2010 08:28:32 -0000
@@ -357,16 +357,26 @@ for prepath in "$prepaths[@]"; do
   cpre=
 
   if [[ ( -n $accept_exact_dirs || -z $path_completion ) && \
-        ${(Q)pre} = (#b)(*)/([^/]#) ]]; then
+        ${pre} = (#b)(*)/([^/]#) ]]; then
     # We've been told either that we can accept an exact directory prefix
     # immediately, or that path expansion is inhibited.  Try the longest
     # path prefix first: in the first case, this saves stats in the simple
     # case and may get around automount behaviour if early components don't
     # yet exist, and in the second case this is the prefix we want to keep.
-    tmp1=$match[1]
-    tpre=$match[2]
+    #
+    # Explanation of substitution: For tmp1 and tpre, which are used further
+    # on, we need to remove quotes from everything that's not a pattern
+    # character, because the code that does the file generation only
+    # strips qutoes from pattern characters (you know better than
+    # to ask why).  Because we need to test for a real directory,
+    # however, for tmp2 we unquote everything.
+    tmp1=${match[1]}
+    tpre=${match[2]}
+    tmp2=${(Q)tmp1}
+    tmp1=${tmp1//(#b)\\([^\\\]\[\^\~\(\)\#\*\?])/$match[1]}
+    tpre=${tpre//(#b)\\([^\\\]\[\^\~\(\)\#\*\?])/$match[1]}
     while true; do
-      if [[ -z $path_completion || -d $prepath$realpath$donepath$tmp1 ]]; then
+      if [[ -z $path_completion || -d $prepath$realpath$donepath$tmp2 ]]; then
 	donepath=$donepath$tmp1/
 	pre=$tpre
 	break
@@ -381,7 +391,14 @@ for prepath in "$prepaths[@]"; do
 
   tpre="$pre"
   tsuf="$suf"
-  testpath="$donepath"
+  # Now we strip quoting from pattern characters, too, because
+  # testpath is used as a literal string.  I suppose we could
+  # alternatively use ${~testpath} later.
+  #
+  # I'm not sure if donepath itself should be entirely unquoted at
+  # some point but probably not here, since we need the quoted pattern
+  # characters in tmp1 below (I think).
+  testpath="${donepath//(#b)\\([\\\]\[\^\~\(\)\#\*\?])/$match[1]}"
 
   tmp2="${(M)tpre##${~skips}}"
   tpre="${tpre#$tmp2}"

--MP_/y_/HczNgPTB/lzE5DQPOeC2--

