From zsh-workers-return-15326-mason-zsh=primenet.com.au@sunsite.dk Mon Jul 09 15:24:58 2001
Return-Path: <zsh-workers-return-15326-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29228 invoked from network); 9 Jul 2001 15:24:56 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Jul 2001 15:24:56 -0000
Received: (qmail 27065 invoked by alias); 9 Jul 2001 15:24:48 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15326
Received: (qmail 27031 invoked from network); 9 Jul 2001 15:24:47 -0000
Message-ID: <Tc0a88d0154a3e9573c@mailsweeper01.cambridgesiliconradio.com>
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: Re: Debugging of dynamocally defined functions 
In-reply-to: ""Bart Schaefer""'s message of "Sat, 07 Jul 2001 23:30:10 -0000."
             <1010707233010.ZM16910@candle.brasslantern.com> 
Date: Mon, 09 Jul 2001 11:38:29 +0100
From: Peter Stephenson <pws@csr.com>

"Bart Schaefer" wrote:
> In another message, PWS said:
> > 
> > By the way, you can use the trick of
> > 
> >   eval "$(which compdef)"
> > 
> > to sync the line numbers with the which output.  At least I hope so ---
> > if this goes screwy there's a bug in text.c.
> 
> No, you can't.  This causes all the lines to be numbered zero.

> `zed -f' has the same problem; drives me nuts.

Should we try this patch for the time being?  It's a local fix to enable
line numbers any time strings are parsed in a standard fashion (there are
other ways strings can get parsed, but most of the syntactically
significant code such as eval goes through here).  If we decide to adopt
this, a lot of other code can go.

This has other side effects.  For one thing, `eval' now produces line
numbers in its own context, rather than in the surrounding context.  This
is what perl does, so maybe that's OK:

  % fn() {
  function> print $LINENO
  function> print $LINENO
  function> eval 'print eval $LINENO'
  function> eval 'print eval $LINENO'
  function> print $LINENO
  function> }
  % fn
  1
  2
  eval 1
  eval 1
  5

Previously, you would get `3' and `4' from the evals.  That was the object
of doing it that way.  The good news is that `eval "$(which fn)"' works
with the new way.

It's rather messier to turn line numbering on just when you start parsing a
function, but I can have a go at that if it seems useful.  However, I
rather suspect that road could get horrendously twisted, and I'd much
rather have it all or nothing.

Index: Src/exec.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/exec.c,v
retrieving revision 1.33
diff -u -r1.33 exec.c
--- Src/exec.c	2001/06/27 11:22:05	1.33
+++ Src/exec.c	2001/07/09 10:34:28
@@ -152,6 +152,14 @@
     Eprog p;
     int oldlineno = lineno;
 
+#if 1
+    /*
+     * Force line numbering on.  If this seems like a good idea,
+     * we can enable it globally, with consequent code simplifications.
+     * But I bet it's not that simple.
+     */
+    ln = 1;
+#endif
     lexsave();
     inpush(s, (ln ? INP_LINENO : 0), NULL);
     strinbeg(0);

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR Ltd., Unit 300, Science Park, Milton Road,
Cambridge, CB4 0XL, UK                          Tel: +44 (0)1223 392070


**********************************************************************
The information transmitted is intended only for the person or
entity to which it is addressed and may contain confidential 
and/or privileged material. 
Any review, retransmission, dissemination or other use of, or
taking of any action in reliance upon, this information by 
persons or entities other than the intended recipient is 
prohibited.  
If you received this in error, please contact the sender and 
delete the material from any computer.
**********************************************************************

