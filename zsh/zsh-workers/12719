From zsh-workers-return-12719-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Aug 29 20:25:20 2000
Return-Path: <zsh-workers-return-12719-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3991 invoked from network); 29 Aug 2000 20:25:18 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Aug 2000 20:25:18 -0000
Received: (qmail 16303 invoked by alias); 29 Aug 2000 20:24:45 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12719
Received: (qmail 16296 invoked from network); 29 Aug 2000 20:24:45 -0000
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: vared word splitting again.
Date: Tue, 29 Aug 2000 21:24:43 +0100
From: Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Message-Id: <E13Trw0-0000YY-00.2000-08-29-21-24-40@mail12.svr.pol.co.uk>

I missed the possibility that an array could have real backslashes in it.

Index: Doc/Zsh/mod_zle.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_zle.yo,v
retrieving revision 1.6
diff -u -r1.6 mod_zle.yo
--- Doc/Zsh/mod_zle.yo	2000/07/27 17:48:47	1.6
+++ Doc/Zsh/mod_zle.yo	2000/08/29 20:23:22
@@ -162,10 +162,11 @@
 created, the parameter is unset and recreated.
 
 If an array or array slice is being edited, separator characters as defined
-in tt($IFS) will be shown quoted with a backslash.  Conversely, when the
-edited text is split into an array, a backslash quotes an immediately
-following separator character; no other special handling of backslashes, or
-any handling of quotes, is performed.
+in tt($IFS) will be shown quoted with a backslash, as will backslashes
+themselves.  Conversely, when the edited text is split into an array, a
+backslash quotes an immediately following separator character or backslash;
+no other special handling of backslashes, or any handling of quotes, is
+performed.
 
 Individual elements of existing array or associative array parameters
 may be edited by using subscript syntax on var(name).  New elements are
Index: Src/utils.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/utils.c,v
retrieving revision 1.13
diff -u -r1.13 utils.c
--- Src/utils.c	2000/07/27 22:02:46	1.13
+++ Src/utils.c	2000/08/29 20:23:36
@@ -1829,6 +1829,8 @@
     return i;
 }
 
+/* see findsep() below for handling of `quote' argument */
+
 /**/
 mod_export char **
 spacesplit(char *s, int allownull, int heap, int quote)
@@ -1854,7 +1856,7 @@
     else if (!allownull && t != s)
 	*ptr++ = dup("");
     while (*s) {
-	if (isep(*s == Meta ? s[1] ^ 32 : *s)) {
+	if (isep(*s == Meta ? s[1] ^ 32 : *s) || (quote && *s == '\\')) {
 	    if (*s == Meta)
 		s++;
 	    s++;
@@ -1891,7 +1893,8 @@
      * quote is a flag that '\<sep>' should not be treated as a separator.
      * in this case we need to be able to strip the backslash directly
      * in the string, so the calling function must have sent us something
-     * modifiable.  currently this only works for sep == NULL.
+     * modifiable.  currently this only works for sep == NULL.  also in
+     * in this case only, we need to turn \\ into \.
      */
     int i;
     char *t, *tt;
@@ -1899,7 +1902,7 @@
     if (!sep) {
 	for (t = *s; *t; t++) {
 	    if (quote && *t == '\\' &&
-		isep(t[1] == Meta ? (t[2] ^ 32) : t[1])) {
+		(isep(t[1] == Meta ? (t[2] ^ 32) : t[1]) || t[1] == '\\')) {
 		chuck(t);
 		if (*t == Meta)
 		    t++;
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.10
diff -u -r1.10 zle_main.c
--- Src/Zle/zle_main.c	2000/08/14 16:54:04	1.10
+++ Src/Zle/zle_main.c	2000/08/29 20:23:39
@@ -839,13 +839,16 @@
 	    tptr = tmparr = (char **)zhalloc(sizeof(char *)*(arrlen(arr)+1));
 	    for (aptr = arr; *aptr; aptr++) {
 		int sepcount = 0;
-		/* See if this word contains a separator character */
+		/*
+		 * See if this word contains a separator character
+		 * or backslash
+		 */
 		for (t = *aptr; *t; t++) {
 		    if (*t == Meta) {
 			if (isep(t[1] ^ 32))
 			    sepcount++;
 			t++;
-		    } else if (isep(*t))
+		    } else if (isep(*t) || *t == '\\')
 			sepcount++;
 		}
 		if (sepcount) {
@@ -858,7 +861,7 @@
 			    if (isep(t[1] ^ 32))
 				*nptr++ = '\\';
 			    *nptr++ = *t++;
-			} else if (isep(*t))
+			} else if (isep(*t) || *t == '\\')
 			    *nptr++ = '\\';
 			*nptr++ = *t++;
 		    }

-- 
Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Work: pws@csr.com
Web: http://www.pwstephenson.fsnet.co.uk

