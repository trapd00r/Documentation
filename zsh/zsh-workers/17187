From zsh-workers-return-17187-mason-zsh=primenet.com.au@sunsite.dk Mon May 20 17:43:42 2002
Return-Path: <zsh-workers-return-17187-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21143 invoked from network); 20 May 2002 17:43:41 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 20 May 2002 17:43:41 -0000
Received: (qmail 29353 invoked by alias); 20 May 2002 17:43:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 17187
Received: (qmail 29341 invoked from network); 20 May 2002 17:43:32 -0000
From: Borsenkow Andrej <Andrej.Borsenkow@mow.siemens.ru>
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: "'Zsh hackers list'" <zsh-workers@sunsite.dk>
Subject: Re: _call_program (and possibly other hooks) or opt_args quoting
	prob lem.
In-Reply-To: <1020520164035.ZM22369@candle.brasslantern.com>
References: 
	<6134254DE87BD411908B00A0C99B044F02E89AE4@mowd019a.mow.siemens.ru> 
	<1020520164035.ZM22369@candle.brasslantern.com>
Content-Type: text/plain; charset=KOI8-R
Content-Transfer-Encoding: quoted-printable
X-Mailer: Ximian Evolution 1.0.5-1mdk 
Date: 20 May 2002 21:43:19 +0400
Message-Id: <1021916607.3408.10.camel@localhost.localdomain>
Mime-Version: 1.0

=F7 =F0=CE=C4, 20.05.2002, =D7 20:40, Bart Schaefer =
=CE=C1=D0=C9=D3=C1=CC:
>=20
> I don't have this _info completion function, so I'm having a hard =
time
> coming up with a way to reproduce this.
>=20

You do no need to. Just do:

_foo() {
    local context state line ret=3D1
    typeset -A opt_args

    _arguments \
        '-d[directory]:directory:_files -/' \
        '1:test_arg:->test' && ret=3D0

    case "$state" in
        test )
            local -a opts
            (( $+opt_args[-d] )) && opts=3D(-W $opt_args[-d])
            _files $opts && ret=3D0
        ;;
    esac

    return $ret
}

mkdir a\ b
touch a\ b/test

and try to complete

foo -d $PWD/a\ b TAB


> Perhaps "${(@qqq)${(@e)argv[2,-1]}}" ?
>=20
> Or perhaps drop the `eval' and just use "${(@e)argv[2,-1]}}" directly =
in
> the latter branch -- the only reason I can think of for the `eval' to =
be
> there is to expand aliases, and I wouldn't think we'd want to do that =
when
> inside _call_program, but I could be wrong.
>=20
> } Actually I begin to feel that _arguments should eval parameter =
value
> } before storing it. Can anybody give example when parameter value as =
it
> } appears on command line is useful?=20
>=20
> I'm not sure what you mean by "parameter value as it appears" -- is =
the
> word "value" out of place in that phrase?
>

Once more:

user enters

$PWD/a\ b

as the "value" of option -d. When this is finally passed to a program
for execution, shell expands $PWD so program actually sees (remove
quotes) "/home/bor/test/a b". This is "real" value of option -d.
Alternatively, we can store it as it appears on the line - i.e. =
"$PWD/a\
b". _Then_ _call_program would work just fine - by eval'ing this you'd
get exactly the correct value.


What happens currently is, zsh removes quoting when it stores values in
opt_args array but it does not expand it. After this is done there is =
no
way to recover original string as entered by user. So in cases when you
may want it (see above example _foo) you have no means to get real
value.

Look in trace for above example:

+_foo:11> opts=3D( -W $PWD/a b )

how do we know that space has been quoted but dollar in $PWD was not?
Any quoting that you apply now will be equally applied to both space =
and
$ - while you need to leave $ unquoted (for eval).

=20
> What about the _expand completer?
>=20

The problem is not to complete the value of option (this works just
fine). The problem is to use this value in completing other parts of
command.

I am sorry if it is confusing but I really do not understand what you =
do
not understand ... it seems pretty clear to me :-)

-andrej

