Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <990126162520.ZM25560@candle.brasslantern.com>
Date: Tue, 26 Jan 1999 16:25:20 -0800
In-Reply-To: <19990126184200.B27794@fysh.org>
Comments: In reply to Phil Pennock <comet@fysh.org>
        "Example function" (Jan 26,  6:42pm)
References: <19990126184200.B27794@fysh.org>
X-Mailer: Z-Mail Lite (5.0.0 30July97)
To: Phil Pennock <comet@fysh.org>,
        Zsh Development Workers <zsh-workers@sunsite.auc.dk>
Subject: Re: Example function
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5037

On Jan 26,  6:42pm, Phil Pennock wrote:
> Subject: Example function
>       
> It's a zless which automatically determines from the file extension
> which decompressor to use.  The comments explain it.  This has evolved
> over about a year and a half, hence my needing help sorting out the
> array bit.

This is certainly interesting, but I'm really puzzled why you wanted to
do it the way you did it.  For example, why build a parallel dispfunc
array and then merge it with argv at the end, rather than just rewrite
argv in place (which you already do in some instances)?

Also the (@) flags in the variable expansions in the last line are
extraneous.

Anyway, here's how I'd write that same function (runs in 3.0.5, too, which
Phil's doesn't because of the for (( )) syntax):

function zl() {
  emulate -R zsh
  [[ $# -ge 1 ]] || return
  local lessopts
  set -A lessopts
  integer i=1 loi=1
  while ((i <= $#))
  do
    case $argv[i] in
    -zforce) argv[i,i+2]=("=($argv[i+1] \"$argv[i+2]\")"); ((++i));;
    -*) lessopts[loi++]=\"$argv[i]\"; argv[i]=(); continue;;
    *.(gz|Z)) argv[i]="=(zcat \"$argv[i]\")";;
    *.bz2) argv[i]="=(bzip2 -dc \"$argv[i]\")";;
    *.bz) argv[i]="=(bzip -dc \"$argv[i]\")";;
    esac
    ((++i))
  done
  eval command less $lessopts $*
}

Of course, this still assumes you don't have any less options or file names
that contain double-quote characters ...

(One of the things on the associative-array wishlist is "reverse pattern"
lookup, that is, treat the array keys as patterns and match them against
the subscript.  Then you could do silly stuff like

	typeset -A map
	map=('*.(gz|Z)'	zcat
	     '*.bz2' 'bzip2 -dc'
	     '*.bz' 'bzip -dc'
	     '*' '<')
	eval ${(q)map[$argv[i]]} '$argv[i]'

where I'm using (q) as the fictional reverse-pattern query flag; probably
there's a better letter.)

