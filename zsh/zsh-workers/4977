Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Mon, 25 Jan 1999 11:40:18 +0100 (MET)
Message-Id: <199901251040.LAA12723@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: suggestion for new condition
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 4977


Dunno if you'll like this one.

I sometimes missed an easy way to check if a certain parameter was set 
or of a specific type. The patch below adds the condition `-v' for
this:

  `-v param'       is true if the parameter `param' is set
  `-v param type'  is true if paramater `param' is set and of the
                   given type; `type' may be any of: scalar, array,
		   integer, association, left, right, right-blank,
		   right-zero, upper, readonly, tag, export, and
		   unique

Changing these names, adding single character abbreviations, and
allowing `-v' to take more than one type wouldn't be too hard to
implement, but I first wanted to know if anyone else likes it.

Except for the hunks in `new-completion-examples' the patch should
work with pws-[1-4] (or pws-[2-4]). The stuff in
`new-completion-examples' fixes a bug for the completion for `wait' I
just discovered and makes the new condition be used (e.g. for
completing keys in subscripts of associative arrays).

Bye
 Sven

*** os/cond.c	Mon Jan 25 10:22:39 1999
--- Src/cond.c	Mon Jan 25 10:27:33 1999
***************
*** 114,119 ****
--- 114,163 ----
  	return (!!strlen(c->left));
      case 'o':
  	return (optison(c->left));
+     case 'v':
+ 	{
+ 	    Param pm = (Param) paramtab->getnode(paramtab,
+ 						 (char *) c->left);
+ 
+ 	    if (c->right) {
+ 		char *tn = (char *) c->right;
+ 		int t = (pm ? pm->flags : 0);
+ 
+ 		if (!strcmp(tn, "scalar"))
+ 		    t = (PM_TYPE(t) == PM_SCALAR);
+ 		else if (!strcmp(tn, "array"))
+ 		    t = (PM_TYPE(t) == PM_ARRAY);
+ 		else if (!strcmp(tn, "integer"))
+ 		    t = (PM_TYPE(t) == PM_INTEGER);
+ 		else if (!strcmp(tn, "association"))
+ 		    t = (PM_TYPE(t) == PM_HASHED);
+ 		else if (!strcmp(tn, "left"))
+ 		    t = (t & PM_LEFT);
+ 		else if (!strcmp(tn, "right"))
+ 		    t = (t & (PM_RIGHT_B | PM_RIGHT_Z));
+ 		else if (!strcmp(tn, "right-blank"))
+ 		    t = (t & PM_RIGHT_B);
+ 		else if (!strcmp(tn, "right-zero"))
+ 		    t = (t & PM_RIGHT_Z);
+ 		else if (!strcmp(tn, "upper"))
+ 		    t = (t & PM_UPPER);
+ 		else if (!strcmp(tn, "readonly"))
+ 		    t = (t & PM_READONLY);
+ 		else if (!strcmp(tn, "tag"))
+ 		    t = (t & PM_TAGGED);
+ 		else if (!strcmp(tn, "export"))
+ 		    t = (t & PM_EXPORTED);
+ 		else if (!strcmp(tn, "unique"))
+ 		    t = (t & PM_UNIQUE);
+ 		else {
+ 		    zerr("unrecognized paramter type: `%s'", tn, 0);
+ 
+ 		    return 0;
+ 		}
+ 		return (pm ? t : 0);
+ 	    }
+ 	    return !!pm;
+ 	}
      case 'p':
  	return (S_ISFIFO(dostat(c->left)));
      case 'r':
*** os/parse.c	Mon Jan 25 10:22:41 1999
--- Src/parse.c	Mon Jan 25 10:27:33 1999
***************
*** 1332,1338 ****
      n->left = (void *) b;
      if (a[0] != '-' || !a[1])
  	COND_ERROR("parse error: condition expected: %s", a);
!     else if (!a[2] && strspn(a+1, "abcdefgknoprstuwxzhLONGS") == 1)
  	n->type = a[1];
      else {
  	char *d[2];
--- 1332,1338 ----
      n->left = (void *) b;
      if (a[0] != '-' || !a[1])
  	COND_ERROR("parse error: condition expected: %s", a);
!     else if (!a[2] && strspn(a+1, "abcdefgknoprstuvwxzhLONGS") == 1)
  	n->type = a[1];
      else {
  	char *d[2];
***************
*** 1393,1407 ****
  	    n->right = (void *) arrdup(d);
  	}
      } else if (a[0] == '-' && a[1]) {
! 	char *d[3];
  
! 	n->ntype = NT_SET(N_COND, NT_STR, NT_STR | NT_ARR, 0, 0);
! 	n->type = COND_MOD;
! 	n->left = (void *) a;
! 	d[0] = b;
! 	d[1] = c;
! 	d[2] = NULL;
! 	n->right = (void *) arrdup(d);
      } else
  	COND_ERROR("condition expected: %s", b);
      return n;
--- 1393,1413 ----
  	    n->right = (void *) arrdup(d);
  	}
      } else if (a[0] == '-' && a[1]) {
! 	if (a[1] == 'v' && !a[2]) {
! 	    n->ntype = NT_SET(N_COND, NT_STR, NT_STR, 0, 0);
! 	    n->type = 'v';
! 	    n->left = (void *) b;
! 	} else {
! 	    char *d[3];
  
! 	    n->ntype = NT_SET(N_COND, NT_STR, NT_STR | NT_ARR, 0, 0);
! 	    n->type = COND_MOD;
! 	    n->left = (void *) a;
! 	    d[0] = b;
! 	    d[1] = c;
! 	    d[2] = NULL;
! 	    n->right = (void *) arrdup(d);
! 	}
      } else
  	COND_ERROR("condition expected: %s", b);
      return n;
*** od/Zsh/cond.yo	Mon Jan 25 10:22:12 1999
--- Doc/Zsh/cond.yo	Mon Jan 25 10:27:45 1999
***************
*** 46,51 ****
--- 46,99 ----
  may be a single character, in which case it is a single letter option name.
  (See noderef(Specifying Options).)
  )
+ item(tt(-v) var(name) [ var(type) ])(
+ true if a parameter var(name) exists. If an optional var(type) is
+ given this conditions is true only if the parameter is of the given
+ type. Currently understood types are:
+ 
+ startitem()
+ item(tt(scalar))(
+ for scalar parameters
+ )
+ item(tt(array))(
+ for arrays
+ )
+ item(tt(integer))(
+ for integer parameters
+ )
+ item(tt(associative))(
+ for associative arrays
+ )
+ item(tt(left))(
+ for left justified parameters
+ )
+ item(tt(right))(
+ for right justified parameters
+ )
+ item(tt(right-blank))(
+ for right justified parameters with leading blanks
+ )
+ item(tt(right-zero))(
+ for right justified parameters with leading zeros
+ )
+ item(tt(upper))(
+ for parameters whose values are converted to all upper case when they
+ are expanded
+ )
+ item(tt(readonly))(
+ for readonly parameters
+ )
+ item(tt(tagg))(
+ for tagged parameters
+ )
+ item(tt(export))(
+ for exported parameters
+ )
+ item(tt(unique))(
+ for arrays which keep only the first occurrence of duplicated values
+ )
+ enditem()
+ )
  item(tt(-p) var(file))(
  true if var(file) exists and is a FIFO special file (named pipe).
  )
*** om/new-completion-examples	Mon Jan 25 11:24:35 1999
--- Misc/new-completion-examples	Mon Jan 25 11:37:00 1999
***************
*** 43,49 ****
      shift
      autoload "$1"
    fi
!   if [[ ${+patcomps} == 1 ]] then
      patcomps=("$patcomps[@]" "$2 $1" )
    else
      patcomps=( "$2 $1" )
--- 43,49 ----
      shift
      autoload "$1"
    fi
!   if [[ -v patcomps ]] then
      patcomps=("$patcomps[@]" "$2 $1" )
    else
      patcomps=( "$2 $1" )
***************
*** 75,87 ****
  # the arguments from the command line as its arguments.
  
  call-complete() {
!   local var
! 
!   eval var\=\$\{\+$1\}
!   if [[ "$var" == 0 ]] then
!     "$@"
!   else
      eval complist \$\{${1}\[\@\]\}
    fi
  }
  
--- 75,84 ----
  # the arguments from the command line as its arguments.
  
  call-complete() {
!   if [[ -v $1 ]] then
      eval complist \$\{${1}\[\@\]\}
+   else
+     "$@"
    fi
  }
  
***************
*** 324,330 ****
  defcomp __subscr --subscr--
  __subscr() {
    compalso --math-- "$@"
!   # ...probably other stuff
  }
  
  # Do sub-completion for pre-command modifiers.
--- 321,327 ----
  defcomp __subscr --subscr--
  __subscr() {
    compalso --math-- "$@"
!   [[ -v $COMMAND association ]] && eval complist -k \"\(\$\{\(k\)$COMMAND\}\)\"
  }
  
  # Do sub-completion for pre-command modifiers.
***************
*** 368,376 ****
  defcomp __bjobs bg
  __bjobs=(-z -P '%')
  
- defcomp wait
- __wait=(-j -P '%' + -s '`ps -x | tail +2 | cut -c1-5`')
- 
  defcomp __arrays shift
  __arrays=(-A)
  
--- 365,370 ----
***************
*** 536,541 ****
--- 530,541 ----
      complist -P '%' -j
      complist -y killfunc -s '`ps -x 2>/dev/null | tail +2 | cut -c1-5`'
    fi
+ }
+ 
+ defcomp wait
+ __wait() {
+     complist -P '%' -j
+     complist -y killfunc -s '`ps -x 2>/dev/null | tail +2 | cut -c1-5`'
  }
  
  defcomp cd

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

