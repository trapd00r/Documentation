From zsh-workers-return-28008-mason-zsh=primenet.com.au@zsh.org Tue Jun 08 13:39:40 2010
Return-Path: <zsh-workers-return-28008-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15011 invoked by alias); 8 Jun 2010 13:39:40 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28008
Received: (qmail 16393 invoked from network); 8 Jun 2010 13:39:38 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-4.2 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_MED
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at fys.uio.no does not designate permitted sender hosts)
Date: Tue, 8 Jun 2010 15:39:34 +0200
From: Haakon Riiser <haakon.riiser@fys.uio.no>
To: zsh-workers@zsh.org
Subject: New completion script for FFmpeg
Message-ID: <20100608133933.GA24553@snowbird.venod.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.20 (2009-06-14)
X-UiO-Ratelimit-Test: rcpts/h 5 msgs/h 4 sum rcpts/h 5 sum msgs/h 4 total rcpts 200 max rcpts/h 6 ratelimit 0
X-UiO-Spam-info: not spam, SpamAssassin (score=-5.0, required=5.0, autolearn=disabled, UIO_MAIL_IS_INTERNAL=-5, uiobl=NO, uiouri=NO)
X-UiO-Scanned: 2CA25924004AF0C5E115E43DD50B325D376FEF0D
X-UiO-SPAM-Test: remote_host: 84.209.71.9 spam_score: -49 maxlevel 80 minaction 2 bait 0 mail/h: 4 total 159 max/h 5 blacklist 0 greylist 0 ratelimit 0

Just wrote a completion script for the audio/video encoder FFmpeg,
and thought I'd share it here in case you want to include it
with zsh.  Since FFmpeg is a moving target (most people use SVN
snapshots), the script uses perl and the ffmpeg executable to
dynamically generate the argument specification.  Hopefully,
this should make the completer more future-proof.  (It assumes
that both ffmpeg and perl is in the PATH, though.)

##############################################################################
#compdef ffmpeg

local context state line
typeset -A opt_args

local BOLD=$'\e[1m'
local NORM=$'\e[m'

_ffmpeg_compadd() {
    compadd -X "${BOLD}$1${NORM}" -q -S "$3" -a $2
}

_ffmpeg_acodecs() {
    local acodecs
    acodecs=($(ffmpeg -codecs 2>/dev/null | sed -n '/^ .[E ]A/ {s/^ .......//; s/ .*//p;}'))
    _ffmpeg_compadd 'force audio codec (''copy'' to copy stream)' acodecs ''
}

_ffmpeg_vcodecs() {
    local vcodecs
    vcodecs=($(ffmpeg -codecs 2>/dev/null | sed -n '/^ .[E ]V/ {s/^ .......//; s/ .*//p;}'))
    _ffmpeg_compadd 'force video codec (''copy'' to copy stream)' vcodecs ''
}

_ffmpeg_argspecs="$(ffmpeg -h 2>/dev/null | perl -e '
my $lastopt;
my $lastopt_description;
my $lastopt_takesargs;
my @lastopt_values;
while (<>) {
    if (/^(-\S+)\s+(\S.+)$/) {
        print_opt();
        $lastopt = $1;
        $lastopt_description = $2;
        if ($lastopt_description =~ /<\w+>/) {
            $lastopt_description =~ s/<.*?>\s+//;
            $lastopt_description =~ s/\S{5} ?//;
            $lastopt_description = $lastopt if not $lastopt_description;
            escape_str($lastopt_description);
        } elsif ($lastopt_description =~ /^(\S+)\s\s+/) {
            my $example = $1;
            $lastopt_description =~ s/^\S+\s\s+//;
            escape_str($example);
            escape_str($lastopt_description);
            if ($example eq q(filename)) {
                $lastopt_takesargs = 0;
                $lastopt .= qq(:$lastopt_description:_files);
            } elsif ($lastopt eq q(-acodec)) {
                $lastopt_takesargs = 0;
                $lastopt .= qq(:$lastopt_description:_ffmpeg_acodecs);
            } elsif ($lastopt eq q(-vcodec)) {
                $lastopt_takesargs = 0;
                $lastopt .= qq(:$lastopt_description:_ffmpeg_vcodecs);
            } else {
                $lastopt_takesargs = 1;
                $lastopt_description .= qq{ ($example)};
            }
        } else {
            $lastopt_takesargs = 0;
        }
        @lastopt_values = ();
    } elsif (/^   (\S+)/) {
        $lastopt_takesargs = 1;
        push @lastopt_values, $1;
    }
}
print_opt();
exit;

sub escape_str {
    $_[0] =~ s/:/\\:/g;
}

sub print_opt {
    return if not $lastopt;

    print qq($lastopt);
    if (!$lastopt_takesargs) {
        print qq(\n);
    } else {
        print qq(:$lastopt_description:);
        if (@lastopt_values) {
            printf qq{(%s)}, join(q( ), @lastopt_values);
        }
        print qq(\n);
    }
}
')"
_ffmpeg_argspecs=(${(f)_ffmpeg_argspecs})

_arguments -S \
    "${_ffmpeg_argspecs[@]}" \
    '*:output file:_files' \
    && return 0

return 1
##############################################################################

-- 
 Haakon

