From zsh-users-return-5538-mason-zsh=primenet.com.au@sunsite.dk Tue Nov 26 17:00:11 2002
Return-Path: <zsh-users-return-5538-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3227 invoked from network); 26 Nov 2002 17:00:10 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 26 Nov 2002 17:00:10 -0000
Received: (qmail 7891 invoked by alias); 26 Nov 2002 16:59:28 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5538
Received: (qmail 7854 invoked from network); 26 Nov 2002 16:59:23 -0000
Message-ID: <6134254DE87BD411908B00A0C99B044F04945AD3@MOWD019A>
From: Borzenkov Andrey <Andrey.Borzenkov@siemens.com>
To: "'dominik.vogt@gmx.de'" <dominik.vogt@gmx.de>,
   "'zsh-users@sunsite.dk'" <zsh-users@sunsite.dk>
Subject: RE: why does "jobs | wc" not work?
Date: Tue, 26 Nov 2002 20:11:37 +0300
MIME-Version: 1.0
X-Mailer: Internet Mail Service (5.5.2653.19)
Content-Type: text/plain

> 
> Yes, I noticed that in the mean time.  Actually, all I am trying
> to do is fetch the number of background jobs in sh without calling
> external commands

bor@itsrm2% sleep 1000000 &
[1] 20639
bor@itsrm2% echo $#jobstates 
1
bor@itsrm2% echo $ZSH_VERSION 
4.0.4

-andrey


 and - preferrably - not writing temporary data
> to files.  It's surprisingly difficult to do:
> 
>   I=0; jobs | while read FOO; do I=$[I+1]; done; echo $I
> 
> works neither in zsh (jobs produces no output) nor in sh (the I
> variable is local to the subshell running "while").  In sh
> (actually, bash in sh mode), I can assign the output of jobs to
> a variable:
> 
>   JOBS=`jobs`
> 
> But that doesn't help because I see no way to get that as input
> into the while loop without forking it into a subshell.  In zsh,
> this should work:
> 
>   I=0; echo "$JOBS" | while read X; do I=$[I+1]; done; echo $I
> 
> But then,
> 
>   JOBS=`jobs`
> 
> fails :-/
> 
> All I can think of is to write the output in a temporary file:
> 
>   jobs > x; I=0; while read X; do I=$[I+1]; done < x; echo $I
> 
> Can anyone think of a more efficient way (speed does matter here)?
> 
> Bye
> 
> Dominik ^_^  ^_^



