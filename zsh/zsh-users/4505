From zsh-users-return-4505-mason-zsh=primenet.com.au@sunsite.dk Sat Nov 24 23:05:09 2001
Return-Path: <zsh-users-return-4505-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3454 invoked from network); 24 Nov 2001 23:05:08 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 24 Nov 2001 23:05:08 -0000
Received: (qmail 24996 invoked by alias); 24 Nov 2001 23:04:50 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 4505
Received: (qmail 24985 invoked from network); 24 Nov 2001 23:04:49 -0000
Message-ID: <20011124230445.73247.qmail@web12302.mail.yahoo.com>
Date: Sat, 24 Nov 2001 18:04:45 -0500 (EST)
From: Le Wang <lewang@yahoo.com>
Subject: compinit problems with CygWin and Win XP
To: Zsh users list <zsh-users@sunsite.dk>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

Hi all,

I've used Zsh with cygwin and win2k with no probs for
a few weeks, and I just upgraded to XP.  I just
compiled Zsh 4.0.4 with no errors using:

./configure && make && make test && make install

But now when I execute:

autoload -U compinit
compinit

I get this huge dump of functions:

-------------------------
_call_program () {
	local tmp
	if zstyle -s ":completion:${curcontext}:${1}" command
tmp
	then
		if [[ "$tmp" = -* ]]
		then
			eval "$tmp[2,-1]" "$argv[2,-1]"
		else
			eval "$tmp"
		fi
	else
		eval "$argv[2,-1]"
	fi
}
compdump () {
	# undefined
	builtin autoload -XU
}
compinit () {
	emulate -L zsh
	setopt extendedglob
	typeset _i_dumpfile _i_files _i_line _i_done _i_dir
_i_autodump=1
	typeset _i_tag _i_file _i_addfiles _i_fail=ask
_i_check=yes _i_name
	while [[ $# -gt 0 && $1 = -[dDiuC] ]]
	do
		case "$1" in
			-d) _i_autodump=1 
				shift
				if [[ $# -gt 0 && "$1" != -[dfQC] ]]
				then
					_i_dumpfile="$1" 
					shift
				fi ;;
			-D) _i_autodump=0 
				shift ;;
			-i) _i_fail=ign 
				shift ;;
			-u) _i_fail=use 
				shift ;;
			-C) _i_check= 
				shift ;;
		esac
	done
	typeset -gA _comps _services _patcomps _postpatcomps
_compautos
	typeset -gA _lastcomp
	if [[ -n $_i_dumpfile ]]
	then
		_comp_dumpfile="$_i_dumpfile" 
	else
		_comp_dumpfile="${ZDOTDIR:-$HOME}/.zcompdump" 
	fi
	_comp_options=(glob bareglobqual nullglob
rcexpandparam extendedglob unset NO_markdirs
NO_globsubst NO_shwordsplit NO_shglob NO_kshglob
NO_ksharrays NO_cshnullglob NO_allexport NO_aliases
NO_errexit) 
	_comp_setup='setopt localoptions localtraps
${_comp_options[@]};
             exec </dev/null;
             trap - ZERR' 
	compprefuncs=() 
	comppostfuncs=() 
	: $funcstack
	compdef () {
		local opt autol type func delete new i ret=0 cmd svc
		if [[ $#* -eq 0 ]]
		then
			echo "$0: I needs arguments"
			return 1
		fi
		while getopts "anpPkKd" opt
		do
			case "$opt" in
				a) autol=yes  ;;
				n) new=yes  ;;
				[pPkK]) if [[ -n "$type" ]]
					then
						echo "$0: type already set to $type"
						return 1
					fi
					if [[ "$opt" = p ]]
					then
						type=pattern 
					elif [[ "$opt" = P ]]
					then
						type=postpattern 
					elif [[ "$opt" = K ]]
					then
						type=widgetkey 
					else
						type=key 
					fi ;;
				d) delete=yes  ;;
			esac
		done
		shift OPTIND-1
		if [[ $#* -eq 0 ]]
		then
			echo "$0: I needs arguments"
			return 1
		fi
		if [[ -z "$delete" ]]
		then
			if [[ "$1" = *\=* ]]
			then
				for i
				do
					if [[ "$i" = *\=* ]]
					then
						cmd="${i%%\=*}" 
						svc="${i#*\=}" 
						func="$_comps[${(k)_services[(R)$svc]:-$svc}]" 
						(( $+_services[$svc] )) && svc=$_services[$svc] 
						[[ -z "$func" ]] &&
func="${_patcomps[(K)$svc][1]:-${_postpatcomps[(K)$svc][1]}}"

						if [[ -n "$func" ]]
						then
							_comps[$cmd]="$func" 
							_services[$cmd]="$svc" 
						else
							echo "$0: unknown command or service: $svc"
							ret=1 
						fi
					else
						echo "$0: invalid argument: $i"
						ret=1 
					fi
				done
				return ret
			fi
			func="$1" 
			[[ -n "$autol" ]] && autoload -U "$func"
			shift
			case "$type" in
				pattern) if [[ $# -gt 1 ]]
					then
						echo "$0: only one pattern allowed"
						return 1
					fi
					_patcomps[$1]="$func"  ;;
				postpattern) if [[ $# -gt 1 ]]
					then
						echo "$0: only one pattern allowed"
						return 1
					fi
					_postpatcomps[$1]="$func"  ;;
				widgetkey) while [[ -n $1 ]]
					do
						if [[ $# -lt 3 ]]
						then
							echo "$0: compdef -K requires <widget>
<comp-widget> <key>"
							return 1
						fi
						[[ $1 = _* ]] || 1="_$1" 
						[[ $2 = .* ]] || 2=".$2" 
						[[ $2 = .menu-select ]] && zmodload -i
zsh/complist
						zle -C "$1" "$2" "$func"
						if [[ -n $new ]]
						then
							bindkey "$3" | read -A opt
							[[ $opt[-1] = undefined-key ]] && bindkey "$3"
"$1"
						else
							bindkey "$3" "$1"
						fi
						shift 3
					done ;;
				key) if [[ $# -lt 2 ]]
					then
						echo "$0: missing keys"
						return 1
					fi
					if [[ $1 = .* ]]
					then
						[[ $1 = .menu-select ]] && zmodload -i
zsh/complist
						zle -C "$func" "$1" "$func"
					else
						[[ $1 = menu-select ]] && zmodload -i
zsh/complist
						zle -C "$func" ".$1" "$func"
					fi
					shift
					for i
					do
						if [[ -n $new ]]
						then
							bindkey "$i" | read -A opt
							[[ $opt[-1] = undefined-key ]] || continue
						fi
						bindkey "$i" "$func"
					done ;;
				*) for i
					do
						if [[ "$i" = *\=* ]]
						then
							cmd="${i%%\=*}" 
							svc=yes 
						else
							cmd="$i" 
							svc= 
						fi
						if [[ -z "$new" || "${+_comps[$i]}" -eq 0 ]]
						then
							_comps[$cmd]="$func" 
							if [[ -n "$svc" ]]
							then
								_services[$cmd]="${i#*\=}" 
							fi
						fi
					done ;;
			esac
		else
			case "$type" in
				pattern) unset "_patcomps[$^@]" ;;
				postpattern) unset "_postpatcomps[$^@]" ;;
				key) echo "$0: cannot restore key bindings"
					return 1v ;;
				*) unset "_comps[$^@]" ;;
			esac
		fi
	}
	typeset _i_wdirs _i_wfiles
	_i_wdirs=() 
	_i_wfiles=() 
	autoload -U compaudit
	if [[ -n "$_i_check" ]]
	then
		typeset _i_q
		if ! eval compaudit
		then
			if [[ -n "$_i_q" ]]
			then
				if [[ "$_i_fail" = ask ]]
				then
					if ! read -q "?Ignore insecure $_i_q and continue
[ny]? "
					then
						echo "$0: initialization aborted"
						unfunction compinit compdef
						unset _comp_dumpfile _comp_secure compprefuncs
comppostfuncs _comps _patcomps _postpatcomps
_compautos _lastcomp
						return 1
					fi
					_i_wfiles=() 
					_i_wdirs=() 
				else
					(( $#_i_wfiles )) &&
_i_files=("${(@)_i_files:#(${(j:|:)_i_wfiles%.zwc})}")

					(( $#_i_wdirs )) &&
_i_files=("${(@)_i_files:#(${(j:|:)_i_wdirs%.zwc})/*}")

				fi
			fi
			_comp_secure=yes 
		fi
	fi
	autoload -U compdump compinstall
	_i_done='' 
	if [[ -f "$_comp_dumpfile" ]]
	then
		if [[ -n "$_i_check" ]]
		then
			read -rA _i_line < "$_comp_dumpfile"
			if [[ _i_autodump -eq 1 && $_i_line[2] -eq
$#_i_files ]]
			then
				builtin . "$_comp_dumpfile"
				_i_done=yes 
			fi
		else
			builtin . "$_comp_dumpfile"
			_i_done=yes 
		fi
	fi
	if [[ -z "$_i_done" ]]
	then
		typeset -A _i_test
		for _i_dir in $fpath
		do
			[[ $_i_dir = . ]] && continue
			(( $_i_wdirs[(I)$_i_dir] )) && continue
			for _i_file in $_i_dir/^([^_]*|*~|*.zwc)(N)
			do
				_i_name="${_i_file:t}" 
				(( $+_i_test[$_i_name] + $_i_wfiles[(I)$_i_file]
)) && continue
				_i_test[$_i_name]=yes 
				read -rA _i_line < $_i_file
				_i_tag=$_i_line[1] 
				shift _i_line
				case $_i_tag in
					\#compdef) if [[ $_i_line[1] = -[pPkK](n|) ]]
						then
							compdef ${_i_line[1]}na "${_i_name}"
"${(@)_i_line[2,-1]}"
						else
							compdef -na "${_i_name}" "${_i_line[@]}"
						fi ;;
					\#autoload) autoload -U "$_i_line[@]" ${_i_name}
						[[ "$_i_line" != \ # ]] &&
_compautos[${_i_name}]="$_i_line"  ;;
				esac
			done
		done
		if [[ $_i_autodump = 1 ]]
		then
			compdump
		fi
	fi
	for _i_line in complete-word delete-char-or-list
expand-or-complete expand-or-complete-prefix
list-choices menu-complete menu-expand-or-complete
reverse-menu-complete
	do
		zle -C $_i_line .$_i_line _main_complete
	done
	zle -la menu-select && zle -C menu-select
.menu-select _main_complete
	bindkey '^i' | read -A _i_line
	if [[ ${_i_line[2]} = expand-or-complete ]] && zstyle
-a ':completion:' completer _i_line && ((
${_i_line[(i)_expand]} <= ${#_i_line} ))
	then
		bindkey '^i' complete-word
	fi
	unfunction compinit compaudit
	autoload -U compinit compaudit
	return 0
}
compinstall () {
	# undefined
	builtin autoload -XU
}
---------------------

Anyone else come across this?

Thanks
-lw

_______________________________________________________
Build your own website in minutes and for free at http://ca.geocities.com

