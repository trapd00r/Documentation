From zsh-users-return-9263-mason-zsh=primenet.com.au@sunsite.dk Sun Aug 07 09:12:48 2005
Return-Path: <zsh-users-return-9263-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20753 invoked from network); 7 Aug 2005 09:12:39 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 7 Aug 2005 09:12:39 -0000
Received: (qmail 85241 invoked from network); 7 Aug 2005 09:12:32 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 7 Aug 2005 09:12:32 -0000
Received: (qmail 6842 invoked by alias); 7 Aug 2005 09:12:03 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 9263
Received: (qmail 6825 invoked from network); 7 Aug 2005 09:12:03 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 7 Aug 2005 09:12:03 -0000
Received: (qmail 82896 invoked from network); 7 Aug 2005 09:12:03 -0000
Received: from unknown (HELO ivc.alykel.ru) (80.255.146.26)
  by a.mx.sunsite.dk with SMTP; 7 Aug 2005 09:10:14 -0000
Received: (qmail 7001 invoked by uid 89); 7 Aug 2005 09:10:07 -0000
Received: from unknown (HELO ?192.168.200.192?) (uvv@alykel.ru@192.168.200.192)
  by 0 with SMTP; 7 Aug 2005 09:09:56 -0000
Message-ID: <42F5D004.2040707@yandex.ru>
Date: Sun, 07 Aug 2005 17:10:28 +0800
From: UVV <UVV-mail@yandex.ru>
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru-RU; rv:1.7) Gecko/20040618
X-Accept-Language: en-us, en, ru
MIME-Version: 1.0
To:  zsh-workers@sunsite.dk,  zsh-users@sunsite.dk
Subject: Russian FAQ
Content-Type: multipart/mixed;
 boundary="------------090109020601050809040306"
X-Spam-Checker-Version: SpamAssassin 3.0.4 (2005-06-05) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.3 required=5.0 tests=AWL,BAYES_00,URI_REDIRECTOR 
	autolearn=unavailable version=3.0.4

This is a multi-part message in MIME format.
--------------090109020601050809040306
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

With no comments!
Please, mail me about any mistakes!

--------------090109020601050809040306
Content-Type: text/plain;
 name="zshfaq.yo"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
 filename="zshfaq.yo"

mailto(pws@pwstephenson.fsnet.co.uk)\
whentxt(notableofcontents())\
COMMENT(-- mytt is like tt but adds quotes `like this' for plain text --)\
def(mytt)(1)(\
  whentxt(`ARG1')\
  whenhtml(tt(ARG1))\
  whenlatex(tt(ARG1))\
  whenms(tt(ARG1))\
  whensgml(tt(ARG1)))\
COMMENT(-- mybf/em are like bf/em but add *emphasis* for text too --)\
def(mybf)(1)(\
  whentxt(*ARG1*)\
  whenhtml(bf(ARG1))\
  whenlatex(bf(ARG1))\
  whenms(bf(ARG1))\
  whensgml(bf(ARG1)))\
def(myem)(1)(\
  whentxt(_ARG1_)\
  whenhtml(em(ARG1))\
  whenlatex(em(ARG1))\
  whenms(em(ARG1))\
  whensgml(em(ARG1)))\
COMMENT(-- mydit is like dit but no `o' for text mode --)\
def(mydit)(1)(\
    whenlatex(dit(ARG1))\
    whenhtml(dit(ARG1))\
    whentxt(ARG1)\
    whenman(dit(ARG1))\
    whenms(dit(ARG1))\
    whensgml(dit(ARG1)))\
COMMENT(-- myeit is like eit but fancier text formatting --)\
def(myeit)(0)(\
    whenlatex(eit())whenhtml(eit())whenman(eit())whenms(eit())whensgml(eit())\
    whentxt(eit()CHAR(41)))\
def(myeitd)(0)(\
    whenlatex(eit())whenhtml(eit())whenman(eit())whenms(eit())whensgml(eit())\
    whentxt(.))\
COMMENT(-- don't want headers for text, USENET headers must come first --)\
def(myreport)(3)(\
whentxt(report()()())\
whenhtml(report(ARG1)(ARG2)(ARG3))\
whenlatex(report(ARG1)(ARG2)(ARG3))\
whenman(report(ARG1)(ARG2)(ARG3))\
whenms(report(ARG1)(ARG2)(ARG3))\
whensgml(report(ARG1)(ARG2)(ARG3)))
myreport(Z-Shell Часто задаваемые вопросы)(Peter Stephenson)(2005/01/11)
COMMENT(-- the following are for Usenet and must appear first)\
description(\
mydit(Имя архива:) unix-faq/shell/zsh 
mydit(Последнее изменение:) 01.08.2005 
mydit(Опубликовано:) email(pws@pwstephenson.fsnet.co.uk (Peter Stephenson)) 
mydit(Переведено:) email(UVV-mail@yandex.ru (Юрков Вячеслав Владимирович)) 
mydit(Частота обновления:) ежемесячно
mydit(Авторская информация:) (C) P.W. Stephenson, 1995--2005 (См. в конце документа)
)

  Этот документ содержит список часто задаваемых (или просто важных) вопросов, касающихся Z-shell, командного интерпретатора для многих UNIX-систем, который свободно доступен всем, у кото есть FTP-доступ. Zsh относится к числу самых мощных свободно доступных Bourne-like шеллов для интерактивного использования. 

  Если вы никогда не слышали о mytt(sh), mytt(csh) или mytt(ksh), тогда вам вероятно лучше начать с чтения обычного введения в UNIX, чем с этого документа. 

  Если вы хотите узнать, где взять последнюю версию, переходите к вопросу link(1.6)(16), а неразрешимые проблемы освещены в вопросе link(5.2)(52). 
  whentxt(Замечание: Текст, заключённый в `такие кавычки', является простым текстом. Фрагменты, которые вы вводите, заключаются в другие кавычки.)
COMMENT(-- need to do this specially in text since it should go here --)
whentxt(Содержание:
Глава 1: Знакомство с zsh и как его установить
1.1: Источники информации
1.2: Что это?
1.3: Что в нём хорошего?
1.4: На каких машинах он запустится? (А также важные замечания по компиляции)
1.5: Какая последняя версия?
1.6: Где мне его взять?
1.7: У меня нет доступа суперпользователя: как сделать, чтобы zsh запускался при входе в систему?

Глава 2: Чем zsh отличается от ...?
2.1: Отличия от sh и ksh
2.2: Сходства с csh
2.3: Почему мои псевдонимы от csh не работают? (А также другие ошибки с псевдонимами.)
2.4: Сходства с tcsh
2.5: Сходства с bash
2.6: Должен ли zsh быть больше/меньше похож на ksh/(t)csh?
2.7: Поддерживает ли zsh Unicode/UTF-8?

Глава 3: Как заставить работать различные вещи
3.1: Почему переменная `$var', где `var="foo bar"' не делает того чего я ожидаю?
3.2: В какой конфигурационный файл я должен прописать...?
3.3: В чём различия между `export' и параметром ALL_EXPORT ?
3.4: Как мне выключить коррекцию правописания/универсализацию файловых имён для одной команды?
3.5: Как мне сделать, чтобы мета клавиша работала на моём xterm?
3.6: Как мне сделать, чтобы текущая директория автоматически выводилась в заголовке xterm?
3.7: Как мне сделать, чтобы лист завершения команд использовал 8-битные символы?
3.8: Почему "стрелки" (клавиши управления курсором) не работают?
3.9: Почему терминал в некоторых случаях ведёт себя смешно?
3.10: Почему zsh не работает больше в режиме Emacs?
3.11: Почему мои автозагружаемые функции не загружаются?
3.12: Как работает базовая арифметика?
3.13: Как мне получить новую строку в приглашении?
3.14: Почему `bindkey ^a command-name' или `stty intr ^-' ведут себя как-то смешно?
3.15: Почему я не могу больше связать сочетания \C-s и \C-q ?
3.16: Как мне выполнить команду `foo' внутри функции foo?
3.17: Почему подстановка команды из истории при использовании восклицательного знака возвращает что-то смешное?
3.18: Почему zsh убивает все фоновые процессы при выходе?
3.19: Как мне просмотреть всё содержимое истории?
3.20: Почему другой синтаксис цикла тоже работает, например `while {...} {...}'?
3.21: Почему моя история не сохранилась?
3.22: Как получить значение переменной, имя которой является значением другой переменной?
3.23: Как предотвратить затирание сообщения, в котором нет символа новой строки, приглашением командной строки?
3.24: Что случилось с операциями вырезания и вставки в xterm?
3.25: Как мне разукрасить приглашение командной строки в цветном xterm?
3.26: Почему при выполнении команды `foo 2>&1 >foo.out | bar' вывод дублируется?

Глава 4: Секреты завершения
4.1: Что такое завершение?
4.2: Что может быть завершено?
4.3: Как zsh поступает с неопределёнными завершениями?
4.4: Как мне завершить в середине слова / до курсора?
4.5: Как мне начать с программируемым завершением?
4.6: Достаточно ли полезно программируемое завершение?

Глава 5: Будущее zsh
5.1: Какие ошибки известны и неисправлены? (А также недавние важные изменения)
5.2: Где мне доложить об ошибках, получить больше информации / кто работает над zsh?
5.3: Как насчёт списка пожеланий?
5.4: Есть ли у zsh проблема 2000 года (отображение даты)?

Благодарности

Авторская информация
--- Конец содержания ---
)

chapter(Знакомство с zsh и как его установить)

sect(Источники информации)
label(11)

  Информация о zsh доступна через World Wide Web: url(http://sunsite.dk/zsh/)(http://sunsite.dk/zsh/) . Сервер предоставляет этот FAQ и много другого, в данный момент он поддерживается Karsten Thygesen и другими (email(zsh@sunsite.dk)). FAQ находится здесь url(http://sunsite.dk/zsh/FAQ/)(http://sunsite.dk/zsh/FAQ/) . На сайте также можно найти zsh-скрипты и функции; мы с удовольствием добавим другие или просто дадим ссылку на вашу собственную коллекцию.

  Этот документ в оригинале был написан в формате YODL, позволяющем легко конвертировать себя в различные форматы. Главный исходный файл лежит здесь url(http://sunsite.dk/zsh/FAQ/zshfaq.yo)(http://sunsite.dk/zsh/FAQ/zshfaq.yo) и текстовая версия: url(http://sunsite.dk/zsh/FAQ/zshfaq.txt)(http://sunsite.dk/zsh/FAQ/zshfaq.txt) .

  Другой полезный источник информации - это собрание FAQ-статей, часто размещаемых в Usenet группе новостей comp.unix.questions, comp.unix.shells и comp.answers с ответами на обычные вопросы по UNIX. Пять из семи статей связаны с шеллами, включая zsh, с кратким описанием различий. Так же существует отдельный FAQ по различиям шеллов и как сменить шелл. FAQ'и Usenet'а доступны по FTP с rtfm.mit.edu и зеркал, а так же через World Wide Web:

  description(
    mydit(США)             url(http://www.cis.ohio-state.edu/hypertext/faq/usenet/top.html)
    (http://www.cis.ohio-state.edu/hypertext/faq/usenet/top.html)
    mydit(Великобритания)  url(http://www.lib.ox.ac.uk/internet/news/faq/comp.unix.shell.html)
    (http://www.lib.ox.ac.uk/internet/news/faq/comp.unix.shell.html)
    mydit(Нидерланды)      url(http://www.cs.uu.nl/wais/html/na-dir/unix-faq/shell/.html)
    (http://www.cs.uu.nl/wais/html/na-dir/unix-faq/shell/.html)
  )

  Вы так же можете получить его по электронной почте, послав письмо на email(mail-server@rtfm.mit.edu) с сообщением mytt(send faqs/unix-faq/shell/zsh).

  Последняя версия этого FAQ также доступна из любого zsh архива, указанного в списке в пункте link(1.6)(16).

  Для удобства чтения, а также вдобавок к описанию полезных возможностей я выложил туда же руководство пользователя. Это будет долгий проект, но неполная версия рассказывает, как писать конфигурационные файлы и как использовать новую, более мощную форму завершения, которая впервые появилась в версии 3.1.6 (и не описана в этом FAQ'е), оно (руководство) может быть найдено здесь url(http://www.pwstephenson.fsnet.co.uk/computing/)(http://www.pwstephenson.fsnet.co.uk/computing/) ,причём в различных форматах.

  (Как метод чтения в Emacs, вы можете набрать tt(\M-2 \C-x $) , чтобы сделать весь структурированный текст невидимым, затем tt(\M-0 \C-x $) , когда вы на заголовке, который вам нужен)

  Для более эклектичной информации вам следует посетить вопрос link(5.2)(52).

sect(Что это?)

  Zsh - это командный интерпретатор UNIX (шелл), который из стандартных шеллов больше похож на Korn shell (ksh); его совместимость с 1988 Korn shell постепенно выросла. Он включает усовершенствования многих типов, особенно в редакторе командной строки, параметры для выбора режима, универсализацию файловых имён, функции, к которым привыкли пользователи C-shell (csh), и дополнительные возможности, взятые из tcsh других шеллов.

  Его написал Paul Falstad, когда он был студентом университета Princeton; тем не менее, Paul больше не поддерживает его и вопросы следует отправлять в рассылку (см. вопрос link(5.2)(52)). Zsh распространяется на условиях стандартной лицензии Berkeley.

  За подробностями рекомендуется обратиться к файлам Doc/intro.txt или Doc/intro.troff, включённым в исходный код дистрибутива. Список возможностей приведён в файле FEATURES.

sect(Что в нём хорошего?)

  Вот несколько пунктов в чём zsh действительно хорош. Не претендует на исключительность, особенно как шеллы, копирующие друг друга, хотя в редакторе командной строки и в универсализации файловых имён zsh вне конкуренции. Я не знаю о главных интерактивных особенностях в других свободно доступных шеллах, которые zsh также не имеет (за исключением некоторых).

  itemize(
  it() Редактор командной строки:
  itemize(
    it() программируемое завершение: объединяет способность использовать всю мощь zsh: универсализацию имён и возможности программирования,
    it() многострочные команды доступны для редактирования как один буфер (даже файлы!),
    it() редактирование переменных (vared),
    it() стек буфера команд,
    it() печать текста прямо в буфер непосредственно для редактирования (print -z),
    it() выполнение несвязанных команд,
    it() два разных вида меню завершения,
    it() завершение переменных, функций и параметров,
    it() встроенное расширение переменных и команд истории.  
  )
  it() Чрезвычайно мощная универсализация имён включает в себя:
  itemize(
    it() рекурсивная универсализация имён (см. find),
    it() уточнение файловых атрибутов (размер, тип, т.д. также cf. find),
    it() полное замещение и отрицание шаблонов.
  )
  it() Поддержка нескольких перенаправлений (проще, чем tee).
  it() Большое количество параметров для приспосабливания.
  it() Расширение пути (=foo -> /usr/bin/foo).
  it() Удобочитаемые выражения в watch, time и prompt (включая условные выражения).
  it() Именованные директории (named directories).
  it() Исчерпывающая арифметика с целыми и вещественными числами.
  it() Манипуляции с массивами (включая переворот строк).
  it() Ассоциативные массивы (хеши ключ-значение)
  it() Исправление орфографических ошибок.
  )

sect(На каких машинах он запустится? (А также важные замечания по компиляции))

  Начиная с версии 3.0, zsh использует в качестве механизма установки GNU autoconf. Это значительно повышает гибкость по сравнению со старым механизмом `buildzsh'. Следовательно, zsh должен скомпилироваться и запускаться на любой современной версии UNIX, и на многих не слишком современных версиях тоже. Чтобы получить информацию по конкретной архитектуре, лучше взглянуть в файл MACHINES.

  Существуют также отдельные порты для Windows и OS/2 (см. `Где я могу взять' далее).

  Если вы хотите что-то изменить, чтобы добавилась поддержка новой платформы, это будет учтено, если бы вы добавили препроцессорный код и изменили configure.in и acconfig.h для автоматической конфигурации zsh. Затем отошлите требуемые контекстные diff-файлы в рассылку (вопрос link(5.2)(52)). Пожалуйста, убедитесь, для начала, что у вас последняя версия дистрибутива.

  Чтобы начать работать, достаньте исходный дистрибутив (вопрос link(1.6)(16)), разархивируйте его, и прочитайте файл INSTALL в главном каталоге. Файл MACHINES содержит информацию по конпиляции на определенных архитектурах.
  
  mybf(Замечание для пользователей nawk) (Следующая информация поступила от Zoltan Hidvegi): На некоторых системах nawk файл signames.h может быть неправильным. Из-за этого сигнальные коды могут стать непригодными. Это часто происходит на Ultrix, HP-UX, IRIX (?). Установите gawk, если вы столкнулись с такими проблемами.

sect(Какая последняя версия?)

  Zsh 4.2.5 - последняя стабильная версия (на момент перевода).

  Больше не будет версии 4.0 теперь версия 4.2 станет стабильным релизом.

  Иногда доступна следующая бета-версия. Развитие zsh - это заплатка за заплаткой, с каждой промежуточной общедоступной версией. Заметьте, что `открытая' система разработки подразумевает ошибки, появляющиеся в большинстве новых версий. Обычно они быстро исправляются. Если вам действительно интересно узнать о самых последних улучшениях, и вы меньше беспокоитесь о стабильности окружения - разрабатываемая версия загружается довольно часто в архив tt(директории разработчиков).

  Заметьте также, что шелл изменяется, поэтому он может стать несовместимым со старыми версиями; посмотрите концовку вопроса link(5.1)(51) для уточнения. Изменения такова вида почти всегда называются новичками лишними возможностями в оригинальном проекте (как воспринято текущими пользователями), или расширяют совместимость с другими Bourne shell производными, или (в основном в 3.0 ветке) предоставляют POSIX совместимость.

sect(Где мне его взять?)
label(16)

  Координатором разработки проекта в настоящее время являюсь я; псевдоним email(coordinator@zsh.org) может быть использован для контакта с кем угодно, кто на рабочем месте. Известны следующие часто обновляющиеся зеркала; первое - это официальный архивный сайт, на сегодняшний день он находится в Австралии. Все они доступны по анонимному FTP. Главные сайты имеют тест версии в поддиректории `testing': эти ежеминутные разрабатываемые версии следует брать если вы планируете помочь протестировать последнюю версии шелла. Следующий список также есть на url(http://www.zsh.org)(http://www.zsh.org) .
  descriprion(
    mydit(Домашний сайт)  url(ftp://ftp.zsh.org)(ftp://ftp.zsh.org)
    mydit()               url(http://www.zsh.org/pub/zsh/)(http://www.zsh.org/pub/zsh/)
    mydit(Австралия)      url(ftp://ftp.ips.gov.au/mirror/zsh/)(ftp://ftp.ips.gov.au/mirror/zsh/)
    mydit(Дания)          url(ftp://sunsite.dk/pub/unix/shells/zsh)(ftp://sunsite.dk/pub/unix/shells/zsh)
    mydit(Финляндия)      url(ftp://ftp.funet.fi/pub/unix/shells/zsh/)(ftp://ftp.funet.fi/pub/unix/shells/zsh/)
    mydit(Франция)        url(ftp://ftp.cenatls.cena.dgac.fr/shells/zsh/)(ftp://ftp.cenatls.cena.dgac.fr/shells/zsh/)
    mydit(Германия)       url(ftp://ftp.fu-berlin.de/pub/unix/shells/zsh/)(ftp://ftp.fu-berlin.de/pub/unix/shells/zsh/)
    mydit()		  url(ftp://ftp.uni-trier.de/pub/unix/shell/zsh/)(ftp://ftp.uni-trier.de/pub/unix/shell/zsh/)
    mydit(Венгрия)        url(ftp://ftp.cs.elte.hu/pub/zsh/)(ftp://ftp.cs.elte.hu/pub/zsh/)
    mydit()		  (также url(http://www.cs.elte.hu/pub/zsh/)(http://www.cs.elte.hu/pub/zsh/))
    mydit()		  url(ftp://ftp.kfki.hu/pub/packages/zsh/)(ftp://ftp.kfki.hu/pub/packages/zsh/)
    mydit(Израиль)        url(ftp://ftp.math.technion.ac.il/pub/zsh/)(ftp://ftp.math.technion.ac.il/pub/zsh/)
    mydit()		  url(http://www.math.technion.ac.il/pub/zsh/)(http://www.math.technion.ac.il/pub/zsh/)
    mydit(Италия)         url(ftp://ftp.unina.it/pub/Unix/pkgs/shell/zsh/)(ftp://ftp.unina.it/pub/Unix/pkgs/shell/zsh/)
    mydit(Япония)         url(ftp://ftp.nisiq.net/pub/shells/zsh/)(ftp://ftp.nisiq.net/pub/shells/zsh/)
    mydit()               url(ftp://ftp.win.ne.jp/pub/shell/zsh/)(ftp://ftp.win.ne.jp/pub/shell/zsh/)
    mydit(Норвегия)       url(ftp://ftp.uit.no/pub/unix/shells/zsh/)(ftp://ftp.uit.no/pub/unix/shells/zsh/)
    mydit(Польша)         url(ftp://sunsite.icm.edu.pl/pub/unix/shells/zsh/)(ftp://sunsite.icm.edu.pl/pub/unix/shells/zsh/)
    mydit(Румыния)        url(ftp://ftp.roedu.net/pub/mirrors/ftp.zsh.org/pub/zsh/)(ftp://ftp.roedu.net/pub/mirrors/ftp.zsh.org/pub/zsh/)
    mydit()               url(ftp://ftp.kappa.ro/pub/mirrors/ftp.zsh.org/pub/zsh/)(ftp://ftp.kappa.ro/pub/mirrors/ftp.zsh.org/pub/zsh/)
    mydit(Словения)       url(ftp://ftp.siol.net/mirrors/zsh/)(ftp://ftp.siol.net/mirrors/zsh/)
    mydit(Швеция)         url(ftp://ftp.lysator.liu.se/pub/unix/zsh/)(ftp://ftp.lysator.liu.se/pub/unix/zsh/)
    mydit(Великобритания) url(ftp://ftp.net.lut.ac.uk/zsh/)(ftp://ftp.net.lut.ac.uk/zsh/)
    mydit()               (также по FSP на 21)
    mydit()               url(ftp://sunsite.org.uk/packages/zsh/)(ftp://sunsite.org.uk/packages/zsh/)
    mydit(США)            url(ftp://uiarchive.uiuc.edu/pub/packages/shells/zsh/)(ftp://uiarchive.uiuc.edu/pub/packages/shells/zsh/)
    mydit()		  url(ftp://ftp.rge.com/pub/shells/zsh/)(ftp://ftp.rge.com/pub/shells/zsh/)
    mydit()               url(ftp://foad.org/pub/zsh/)(ftp://foad.org/pub/zsh/)
    mydit()               url(http://foad.org/zsh/)(http://foad.org/zsh/)
  )
  Порт для Windows разработан отдельно email(Amol Deshpande <amold@microsoft.com>); пожалуйста, сообщайте непосредственно ему о любых  специфичных проблемах Windows. Он основан на версии 3.0.5, и возможно не будет дальше разрабатываться. Вы можете его взять с:
  description(
    mydit()            url(ftp://ftp.blarg.net/users/amol/zsh)(ftp://ftp.blarg.net/users/amol/zsh)
  )

  Для версии 4 - нет порта для Windows, но новые релизы компилируются под Cygwin - свободно доступное UNIX окружение для Win32 API. Вы можете найти информацию о нем на:  
  url(http://sourceware.cygnus.com/cygwin)(http://sourceware.cygnus.com/cygwin).

  Также для OS/2 порт доступен от email(TAMURA Kent <kent@tril.ibm.co.jp>) на
  description(
    mydit()		url(http://cgi.din.or.jp/~tkent/tmp/zsh-3.0.0-os2-a01.zip)(http://cgi.din.or.jp/~tkent/tmp/zsh-3.0.0-os2-a01.zip)
  )

  В середине октября 1997 появился архив патчей, посылаемых в рассылку разработчиков. Заметьте, что не все из них могут быть добавлены в шелл, а некоторые уже добавлены; вы можете просто искать что-то, чего вы хотите и чего нет в вашей версии шелла. Также могут быть некоторые предпосылки ранее в архиве. Он может быть найден (как описано в link(1.1)(11)) на:
  description(
    mydit()		url(http://sunsite.dk/zsh/Patches/)(http://sunsite.dk/zsh/Patches/)
  )

sect(У меня нет доступа суперпользователя: как сделать, чтобы zsh запускался при входе в систему?)

  К несчастью, на многих машинах вы не можете использовать mytt(chsh) для того, чтобы изменить ваш шелл до тех пор, пока файл /etc/shells не будет содержать имени шелла, т.е. если у вас есть своя собственная копия zsh, то вам нужна некоторая хитрость, чтобы использовать его при входе в систему. (Просто набрать mytt(zsh) - это не серьезное решение, т.к. ваш оригинальный шелл ждет пока вы выйдете.)

  Основная идея - использовать mytt(exec <zsh-path>), чтобы заменить текущий шелл на zsh. Часто вы можете это сделать в своем профиле, в таком файле как .profile (если ваш шелл sh или ksh) или .login (если csh). Убедитесь, что у вас есть способ в дальнейшем изменить файл (например через FTP) до того как вы попробуете mytt(exec) - это часто бывает непростительно. 

  Если zsh в поддиректории mytt(bin) в вашей домашней директории, напишите это в .profile:
  verb(
    [ -f $HOME/bin/zsh ] && exec $HOME/bin/zsh -l
  )
  или, если ваш шелл csh или tcsh, напишите это в .login:
  verb(
    if ( -f ~/bin/zsh ) exec ~/bin/zsh -l
  )
  (в любом случае параметр mytt(-l) говорит zsh, что он используется как оболочка входа в систему).

  Если вы хотите проверить работоспособность сценария, вы можете сделать, чтобы при входе в систему был вопрос, запускать ли zsh. Следующий скрипт работает для Bourne-like шеллов:
  verb(
    [ -f $HOME/bin/zsh ] && {
            echo "Введите Y, чтобы запустить zsh: \c"
            read line
            [ "$line" = Y ] && exec $HOME/bin/zsh -l
    }
  )
  и для C-shell-like шеллов:
  verb(
    if ( -f ~/bin/zsh ) then
            echo -n "Введите Y, чтобы запустить zsh: "
            if ( "$<" == Y ) exec ~/bin/zsh -l
    endif
  )
  Не стоит писать это (даже без параметра -l) в файл .cshrc, по крайней мере, не проверив, что csh предполагает делать, т.к. каждый экземпляр csh вернётся в zsh и скрипты (да, к сожаление некоторые люди пишут так), вызванные НЕ при помощи `csh -f' откажутся работать. Если вы хотите, чтобы xterm запускал zsh, измените переменную окружения SHELL на полный путь к шеллу zsh в то же время, когда вы запускаете zsh (фактически, это здравая логика, даже если вы не используете xterm). Если вы запустили zsh из своего .cshrc, минимальная безопасность - проверить mytt(if ($?prompt) exec zsh).

  Если бы вы хотели, чтобы шелл показывался в списке процессов как mytt(-zsh), вы можете сделать ссылку (-zsh) на (zsh) (т.е. mytt(ln -s ~/bin/zsh ~/bin/-zsh)) и изменить exec на mytt(exec -zsh).  (Убедитесь, что mytt(-zsh) найдется через переменную path.) Это будет работать так же, как и параметр mytt(-l). 

  Сноска: если у вас нет доступа суперпользователя, убедитесь, что zsh занесен в /etc/shells на всех соответствующих машинах, включая NIS клиенты, иначе у вас будут проблемы с FTP доступом к этим машинам.

chapter(Чем zsh отличается от ...?)

  Как уже упоминалось ранее, zsh более похож на ksh, в то же время множество дополнений порадуют пользователей csh. Здесь приведены более детальные сведения. Посмотрите также статью `Различия UNIX шеллов и как изменить ваш шелл' (`UNIX shell differences and how to change your shell)', часто размещаемую в USENET группе comp.unix.shell.

sect(Отличия от sh и ksh)
label(21)

  Большинство возможностей ksh (следовательно также и sh) присутствуют в zsh; проблемы могут возникнуть, потому что организация их слегка различается. Заметьте также, что не все функции ksh одинаковы. Я основывался на версии ksh 11/16/88f; отличия от ksh93 будут более существенны.

  Подведём итог:
  enumerate(
  myeit() по всем параметрам небезопасно допускать обычный запуск zsh пользователем, т.к. он будет вести себя как sh или ksh совместимый;
  myeit() вызывая zsh как sh или ksh (или если каждый из них является символической ссылкой на zsh) нужно задавать соответствующие параметры для лучшей совместимости (из самого zsh, вызов mytt(ARGV0=sh zsh) будет тоже работать);
  myeit() начиная с версии 3.0 улучшается совместимость sh, поэтому zsh теперь можно использовать с GNU configure или perl Configure;
  myeit() степень совместимости с ksh также на высоте, но несколько вещей отсутствуют: например, более сложные формы выражений различны для версий до 3.1.3 --- смотрите более детальный список ниже;
  myeit() также, с версии 3.0 доступна команда `emulate': `emulate ksh' и `emulate sh' задают различные параметры точно так же как и изменение однобуквенных флагов, как если бы шелл был бы вызван с соответствующим именем. Включение команды `emulate sh; setopt localoptions' в шелл-функции включит эмуляцию sh только для этой функции. В версии 4 (и в 3.0.6 до 8), это может быть записано как `emulate -L sh'.
  )
  Классическое различие - разбивание на слова, обсуждаемое в вопросе link(3.1)(31); это захватывает очень многих начинающих пользователей zsh. Как правило, это актуальная ошибка, касающаяся каждого другого шелла. Ответ - это задать tt(SH_WORD_SPLIT) для обратной совместимости. Следующее классическое различие - не имеющая себе равных форма универсализации имён - причина отказа команд; задайте tt(NO_NOMATCH) для этого.
  
  Вот список различных параметров, с которыми возрастёт ksh-совместимость, хотя могут уменьшиться способности zsh: читайте руководство по параметрам tt(GLOB_SUBST), tt(IGNORE_BRACES) (хотя расширение скобок встречается в нескольких версиях ksh), tt(KSH_ARRAYS), tt(KSH_GLOB), tt(KSH_OPTION_PRINT), tt(LOCAL_OPTIONS), tt(NO_BAD_PATTERN), tt(NO_BANG_HIST), tt(NO_EQUALS), tt(NO_HUP), tt(NO_NOMATCH), tt(NO_RCS), tt(NO_SHORT_LOOPS), tt(PROMPT_SUBST), tt(RM_STAR_SILENT), tt(POSIX_BUILTINS), tt(SH_FILE_EXPANSION), tt(SH_GLOB), tt(SH_OPTION_LETTERS), tt(SH_WORD_SPLIT) (см. вопрос link(3.1)(31)) и tt(SINGLE_LINE_ZLE).
  Заметьте, что вы можете выключить любые встроенные команды, которые вам не нужны. Если вызвать как `ksh', шелл попытается задать подходящие параметры.

  Вот несколько отличий от ksh - в основном они существенны для программистов ksh, некоторые из них могут быть восприняты как ошибки. Заметьте, что этот список умышленно полный и большинство значений довольно незначительны. Такие отметки `*' представляют стиль ksh, если шелл вызван с именем `ksh' или если действует `emulate ksh'. Главные слова, относящиеся к параметрам шелла, подчёркнуты. 

  itemize(
  it() Синтаксис:
  itemize(
    it() * Разделения на слова: см. вопрос link(3.1)(31).
    it() * Массивы (по умолчанию) больше похожи на массивы csh, чем ksh: индексы начинаются с 1, не с 0; tt(array[0]) относится к tt(array[1]); mytt($array) относится ко всему массиву, не к tt($array[0]); скобки лишние: tt($a[1] == ${a[1]}), и т.д. Задайте параметр tt(KSH_ARRAYS) для совместимости.
    it() Сопроцессы, установленные mytt(coproc); mytt(|&) ведут себя так же, как и в csh. Обработка файловых дескрипторов сопроцесса тоже различается.
    it() В mytt(cmd1 && cmd2 &), только mytt(cmd2) вместо всего выражения запустится в фоне zsh. В руководстве написано, что это ошибка. Используйте mytt({ cmd1 && cmd2 } &) для фона.
  )
  it() Подстановка в командной строке, универсализация имен и т.д.:
  itemize(
    it()* Невозможность сопоставить образец универсального имени вызовет ошибку (используйте tt(NO_NOMATCH)).
    it()* Результаты подстановки трактуются как обычный текст: mytt(foo="*"; print $foo) напечатает все файлы в ksh, но mytt(*) в zsh следует использовать tt(GLOB_SUBST), чтобы достичь того же результата.
    it()* tt($PSn) не делает параметрическую подстановку по умолчанию (используйте tt(PROMPT_SUBST)).
    it()* Стандартная универсализация имен не позволяет образцы в стиле ksh.
        Эквивалентность:

----------------------------------------------------------------------
      ksh              zsh         Значения
     ------           ------       ---------
     !(foo)            ^foo        Что-либо, кроме foo.
                or   foo1~foo2     Что-либо по образцу foo1 , но не foo2[1].
@(foo1|foo2|...)  (foo1|foo2|...)  Один из foo1 или foo2 или ...
     ?(foo)           (foo|)       Ноль или один случай foo.
     *(foo)           (foo)#       Ноль или больше случаев foo.
     +(foo)           (foo)##      Один или больше случаев foo.
----------------------------------------------------------------------

      Формы mytt(^), mytt(~) и mytt(#) (но не mytt(|)) требуют tt(EXTENDED_GLOB). Начиная с версии 3.1.3, формы ksh полностью поддерживаются, когда задан параметр tt(KSH_GLOB); для предыдущих версий вы должны пользоваться данной таблицей.

      [1] Заметьте, что символ mytt(~) - это только оператор универсализации имён, имеющий меньший приоритет, чем mytt(/). Например, mytt(**/foo~*bar*) указывает на любые файлы в поддиректории mytt(foo), кроме mytt(bar), встречающихся по пути (т.е. mytt(users/barstaff/foo) будут исключены оператором mytt(~)). Как mytt(**) оператор не может быть сгруппирован (в круглых скобках он трактуется как mytt(*)), это нужно, чтобы исключить несколько поддиректорий из образца mytt(**).
    it() Присваивания без кавычек производят расширение имени файла после двоеточия mytt(:) (предназначается для tt(PATH)). 
    it() mytt(typeset) и mytt(integer) имеют специальное поведение для присваиваний в ksh, но не в zsh. Например, вот это не работает в zsh:
    verb(
	    integer k=$(wc -l ~/.zshrc)
    )
        потому что возвращаемое значение из tt(wc) включает ведущие пробелы, которые разделяют слова. Ksh трактует присваивание специально как одно слово.
  )
  it() Выполнение команд:
  itemize(
    it()* Нет переменной tt($ENV) (используйте tt(/etc/zshrc), tt(~/.zshrc); а также tt($ZDOTDIR)).
    it() tt($PATH) не просматривается для команд, специально вызванных без -c.
  )
  it() Псевдонимы и функции:
  itemize(
    it() Важен порядок в котором определяются псевдонимы и функции: функции, определённые с помощью (), расширяют псевдонимы -- см. вопрос link(2.3)(23).
    it() Псевдонимы и функции не могут экспортироваться.
    it() Нет отслеживаемых псевдонимов: хеширование команд их заменяет.
    it() Использование псевдонимов для привязки к клавишам заменено на `bindkey'.
    it()* Параметры не локальны для функций (используйте LOCAL_OPTIONS; заметьте, что это всегда может быть выключено локально, чтобы передать параметры от функции на вызываемый уровень).
    it() Функции, определённые как `function funcname { body }' ведут себя точно так же, как и `funcname () { body }'. В ksh последние ведут себя как если бы их тело было прочитано из файла, начинающегося с `.', и только последние ведут себя действительно как функции.
  )
  it() Прерывания и сигналы:
  itemize(
    it()* Прерывания не локальны для функций. Параметр LOCAL_TRAPS доступен с версии 3.1.6.
    it()   TRAPERR стал TRAPZERR (это было вызвано UNICOS, который имеет SIGERR).
  )
  it()  Редактирование:
  itemize(
    it() Параметры tt(gmacs), tt(viraw) - не поддерживаются. Используйте bindkey, чтобы изменить поведение редактора: mytt(set -o {emacs,vi}) стало `bindkey -{e,v}', хотя `set -o emacs' и `set -o vi' поддерживаются для совместимости; для gmacs - перейдите в режим emacs и используйте `bindkey \^t gosmacs-transpose-characters'.
    it() Параметр mytt(keyword) - не существует и mytt(-k) - вместо интерактивных комментариев. (mytt(keyword) - так же исчезла в недавних версиях ksh.)
    it()* Управление историей в многочисленных шеллах различно: история не сохраняется и не восстанавливается после каждой команды. Параметр tt(SHARE_HISTORY) появился в версии 3.1.6 и он задаётся в режиме ksh совместимости, чтобы исправить это.
    it() mytt(\) не экранирует символы (используйте mytt(^V)).
    it() Не все привязывания ksh задаются (например mytt(<ESC>#); пробуйте mytt(<ESC>q)).
    it()* mytt(#) - в интерактивном шелле по умолчанию НЕ трактуется как комментарий. 
  )
  it()  Встроенные команды:
  itemize(
    it() Некоторые встроенные команды (tt(r), tt(autoload), tt(history), tt(integer) ...) были псевдонимами в ksh. 
    it() Встроенной команды newgrp нет: используйте mytt(alias newgrp="exec newgrp")
    it() mytt(jobs) не имеет флага mytt(-n).
  )
  it()  Другие особенности:
  itemize(
    it() mytt(select) всегда показывает заново список выбора на каждом цикле.
  )
  )

sect(Сходства с csh)

  Хотя определённые возможности стремятся заманить пользователей csh, синтаксис, в общем, довольно различен и вам, несомненно, не следует пытаться запустить скрипты без изменения. c2z сценарий предоставляется с исходниками (в Misc/c2z) для того, чтобы помочь преобразовать файлы .cshrc и .login; посмотрите также следующий вопрос, касающийся псевдонимов, особенно тех, которые с аргументами.

  Csh-совместимые дополнения включают в себя:
  itemize(
  it() встроенные команды tt(logout), tt(rehash), tt(source), tt((un)limit).
  it() файл tt(*rc) для интерактивных шеллов.
  it() стеки директорий.
  it() параметры tt(cshjunkie*), tt(ignoreeof).
  it() параметр tt(CSH_NULL_GLOB).
  it() tt(>&), tt(|&) и т.п. перенаправления.
      (Заметьте, что mytt(>file 2>&1) стандартная команда Bourne shell'а для csh она выглядит так mytt(>&file).)
  it() tt(foreach ...) loops; альтернативный синтаксис для других циклов.
  it() Альтернативный синтаксис mytt(if ( ... ) ...), хотя он не работает как в csh: он ожидает команду в круглых скобках, также как и mytt(for), mytt(which).
  it() tt($PROMPT) такая же как и tt($PS1), tt($status) такая же как и tt($?), tt($#argv) такая же как и tt($#), .... 
  it() Экранируемые последовательности пишутся через tt(%) для приглашения.
  it() Специальные массивы tt($PATH) и т.п., разделённые двоеточиями, tt($path) массивы.
  it() история с использованием tt(!) (которая может быть выключена через mytt(setopt nobanghist)).
  it() Массивы имеют такие же возможности, как и в csh (см. link(2.1)(21)).
  )

sect(Почему мои псевдонимы от csh не работают? (А также другие ошибки с псевдонимами.))
label(23)

  Для начала, проверьте, какой синтаксис вы используете
  verb(
    alias newcmd='list of commands'
  )
  а не
  verb(
    alias newcmd 'list of commands'
  )
  который не будет работать. (Если `newcmd' и `list of commands' уже определены как псевдонимы.)

  В противном случае, ваши псевдонимы возможно содержат ссылку на командную строку формы mytt(\!*), и т.п. Zsh не оперирует таким поведением так, как это делают шелл-функции, которые предоставляют решение этой проблемы более содержательно с другими формами аргументов. Например, csh псевдоним
  verb(
    alias cd 'cd \!*; echo $cwd'
  )
  может быть заменён функцией zsh,
  verb(
    cd() { builtin cd "$@"; echo $PWD; }
  )
  (`builtin' собщает zsh использовать свой собственный `cd', избегая бесконечного цикла, или, возможно лучше,
  verb(
    cd() { builtin cd "$@"; print -D $PWD; }
  )
  (который содержит преобразование вашей домашней директории в tt(~)). Фактически, эта проблема лучше решена определением специальной функции chpwd() (см. руководство). Заметьте также, что mytt(;) в конце функции не обязательно в zsh, в отличие от ksh или sh.

  Вот руководство Bart Schaefer по преобразованию псевдонимов csh для zsh.
  enumerate(
  myeit() В csh псевдоним ссылается на параметры (tt(\!:1), tt(\!*) и т.п.), тогда в zsh вам нужна функция (ссылающаяся на tt($1), tt($*) и т.п.). Иначе, вы можете использовать псевдонимы zsh.

  myeit() Если вы используете функцию zsh, вам нужно ссылаться по крайней мере на tt($*) в теле (внутри tt({ })). Параметры не автоматически появляются внутри tt({ }), это способ их добавления в псевдоним.

  myeit() Если csh псевдоним ссылается на своё собственное имя (tt(alias rm "rm -i")), тогда в функции zsh вам нужно ключевое слово "command" (function tt(rm()) { command rm -i "$@" }), но в псевдонимах zsh оно не нужно (tt(alias rm="rm -i")).

  myeit() Если у вас есть псевдонимы, ссылающиеся друг на друга (tt(alias ls "ls -C"; alias lf "ls -F" ==> lf == ls -C -F)), тогда вы должны либо:
  itemize(
    it() преобразовать их все в функции zsh; или
    it() после преобразования, убедитесь, что ваш .zshrc определяет все ваши псевдонимы до того, как он определяет какую-либо из функций.
    )

     Эти первые четыре правила - всё, что вам действительно нужно, но вот ещё четыре для более сложных csh псевдонимов:

  myeit() Распределение внутренних переменных csh в zsh функции (принимается, что tt(SH_WORD_SPLIT) и tt(KSH_ARRAYS) НЕ заданы в zsh):
    verb(
      csh             zsh
     =====         ==========
     \!*           $*              (или $argv)
     \!^           $1              (или $argv[1])
     \!:1          $1
     \!:2          $2              (или $argv[2], и т.п.)
     \!$           $*[$#]          (или $argv[$#], или $*[-1])
     \!:1-4        $*[1,4]
     \!:1-         $*[1,$#-1]      (или $*[1,-2])
     \!^-          $*[1,$#-1]
     \!*:q         "$@"
     \!*:x         $=*             ($*:x не работает (пока))
    )
    
  myeit() Запомните, что ссылаться на позицию (tt($1), tt($2), и т.п.) большую, чем число параметров, - это НЕ синтаксическая ошибка zsh. (Например, в csh псевдоним, ссылающийся на tt(\!:5) будет являться причиной ошибки, если 4 или меньше количество аргументов задано; в zsh функции, tt($5) - это пустая строка, если параметров 4 или меньше.)

  myeit() Чтобы начать псевдоним с символа - (чёрточка, дефис), используйте mytt(alias --):
    verb(
             csh                            zsh
        ===============             ==================
        alias - "fg %-"             alias -- -="fg %-"
    )
  myeit() Избегайте mytt(alias -g) в zsh, если вы не уверены в том, что вы делаете.
  )

  Ещё одна серьёзная проблема с псевдонимами: рассмотрим
  verb(
    alias l='/bin/ls -F'
    l() { /bin/ls -la "$@" | more }
  )
  mytt(l) в определении функции находится в позиции команды, которая расширяет псевдоним, определяющий mytt(/bin/ls) и mytt(-F) как функцию, которая вызывает mytt(/bin/ls), которая в свою очередь вызывает рекурсию. Этого можно избежать, если вы используете mytt(function) для определения функции, которая не расширяет псевдоним. Это возможно аргументировать для дополнительных предупреждений где-нибудь в этом беспорядке.

  Правило Bart'a Schaefer'a: Определите сначала те псевдонимы, которые вы ожидаете использовать в теле функций, но определите функцию сначала, если псевдоним имеет такое же имя как и функция.

sect(Сходства c tcsh)

  (Естественно, в этот раздел можно отнести всё, что написано для csh.) Определённые возможности заимствованы из tcsh, включая tt($watch), tt(run-help), tt($savehist), периодичные команды и т.п., расширенные подтверждения, встроенные tt(sched) и tt(which). Программируемое завершение было основано на tcsh, но оно полностью отличается от tcsh's mytt(complete). (Есть perl-скрипт, называемый tt(lete2ctl), в директории Misc исходного дистрибутива для преобразования mytt(complete) в mytt(compctl) выражения.) Это не окончательный список: некоторые возможности пошли в другом направлении.

  Если вы пропустили функцию редактора tt(run-fg-editor), попробуйте что-нибудь с mytt(bindkey -s) (которая привязывает строку к нажатию клавиши), например
  verb(
    bindkey -s '^z' '\eqfg %$EDITOR:t\n'
  )
  которая помещает текущую строку в стек и пытается перенести работу с базовым именем вашего редактора на передний план. mytt(bindkey -s) даёт неограниченные возможности на этих строках. Вы можете выполнить любую команду в середине редактирования строки также, как соответствующий tcsh параметр mytt(-c):
  verb(
    bindkey -s '^p' '\eqpwd\n'
  )
  В обоих примерах, mytt(\eq) сохраняет текущую позицию ввода, которая будет восстановлена после выполнения команды; лучший эффект с многострочными буферами достигается, если вы также имеете
  verb(
    bindkey '\eq' push-input
  )
  для сохранения всего буфера. В версии 4 и последней версии zsh 3.1, у вас есть следующие более сложные параметры
  verb(
    run-fg-editor() {
      zle push-input
      BUFFER="fg %$EDITOR:t"
      zle accept-line
    }
    zle -N run-fg-editor
  )
  и вы можете теперь привязать tt(run-fg-editor) точно так же, как и любую другую функцию редактора.

sect(Сходства с bash)

  Bourne-Again Shell, bash - это другой расширенный Bourne-like шелл; самое главное очевидное отличие от zsh, что он не пытается эмулировать Korn shell. Поскольку оба шелла активно развиваются, то возможно не обязательно быть слишком специфичным в этом вопросе. bash обращает больше внимания на соответствие стандартам (в т.ч. POSIX), и он избегает больше непонятных возможностей (программируемое завершение и т.д.), чем zsh.

  Однако, в последние годы были некоторые пересечения с расширениями. Zsh (начиная с 3.1.6) имеет возможность bash'а `tt(${var/old/new})' замены текста tt(old) на текст tt(new) в параметрах tt($var). Заметьте здесь одно отличие: пока оба шелла принадлежат синтаксису `tt(${var/#old/new})' и `tt(${var/%old/new})' для фиксации образца tt(old) в начале или в конце текта параметра соответственно, в zsh вы не можете поставить `tt(#)' или `tt(%)' внутрь параметра: другими словами `tt({var/$old/new})', где tt(old) начинается с `tt(#)' трактуется как обычный символ в zsh, в отличие от bash. Чтобы сделать такое в zsh, вы можете использовать (из 3.1.7) новый синтаксис для фиксирования в любой форме, `tt((#s))' соответствует началу строки, и `tt((#e))' соответствует концу. Это требует заданного параметра tt(EXTENDED_GLOB).

sect(Не должен ли zsh быть больше/меньше похож на ksh/(t)csh?)

  Люди часто спрашивают, почему zsh имеет все эти `ненужные' csh-like возможности, или кроме того, почему zsh не понимает более глубоко синтаксис csh. Это далеко от окончательного ответа и дебаты несомненно будут продолжаться.

  Целью Paul'а в написании zsh было создание ksh-like шелла, который бы имел возможности семейства csh. Долгое время csh был предпочитаемым интерактивным шеллом, и было сильное сопротивление, чтобы сменить csh на что-нибудь, не принадлежащее к семейству, следовательно расширенный синтаксис и параметр tt(CSH_JUNKIE). Этот аргумент всё ещё в силе. С другой стороны, аргументы для близкой замены ksh даже более весомые: недостатки csh как языка программирования хорошо известны (взгляните в любой Usenet FAQ архив, например url(http://www.cis.ohio-state.edu/hypertext/faq/usenet/unix-faq/shell/csh-whynot/faq.html)(http://www.cis.ohio-state.edu/hypertext/faq/usenet/unix-faq/shell/csh-whynot/faq.html), если вы сомневаетесь) и zsh может запускать множество стандартных сценариев, таких как /etc/rc.

  Конечно это делает zsh довольно огромным с большими возможностями, это обращение, в основном, к хакерам. Только ответ, возможно, полностью удовлетворительный, т.е. вы должны игнорировать то, что вам не нужно. Представление о загрузке в модулях в версии 3.1 должно помочь.

sect(Поддерживает ли zsh Unicode/UTF-8?)

  `Unicode', или UCS (Universal Character Set), это современная направление специализированной кодировки. Она заменяет огромное количество специальных кодировок вне ASCII. `UTF-8' это Unicode кодировка, которая особенно естественна на Unix-like системах.

  В: Поддерживает ли zsh UTF-8?

  О: встроенная команда zsh printf поддерживает "\u" и "\U" экранирование, которая выводит произвольные символы Unicode.  ZLE (the Zsh Line Editor) не имеет понятия о кодировках, и путается при многооктетных кодировках.

  В: Почему у zsh нет соответствующей поддержки UTF-8?

  О: Код ещё не написан.

  В: Что сложного в реализации поддержки UTF-8?

  О: Для того, чтобы правильно оперировать с произвольной кодировкой, значительные изменения нужно внести в шелл.

  В: Почему zsh не может просто использовать readline?

  О: ZLE не изолирован от остального шелла. Изолировать его так, чтобы можно было заменить на readline требовало бы значимых усилий. К тому же, используя readline появился бы обратный эффект значимой потери возможностей.

  В: Какие изменения планируются?

  О: Ввод поддержки Unicode будет постепенный, ну а если вы интересуетесь во введении, то вам следует присоединиться к листу рассылок разработчиков (zsh-workers mailing list). Как первый шаг, ZLE будет переписан с использованием непосредственно широких символов (wide characters). Символы, основанные на виджетах(widgets), смогут тогда оперировать с целым широким символом, вместо одного байта, и нужная ширина символов может быть рассчитана с помощью функции wcswidth().

chapter(Как заставить работать различные вещи)

sect(Почему переменная mytt($var), где mytt(var="foo bar") не делает того чего я ожидаю?)
label(31)

  В большенстве Bourne-shell производных, переменные из нескольких слов, такие как
  verb(
    var="foo bar"
  )
  разделяются на слова, когда пропускаются через команду или используются в mytt(for foo in $var) цикле. По умолчанию, zsh не ведёт себя так, чтобы переменная осталась целой. (Это не ошибка! Смотрите дальше.) Параметр tt(SH_WORD_SPLIT) существует, чтобы предоставить совместимость.

  Например, определение функции args показывает количество её аргументов:
  verb(
    args() { echo $#; }
  )
  и с нашим определением `var',
  verb(
    args $var
  )
  на выходе результат будет `1'. После
  verb(
    setopt shwordsplit
  )
  такая же функция даст результат `2', как с sh и ksh.

  Если вам не нужна полная sh/ksh совместимость, вам следует спросить себя, действительно ли вы хотите такого поведения, т.к. результат может дать неожиданный эффект для переменных, безобидно заполненных пробелами. Это может быть ужасной проблемой с кавычками, когда сценарий вызывают из других шеллов. Обычный способ добиться разделения на слова в zsh - это через массивы. Например,
  verb(
    set -A array one two three twenty
  )
  (или
  verb(
    array=(one two three twenty)
  )
  если вы предпочитаете), следующее
  verb(
    args $array
  )
  даст результат `4', не обращая внимания на параметр tt(SH_WORD_SPLIT). Массивы также более универсальны, чем строки. Возможно, если бы этот механизм был бы всегда доступен, никогда не было бы автоматического разделения на слова в скалярах, которые являются разновидностью неконтролируемых слабых массивов.

  Заметьте, что это происходит, невзирая на значение разделителя внутренних полей, tt($IFS); другими словами, с mytt(IFS=:; foo=a:b; args $foo) вы получите ответ 1.

  Другим способом разделить на слова - включить здравомыслящее использование `eval':
  verb(
    sentence="Longtemps, je me suis couch\\'e de bonne heure."
    eval "words=($sentence)"
  )
  после которого $words - это массив со словами из $sentence (заметьте, что специальные символы для шелла, такие как mytt(') в этом примере, должны уже быть в кавычках), или, меньше стандарта, но зато более надёжно, включить tt(SH_WORD_SPLIT) только для одной переменной:
  verb(
    args ${=sentence}
  )
  всегда вернёт 8 над определением mytt(args). (Для старых версий zsh, tt(${=foo}) - переключает tt(SH_WORD_SPLIT); теперь он просто включается.)

  Заметьте также, что метод tt("$@") разделения на слова всегда доступен в zsh функциях и сценариях (хотя точнее это разделение с использованием массива - не разделение по словам). Это более портировано, чем tt($*), и будет работать, невзирая на параметр tt(SH_WORD_SPLIT); другое различие - tt($*) удаляет пустые аргументы из массива. Вы можете это исправить половину этого, используя tt(${==*}), которая выключит tt(SH_WORD_SPLIT) для продолжения преобразования.

  tt(SH_WORD_SPLIT) задаётся, когда zsh вызывается с именами `ksh' или `sh', или (что полностью эквивалентно) когда заданы mytt(emulate ksh) или mytt(emulate sh).

  Есть один эффект разделения на слова, который различается в ksh и zsh. В ksh у встроенных команд (например таких как tt(typeset) и tt(export)), которые объявляют параметры, включение разделения на слова не будет действовать после присваивания аргумента:
  verb(
    typeset param=`echo foo bar`
  )
  в ksh будет создан параметр со значением mytt(foo bar), а в zsh будет создан параметр tt(param) со значением tt(foo) и параметром tt(bar), чьё значение пустое. Противоположность этого с нормальным присваиванием (никакого tt(typeset) или другой команды впереди), которое никогда не разделит на слова, пока задан параметр tt(GLOB_ASSIGN). С zsh версии 4.0.2 параметр tt(KSH_TYPESET), задающийся автоматически в режиме совместимости, исправляет эту проблему. Заметьте, что в bash такое поведение встречается со всеми аргументами, которые выглядят как присваивания с каким бы то ни было именем команды; в zsh такое поведение можно получить, задав параметр tt(MAGIC_EQUAL_SUBST).

sect(В какой конфигурационный файл я должен прописать...?)

  Существует 4 конфигурационных файла, которые инициализируются при запуске в различных обстоятельствах: tt(.zshenv), tt(.zprofile), tt(.zshrc) и tt(.zlogin). Они обычно находятся в вашей домашней директории, но переменная tt($ZDOTDIR) может быть задана, чтобы изменить это. Здесь приведены несколько кратких советов, как их использовать. Существуют также файлы, которые системный администратор может задать для всех шеллов; вы можете избежать запуска всех, кроме tt(/etc/zshenv), запустив zsh с параметром tt(-f) --- по этой причине важно для администраторов удостовериться, что tt(/etc/zshenv) не содержит ничего лишнего.

  Порядок, в котором эти 4 файла ищутся (ни один их них myem(не обязан) существовать) только что приведён. Тем не менее, tt(.zprofile) и tt(.zlogin) запускаются только когда zsh - оболочка входа в систему (login shell) --- когда вы первый раз зашли в систему, конечно, и когда вы запускаете zsh с параметром tt(-l). Все login shells интерактивные. Порядок различается только между этим; вам следует решить, когда вам нужно выполнить команды: до или после tt(.zshrc). Эти файлы - хорошее место, чтобы задать переменные окружения (т.е. команды mytt(export)), т.к. они передаются всем шеллам и нет необходимости устанавливать их заново, а также проверять, правильно ли настроен терминал (за исключением случаев, когда вы хотите изменить свойства эмулятора терминала, например tt(xterm), тогда вам нужно изменять файл tt(.zshrc), т.к. обычно вы не получаете оболочку входа в систему).  

  Только один файл вы можете заменить, который запускается каждый раз при старте zsh (только если вы не используете параметр tt(-f)) это tt(.zshenv), это хорошее место для команд, даже если шелл неинтерактивный: параметры для изменения синтаксиса, такие как tt(EXTENDED_GLOB), любые изменения, касающиеся mytt(limit), любые переменные, какие только хотите, чтобы убедиться, что они заданы, например, tt($fpath) для поиска функций. Вы несомненно не хотите, чтобы tt(.zshenv) что-нибудь выводил на стандартный вывод. Некоторые люди предпочитают не использовать tt(.zshenv) для задания параметров, как влиятельный сценарий; но чтобы сделать zsh сценарии портируемыми обычно требуется немного усилий.

  И наконец, tt(.zshrc) запускается для каждого интерактивного шелла; он включает в себя и оболочки входа в систему, но также в любое время, когда вы запускаете шелл, просто набрав mytt(zsh) или открыв новое окно эмуляции терминала. В этом файле место для изменения поведения редактирования через параметры или mytt(bindkey), контролирования, как сохраняется ваша история, задания псевдонимов, несмотря на то, что вы их будете использовать в сценариях, и для любого другого мусора, который не может быть экспортирован, но вы только используете прямо для интерактивного шелла. Вы вероятно не хотите, чтобы tt(.zshrc) что-либо выводил на стандартный вывод, есть случай, когда это может оказаться проблемой, такой как использование mytt(rsh) с другой машины по сети. По поводу сохранения истории обращаться к вопросу link(3.21)(321).

sect(В чём различия между `export' и параметром tt(ALL_EXPORT) ?)

  Обычно, чтобы экспортировать переменную в окружение вы используете mytt(export var). Команда mytt(setopt allexport) экспортирует в окружение все переменные, которые впоследствии будут заданы (не все, а которые существуют на данный момент).

  Это может казаться полезной стенографией, но на практике может иметь и бесполезные эффекты:
  enumerate(
  myeit() С тех пор, как каждая переменная экспортируется в окружение, так же как и запомненная шеллом, память, которая ей требуется, будет выделена дважды. Это так же больше как и медленнее.
  myeit() Действительно каждая переменная будет экспортирована, даже переменная в цикле mytt(for). Это возможно лишнее.
  myeit() Произвольная переменная, созданная пользователем, может иметь специальное значение для команды. Т.к все переменные видны для команды, то против этого никакой защиты нет.
  )
  По этим причинам обычно лучше всего избегать tt(ALL_EXPORT), если только не специфическое его использование. Одно безопасное использование - это задать его до создания списка переменных в инициализационном файле, и удалить его сразу после этого. Только эти переменные будут автоматически экспортированы.

sect(Как мне выключить коррекцию правописания/универсализацию имён для одной команды?)

  В первом случае, вы вероятно запишите mytt(setopt correctall) в инициализационный файл, тогда zsh будет проверять правописание каждого слова в командной строке. Вы возможно не хотите такого поведения для команд, которые оперируют созданием файлов.

  Для этого нужно для нарушенной команды сделать псевдоним со словом mytt(nocorrect) перед ней, т.е.
  verb(
    alias mkdir='nocorrect mkdir'
  )
  Для выключения универсализации, рационально сделать идентично:
  verb(
    alias mkdir='noglob mkdir'
  )
  Можно совместить tt(nocorrect) и tt(noglob), если хотите, но tt(nocorrect) должно стоять первым, т.к. оно нужно командной строке, в то время как tt(noglob) рассматривается только на выполнении команды.

  Заметьте также, что шелл функции не будут работать: директивы должны быть расширены прежде, чем анализируется остальная часть строки.

sect(Как мне сделать, чтобы мета клавиша работала на моём xterm?)
label(35)

  Как говорится в руководстве, zsh нужно сообщить о мета клавише, используя mytt(bindkey -me) или mytt(bindkey -mv) в вашем .zshrc или в командной строке. Вам, возможно также нужно сказать драйверу терминала, чтобы он позволил `meta' бит символа через: mytt(stty pass8). Пример из .zshrc:
  verb(
    [[ $TERM = "xterm" ]] && stty pass8 && bindkey -me
  )
  или на SYSVR4-ish системах без pass8,
  verb(
    [[ $TERM = "xterm" ]] && stty -parenb -istrip cs8 && bindkey -me
  )
  (выключение контроля четности не лишит высшего бита, используйте восьмибитные символы).
  Убедитесь, что это написано myem(ДО) любого определения bindkey в вашем .zshrc, который переопределяет клавиши, нормально определенные в раскладке emacs/vi. Вам также нужно задать tt(полный восьмибитный вывод) в файле tt(~/.Xdefaults), хотя он включен по умолчанию и маловероятно, что кто-нибудь с этим столкнется.

  Вам не нужна команда mytt(bindkey), чтобы определить свою собственную последовательность с использованием мета клавиши, хотя вам ве равно нужна команда mytt(stty).

sect(Как мне сделать, чтобы текущая директория автоматически выводилась в заголовке xterm?)

  Вам следует использовать специальную функцию mytt(chpwd), которая вызывается, когда меняется текущая директория. Следующий сценарий проверяет, является ли стандартный вывод терминалом, тогда в заголовок пишется текущая директория, если терминал tt(xterm) или другой относительно близкий, или tt(sun-cmd).

  verb(
  chpwd() {
    [[ -t 1 ]] || return
    case $TERM in
      sun-cmd) print -Pn "\e]l%~\e\\"
        ;;
      *xterm*|rxvt|(dt|k|E)term) print -Pn "\e]2;%~\a"
        ;;
    esac
  }
  )

  Измените mytt(%~), если хотите, чтобы сообщения были различными.  (Параметр mytt(-P) интерпретирует такую последовательность как в приглашении, в этом случае вызывает текущую директорию; вы конечно можете использовать здесь mytt($PWD), но она не будет использовать нотацию mytt(~), которую я считаю чище.) Возможно вы захотите вызвать tt(chpwd) прямо, когда tt(xterm) запускается: вам нужно только поместить mytt(chpwd) в tt(.zshrc) после её определения или автозагрузки.

sect(Как мне сделать, чтобы лист завершения команд использовал 8-битные символы?)

  Если вы уверены, что ваш терминал поддерживает их, самый лёгкий путь, начиная с версий 3.0.6 и 3.1 шелла, это задать параметр tt(PRINT_EIGHT_BIT). В принципе, это будет работать автоматически, если ваш компьютер использует систему `locale' и переменные локали заданы правильно, zsh поймёт их. Тем не менее, если локаль не настроена, будет намного проще задать параметр. Для ранних версий zsh 3, вам придётся понять локали, смотрите страницы справочного руководства tt(setlocale(3)) и tt(zshparam(1)), самая простая возможность - задать tt(LC_ALL=en_US). Для более старых версий легкого способа нет.

sect(Почему "стрелки" (клавиши управления курсором) не работают?)

  Курсорные клавиши посылают различные коды, зависящие от терминала; zsh знает только хорошо известные версии. Если вы увидите подобные проблемы, тогда попытайтесь написать следующее в ваш tt(.zshrc):

  verb(
    bindkey "$(echotc kl)" backward-char
    bindkey "$(echotc kr)" forward-char
    bindkey "$(echotc ku)" up-line-or-history
    bindkey "$(echotc kd)" down-line-or-history
  )

  Если вы используете режим vi, тогда пишите в соответствующем месте mytt(vi-backward-char) и mytt(vi-forward-char). Что касается версии 4.0.1, zsh попытается найти эти коды и сделать привязывание (оба, и для emacs, и для vi), но в некоторых случаях это может не сработать.

  Заметьте также, что до версии 3.0 с привязыванием произвольной многокнопочной последовательности могли быть проблемы, так что проверяйте сценарий с вашими установкам. А с версии 3.1.3 большие последовательности поддерживаются по умолчанию, а именно в форме mytt(<ESC>O) следующей за mytt(A), mytt(B), mytt(C) или mytt(D), так же как и соответствующие, установленные в начале mytt(<ESC>[), так что это может быть излишним.

  Практическая проблема, которая иногда возникает: есть два различных режима "стрелок", нормальный режим и "стрелки" на дополнительной клавиатуре, которые посылают различные последовательности. Хотя это большой исторический артефакт, но иногда бывает, что ваш терминал перешёл с одного режима на другой, например, какая-нибудь программа перешла в другой режим, но не перешла обратно. Таким образом вы столкнулись с этими эффектами. К счастью в этом случае последовательность кнопки "стрелки", вероятно, будет стандартной, и вы легко сможете заставить работать оба вида "стрелок". Следующий код делает это:
  verb(
    bindkey '\e[A'  up-line-or-history
    bindkey '\e[B'  down-line-or-history
    bindkey '\e[C'  forward-char
    bindkey '\e[D'  backward-char
    bindkey '\eOA'  up-line-or-history
    bindkey '\eOB'  down-line-or-history
    bindkey '\eOC'  forward-char
    bindkey '\eOD'  backward-char
  )
  Для большинства, даже смутно VT100-совместимых терминалов, приведённые восемь инструкций довольно безопасны для вашего tt(.zshrc). Конечно вы можете заменить здесь различные функции для второго аргумента.

sect(Почему терминал в некоторых случаях ведёт себя смешно?)

  Если вы используете OpenWindows cmdtool как ваш терминал, любая экранируемая последовательность (например произведённая курсорными кнопками) будет проглочена и никогда не достигнута zsh. Или используйте инструменты шелла или избегайте команд с экранируемыми последовательностями. Вы также можете выключить прокрутку из меню cmdtool (которая эффективно станет инструментом шелла). Если вам всё-таки нужна прокрутка, попытайтесь использовать xterm с активными scrollbar'ами.

  Это не проблема, если вы используете stty, чтобы изменить какие-нибудь свойства терминала, убедитесь, что вы не просили zsh заморозить свойства tty:
  наберите
  verb(
    ttyctl -u
  )
  до использования команды stty.

  С другой стороны, если вы не используете stty и вас есть проблемы, вам напротив нужна: mytt(ttyctl -f), замораживающая терминал от глюков других програм (kermit знает, как их делать).

  Эту проблему я наблюдал на личном опыте (на рабочей станции AIX 3.2 с xterm) - деинициализационные последовательности termcap, посылаемые утилитой `less', были причиной того, что automargins выключились --- фактически - это не проблема шелла, но вы возможно думали иначе. Чтобы это исправить, нужно в переменной окружения tt(LESS) присвоить `tt(X)', чтобы последовательности не посылались. Другие программы тоже могут посылать такие последовательности.

  Если myem(это) не проблема, а у вас есть сложности с внешними командами (не являющимися частью zsh), и вы думаете, что виной тому параметры терминала (например, tt(^V) интерпретируется как `буквальный следующий символ' (`literal next character'), когда вы хотите совсем по-другому), попробуйте
  verb(
    ttyctl -u
    STTY='lnext "^-"' commandname
  )
  (в данном примере). Обратите внимание, что zsh не сбрасывает терминал полностью: только режимы, которые его используют, и множество специальных символов обработки (см. tt(stty(1)) страницу руководства).

sect(Почему zsh не работает больше в режиме Emacs?)

  (Эта информация поступила от Bart Schaefer и других разработчиков.)

  Emacs 19.29 или близкие к нему перестают использовать тип терминала "emacs" в буферах шелла и взамен его ставят "dumb". Zsh проводит обработку emacs, только когда тип терминала "emacs".

  Возможно самый надёжный способ решить это - взглянуть на переменную окружения mytt($EMACS), которая имеет значение mytt(t) в режиме Emacs. Написать
  verb(
    [[ $EMACS = t ]] && unsetopt zle
  )
  в ваш .zshrc, этого должно быть достаточно.

  Другой метод - это написать
  verb(
    #!/bin/sh
    TERM=emacs exec zsh
  )
  в файл ~/bin/eshell, затем mytt(chmod +x ~/bin/eshell), и указать emacs, что бы он использовал его как шелл, добавив
  verb(
    (setenv "ESHELL" (expand-file-name "~/bin/eshell"))
  )
  в ~/.emacs.

3.11: Почему мои автозагружаемые функции не загружаются?

  Проблема возникает из-за того, что есть два пути автозагрузки функций (смотрите секцию AUTOLOADING FUNCTIONS руководства zsh, страницу zshmisc, для более подробной информации):
  enumerate(
  myeit() Файл содержит только тело функции, т.е. нет заголовка функции mytt(function foo {) или mytt(foo () {), и следовательно нет завершения mytt(}) в конце. Это традиционный метод zsh. Преимущество в том, что файл называется точно также, как и сценарий. Чтобы определить функцию mytt(xhead () { print -n "\033]2;$*\a"; }), файл должен только содержать mytt(print -n "\033]2;$*\a").  
  myeit() Файл содержит полное определение функции, и может даже другой код: он запускается, когда функцию нужно загрузить, тогда функция сама запускается. Это метод ksh. Чтобы определить такую же функцию mytt(xhead), всё обычное определение следует поместить в файл.
  )

  В старых версиях zsh, до версии 3.0, использовался только первый метод, убедитесь, что файл, содержащий тело функции, найден. Вы также можете определять другие функции в стандартной форме определений, хотя они будут переопределены каждый раз, когда вы вызываете главную функцию.

  В версии 3.0.x можно использовать второй метод определения автозагружаемых функций. К несчастью, этот метод не совместим со старым поведением zsh, которое позволяло вам переопределять функцию, когда вы её вызываете.

  Начиная с версии 3.1, появился параметр tt(KSH_AUTOLOAD), позволяющий полную ksh совместимость, т.е функция myem(должна) быть написана по второй форме, приведённой выше. Если этот параметр не задан, zsh попытается угадать, какую форму вы используете: если файл содержит только полное определение функции по второй форме и ничего больше, кроме комментариев и свободного места, то будет использована функция, определённая в файле; иначе будет задействован старый метод. Если конечно установлен параметр mytt(emulate ksh).

  (Хороший трюк, чтобы загрузить все функции в данной директории, это включить строку mytt(autoload ~/fns/*(:t)) в .zshrc; кусок в круглых скобках удалит из имён файлов директории, оставив только имена функций.)

sect(Как работает базовая арифметика?)

  Теперь воспринимается синтаксис ksh, т.е.
  verb(
    let 'foo = 16#ff'
  )
  или эквивалентно
  verb(
    (( foo = 16#ff ))
  )
  или даже
  verb(
    foo=$((16#ff))
  )
  Оригинальный синтаксис был
  verb(
    (( foo = [16]ff ))
  )
  --- это было основано на неправильном понимании руководства ksh. Он всё ещё работает, но считается устаревшим. Тогда
  verb(
    echo $foo
  )
  даст ответ `255'. Можно объявить переменные явно целыми, через
  verb(
    typeset -i foo
  )
  которое даст различные эффекты: а именно основание, используемое в первом присваивании (шестнадцатиричное в примере) в последствии используется всякий раз, когда `foo' отображается (хотя внутренне представление не меняется). Гарантировать, чтобы foo всегда отображалась в десятичной системе, нужно объявить так
  verb(
    typeset -i 10 foo
  )
  которое запрашивает десятичное основание для вывода. Вы можете изменить основание вывода существующей переменной следующим способом. Метод mytt($(( ... ))) будет всегда отображать в десятичной, за исключением версии 3.1.9, в которой появилась новая возможность выбора основания для вывода:
  verb(
    print $(( [#16] 255 ))
  )
  
sect(Как мне получить новую строку в приглашении?)
label(313)

  Вы можете заключить символ новой строки в кавычки, т.е.
  verb(
    PROMPT="Hi Joe,
    what now?%# "
  )
  Если вы задали параметр cshjunkiequotes, который тормозит это поведение, вы должны заключить это в mytt(unsetopt cshjunkiequotes) и mytt(setopt cshjunkiequotes), или написать это в ваш tt(.zshrc) до задания этого параметра.

  В недавних версиях zsh (не 3.0), есть форма записи, которая интерпретирует последовательности типа `tt(\n)', но иначе действует в одинарных кавычках: окружите строку так tt($'...'). Следовательно:
  verb(
    PROMPT=$'Hi Joe,\nwhat now?%# '
  )
  хороший способ сделать то, что вам надо. Заметьте, что это не расширение приглашения, которое экранирует `tt(\n)' в новую строку.

sect(Почему mytt(bindkey ^a command-name) или mytt(stty intr ^-) ведут себя как-то смешно?)

  Возможно, вы задали параметр extendedglob, в этом случае tt(^) и tt(#) - метасимволы. tt(^a) - обозначает любой файл, за исключением tt(a), т.ч это строка интерпретируется как bindkey сопровождённоё списком файлов. Экранируйте tt(^) с помощью бэкслэша или заключите tt(^a) в кавычки.

sect(Почему я не могу больше связать сочетания tt(\C-s) и tt(\C-q) ?)

  Клавиши control-s и control-q теперь контролируют поток по умолчанию, до тех пор пока вы не выключите его с помощью mytt(stty -ixon) или переопределите управление с помощью mytt(stty start) или mytt(stty stop). (Это делается системой, не zsh; шелл просто принимает эти установки.) Другими словами, tt(\C-s) останавливает весь вывод на терминал, в то время как tt(\C-q) возобновляет его.

  Есть параметр tt(NO_FLOW_CONTROL), чтобы не дать zsh контролировать поток и, следовательно, возобновить использование клавиш: напишите mytt(setopt noflowcontrol) в ваш tt(.zshrc).

sect(Как мне выполнить команду mytt(foo) внутри функции foo?)

  Команда mytt(command foo) как раз это и делает. Это применяется только функциях, но не в псевдонимах. Заметьте, что ошибка вроде
  verb(
    zsh: job table full or recursion limit exceeded
  )
  признак того, что вы пытаетесь вызвать `foo' в функции `foo' без использования `command'. Если mytt(foo) не внешняя, а встроенная команда, то взамен используете mytt(builtin foo).

sect(Почему подстановка команды из истории при использовании восклицательного знака возвращает что-то смешное?)

  Если у вас есть команда "tt(echo !-2:$ !$)", первая подстановка из истории задаст подстановку по умолчанию, на которую будут ссылаться следующие подстановки с одним восклицательным знаком, т.е. !$ станет эквивалентно tt(!-2:$). Параметр tt(CSH_JUNKIE_HISTORY) сделает, чтобы все одиночные восклицательные знаки ссылались на последнюю команду.

sect(Почему zsh убивает все фоновые процессы при выходе?)

  Самый простой ответ: вы не просили об обратном. Zsh (в отличие от [t]csh) даёт выбор: убивать фоновые задания или нет: существует параметр mytt(nohup), если вы не хотите их убивать. Заметьте, что вы всегда сможете запускать программы с помощью mytt(nohup) на переднем плане, независимо от того, задан параметр или нет, который предотвратит задачу от убийства при выходе. (В действительности mytt(nohup) внешняя команда.)

  Встроенная mytt(disown) - очень полезна в этом плане: если zsh информирует, что у вас есть фоновые задания, когда вы пытаетесь выйти, вы можете mytt(disown) всех, кого не нужно убивать при выходе. Это также хороший способ выполнения работ, которым не требуется шелл (такие как создание окна), шелл для них невидим. Подобно этому, вы можете запустить фоновую задачу с помощью mytt(&!) вместо mytt(&) на конце, которая автоматически потеряет родителя.

sect(Как мне просмотреть всё содержимое истории?)

  Сказать zsh, чтобы начал с первого элемента: mytt(history 1). Элементы в начале, которых больше нет в памяти, будут опущены.

sect(Почему другой синтаксис цикла тоже работает, например mytt(while {...} {...})?)

  Zsh предоставляет альтернативу традиционной sh-like форме с mytt(do),
  verb(
    while TEST; do COMMANDS; done
  )
  позволяя вам иметь COMMANDS, ограниченные другими командными структурами, часто mytt({...}). Правила довольно усложнённые и в большинстве сценариев, возможно, безопаснее и, конечно, более совместимо - придерживаться sh-like правил. Если вы удивлены, я приведу небольшое руководство.

  Чтобы это работало, вы должны убедиться, что TEST точно определён. Например, вот это работает:
  verb(
    while (( i++ < 10 )) { echo i is $i; }
  )
  но это НЕ будет работать:
  verb(
    while let "i++ < 10"; { echo i is $i; }   # Не правильно!
  )
  Причина в том, что после mytt(while), любой список команд в силе. Т.е. сюда включится весь список mytt(let "i++ < 10"; { echo i $i; }); синтаксический анализатор просто не знает, когда ему остановиться. Кроме того, пропускать точку с запятой - неправильно, как это сделано mytt({...}) в аргументе mytt(let). Новая строка ведёт себя так же, как и точка с запятой, так что вы не можете ставить скобку на следующей строке как в C.

  Т.о., когда используете этот синтаксис, test, следующее за mytt(while) должно быть заключено в скобки, любые из них: mytt(((...))), mytt([[...]]), mytt({...}) или mytt((...)) будут работать. (Они имеют их обычное синтаксическое значение тоже, конечно; они неизменны.) Заметьте, что здесь тоже неприменима точка с запятой, т.к. случай становится идентичный предыдущему:
  verb(
    while (( i++ < 10 )); { echo i is $i; }   # Не правильно!
  )
  Это же справедливо для конструкций mytt(if) и mytt(until):
  verb(
    if { true } { echo yes } else { echo no }
  )
  но с mytt(for), которому нужен только список слов, вы можете избежать этого:
  verb(
    for foo in a b; { echo foo is $a; bar=$foo; }
  )
  поскольку анализатор знает, что ему нужно всё до первой точки с запятой. По той же причине нет проблем и для конструкций mytt(repeat), mytt(case) или mytt(select); фактически, mytt(repeat) даже не нуждается в точке с запятой, поскольку он считает только одно слово.

  Это поведение не зависит от параметра SHORTLOOPS (см. руководство), который строго настрого нельзя использовать в программах, т.к. он может сильно запутать.

sect(Почему моя история не сохранилась?)
label(321)

  В zsh вам нужно задать 3 переменных, чтобы история сохранялась при выходе из шелла. Например,
  verb(
    HISTSIZE=200
    HISTFILE=~/.zsh_history
    SAVEHIST=200
  )
  tt($HISTSIZE) - сколько строк непосредственно сохранять,
  tt($HISTFILE) - куда записывать историю,
  tt($SAVEHIST) - сколько строк записывать. Самое простое - чтобы она была равна tt($HISTSIZE), как показано выше. Есть также ещё различные параметры, влияющие на историю; смотрите руководство.

sect(Как получить значение переменной, имя которой является значением другой переменной?)

  Проблема такая - у вас есть переменная tt($E), содержащая строку mytt(EDITOR), и переменная tt($EDITOR), содержащая строку mytt(emacs), или что-нибудь подобное. Как вы доберётесь от tt($E) до emacs одним этапом?

  Стандартного способа нет, чтобы это сделать. Тем не менее, в zsh есть идиома (доступна во всех версиях zsh, начиная с 3.0) для этого:
  verb(
    print ${(e)E:+\$$E}
  )
  Пока проигнорируйте mytt((e)). mytt(:+) значит: если переменная tt($E) задана, заменить следующим, т.е. mytt(\$$E). Это расширяется до mytt($EDITOR) по обычным правилам. Наконец, mytt((e)) обозначает `оцените выражение, которое вы только что сделали'. Это даст mytt(emacs).

  Чтобы сделать это стандартными средствами, воспользуйтесь mytt(eval):
  verb(
    eval echo \$$E
  )
  произведёт такой же результат.

  Версии, начиная с 3.1.6, позволяют вам делать это непосредственно через новые флаги; mytt(${(P)E}).

  Иногда люди замечают, что синтаксис mytt(${${E}}) правильный и ожидают, что у него есть этот эффект. Возможно должен, но в первые дни существования zsh было найдено удобным делать различные замены через одинаковый параметр; например, mytt(${${file##**/}%.*}) удаляет всё до последнего слеша в файле mytt($file), затем всё от последней точки, включая и её(попробуйте, будет работать!). Т.ч. в mytt(${${E}}), внутренние mytt(${...}) в действительности ничего не делают.

sect(Как предотвратить затирание сообщения, в котором нет символа новой строки, приглашением командной строки?)
  
  Проблема вот в чём:
  verb(
    % echo -n foo
    % 
  )
  и tt(foo) переписалась приглашением tt(%). Это происходит потому, что параметр tt(PROMPT_CR) активен по умолчанию, который выполняет перевод строки перед приглашением, для того, чтобы проверить, что редактор командной строки знает в каком он столбце (это нужно для правильного позиционирования правостороннего приглашения (mytt($RPROMPT), mytt($RPS1)) и, чтобы избежать разрушения экрана, когда выполняется редактирование строки). Если вы добавите tt(unsetopt promptcr) в ваш tt(.zshrc), вы увидите любой частичный вывод, но ваш экран может выглядеть странно после нажатия "Enter" или обновления экрана.

  Другое решение для многих терминалов - это определить функцию precmd, которая выводит ширину экранного пространства, вот так:
  verb(
    function precmd {
      echo -n ${(l:$COLUMNS:::):-}
    }
  )
  (Объяснение: пустой параметр расширяет количество заполненных колонок на экране.) Функция precmd будет только опускать экран на новую строку, если вывод был в строке приглашения, иначе дополнительное пространство будет удалено действием tt(PROMPT_CR). Хотя это обычно выглядит прекрасно, результат предыдущего пространства будет включён, когда вы выделяете текст мышью.

  Одна последняя альтернатива - поставить перевод строки в приглашении -- смотрите вопрос link(3.13)(313) для этого.

sect(Что случилось с операциями копирования и вырезания в xterm?)

  В большинстве современных UNIX системах, вырезание текста из одного окна и вставка в другое должны работать отлично. Тем не менее, не некоторых системах есть проблемы, связанные с тем, как оперировать терминалом: большинство программ ожидают, что терминал в режиме `canonical input mode', это означает, что программа передаёт всю строку на ввод за один раз, в то же время, для редактирования шеллу нужен символ за один раз и он должен быть в режиме `non-canonical input mode'. В системах, о которых идёт речь, ввод может быть потерян или переупорядочен, когда изменяются режимы. В действительности существуют две различные проблемы:
  enumerate(
  myeit() Когда вы вставляете что-нибудь в то время, когда программа запущена, шелл извлечёт это позже. Обычно, был тест, который использовался только на системах, где проблема точно существует, т.ч. это возможно на системах, которые не прошли этот тест (например, на определённых версиях IRIX, как выяснилось); продолжения строк также не были обработаны правильно. Более надёжный метод появился с версий 3.0.6 и 3.1.6.
  myeit() Когда шелл ждёт ввода, а вы вставляете кусок текста, содержащий более одной завершённой команды. К несчастью, это более трудная проблема: редактор уже стал активным, но его нужно выключить, когда первая команда выполняется. Шелл ровным счётом не знает: оставшийся текст - это параметры команды или другие команды шелла, т.е. просто ничего не может сделать. Тем не менее, есть одна хитрость: поставьте `tt({)' на отдельной строке, затем вставьте текст для ввода, а потом, также на отдельной строке, напишите `tt(})'. Шелл не будет ничего выполнять до тех пор, пока не считает закрывающуюся скобку; весь ввод читается построчно (для надёжности могут потребоваться исправления, упомянутые выше).
  )
  
sect(Как мне разукрасить приглашение командной строки в цветном xterm?)

  (Или `color xterm', если вы читаете в чёрно-белом.) Вам нужно найти последовательность, которая генерирует различные цвета, из руководства к вашему эмулятору терминала; есть ANSI стандарт о цветах. В недавних (3.1.6) дистрибутивах zsh появилась система тем для цветовой обработки; даже если вы этого не видите, установленная функция `mytt(colors)' (обозначает `colours', если вы читаете это в чёрно-белом) даёт экранированную последовательность. Вы должны написать код примерно так (заимствовано от Oliver Kiddle):
  verb(
    PS1=$'%{\e[1;31m%}<Здесь ваше приглашение>%{\e[0m%}'
  )
  mytt($') вне кавычек вернёт `mytt(\e)' в настоящий экранированный символ; это работает только с версии 3.1.4, т.е. если вы используете 3.0.x, вам нужно что-нибудь похожее на
  verb(
    PS1="$(print '%{\e[1;31m%}<Приглашение здесь>%{\e[0m%}')"
  )
  `mytt(%{...%})' используется в приглашениях для строк, которые не показываются как символы, т.ч. код приглашения не будет просчитывать длину приглашения, т.к. это может плохо сказаться на редактировании. Результат кода `mytt(<ESC>[1;31m)' сделает приглашение красным, а `mytt(<ESC>[0m)' вернёт всё на место, т.ч. остальная часть строки не изменится.

sect(Почему при выполнении команды `tt(foo 2>&1 >foo.out | bar)' вывод дублируется?)

  Это немного неожиданный эффект параметра tt(MULTIOS), который задан по умолчанию. Давайте взглянем ближе:
  verb(
    foo 2>&1 >foo.out | bar
  )
  Вы возможно ожидаете, что команда mytt(foo) перенаправит свой стандартный вывод в поток ввода команды mytt(bar), в то же время свои ошибки будут в файле mytt(foo.out). В действительности, вы видите, что вывод идёт в файл и в поток. Что бы стало яснее, вот такой же пример с реальными командами:
  verb(
    % { print output; print error >&2 } 2>&1 >foo.out | sed 's/error/erratic'
    erratic
    output
    % cat foo.out
    output
  )
  и вы видите, как `tt(output)' появляется дважды.

  Станет ещё яснее, что происходит, если мы напишем:
  verb(
    % print output >foo1.out >foo2.out
    % cat foo1.out
    output
    % cat foo2.out
    output
  )
  Вы наверное узнали, что это стандартная возможность zsh, называемая `tt(multios)' и контролируемая параметром с таким же именем, посредством её, вывод копируется в оба файла, когда перенаправление появляется дважды. В первом примере происходит то же самое, тем не менее второе перенаправление замаскировано как поток. Если вы хотите убрать такой эффект, вам нужно сбросить параметр mytt(MULTIOS).

chapter(Секреты завершения)

Программируемое завершение использует команду `compctl' - это одна из наиболее мощных, а также потенциально запутывающих, особенностей zsh; здесь я привожу небольшое введение. Набор поддерживаемых завершений с примерами идёт с исходником в файле Misc/compctl-examples; завершения для многих из наиболее употребимых команд могут быть найдены там же.

Если это не устраивает вас, вы можете выбрать новую, более изящную систему завершения, которая появилась в версии 3.1.6. Она основана на функциях, вызываемых автоматически для завершения в конкретном контексте (например, функция tt(_cd) оперирует завершением для команды tt(cd)) и установленных автоматически с шеллом, т.е. всё что вам нужно сделать, в принципе, это разместить их для загрузки. Достаточно дописать `tt(autoload -U compinit; compinit)' в файл tt(.zshrc). Остальная секция рассказывает о старой системе завершения.

sect(Что такое завершение?)

  `Завершение' (`Completion') - это когда вы нажимаете командную клавишу (TAB по умолчанию) и шелл пытается угадать слово, которое вы вводите, и закончить его --- особенно ценно для длинных имён файлов в частности, но в zsh намного больше возможностей.

  Есть ещё один связанный процесс, `расширение' (`expansion'), когда шелл видит, что вы ввели что-то, что можно преобразовать во что-то ещё, так например переменная преобразуется в её значение ($PWD станет /home/users/mydir) или ссылка на историю (!! станет всем на последней командной строке). В zsh, когда вы нажимаете TAB, шелл смотрит, можно ли сделать расширение; если да, то оно выполняется, иначе он пытается выполнить завершение. (Вы можете посмотреть, будет ли слово расширено --- не завершено --- через TAB, набрав mytt(\C-x g), отобразится список расширений.) Расширение обычно довольно интуитивно и не контролируется пользователем; оставшуюся главу я буду обсуждать только завершение.

sect(Что может быть завершено?)
label(42)

  Самый простой вид - завершение имён файлов, обсуждавшееся выше. До тех пор, пока вы не сделаете специальное размещение, как описано выше, когда вы наберёте имя команды, всё остальное будет подразумеваться системой завершения как имена файлов. Если вы ввели часть слова и нажали TAB, zsh посмотрит, есть ли совпадения первой части файлового имени и автоматически вставит оставшеюся.

  Другой простой тип - завершение команд, которое применяется (естественно) к первому слову в строке. В этом случае, zsh считает слово некоторой выполняемой командой, лежащей в вашей $PATH (или чем-либо ещё, что можно выполнить, типа встроенной команды, функции или псевдонима) и пытается завершить его.

  Другие формы завершения требуют специального размещения. Посмотрите секцию руководства для compctl, чтобы получить весь список флагов: вы можете сделать команды завершения имён переменных, имён пользователей, задач, и т.д., и т.п.

  Например, обычное использование - у вас есть массив tt($hosts), который содержит имена других машин, которые вы часто используете в сети:
  verb(
    hosts=(fred.ph.ku.ac.uk snuggles.floppy-bunnies.com here.there.edu)
  )
  тогда вы можете указать zsh, что когда вы используете telnet (или ftp, или ...), аргументом будет одно из этих имён:
  verb(
    compctl -k hosts telnet ftp ...
  )
  т.е. если вы наберёте mytt(telnet fr) и нажмёте TAB, остальная часть имени появится сама.

  Ещё более мощный параметр tt(compctl) (tt(-g)) - указать zsh, что только определённые имена файлов можно использовать. Аргумент tt(-g) - это точно так же, как и универсальный образец с обычными специальными символами mytt(*), mytt(?), и т.д. В операторе compctl их нужно заключать в кавычки, чтобы избежать трактования как имён файлов. Напримар,
  verb(
    compctl -g '*.(ps|eps)' ghostview
  )
  указывает zsh, что если вы нажмёте TAB на аргументе после команды ghostview, только файлы, оканчивающиеся на mytt(.ps) или mytt(.eps) будут рассматриваться для завершения.

  Полезное дополнение для zsh появилось в версии 3.1 - завершение директорий:
  verb(
    compctl -/ cd
  )
  Перед тем, как использовать tt(-g): данная команда заботится о таких вещах, как игнорирование директорий, начинающихся с точки, пока вы сами не поставите точку, и все пути директории понятны.

  Обратите внимание, что флаги можно объединять; если у вас больше одного, все возможные завершения для всех помещаются в тот же список, все из них будут возможными завершениями. Т.е.
  verb(
    compctl -k hosts -f rcp
  )
  сообщает zsh, что rcp может иметь как имя файла, так и имя машины после себя. (Вам нужно уметь обрабатывать host:file, это входит в программируемое завершение, смотрите пункт link(4.5)(45).) Также, с версии 3.1 вы всегда можете оперировать директориями в то же время как и файлами, просто добавив tt(-/) в список.

sect(Как zsh поступает с неопределёнными завершениями?)

  Часто существует более одного возможного завершения: например, два файла, начинающиеся с одного и того же символа. Zsh обладает большой гибкостью в этой ситуации через его параметры. По умолчанию - beep и завершение останавливается до того, пока вы не введёте следующий символ. Вы можете нажать tt(\C-D), чтобы увидеть все возможные завершения. (Предполагается, что вы находитесь в конце строки, иначе tt(\C-D) удалит следующий символ и вы должны будете использовать tt(ESC-\C-D).) Это можно изменить следующими параметрами:
  itemize(
   it() tt(NO_BEEP) - без раздражающего beep
   it() tt(NO_LIST_BEEP) - beeping выключается только для неявных завершений
   it() tt(AUTO_LIST) - когда завершение не явное - вы получаете список без нажатия на tt(\C-D)
   it() tt(BASH_AUTO_LIST) - список показывается после второго нажатия на tab при наясном завершении
   it() tt(LIST_AMBIGUOUS) - список не отображается, если есть явный суффикс или префикс для вставки --- параметр может сочетаться с tt(BASH_AUTO_LIST), так что, если оба параметра применимы, вам нужно три раза нажать на tab для списка.
   it() tt(MENU_COMPLETE) - одно завершение всегда вставляется полностью, затем, когда вы нажимаете TAB, оно сменяется на следующее, и так далее, до тех пор, пока вы не начнёте сначала
   it() tt(AUTO_MENU) - вы получаете только режим меню, когда снова нажимаете на TAB при неявном завершении.
   it() Наконец, хотя он и действует на все листы завершения, включая явно запрашиваемые, параметр tt(ALWAYS_LAST_PROMPT), который возвращает курсор на редактируемую линию после отображения листа завершения, при условии, что он достаточно короткий.
  )
  Так же возможны их сочетания; например, tt(AUTO_LIST) и tt(AUTO_MENU) вместе дают интуитивную комбинацию. Начиная с версии 3.1 параметр tt(LIST_AMBIGUOUS) задан по умолчанию; если вы используете autolist, то лучше сделать `unsetopt listambiguous'.

sect(Как мне завершить в середине слова / до курсора?)

  Иногда у вас есть слово в командной строке (давайте придерживаться имён файлов), которое не завершено в середине. Обычно, если вы нажмёте tab в zsh, он просто перейдёт в конец слова и попытается завершить его. Тем не менее, есть два способа изменить это.

  Во-первых, существует параметр COMPLETE_IN_WORD. Когда он задан, шелл попытается закончить слово от курсора. Например, если текущая директория содержит mytt(foobar), тогда с заданным параметром, вы можете завершить mytt(fbar) до mytt(foobar), переместив курсор к mytt(b) и нажав tab.

  Это ещё не всё. Иногда вам нужно завершить часть слова до курсора. Например, слово mytt(/usr/loc/b) нужно завершить до mytt(/usr/local/bin). Обычно zsh не сможет сделать этого за один раз, т.к. здесь пропущены две части (но смотрите ниже!), т.е. вам нужно завершить mytt(/usr/loc) сначала. Для этого вам нужна функция tt(expand-or-complete-prefix): она работает как обычная функция, связанная с tab, но она игнорирует всё, что находится справа от курсора. Если вам нужно такое поведение (некоторые другие шеллы то же делают так), свяжите её с tab; или сделайте другую привязку, например mytt(^X TAB) в tt(~/.zshrc):
  verb(
    bindkey "^X^I" expand-or-complete-prefix
  )
  тогда, в нашем примере, вы можете переместиться за mytt(/usr/loc), нажать клавишу, которую вы только что связали с функцией, переместиться в конец и нажать tab. (Заметьте, что здесь применим режим tt(AUTO_REMOVE_SLASH), смотрите руководство.)

  Даже это не исчерпывает возможности. Включённый в исходный дистрибутив файл tt(Functions/multicomp) - это функция, которую вы можете привязать как альтернативную форму завершения по умолчанию (смотрите ниже описание альтернативного завершения), например
  verb(
    compctl -D -f + -U -Q -K multicomp
  )
  и вся последовательность директорий, такая как mytt(/usr/loc/b) или даже mytt(/u/l/b) может быть завершена за один раз. Это отлично работает с menucompletion, если результат неявный.

sect(Как мне начать с программируемым завершением?)
label(45)

  Наконец, самая сложная часть завершения. Возможно сделать так, чтобы zsh рассматривал различные завершения не только для различных команд, но и для различных слов одной и той же команды, или даже рассматривал другие слова командной строки (например, если последнее слово было специальным флагом) и затем решал, как завершать.

  Есть две вещи, о которых следует беспокоиться. Самое простое - альтернативное завершение: это значит, что zsh сначала попробует одну альтернативу и, если не будет возможных завершений, то попробует следующую. Например
  verb(
    compctl -g '*.ps' + -f lpr
  )
  сообщает, что после lpr вы предпочитаете найти только файлы mytt(.ps), т.е. если они есть, то используются только они, а иначе - любые. У вас также может быть tt(+) без флагов после него, который указывает zsh, что, если ничего не найдено, трактовать команду как любую другую. Это действительно полезно, если по умолчанию завершение запрограммировано, т.е. вы сделали что-то с mytt(compctl -D), чтобы сообщить zsh как команды, которые специально не запрограммированы, должны завершить их аргументы.

  Второй вид. После параметра mytt(-x) zsh ожидает, что далее будет какой-то код завершения, который является буквой и следует за аргументом в квадратных скобках. Например, mytt(p[1]): mytt(p) - для позиции, и аргумент указывает на позицию 1; завершение применимо только к слову, следующему сразу за командой. Вы можете также написать mytt(p[1,3]), теперь завершение применимо к слову, если оно находится между первым и третим словами после команды включительно, и т.д. Смотрите список в секции mytt(compctl) руководства: некоторые условия берут один аргумент в квадратные скобки, некоторые два. Обычно, отрицательные аргументы считаются обратно с конца (например, mytt(p[-1]) применяется к последнему слову в строке).

  (Заметьте разницу между mytt(+) и mytt(-x). Завершение для mytt(+) сначала всегда попытается найти завершения для того, что до mytt(+); если завершение не найдено - будет выведен список. С другой стороны, для mytt(-x), подходящее множество завершений всегда используется, даже если список завершений пустой.)

  Условия, которые следуют за флагами, как обычно и другие условия/флаги задаются (как в link(4.2)(42)), следуя за одинарным - ; все они заканчиваются двойными --, до имени команды. Другими словами, каждая расширенная секция завершения выглядит примерно так:
  verb(
    -x <образец> <флаги>... [ - <образец> <флаги>... ...] --
  )
  Давайте опять взглянем на rcp: предполагается, что вы задали tt($hosts) так же как выше. Будем использовать флаг mytt(n[<n>,<string>]), который указывает zsh - искать tt(<n>)'ое количество совпадений строки <string> в слове и игнорировать всё, что найдено. Мы используем это для завершения битов комбинации rcp mytt(user@host:file). (Конечно, file - имя файла на локальной машине, не на mytt(host), но давайте проигнорируем это; это всё ещё может быть полезным.)
  verb(
    compctl -k hosts -S ':' + -f -x 'n[1,:]' -f - \ 
          'n[1,@]' -k hosts -S ':' -- rcp
  )
  Это означает: (1) попытаться завершить имя хоста (символ до mytt(+)), если успешно, то добавить mytt(:) (tt(-S) для суффикса); (2) если неудачно, то попытаемся выполнить код после mytt(+): смотрим, есть ли в слове mytt(:) (параметр mytt(n[1,:])); если да, то завершаем имя файла (tt(-f)) после первого из них; (3) иначе ищем mytt(@) и завершаем имя хоста после первой их них (параметр mytt(n[1,@])), если успешно, то добавляем mytt(:); (4) если ничего не выполнилось, то используем mytt(-f) перед mytt(-x) и пытаемся завершить имя файла.

  Итак, вот правила: (1) прежде всего попытаться сделать всё, что до mytt(+) (2) пытаться выполнить условия после tt(-x) до того, пока хотя бы одно не выполнится (3) если ничего не выполнилось, то использовать флаги по умолчанию.

  Разные условия также можно объединять. Вот три уровня объединения (в порядке уменьшения):
  enumerate(
   myeit() многочисленные квадратные скобки после одного условия дают альтернативу: например, mytt(s[foo][bar]) указывает, что завершение применимо к словам, начинающимся с mytt(foo) или mytt(bar),
   myeit() пробелы между условиями означают, что оба должны выполняться: например, mytt(p[1] s[-]) указывает, что завершение применимо только к первому слову после команды, если оно начинается с mytt(-),
   myeit() запятые между условиями означают, что любое должно выполниться: например, mytt(c[-1,-f], s[-f]) означает, что любое предыдущее слово (-1 относительно текущего) это tt(-f), или текущее слово начинается с tt(-f) --- полезно использовать такое же завершение - действительно ли tt(-f) имеет пробел после себя.
  )

  Вы должны помнить, что всё выражение должно быть в кавычках, чтобы для tt(compctl) оно являлось одним аргументом.

  Вот ненужный пример (просто чтобы показать обычное mytt(-x) завершение).
  verb(
    compctl -f -x 'c[-1,-u][-1,-U] p[2], s[-u]' -u - \ 
      'c[-1,-j]' -P % -j -- foobar
  )
  Как это прочитать: для команды mytt(foobar), посмотреть если (((предыдущее слово tt(-u)) или (предыдущее слово tt(-U))) и (текущее слово 2)) или (текущее слово начинается с tt(-u)); если так, то попытаться завершить имена пользователей. Если предыдущее слово tt(-j), вставить перед текущим словом префикс mytt(%), если его там нет, и завершить имена задач. Иначе просто завершить имена файлов.

4.6: Достаточно ли полезно программируемое завершение?

  ...тогда ваша последняя надежда - написать шелл-функцию и настроить всё под себя. Объединяя флаги mytt(-U) и mytt(-K func), вы можете получить почти неограниченную мощь. mytt(-U) - указывает zsh, что нужно использовать все завершения, даже не соответствующие тому, что уже есть (так, что написанное будет удалено, когда завершение будет вставлено). mytt(-K func) - указывает zsh имя функции. Функция проходит через часть слова, которое уже введено, и может считать остаток строки с помощью mytt(read -c). Она может вернуть множество завершений через массив mytt(reply), и оно станет множеством возможных завершений. Чтобы лучше всего понять это, нужно взглянуть на mytt(multicomp) и другие функции, поставляемые с дистрибутивом zsh. Несомненно, для чего-нибудь сложного лучше использовать новую систему завершения. В будущем не планируется обновлений для старой системы завершения.

chapter(Будущее zsh)

sect(Какие ошибки известны и неисправлены? (А также недавние важные изменения))
label(51)

  Вот несколько из многих хорошо известных в порядке уменьшения важности. Многие из них могут также считаться отличиями от ksh в вопросе link(2.1)(21); заметьте, что это относится к последней бета версии и что простые ошибки часто исправляются очень быстро. В файле Etc/BUGS в исходном дистрибутиве больше подробностей.
  
  itemize(
  it() Расширение параметров, используемое в формах tt(${param+word}) и tt(${param-word}) может не работать в режиме Bourne-shell совместимости, когда задан параметр tt(SH_WORD_SPLIT) и word содержит пробелы.
  it() mytt(time) игнорируется командой builtin и не может быть использована с mytt({...}).
  it() mytt(set -x) (mytt(setopt xtrace)) по прежнему имеет несколько глюков; большинство из них исправлено в версии 3.1.6.
  it() Понятие Zsh о номере текущей строки (через tt($LINENO)) иногда не определяется, особенно при использовании функций и прерываний. Это точно должно работать с версий 3.0.6 и 3.1.6.
  it() В режиме vi, mytt(u) может вернуть к первоначальной точке модификации.
  it() Параметр singlelinezle конфликтует с приглашениями, содержащими экранируемые последовательности.
  it() Команда mytt(r) не работает внутри mytt($(...)) или mytt(`...`). Это исправлено в версии 3.1.
  it() Использовать mytt(typeset) - не оптимально, особенно с флагами, и ksh-несовместимо. В версии 3.1.6 это было исправлено, но оставшиеся глюки ожидаются.
  it() Вложенные закрытия в расширенной универсализации имён и в форме образцов, таких как
  verb(
      [[ fofo = (fo#)# ]]
  )
     не корректно трактовалось, и были проблемы с усложнёнными исключениями с использованием mytt(^) или mytt(~). Это исправлено с версии 3.1.3.
  )
  it() Трактование mytt(:q) и mytt(:x) с подстановкой параметра ведёт себя странно: ни один из них не работает в любой версии 3.0, а tt(:x) не работает и после.

  Несколько недавних изменений показывают несовместимости (это не ошибки):

  Изменения после zsh 3.0:
  itemize(
  it() Параметры tt(ALWAYS_LAST_PROMPT) (возвращает на строку, которую вы редактируете, после отображения листа завершения) и tt(LIST_AMBIGUOUS) (не делайте tt(AUTO_LIST), если был явный префикс, который должен быть вставлен, т.е. выводите список, если неясно, что вставлять дальше) теперь заданы по умолчанию. Это было сделано в ответ на жалобы, что большинство возможностей zsh не замечаются многими пользователями. Что бы выключить их, нужно прописать mytt(unsetopt alwayslastprompt listambiguous) в файл tt(.zshrc).
  it() В 3.1.5 tt(history-search-{forward,backward}) находит только предыдущие строки, где первое слово такое же как и текущии. Например, 
    verb(
      comp<ESC>p
    )
     найдёт строки в истории похожие на mytt(comp -edit emacs), но не mytt(compress file). По этой причине, mytt(\M-n) и mytt(\M-p) использует tt(history-beginning-search-{forward,backward}), который ищет строку с таким же префиксом до курсора. В версии 3.1.6 появилась другая реализация, которая ближе (но не идентична) к старому поведению, и традиционные связи восстановлены. Ситуация с командами tt({up,down}-line-or-search аналогична).
  it() В режиме вставки vi, клавиши передвижения курсора больше не работают. Следующая команда привязывает их:
      COMMENT(-- note space after backslash --)
    verb(
       bindkey -M viins '^[[D' vi-backward-char '^[[C' vi-forward-char '^[[A' up-line-or-history '^[[B' down-line-or-history
    )
     (пока ваш терминал не требует mytt(^[O) вместо mytt(^[[)). Основная причина в том, что теперь раскладки для клавиш с префиксами в режиме вставки и в командном режиме - различны.
  )
  
  Изменения после zsh 2.5:
  itemize(
  it() Левая часть присваивания больше не подставляется. Следовательно, mytt($1=$2) - не будет работать. Вы можете использовать что-нибудь похожее на mytt(eval "$1=\$2"), что будет идентично.
  it() Прерывания устанавливаются с помощью встроенной команды `trap', которая теперь вызывается с окружением вызвавшего её, как в ksh, вместо нового уровня функции. Прерывания, установленные как функции, (т.е. mytt(TRAPINT() {...})) работают как и раньше.
  it() Параметр tt(NO_CLOBBER) - теперь называется -C и tt(PRINT_EXIT_VALUE) -1; раньше было наоборот. (Использование имён предпочтительнее, чем букв.)
  it() mytt([[) - зарезервированное слово, следовательно, должно быть отделено от других символов свободным местом; mytt({) и mytt(}) также зарезервированные слова, если задан параметр tt(IGNORE_BRACES).
  it() Удалён параметр tt(CSH_JUNKIE_PAREN): csh-like код теперь всегда выполняет то, что он должен выполнять, т.е. mytt(if ( ... ) ...) выполняет код внутри скобок выполняется в отдельном процессе. Чтобы это можно было использовать, синтаксис после mytt(if) менее строг, чем в других шеллах.
  it() mytt(foo=*) - не сразу выполняет универсализацию имён в правой части присваивания; старое поведение теперь требует параметра tt(GLOB_ASSIGN). (mytt(foo=(*)) - чтобы принудительно её выполнить.)
  it() tt(<>) выполняет перенаправление ввода и вывода в установленный файл. Для цифрового обозначения нужно использовать tt(<->).
  it() Классификаторы командной строки, такие как tt(exec), tt(noglob), tt(command), - теперь трактуются больше как встроенные команды: первоначально у них был особенный синтаксис. Это должно облегчить выполнение различных хитростей (выключение, скрытие в параметрах и т.п.).
  it() Встроенная команда pushd была переписана для совместимости с другими шеллами. Старое поведение можно получить шелл функцией.
  it() Текущая версия использует tt(~) для подстановки стека директории вместо tt(=). Это для последовательности: все остальные подстановки директории (tt(~user), tt(~name), tt(~+), ...) используют тильду, т.к. tt(=<number>) вызывало проблемы с подстановкой tt(=program).
  it() Параметр tt(HISTLIT) был поломан различными способами и затем удалён: переписанный механизм истории ничего не изменил, но данный параметр стал ненужным.
  it() Расширение истории выключено в строках, заключённых в одинарные кавычки, как и в других формах расширения, следовательно, восклицательные знаки не нужно экранировать.
  it() Переменная mytt($HISTCHARS) теперь стала mytt($histchars). В данный момент они обе доступны для совместимости.
  it() Параметр tt(PROMPT_SUBST) теперь выполняет backquote expansion -- hence you should quote these in prompts. (как результат, SPROMPT тоже изменился.)
  it() Quoting in prompts has changed: close parentheses inside ternary expressions should be quoted with a tt(%); history is now tt(%!), not tt(!).  Backslashes are no longer special.
  )

sect(Где мне доложить об ошибках, получить больше информации / кто работает над zsh?)
label(52)

  Шелл поддерживается различными (entirely self-appointed) подписчиками листа рассылки,
  verb(
    zsh-workers@sunsite.dk
  )
  т.ч. пишите по любым вопросам (сообщения об ошибках, предложения, жалобы...), связанным с разработкой шелла. Если вы хотите, чтобы кто-нибудь написал непосредственно вам - так и скажите. Большинство заплаток появляются сначала здесь.

  Обратите внимание, что это местоположение недавно изменилось (Январь 1999), и инструкции слегка различны --- в частности, если вы уже подписаны, то инструкции о том, как отписаться будут различаться.

  Пожалуйста, заметьте также, что некоторые ошибки существуют только на определённых архитектурах, к которым разработчики могут не иметь доступа. В этом случае отладочная информация особенно нужна и, по возможности, как можно детальней.

  Есть ещё два небольших прогрессивных листа, один с сообщениями, касающихся использования,
  verb(
    zsh-users@sunsite.dk
  )
  а другой содержит объявления: о версиях, о главных изменениях в шелле, или, например, об этом FAQ,
  verb(
    zsh-announce@sunsite.dk
  )
  (использование последнего в настоящее время ограничено).

  Вы можете присоединиться только к одной рассылке: zsh-workers получают все рассылки, а zsh-users будут получать объявления.

  Инструкции для zsh-announce и zsh-users такие же, как и для zsh-workers: просто измените zsh-workers на то, что нужно.

  Чтобы присоединиться к zsh-workers, нужно послать письмо на
  verb(
    zsh-workers-subscribe@sunsite.dk
  )
  (фактическое содержание не важно). Замените tt(subscribe) на tt(unsubscribe), чтобы отписаться. Программное обеспечение (tt(ezml)) имеет разные глюки, т.е. если что, то вы можете восстановить сообщение из архива. Для более детальной информации пишите на email(zsh-workers-help@sunsite.dk). Административные вопросы лучше слать на email(zsh-workers-owner@sunsite.dk). Рассылку обслуживает email(Karsten Thygesen <karthy@kom.auc.dk>).

  Архив рассылки за последние несколько лет находится здесь
    url(http://www.zsh.org/mla/)(http://www.zsh.org/mla/)
  в главном архиве zsh в Австралии.

  Конечно, вы также можете задавать вопросы в Usenet группу comp.unix.shell; если ничего не помогло, то вы можете написать даже мне.

sect(Как насчёт списка пожеланий?)

  После версии 3, код стал значительно чище, чем раньше, но всё ещё имеет признаки возраста и много вещей могли бы быть сделаны лучще, будь они написаны заново. Более эффективный код для лексики/синтаксиса/выполнения был бы предпочтительнее. Добровольцы особенно приветствуются для этих задач.

  Вот последние изменения, которые появились в zsh 3.1.6.
  itemize(
  it() Ещё более мощная система завершения, основанная на шелл-функциях, позволяет более детально контролировать сопоставление завершений и их вставку и отображение. Функции, работающие `из коробки' будут доступны, включая много функций для внешних команд: файлы в tar-архивах могут быть указаны для извлечения, как будто они реальные файлы; GNU команды, которые принимают параметр mytt(--help), могут сгенерировать лист завершений для них самих на лету, и т.д, и т.п. Вы можете использовать старый стиль завершения, основанный на tt(compctl), для некоторых команд и новый стиль для других; вы можете привязать специфическое завершение команды вашего собственного определения нажатия клавиши.
  it() Другие расширения завершения: соответственный контроль, позволяющий нечувствительные к регистру сопоставления и специальные символы, например mytt(z_t<TAB>) позволяет специальный символ до mytt(_) т.е. расширится до mytt(zle_tricky.c) --- всё под контролем пользователя; завершения могут быть сгруппированы; новая команда завершения, menu-select, позволяет реально выбрать из меню --- вы можете передвигать курсор, чтобы выбрать завершение.
  it() Нечувствительные к регистру и приближённые сопоставления в универсализации кода: например, menu((#ia2)readme' составит строку `readme), не взирая на регистр и допуская две ошибки, такие как tt(README), tt(READ.ME), tt(_README_), tt(Read!Me!). Новая система завершения знает об этом, позволяя исправить завершение, т.е. mytt(mkaef<TAB>) может быть завершено до mytt(Makefile).
  it() Ассоциативные массивы, объявленные с помощью mytt(typeset -A aname); синтаксис для создания, доступа и удаления элементов из них.
  it() Пользователи могут сами создавать их собственные tt(foopath)/tt(FOOPATH) array/path комбинации, такие как tt(path) и tt(PATH).
  it() Динамически загружаемая библиотека для FTP, завершает набор функций для простоты использования шелла. Это позволит вам использовать возможности шелла для написания сценариев, редактирования, завершения, перенаправления, просмотра директорий и т.д. без FTP-сессии.
  )
  
  Другие будущие возможности, которые были предложены:
  itemize(
  it() Код параметров может быть более эффективным, быть может даже с большими возможностями из ksh93.
  it() Конфигурационные файлы zsh создавать с помощью Dotfile Generator.
  it() Дальнейшие усовершенствования интегрирования редактора с функциями шелла.
  it() Ksh совместимость должна быть улучшена.
  it() Параметр для спецификаторов универсализации, чтобы следовать за синтаксисом perl (традиционный пункт).
  )
  
sect(Имеет ли zsh проблемы в 2000 году?)

  Я не слышал этого; решать вам, быть осторожным с датами или нет, где год из двух цифр, хотя, они получены экранированными последовательностями mytt(%W) и mytt(%D), и также командой `tt(print -P)'. У ранних версий zsh здесь могут быть проблемы.

nsect(Благодарности:)

Спасибо листу рассылки zsh, в частности Bart Schaefer, за советы, касающиеся этого документа. Zsh был у архивариусов Jim Mattson, Bas de Bakker, Richard Coleman, Zoltan Hidvegi и Andrew Main, а лист рассылки поддерживается Peter Gray, Rick Ohnemus, Richard Coleman и Karsten Thygesen, все они также заслуживают благодарности. Мир вечно в долгу перед Paul Falstad за изобретение zsh на первом месте (хотя добавил завершение Sven Wischnowsky).

nsect(Авторская информация:)

Автор документа (C) - P.W. Stephenson, 1995, 1996, 1997, 1998, 1999, 2000. Этот текст был создан в Великобритании и автор утвердил свои моральные права под авторскими правами, проектами и патентами, 1988.

Разрешение тем самым предоставляется, без письменного соглашения и без Лицензии или платы, чтобы использовать, копировать, изменять, и распространять этот документ для любой цели, при условии, что вышеупомянутое авторское право появляется во всех копиях этой документации. Помните, что этот документ изменяется ежемесячно и будет более полезно предоставить ссылку на полный текст. Более или менее пригодная ссылка - "information on the Z-shell can be obtained on the World
Wide Web at URL http://sunsite.dk/zsh/".

--------------090109020601050809040306--

