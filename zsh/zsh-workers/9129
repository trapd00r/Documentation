From zsh-workers-return-9129-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Dec 21 22:34:36 1999
Return-Path: <zsh-workers-return-9129-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3153 invoked from network); 21 Dec 1999 22:34:34 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 21 Dec 1999 22:34:34 -0000
Received: (qmail 25487 invoked by alias); 21 Dec 1999 22:34:29 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9129
Received: (qmail 25480 invoked from network); 21 Dec 1999 22:34:28 -0000
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: More tests
Date: Tue, 21 Dec 1999 22:35:40 +0000
From: Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Message-Id: <E120XrM-00073o-00.1999-12-21-22-34-25@mail4.svr.pol.co.uk>

Here are some more tests for basic shell stuff.  You've no idea how
exciting it is writing these, but at least it keeps me from having to fix
bugs (except one).

Things which turned up:

1. I've fixed this one in the patch, so you need to recompile for the tests
   to work.

% print $(( 3 : 4 ))
BUG: math: wallabies roaming too freely in outback
3


2. There's something wrong with synchronisation in multios:

% print hello >foo && print "$(<foo)"
hello
% print hello >foo >bar && print "$(<foo)"

% setopt nomultios
% print hello >foo >bar && print "$(<bar)"
hello

(the last example because foo is created empty, but the command output is
only redirected to bar).

Furthermore, sometimes (in fact, quite often) in the example that doesn't
work, zle isn't initialised properly; it seems to be in canonical input
mode.  This all suggests there is a race present.


3. This must be related to previous problems I reported, where braces are
apparently sometimes treated differently down in the bowels of the shell:
`<f{oo,ubar}' usually opens a stdin multio, but doesn't do so in the
context of the tests.


Index: Src/math.c
===================================================================
RCS file: /home/pws/CVSROOT/projects/zsh/Src/math.c,v
retrieving revision 1.2
diff -u -r1.2 math.c
--- Src/math.c	1999/12/03 19:12:10	1.2
+++ Src/math.c	1999/12/21 21:31:31
@@ -807,6 +807,7 @@
 	push(((a.type & MN_FLOAT) ? a.u.d : a.u.l) ? b : c, NULL);
 	break;
     case COLON:
+	zerr("':' without '?'", NULL, 0);
 	break;
     case PREPLUS:
 	if (spval->type & MN_FLOAT)
Index: Test/04redirect.ztst
===================================================================
RCS file: 04redirect.ztst
diff -N 04redirect.ztst
--- /dev/null	Tue May  5 21:32:27 1998
+++ 04redirect.ztst	Tue Dec 21 17:42:26 1999
@@ -0,0 +1,215 @@
+# Tests corresponding to the `Redirection' texinfo node.
+
+%prep
+  mkdir redir.tmp && cd redir.tmp
+
+%test
+
+  print 'This is file redir' >redir  &&  cat redir
+0:'>' and '<' redirection
+>This is file redir
+
+  rm -f redir
+  print 'This is still file redir' <>redir >&0  &&  cat <>redir
+0:'<>' redirection
+>This is still file redir
+
+  rm -f redir
+  print 'With a bar' >|redir  &&  cat redir
+0:'>|' redirection
+>With a bar
+
+  rm -f redir
+  print 'With a bang' >!redir  &&  cat redir
+0:'>!' redirection
+>With a bang
+
+  rm -f redir
+  print 'Line 1' >>redir  &&  print 'Line 2' >>redir  &&  cat redir
+0:'>>' redirection
+>Line 1
+>Line 2
+
+  rm -f redir
+  print 'Line a' >>|redir  &&  print 'Line b' >>!redir
+0:'>>|' and '>>!' redirection
+
+  foo=bar
+  cat <<'  HERE'
+  $foo
+  HERE
+  eval "$(print 'cat <<HERE\n$foo\nHERE')"
+0:Here-documents
+>  $foo
+>bar
+
+  cat <<-HERE
+# note tabs at the start of the following lines
+	$foo$foo
+	HERE
+0:Here-documents stripping tabs
+>barbar
+
+  cat <<<"This is a line with a $foo in it"
+0:'<<<' redirection
+>This is a line with a bar in it
+
+  exec 3>redir  &&  print hello >&3  &&  print goodbye >&3  && cat redir
+0:'>&' redirection
+>hello
+>goodbye
+
+  exec 3<redir && read foo <&3 && print $foo && read foo <&3 && print $foo
+0:'<&' redirection
+>hello
+>goodbye
+
+  read foo <&-
+1:'<&-' redirection
+
+  print foo >&-
+0:'>&-' redirection
+
+  fn() { local foo; read foo; print $foo; }
+  coproc fn
+  print test output >&p
+  read bar <&p
+  print $bar
+0:'>&p' and '<&p' redirection
+>test output
+
+  ( print Output; print Error >& 2 ) >&errout  &&  cat errout
+0:'>&FILE' handling
+>Output
+>Error
+
+  rm -f errout
+  ( print Output2; print Error2 >& 2 ) &>errout  &&  cat errout
+0:'&>FILE' handling
+>Output2
+>Error2
+
+  rm -f errout
+  ( print Output3; print Error3 >& 2 ) >&|errout  &&  cat errout
+  ( print Output4; print Error4 >& 2 ) >&!errout  &&  cat errout
+  ( print Output5; print Error5 >& 2 ) &>|errout  &&  cat errout
+  ( print Output6; print Error6 >& 2 ) &>!errout  &&
+  ( print Output7; print Error7 >& 2 ) >>&errout  &&
+  ( print Output8; print Error8 >& 2 ) &>>errout  &&
+  ( print Output9; print Error9 >& 2 ) >>&|errout  &&
+  ( print Output10; print Error10 >& 2 ) &>>|errout  &&
+  ( print Output11; print Error11 >& 2 ) >>&!errout  &&
+  ( print Output12; print Error12 >& 2 ) &>>!errout  &&  cat errout
+0:'>&|', '>&!', '&>|', '&>!' redirection
+>Output3
+>Error3
+>Output4
+>Error4
+>Output5
+>Error5
+>Output6
+>Error6
+>Output7
+>Error7
+>Output8
+>Error8
+>Output9
+>Error9
+>Output10
+>Error10
+>Output11
+>Error11
+>Output12
+>Error12
+
+  rm -f errout
+  ( print Output; print Error 1>&2 ) 1>errout 2>&1  && cat errout
+0:'Combining > with >& (1)'
+>Output
+>Error
+
+  rm -f errout
+  ( print Output; print Error 1>&2 ) 2>&1 1>errout   &&  print errout:  &&
+  cat errout
+0:'Combining > with >& (2)'
+>Error
+>errout:
+>Output
+
+# Following two tests have to be separated since in
+#   print bar >foo >bar && print "$(<foo) $(<bar)"
+# the multios aren't flushed until after the substitutions take
+# place.  This can't be right.
+  rm -f errout
+  print doo be doo be doo >foo >bar 
+0:setup 2-file multio
+
+  print "foo: $(<foo)\nbar: $(<bar)"
+0:read 2-file multio
+>foo: doo be doo be doo
+>bar: doo be doo be doo
+
+  rm -f foo bar
+  print dont be dont be dont >foo | sed 's/dont/wont/g' >bar
+0:setup file+pipe multio
+
+  print "foo: $(<foo)\nbar: $(<bar)"
+0:read file+pipe multio
+>foo: dont be dont be dont
+>bar: wont be wont be wont
+
+  rm -f *
+  touch out1 out2
+  print All files >*
+0:setup multio with globbing
+
+  print *
+  print "out1: $(<out1)\nout2: $(<out2)"
+0:read multio with globbing
+>out1 out2
+>out1: All files
+>out2: All files
+
+  print This is out1 >out1
+  print This is out2 >out2
+0:setup multio for input
+
+# Currently, <out{1,2} doesn't work: this is a bug.
+  cat <out*
+0:read multio input
+>This is out1
+>This is out2
+
+  cat out1 | sed s/out/bout/ <out2
+0:read multio input with pipe
+>This is bout1
+>This is bout2
+
+  unset NULLCMD
+  >out1
+1:null redir with NULLCMD unset
+?ZTST_execchunk:2: redirection with no command
+
+  READNULLCMD=cat
+  print cat input >out1
+  <out1
+1:READNULLCMD with NULLCMD unset
+?ZTST_execchunk:2: redirection with no command
+
+  NULLCMD=:
+  >out1
+  [[ ! -s out1 ]] || print out1 is not empty
+0:null redir with NULLCMD=:
+<input
+
+  print cat input >out1
+  <out1
+0:READNULLCMD
+>cat input
+
+  NULLCMD=cat
+  >out1
+  cat out1
+0:null redir with NULLCMD=cat
+<input
+>input
Index: Test/05command.ztst
===================================================================
RCS file: 05command.ztst
diff -N 05command.ztst
--- /dev/null	Tue May  5 21:32:27 1998
+++ 05command.ztst	Tue Dec 21 20:54:47 1999
@@ -0,0 +1,157 @@
+%prep
+
+  storepath=($path)
+
+  mkdir command.tmp command.tmp/dir1 command.tmp/dir2
+
+  cd command.tmp
+
+  print '#!/bin/sh\necho This is top' >tstcmd
+  print '#!/bin/sh\necho This is dir1' >dir1/tstcmd
+  print '#!/bin/sh\necho This is dir2' >dir2/tstcmd
+
+  chmod 755 tstcmd dir1/tstcmd dir2/tstcmd
+
+%test
+  ./tstcmd
+0:./prog execution
+>This is top
+
+  path=($ZTST_testdir/command.tmp/dir1
+        $ZTST_testdir/command.tmp/dir2
+        .)
+  tstcmd
+  path=($storepath)
+0:path (1)
+>This is dir1
+
+  path=(. command.tmp/dir{1,2})
+  tstcmd
+  path=($storepath)
+0:path (2)
+>This is top
+
+  functst() { print $# arguments:; print -l $*; }
+  functst "Eines Morgens" "als Gregor Samsa"
+  functst ""
+  functst "aus unrühigen Träumen erwachte"
+  foo="fand er sich in seinem Bett"
+  bar=
+  rod="zu einem ungeheuren Ungeziefer verwandelt."
+  functst $foo $bar $rod
+# set up alias for next test
+  alias foo='print This is alias one'
+0:function argument passing
+>2 arguments:
+>Eines Morgens
+>als Gregor Samsa
+>1 arguments:
+>
+>1 arguments:
+>aus unrühigen Träumen erwachte
+>2 arguments:
+>fand er sich in seinem Bett
+>zu einem ungeheuren Ungeziefer verwandelt.
+
+  alias foo='print This is alias two'
+  fn() { foo; }
+  fn
+0:Aliases in functions
+>This is alias one
+
+  foo='Global foo'
+  traptst() { local foo="Local foo"; trap 'print $foo' EXIT; }
+  traptst
+0:EXIT trap environment
+>Global foo
+
+  functst() { return 0; print Ha ha; return 1; }
+  functst
+0:return (1)
+
+  functst() { return 1; print Ho ho; return 0; }
+  functst
+1:return (2)
+
+  unfunction functst
+  fpath=(.)
+  print "print This is functst." >functst
+  autoload functst
+  functst
+0:autoloading (1)
+>This is functst.
+
+  unfunction functst
+  print "functst() { print This, too, is functst; }; print Hello." >functst
+  typeset -fu functst
+  functst
+  functst
+0:autoloading with initialization
+>Hello.
+>This, too, is functst
+
+  unfunction functst
+  print "print Yet another version" >functst
+  functst() { autoload -X; }
+  functst
+0:autoloading via -X
+>Yet another version
+
+  chpwd() { print Changed to $PWD; }
+  cd .
+  unfunction chpwd
+0q:chpwd
+>Changed to $ZTST_testdir/command.tmp
+
+# Hard to test periodic, precmd and preexec non-interactively.
+
+  fn() { TRAPEXIT() { print Exit; }; }
+  fn
+0:TRAPEXIT
+>Exit
+
+  unfunction fn
+  print 'TRAPDEBUG() {
+      print Line $LINENO
+    }
+    :
+    unfunction TRAPDEBUG
+  }' > fn
+  autoload fn
+  fn
+  rm fn
+0:TRAPDEBUG
+>Line 1
+>Line 1
+
+  unfunction fn
+  print 'trap '\''print Line $LINENO'\'' DEBUG
+    :
+    trap - DEBUG
+  }' > fn
+  autoload fn
+  fn
+  rm fn
+0:trap DEBUG
+>Line 1
+>Line 2
+
+  TRAPZERR() { print Command failed; }
+  true
+  false
+  true
+  false
+  unfunction TRAPZERR
+0:TRAPZERR
+>Command failed
+>Command failed
+
+  trap 'print Command failed again.' ZERR
+  true
+  false
+  true
+  false
+  trap - ZERR
+0:trap ZERR
+>Command failed again.
+>Command failed again.
Index: Test/06arith.ztst
===================================================================
RCS file: 06arith.ztst
diff -N 06arith.ztst
--- /dev/null	Tue May  5 21:32:27 1998
+++ 06arith.ztst	Tue Dec 21 21:42:10 1999
@@ -0,0 +1,84 @@
+# Tests corresponding to the texinfo node `Arithmetic Evaluation'
+
+%test
+
+  integer light there
+  (( light = 42 )) &&
+  let 'there = light' &&
+  print $(( there ))
+0:basic integer arithmetic
+>42
+
+  float light there
+  integer rnd
+  (( light = 3.1415 )) &&
+  let 'there = light' &&
+  print -- $(( rnd = there * 10000 ))
+# save rounding problems by converting to integer
+0:basic floating point arithmetic
+>31415
+
+  print $(( 0x10 + 0X01 + 2#1010 ))
+0:base input
+>27
+
+  float light
+  (( light = 4 ))
+  print $light
+  typeset -F light
+  print $light
+0:conversion to float
+>4.000000000e+00
+>4.0000000000
+
+  integer i
+  (( i = 32.5 ))
+  print $i
+0:conversion to int
+>32
+
+  integer i
+  (( i = 4 - - 3 * 7 << 1 & 7 ^ 1 | 16 ** 2 ))
+  print $i
+0:precedence (arithmetic)
+>1591
+
+  print $(( 1 < 2 || 2 < 2 && 3 > 4 ))
+0:precedence (logical)
+>1
+
+  print $(( 1 + 4 ? 3 + 2 ? 4 + 3 ? 5 + 6 ? 4 * 8 : 0 : 0 : 0 : 0 ))
+0:precedence (ternary)
+>32
+
+  print $(( 3 ? 2 ))
+1:parsing ternary (1)
+?ZTST_execchunk:2: ':' expected
+
+  print $(( 3 ? 2 : 1 : 4 ))
+1:parsing ternary (2)
+?ZTST_execchunk:2: ':' without '?'
+
+  print $(( 0, 4 ? 3 : 1, 5 ))
+0:comma operator
+>5
+
+  foo=000
+  print $(( ##A + ##\C-a + #foo + $#foo ))
+0:#, ## and $#
+>117
+
+  integer i
+  (( i = 3 + 5 * 1.75 ))
+  print $i
+0:promotion to float
+>11
+
+  typeset x      &&
+  (( x = 3.5 ))  &&
+  print $x       &&
+  (( x = 4 ))    &&
+  print $x
+0:use of scalars to store integers and floats
+>3.5
+>4
Index: Test/07cond.ztst
===================================================================
RCS file: 07cond.ztst
diff -N 07cond.ztst
--- /dev/null	Tue May  5 21:32:27 1998
+++ 07cond.ztst	Tue Dec 21 22:21:17 1999
@@ -0,0 +1,135 @@
+# Tests corresponding to the texinfo node `Conditional Expressions'
+
+%prep
+
+  umask 077
+
+  mkdir cond.tmp
+
+  cd cond.tmp
+
+  touch	unmodified
+
+  touch zerolength
+  print 'Garbuglio' >nonzerolength
+
+  touch modish
+  chmod g+s modish
+  chmod u+s modish
+  chmod +t modish
+
+  touch unmodish
+  chmod 000 unmodish
+%test
+
+  [[ -a zerolength && ! -a nonexistent ]]
+0:-a cond
+
+  # Find a block special file system.  This is a little tricky.
+  block=$(df / | tail -1 | awk '{ print $1 }') &&
+  [[ -b $block && ! -b zerolength ]]
+0:-b cond
+
+  char=(/dev/tty*([1]))
+  [[ -c $char && ! -c $block ]]
+0:-c cond
+
+  [[ -d . && ! -d zerolength ]]
+0:-d cond
+
+  [[ -e zerolength && ! -e nonexistent ]]
+0:-e cond
+
+  [[ -f zerolength && ! -f cond && ! -f $char && ! -f $block && ! -f . ]]
+0:-f cond
+
+  [[ -g modish && ! -g zerolength ]]
+0:-g cond
+
+  ln -s zerolength link
+  [[ -h link && ! -h zerolength ]]
+0:-h cond
+
+  [[ -k modish && ! -k zerolength ]]
+0:-k cond
+
+  foo=foo
+  bar=
+  [[ -n $foo && ! -n $bar && ! -n '' ]]
+0:-n cond
+
+  [[ -o rcs && ! -o norcs && -o noerrexit && ! -o errexit ]]
+0:-o cond
+
+  mknod pipe p
+  [[ -p pipe && ! -p zerolength ]]
+0:-p cond
+
+  [[ -r zerolength && ! -r unmodish ]]
+0:-r cond
+
+  [[ -s nonzerolength && ! -s zerolength ]]
+0:-s cond
+
+# no simple way of guaranteeing test for -t
+
+  [[ -u modish && ! -u zerolength ]]
+0:-u cond
+
+  [[ -x $ZTST_testdir/ztst.zsh && ! -x zerolength ]]
+0:-x cond
+
+  [[ -z $bar && -z '' && ! -z $foo ]]
+0:-z cond
+
+  [[ -L link && ! -L zerolength ]]
+0:-L cond
+
+# hard to guarantee a file not owned by current uid
+  [[ -O zerolength ]]
+0:-O cond
+
+# there may be strange cases where this doesn't work, e.g.
+# inherited funny groups for directories via setgid.
+  [[ -G zerolength ]]
+0:-G cond
+
+# can't be bothered with -S
+
+  cat unmodified
+  touch newnewnew
+  [[ -N newnewnew && ! -N unmodified ]]
+0:-N cond
+
+  [[ newnewnew -nt zerolength && ! (unmodified -nt zerolength) ]]
+0:-nt cond
+
+  [[ zerolength -ot newnewnew && ! (zerolength -ot unmodified) ]]
+0:-ot cond
+
+  [[ link -ef zerolength && ! (link -ef nonzerolength) ]]
+0:-ef cond
+
+  [[ foo = foo && foo != bar && foo == foo && foo != '' ]]
+0:=, == and != conds
+
+  [[ bar < foo && foo > bar ]]
+0:< and > conds
+
+  [[ $(( 3 + 4 )) -eq 0x07 && $(( 5 * 2 )) -ne 0x10 ]]
+0:-eq and -ne conds
+
+  [[ 3 -lt 04 && 05 -gt 2 ]]
+0:-lt and -gt conds
+
+  [[ 3 -le 3 && ! (4 -le 3) ]]
+0:-le cond
+
+  [[ 3 -ge 3 && ! (3 -ge 4) ]]
+0:-ge cond
+
+  [[ 1 -lt 2 || 2 -lt 2 && 3 -gt 4 ]]
+0:|| and && in conds
+
+  [[ -e /dev/fd/0 ]]
+0:/dev/fd support in conds
Index: Test/ztst.zsh
===================================================================
RCS file: /home/pws/CVSROOT/projects/zsh/Test/ztst.zsh,v
retrieving revision 1.4
diff -u -r1.4 ztst.zsh
--- Test/ztst.zsh	1999/12/21 15:18:28	1.4
+++ Test/ztst.zsh	1999/12/21 17:14:15
@@ -69,11 +69,11 @@
 # Report failure.  Note that all output regarding the tests goes to stdout.
 # That saves an unpleasant mixture of stdout and stderr to sort out.
 ZTST_testfailed() {
-  print "Test $ZTST_testname failed: $1"
+  print -r "Test $ZTST_testname failed: $1"
   if [[ -n $ZTST_message ]]; then
-    print "Was testing: $ZTST_message"
+    print -r "Was testing: $ZTST_message"
   fi
-  print "$ZTST_testname: test failed."
+  print -r "$ZTST_testname: test failed."
   ZTST_cleanup
   exit 1
 }

-- 
Peter Stephenson <pws@pwstephenson.fsnet.co.uk>

