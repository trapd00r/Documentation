From zsh-users-return-14129-mason-zsh=primenet.com.au@sunsite.dk Mon May 18 00:41:27 2009
Return-Path: <zsh-users-return-14129-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21656 invoked from network); 18 May 2009 00:41:23 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from new-brage.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.254.104)
  by ns1.primenet.com.au with SMTP; 18 May 2009 00:41:23 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 64334 invoked from network); 18 May 2009 00:41:10 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 18 May 2009 00:41:10 -0000
Received: (qmail 18362 invoked by alias); 18 May 2009 00:40:50 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 14129
Received: (qmail 18351 invoked from network); 18 May 2009 00:40:50 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 18 May 2009 00:40:50 -0000
Received: from prunille.vinc17.org (vinc17.pck.nerim.net [213.41.242.187])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 374A4801E289
	for <zsh-users@sunsite.dk>; Mon, 18 May 2009 02:40:45 +0200 (CEST)
Received: by prunille.vinc17.org (Postfix, from userid 501)
	id DCA1937E172D; Mon, 18 May 2009 02:40:44 +0200 (CEST)
Date: Mon, 18 May 2009 02:40:44 +0200
From: Vincent Lefevre <vincent@vinc17.org>
To: zsh-users@sunsite.dk
Subject: Re: coloring stderr - was Re: piping stderr
Message-ID: <20090518004044.GI27141@prunille.vinc17.org>
Mail-Followup-To: zsh-users@sunsite.dk
References: <20090514104908.98556.qmail@smasher.org>
 <691a5d910905140904p538d5343md0712590db983853@mail.gmail.com>
 <20090515114736.33891.qmail@smasher.org>
 <4A0DD7D7.40500@skepticism.us>
 <20090516002553.91142.qmail@smasher.org>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="ew6BAiZeqk4r7MaW"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <20090516002553.91142.qmail@smasher.org>
X-Mailer-Info: http://www.vinc17.org/mutt/
User-Agent: Mutt/1.5.19-5808-vl-r28634 (2009-05-15)
X-Virus-Scanned: ClamAV 0.94.2/9365/Sat May 16 14:41:29 2009 on bifrost
X-Virus-Status: Clean


--ew6BAiZeqk4r7MaW
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

On 2009-05-16 12:25:50 +1200, Atom Smasher wrote:
> this has me thinking about an old problem... coloring stderr. the two 
> problems i've found previously are (1) keeping stdout and stderr in sync, 
> and (2) stderr that doesn't end with a newline, such as messages from "rm 
> -i".
> 
> this [below] fixes the second problem,

I also solved the second problem a few years ago (see my solution in C,
attached). But I've checked again... the first problem is not solved by
my solution:

$ echo L1; echo L2 >&2; echo L3; echo L4 >&2
L1
L3
L2
L4

Also I disabled stderr coloring because some programs do not use stderr
consistently and I had various problems with them (perhaps because of
lack of synchronization).

> but it's still got some unintended consequences... the problem i'm
> having now with it is that if i start bash as a child of zsh, bash
> is a bit messed up.

I can notice that the bash prompt doesn't appear, because bash has
not been started in interactive mode ('i' is not in "$-"). If I force
interactive mode, I get:

prunille:~> bash -i
zsh: suspended (tty input)  bash -i

-- 
Vincent Lefèvre <vincent@vinc17.org> - Web: <http://www.vinc17.org/>
100% accessible validated (X)HTML - Blog: <http://www.vinc17.org/blog/>
Work: CR INRIA - computer arithmetic / Arenaire project (LIP, ENS-Lyon)

--ew6BAiZeqk4r7MaW
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename="colorize.c"

/* $Id: colorize.c 29330 2009-05-18 00:27:09Z vinc17/prunille $
 *
 * Colorize the standard input. Written for zsh stderr coloring.
 *
 * Bug: stdout and stderr are not synchronized. For instance,
 *   $ echo L1; echo L2 >&2; echo L3; echo L4 >&2
 *   L1
 *   L3
 *   L2
 *   L4
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/select.h>
#include <sys/types.h>

#define BUFFSIZE 512

static volatile sig_atomic_t usr1;

static void sigusr1(int sig)
{
  usr1 = 1;
}

static void writepid(char *tmpfile)
{
  FILE *f;

  f = fopen(tmpfile, "w");
  if (f == NULL)
    {
      perror("colorize (fopen)");
      exit(EXIT_FAILURE);
    }
  fprintf(f, "%ld\n", (long) getpid());
  if (fclose(f) != 0)
    {
      perror("colorize (fclose)");
      exit(EXIT_FAILURE);
    }
}

int main(int argc, char **argv)
{
  pid_t zshpid = 0;
  char *begstr, *endstr;
  fd_set rfds;
  int ret;

  if (argc != 3 && argc != 5)
    {
      fprintf(stderr,
              "Usage: colorize <begstr> <endstr> [ <zshpid> <tmpfile> ]\n");
      exit(EXIT_FAILURE);
    }

  /* Assume that the arguments are correct. Anyway, it is not possible
     to check them entirely. */
  begstr = argv[1];
  endstr = argv[2];
  if (argc == 5)
    {
      /* To do the synchronization with the zsh prompt output...
         Seems to be useless in practice, hence the argc == 3 case. */
      zshpid = atol(argv[3]);
      signal(SIGUSR1, sigusr1);
      writepid(argv[4]);
    }

  fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);

  /* To watch stdin (fd 0). */
  FD_ZERO(&rfds);
  FD_SET(0, &rfds);

  for (;;)
    {
      ret = select(1, &rfds, NULL, NULL, NULL);

      if (ret < 0 && errno != EINTR)
        {
          perror("colorize (pselect)");
          exit(EXIT_FAILURE);
        }

      if (ret > 0)
        {
          static unsigned char buffer[BUFFSIZE];
          static int dontcol = 0;
          ssize_t n;

          while ((n = read(0, buffer, BUFFSIZE)) >= 0)
            {
              ssize_t i;

              if (n == 0)
                return 0;  /* stdin has been closed */
              for (i = 0; i < n; i++)
                {
                  if (buffer[i] == 27)
                    dontcol = 1;
                  if (buffer[i] == '\n')
                    dontcol = 0;
                  if (!dontcol)
                    fputs(begstr, stdout);
                  putchar(buffer[i]);
                  if (!dontcol)
                    fputs(endstr, stdout);
                }
            }
          fflush(stdout);
        }

      if (usr1)
        {
          usr1 = 0;
          if (kill(zshpid, SIGUSR1) != 0)
            {
              perror("colorize (kill)");
              exit(EXIT_FAILURE);
            }
        }
    }
}

--ew6BAiZeqk4r7MaW--

