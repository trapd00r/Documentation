From zsh-workers-return-5548-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Feb 26 15:39:24 1999
Return-Path: <zsh-workers-return-5548-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8899 invoked from network); 26 Feb 1999 15:39:23 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Feb 1999 15:39:23 -0000
Received: (qmail 11919 invoked by alias); 26 Feb 1999 15:39:03 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5548
Received: (qmail 11911 invoked from network); 26 Feb 1999 15:39:02 -0000
Date: Fri, 26 Feb 1999 16:38:19 +0100 (MET)
Message-Id: <199902261538.QAA32458@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: example completion for a2ps


Below is a bit of cleanup in `_path_files', making the `-F' option
work again.
Then there are some enhancements in `_comp_parts' (damn, why didn't I
name this `_parts', no other function starts with `_comp'). And
finally there is a (probably silly) example function using
`_comp_parts' -- a completion function for `a2ps' (GNU version 4.10.1).

With that you can do `a2ps --c=y<TAB>' to get `a2ps --compact=yes' and 
things like that.

The function could still do with a bit of work, though.

Bye
 Sven

diff -u Functions/Completion/_a2ps Functions/Completion/_a2ps
--- Functions/Completion/_a2ps	Fri Feb 26 16:28:54 1999
+++ Functions/Completion/_a2ps	Fri Feb 26 16:20:05 1999
@@ -0,0 +1,22 @@
+#defcomp a2ps
+
+if [[ -prefix -- ]]; then
+  _comp_parts '(--borders --compact --truncate-lines --interpret
+                --print-anyway --delegate)' '=' '(yes no)'
+  _comp_parts '(--major)' '=' '(rows columns)'
+  _comp_parts '(--end-of-line)' '=' '(r n nr rn any)'
+
+  complist -S= -k '(--medium --columns --rows --line-numbers
+                    --font-size --lines-per-page --chars-per-line
+ 		    --tabsize --non-printable-format --encoding
+		    --title --stdin --prologue --highlight-level
+		    --strip-level --output --version-control --suffix
+		    --printer --copies --sides --page-prefeed
+		    --no-page-prefeed)'
+  complist -qS= -k '(--margin --header --underlay --left-title
+                     --right-title --left-footer --footer --right-footer
+		     --pages --pretty-print)'
+  complist -k '(--landscape --portrait --catman --no-header)'
+else
+  _files -F fignore -g "*~*.ps"
+fi
diff -u of/Completion/_comp_parts Functions/Completion/_comp_parts
--- of/Completion/_comp_parts	Fri Feb 26 12:50:25 1999
+++ Functions/Completion/_comp_parts	Fri Feb 26 16:22:28 1999
@@ -13,17 +13,32 @@
 # `friends'. If the string on the line contains a `@', the substring
 # after it will be completed from the array `hosts'. Of course more
 # arrays may be given, each preceded by another separator string.
+#
+# This function understands the `-J group', `-V group', and
+# `-X explanation' options.
+#
 # This function does part of the matching itself and calls the functions
 # `_match_test' and `_match_pattern' for this.
 
 local str arr sep test testarr tmparr prefix suffixes matchers autosuffix
-local matchflags
+local matchflags opt group expl
 
-# I have a global matching specification with multiple sets and want
-# all this tried only once, you may want to change this line.
+# Test if we should use this function for the global matcher in use.
 
 _match_test _comp_parts || return
 
+# Get the options.
+
+group=()
+expl=()
+while getopts "J:V:X:" opt; do
+  case "$opt" in
+  [JV]) group=("-$opt" "$OPTARG");;
+  X)    expl=(-X "$OPTARG");;
+  esac
+done
+shift OPTIND-1
+
 # Get the string from the line.
 
 str="$PREFIX$SUFFIX"
@@ -72,11 +87,14 @@
 if [[ $# -le 1 || "$str" != *${2}* ]]; then
   # No more separators, build the matches.
   matchflags=""
+  test="$str"
   _match_pattern _comp_parts test matchflags
   test="${matchflags}${test}"
   testarr=( "${(@M)${(@P)arr}:#${~test}*}" )
 fi
 
+[[ $#testarr -eq 0 || ${#testarr[1]} -eq 0 ]] && return
+
 # Now we build the suffixes to give to the completion code.
 shift
 matchers=()
@@ -125,5 +143,5 @@
 
 # Add the matches for each of the suffixes.
 for i in "$suffixes[@]"; do
-  compadd "$matchers[@]" "$autosuffix[@]" -p "$prefix" -s "$i" - "$testarr[@]"
+  compadd "$group[@]" "$expl[@]" "$matchers[@]" "$autosuffix[@]" -p "$prefix" -s "$i" - "$testarr[@]"
 done
diff -u of/Completion/_path_files Functions/Completion/_path_files
--- of/Completion/_path_files	Fri Feb 26 16:31:37 1999
+++ Functions/Completion/_path_files	Fri Feb 26 16:31:45 1999
@@ -58,7 +58,7 @@
          else
            ignore=( ${(P)${tmp1}} )
          fi
-	 (( $#ignore )) && ignore=(-F "$ignore[@]")
+	 (( $#ignore )) && ignore=(-F "( $ignore )")
          ;;
   [JV])  group=("-$opt" "$OPTARG")
          ;;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

