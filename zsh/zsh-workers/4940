From zsh-workers-request@math.gatech.edu Thu Jan 21 09:45:42 1999
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19411 invoked from network); 21 Jan 1999 09:45:39 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 21 Jan 1999 09:45:39 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id EAA23741;
	Thu, 21 Jan 1999 04:43:48 -0500 (EST)
Resent-Date: Thu, 21 Jan 1999 04:43:48 -0500 (EST)
Date: Thu, 21 Jan 1999 10:42:39 +0100 (MET)
Message-Id: <199901210942.KAA18505@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
In-reply-to: "Bart Schaefer"'s message of Sun, 10 Jan 1999 18:38:28 -0800
Subject: Re: Latest patched development version
Resent-Message-ID: <"Q1Fp.0.uo5.KRlfs"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4940
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Bart Schaefer wrote:

> Is there any reason that -tc simply can't be implicit?  That is, why not
> always continue with the next suitable completion, leaving -t+ -t- and -tx
> to change what "next suitable" means?  And then perhaps throw in something
> like -tn to mean "no, DON'T continue."
> 
> Seems to me it's more often the case that you want to go on trying other
> possible completions rather than giving up.  The default should be what
> the most common case is.

(Even without getting more opinions on this I used some spare time to
build the patch below...)

After re-reading Bart's message I started to like the idea. So, the
patch below makes `-t' behave like Bart described above. The fact that 
the patch doesn't need to fiddle with zle_tricky.c shows that this
isn't that big a change in the concept of `-t'.
With this patch `-t' accepts only one character which says where to
continue to produce matches. Without any `-t' the next matching
compctl is used, since (as Bart already said) multiple matching
compctls weren't possible before (except for `-T') this shouldn't
introduce too much incompatibility. This also means that you don't
need `-tc' in `-T' or pattern compctls. On the other side, if you have 
a case where you don't want normal completion to be used, you should
add a `-tn' (so it's only a slight shift in incompatibilities to a
hopefully less common case).
Especially those who use `compctl -Tx 's[~]' -k friend ...' or
something like that to avoid the normal user-name generation should
put `-tn' in there or otherwise this will become pretty useless.

Any comments?

Bye
 Sven

diff -c os/Zle/compctl.c Src/Zle/compctl.c
*** os/Zle/compctl.c	Thu Jan 21 09:12:18 1999
--- Src/Zle/compctl.c	Thu Jan 21 10:12:04 1999
***************
*** 400,405 ****
--- 400,406 ----
      }
  
      memset((void *)&cct, 0, sizeof(cct));
+     cct.mask2 = CC_CCCONT;
  
      /* Loop through the flags until we have no more:        *
       * those with arguments are not properly allocated yet, *
***************
*** 516,541 ****
  			p = *++argv;
  			*argv = "" - 1;
  		    }
! 		    while (*p) {
! 			switch (*p) {
! 			case '+':
! 			    cct.mask2 |= CC_XORCONT;
! 			    break;
! 			case 'c':
! 			    cct.mask2 |= CC_CCCONT;
! 			    break;
! 			case '-':
! 			    cct.mask2 |= CC_PATCONT;
! 			    break;
! 			case 'x':
! 			    cct.mask2 |= CC_DEFCONT;
! 			    break;
! 			default:
! 			    zwarnnam(name, "invalid retry specification character `%c'",
! 				     NULL, *p);
! 			    return 1;
! 			}
! 			p++;
  		    }
  		}
  		break;
--- 517,544 ----
  			p = *++argv;
  			*argv = "" - 1;
  		    }
! 		    switch (*p) {
! 		    case '+':
! 			cct.mask2 = CC_XORCONT;
! 			break;
! 		    case 'n':
! 			cct.mask2 = 0;
! 			break;
! 		    case '-':
! 			cct.mask2 = CC_PATCONT;
! 			break;
! 		    case 'x':
! 			cct.mask2 = CC_DEFCONT;
! 			break;
! 		    default:
! 			zwarnnam(name, "invalid retry specification character `%c'",
! 				 NULL, *p);
! 			return 1;
! 		    }
! 		    if (p[1]) {
! 			zwarnnam(name, "too many retry specification characters: `%s'",
! 				 p + 1, 0);
! 			return 1;
  		    }
  		}
  		break;
***************
*** 835,840 ****
--- 838,844 ----
  		cc->xor = (Compctl) zcalloc(sizeof(*cc));
  		cc = cc->xor;
  		memset((void *)&cct, 0, sizeof(cct));
+ 		cct.mask2 = CC_CCCONT;
  	    }
  	}
      }
***************
*** 1362,1378 ****
  	    t >>= 1;
  	}
      }
!     if (flags2 & (CC_XORCONT | CC_CCCONT | CC_PATCONT | CC_DEFCONT)) {
  	printf(" -t");
  	if (flags2 & CC_XORCONT)
  	    putchar('+');
- 	if (flags2 & CC_CCCONT)
- 	    putchar('c');
  	if (flags2 & CC_PATCONT)
  	    putchar('-');
  	if (flags2 & CC_DEFCONT)
  	    putchar('x');
!     }
      /* now flags with arguments */
      printif(cc->mstr, 'M');
      if (flags2 & CC_NOSORT)
--- 1366,1381 ----
  	    t >>= 1;
  	}
      }
!     if (flags2 & (CC_XORCONT | CC_PATCONT | CC_DEFCONT)) {
  	printf(" -t");
  	if (flags2 & CC_XORCONT)
  	    putchar('+');
  	if (flags2 & CC_PATCONT)
  	    putchar('-');
  	if (flags2 & CC_DEFCONT)
  	    putchar('x');
!     } else if (!(flags2 & CC_CCCONT))
! 	printf(" -tn");
      /* now flags with arguments */
      printif(cc->mstr, 'M');
      if (flags2 & CC_NOSORT)
diff -c od/Zsh/compctl.yo Doc/Zsh/compctl.yo
*** od/Zsh/compctl.yo	Thu Jan 21 09:29:30 1999
--- Doc/Zsh/compctl.yo	Thu Jan 21 10:25:57 1999
***************
*** 85,91 ****
  to the user database is too slow and/or it contains too many users (so
  that completion after `tt(~)' is too slow to be usable), you can use
  
! nofill(tt(compctl -Tx  'C[0,*/*]' -f - 's[~]' -k friends -S/))
  
  to complete the strings in the array tt(friends) after a `tt(~)'.
  The first argument is necessary so that this form of ~-completion is
--- 85,91 ----
  to the user database is too slow and/or it contains too many users (so
  that completion after `tt(~)' is too slow to be usable), you can use
  
! nofill(tt(compctl -Tx  'C[0,*/*]' -f - 's[~]' -k friends -S/ -tn))
  
  to complete the strings in the array tt(friends) after a `tt(~)'.
  The first argument is necessary so that this form of ~-completion is
***************
*** 432,447 ****
  with the same name and the matches in those groups will not be mixed.
  )
  item(tt(-t) var(continue))(
! The var(continue)-string contains a set of characters that specify if 
! and when completion should continue to produce matches where it normally
! would not do that. The character tt(c) means that completion continues
! with the next suitable compctl (i.e. if you don't specify this in a
! tt(compctl -T), compctls for commands are never used). The character
! tt(PLUS()) is used to continue with the matches for the next alternative
! completion (see below). The characters tt(-) and tt(x) may be used in
! sub-lists for extended completion (see below). They will make the completion
! code use the flag list after the next tt(-) (if the corresponding pattern
! matches) and the default flag list (those before the tt(-x)), respectively.
  )
  item(tt(-M) var(match-spec))(
  This defines additional matching control specifications that should be used
--- 432,449 ----
  with the same name and the matches in those groups will not be mixed.
  )
  item(tt(-t) var(continue))(
! The var(continue)-string contains a character that specifies which set 
! of completion flags should be used next. Normally those of the next
! matching compctl are used, i.e. pattern compctls and normal compctls
! after tt(-T) and after a pattern compctl. If var(continue) is the
! character tt(PLUS()) the flags for the next alternative completion
! (see below) are used. The characters tt(-) and tt(x) can be used in
! sub-lists for extended completion (see below). They will make the
! completion code use the flag list after the next tt(-) (if the
! corresponding pattern matches) and the default flag list (those before
! the tt(-x)), respectively. if var(continue) is the character tt(n) no
! other flag lists are used, i.e. the generation of matches stops
! immediately.
  )
  item(tt(-M) var(match-spec))(
  This defines additional matching control specifications that should be used

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

