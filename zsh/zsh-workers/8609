From zsh-workers-return-8609-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Nov 10 17:11:54 1999
Return-Path: <zsh-workers-return-8609-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21159 invoked from network); 10 Nov 1999 17:11:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 10 Nov 1999 17:11:53 -0000
Received: (qmail 19975 invoked by alias); 10 Nov 1999 17:11:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8609
Received: (qmail 19952 invoked from network); 10 Nov 1999 17:11:37 -0000
Date: Wed, 10 Nov 1999 12:11:35 -0500
From: Clint Adams <schizo@debian.org>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: math i18n
Message-ID: <19991110121135.A19502@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
User-Agent: Mutt/1.0pre4i

% export LC_ALL=pl_PL

% typeset -F a; ((a=1.1))
zsh: bad floating point constant

% ((a=1,1)) ; echo $a
1,0000000000

% LANG=C; ((a=1.1)) ; echo $a
1.1000000000

You can't make a floating point assignment if your locale's
decimal point is a comma.

The problem here is that strtod is using the locale yet zsh is
ignoring it.

This patch fixes the problem basically by allowing locale
to switch the meanings of '.' and ','.  Because I'm an
ignorant American, I have no idea what this breaks.

--- Src/math.c	1999/11/10 08:23:22	1.1.1.18
+++ Src/math.c	1999/11/10 17:03:30
@@ -184,9 +184,20 @@
 static int
 zzlex(void)
 {
+    char decimal = '.', thousands = ',';
     int cct = 0;
+#ifdef USE_LOCALE
+    struct lconv *lc;
+#endif
 
     yyval.type = MN_INTEGER;
+
+#ifdef USE_LOCALE
+    lc = localeconv();
+    decimal = *(lc->decimal_point);
+    thousands = *(lc->thousands_sep);
+#endif
+
     for (;; cct = 0)
 	switch (*ptr++) {
 	case '+':
@@ -324,7 +335,9 @@
 	case ':':
 	    return COLON;
 	case ',':
-	    return COMMA;
+	case '.':
+	    if (*(ptr-1) == thousands) return COMMA;
+	    else break;
 	case '\0':
 	    ptr--;
 	    return EOI;
@@ -349,15 +362,15 @@
 	    }
 	/* Fall through! */
 	default:
-	    if (idigit(*--ptr) || *ptr == '.') {
+	    if (idigit(*--ptr) || *ptr == decimal) {
 		char *nptr;
 		for (nptr = ptr; idigit(*nptr); nptr++);
 
-		if (*nptr == '.' || *nptr == 'e' || *nptr == 'E') {
+		if (*nptr == decimal || *nptr == 'e' || *nptr == 'E') {
 		    /* it's a float */
 		    yyval.type = MN_FLOAT;
 		    yyval.u.d = strtod(ptr, &nptr);
-		    if (ptr == nptr || *nptr == '.') {
+		    if (ptr == nptr || *nptr == decimal ) {
 			zerr("bad floating point constant", NULL, 0);
 			return EOI;
 		    }

