From zsh-workers-return-28308-mason-zsh=primenet.com.au@zsh.org Sat Oct 02 19:41:30 2010
Return-Path: <zsh-workers-return-28308-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11961 invoked by alias); 2 Oct 2010 19:41:30 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28308
Received: (qmail 21270 invoked from network); 2 Oct 2010 19:41:28 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <101002124116.ZM8699@torch.brasslantern.com>
Date: Sat, 02 Oct 2010 12:41:11 -0700
In-reply-to: <alpine.LNX.2.01.1009261643520.30023@hp>
Comments: In reply to "Benjamin R. Haskell" <zsh@benizi.com>
 "Re: (bug report) Starting zsh takes ~5 seconds with the latest commits after
 20th of September with big history file" (Sep 26,  9:26pm)
References: <20100926181231.GA4616@arch>
	<100926131528.ZM407@torch.brasslantern.com>
	<alpine.LNX.2.01.1009261643520.30023@hp>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-workers@zsh.org
Subject: PATCH Re: (bug report) Starting zsh takes ~5 seconds with the latest
 commits after 20th of September with big history file
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 26,  9:26pm, Benjamin R. Haskell wrote:
} Subject: Re: (bug report) Starting zsh takes ~5 seconds with the latest co
}
} On Sun, 26 Sep 2010, Bart Schaefer wrote:
} 
} > Probably the right thing to do is:
} >
} > (1) have an option for the new behavior (HIST_LEX_WORDS ?);
} >
} > (2) implicitly turn that option off on the way through shell exit, so
} >    history rewrites/comparisons use faster processing.
} 
} Personally, I don't think I'd ever turn on a HIST_LEX_WORDS option.
} 
} Starting to regret noticing the problem in the first place. :-\

I'm sure it's best that somebody did.

Here's a patch for part (2) of the suggestion above, I'll leave it to
someone else to add the option -- it should be pretty obvious where to
check for it.

Most of the diff is re-indentation.  This patch *follows* 28295 (plus
the unposted tweak that PWS committed).

Index: Src/hist.c
--- ../current/Src/hist.c	2010-09-26 13:05:43.000000000 -0700
+++ Src/hist.c	2010-10-02 12:33:08.000000000 -0700
@@ -2335,61 +2335,84 @@
 	    else
 		he->ftim = ftim;
 
-	    /*
-	     * Divide up the words.  Attempt to do this using the lexer.
-	     */
 	    nwordpos = 0;
 	    start = pt;
-	    wordlist = bufferwords(NULL, pt, NULL);
-	    he->nwords = countlinknodes(wordlist);
-	    if (2*he->nwords > nwords) {
-		nwords = 2*he->nwords;
-		words = (short *)realloc(words, nwords*sizeof(short));
-	    }
-	    while (firstnode(wordlist)) {
-		char *word = uremnode(wordlist, firstnode(wordlist));
-		
-		while (inblank(*pt))
-		    pt++;
-		if (!strpfx(word, pt)) {
-		    int bad = 0;
-		    /*
-		     * Oddity 1: newlines turn into semicolons.
-		     */
-		    if (!strcmp(word, ";"))
-			continue;
-		    /*
-		     * Oddity 2: !'s turn into |'s.
-		     */
-		    while (*pt) {
-			if (!*word) {
-			    bad = 1;
-			    break;
-			}
-			if (*pt == *word ||
-			    (*pt == '!' && *word == '|')) {
+
+	    if (readflags & HFILE_FAST) {
+		/*
+		 * Divide up the words.  We don't care how it lexes,
+		 * so just look for white-space.
+		 */
+		do {
+		    while (inblank(*pt))
+			pt++;
+		    if (*pt) {
+			if (nwordpos >= nwords)
+			    words = (short *) realloc(words,
+						      (nwords += 64)*sizeof(short));
+			words[nwordpos++] = pt - start;
+			while (*pt && !inblank(*pt))
 			    pt++;
-			    word++;
-			} else {
-			    bad = 1;
-			    break;
-			}
+			words[nwordpos++] = pt - start;
 		    }
-		    if (bad) {
+		} while (*pt);
+
+		he->nwords = nwordpos/2;
+	    } else {
+		/*
+		 * Divide up the words.  Attempt to do this using the lexer.
+		 */
+		wordlist = bufferwords(NULL, pt, NULL);
+		he->nwords = countlinknodes(wordlist);
+		if (2*he->nwords > nwords) {
+		    nwords = 2*he->nwords;
+		    words = (short *)realloc(words, nwords*sizeof(short));
+		}
+		while (firstnode(wordlist)) {
+		    char *word = uremnode(wordlist, firstnode(wordlist));
+		
+		    while (inblank(*pt))
+			pt++;
+		    if (!strpfx(word, pt)) {
+			int bad = 0;
+			/*
+			 * Oddity 1: newlines turn into semicolons.
+			 */
+			if (!strcmp(word, ";"))
+			    continue;
+			/*
+			 * Oddity 2: !'s turn into |'s.
+			 */
+			while (*pt) {
+			    if (!*word) {
+				bad = 1;
+				break;
+			    }
+			    if (*pt == *word ||
+				(*pt == '!' && *word == '|')) {
+				pt++;
+				word++;
+			    } else {
+				bad = 1;
+				break;
+			    }
+			}
+			if (bad) {
 #ifdef DEBUG
-			dputs(ERRMSG("bad wordsplit reading history: %s\nat: %s"
-				     "\nword: %s"),
-			      start, pt, word);
+			    dputs(ERRMSG("bad wordsplit reading history: %s"
+					 "\nat: %s\nword: %s"),
+				  start, pt, word);
 #endif
-			words[nwordpos++] = pt - start;
-			pt += strlen(pt);
-			words[nwordpos++] = pt - start;
-			break;
+			    words[nwordpos++] = pt - start;
+			    pt += strlen(pt);
+			    words[nwordpos++] = pt - start;
+			    break;
+			}
 		    }
+		    words[nwordpos++] = pt - start;
+		    pt += strlen(word);
+		    words[nwordpos++] = pt - start;
 		}
-		words[nwordpos++] = pt - start;
-		pt += strlen(word);
-		words[nwordpos++] = pt - start;
 	    }
 
 	    if (he->nwords) {

-- 

