From zsh-users-return-15387-mason-zsh=primenet.com.au@zsh.org Fri Sep 10 14:36:17 2010
Return-Path: <zsh-users-return-15387-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25912 invoked by alias); 10 Sep 2010 14:36:17 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15387
Received: (qmail 24191 invoked from network); 10 Sep 2010 14:36:13 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <100910073557.ZM21299@torch.brasslantern.com>
Date: Fri, 10 Sep 2010 07:35:57 -0700
In-reply-to: <20100910061319.GA73504@redoubt.spodhuis.org>
Comments: In reply to Phil Pennock <zsh-workers+phil.pennock@spodhuis.org>
   "Refering to overlaid variable from within a function" (Sep 10,  2:13am)
References: <20100910061319.GA73504@redoubt.spodhuis.org>
	<20100910094157.3f128d4d@pwslap01u.europe.root.pri>
In-reply-to: <20100910094157.3f128d4d@pwslap01u.europe.root.pri>
Comments: In reply to Peter Stephenson <Peter.Stephenson@csr.com>
 "Re: Refering to overlaid variable from within a function" (Sep 10,  9:41am)
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: zsh-users@zsh.org
Subject: Re: Refering to overlaid variable from within a function
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Sep 10,  2:13am, Phil Pennock wrote:
}
} Is there a way to refer to variables as they exist in the context of the
} caller of a function, so that you can use a name but not have to worry
} about the caller's names?

Yes, but it's sneaky.

    bar () {
        local a="this is bar's $1"
        print $a
        trap "$1+=\" and \"${(q-)a}" EXIT
    }
    foo () {
        local a="this is foo's a"
        print $a
        bar a
        print $a
    }

Now run "foo".

The EXIT trap runs in the context of the caller of the function which is
exiting.  The challenge, of course, is to construct a TRAPEXIT function
such that the local $a is expanded at the time the trap is defined but
the assignment doesn't occur until the trap runs, which may be trickier
for arrays or hashes than it is for strings.

This doesn't work in bash because exit traps don't run on function exit,
and don't go out of scope on function exit either.  I don't know whether
that scoping effect is likely to run afoul of some POSIX definition of
how traps work.  I don't have a genuine ksh to try.
 
On Sep 10,  9:41am, Peter Stephenson wrote:
}
} I don't think there is a clean way of doing this. The variable code
} is one of the parts that could do with a complete overhaul to make it
} maintainable but without breaking its current functionality, which is
} a bit like completely replacing the jam layer in a sponge cake with
} marmalade without breaking the cake.

Not to mention that the behavior of variable scoping is defined by the
shell language, and mucking with it could have all sorts of unforeseen
consequences.

