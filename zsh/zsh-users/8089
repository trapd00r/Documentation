From zsh-users-return-8089-mason-zsh=primenet.com.au@sunsite.dk Thu Oct 21 16:40:39 2004
Return-Path: <zsh-users-return-8089-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 26936 invoked from network); 21 Oct 2004 16:40:38 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 21 Oct 2004 16:40:38 -0000
Received: (qmail 69833 invoked from network); 21 Oct 2004 16:40:30 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 21 Oct 2004 16:40:30 -0000
Received: (qmail 22033 invoked by alias); 21 Oct 2004 16:40:22 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 8089
Received: (qmail 22019 invoked from network); 21 Oct 2004 16:40:21 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 21 Oct 2004 16:40:21 -0000
Received: (qmail 68879 invoked from network); 21 Oct 2004 16:40:21 -0000
Received: from moonbase.zanshin.com (64.84.47.139)
  by a.mx.sunsite.dk with SMTP; 21 Oct 2004 16:40:19 -0000
Received: from toltec.zanshin.com (toltec.zanshin.com [64.84.47.166])
	by moonbase.zanshin.com (8.13.1/8.13.1) with ESMTP id i9LGeEae007281;
	Thu, 21 Oct 2004 09:40:14 -0700
Date: Thu, 21 Oct 2004 09:40:14 -0700 (PDT)
From: Bart Schaefer <schaefer@brasslantern.com>
Reply-To: zsh-users@sunsite.dk
To: Nikolai Weibull <zsh-users-list@pcppopper.org>
cc: zsh-users@sunsite.dk
Subject: Re: Associative Arrays
In-Reply-To: <20041021123835.GF9224@puritan.pcp.ath.cx>
Message-ID: <Pine.LNX.4.61.0410210900110.14956@toltec.zanshin.com>
References: <20041020195348.GJ11322@puritan.pcp.ath.cx>
 <20041021110526.GE1740@frhdtmp102861.morse.corp.wan> <20041021123835.GF9224@puritan.pcp.ath.cx>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
X-Spam-Checker-Version: SpamAssassin 2.63 on a.mx.sunsite.dk
X-Spam-Level: 
X-Spam-Status: No, hits=0.0 required=6.0 tests=none autolearn=no version=2.63
X-Spam-Hits: 0.0

On Thu, 21 Oct 2004, Nikolai Weibull wrote:

> * Stephane Chazelas <Stephane.Chazelas@morse.com> [Oct 21, 2004 13:10]:
> > > I'm have a few questions regarding associative arrays.  What exactly 
> > > is the A flag for parameter expansion for?  I mean, how does one use 
> > > it, and how does one use the AA flag?
> >
> > : ${(AA)=a::=foo bar}
> 
> aha, OK.  How very useful.

Obviously one would be more likely to use it as ${(AA)=a:=foo bar} (note
only one colon) where it assigns only if the hash is empty.

> > > Is there any way to pass an associative array as ONE argument to a 
> > > function and easily deal with it as the same associative array in 
> > > the other function?

I note in passing that this is not just an issue with associative arrays. 
The shell language (not just zsh's language) in general lacks a way to 
truly pass by reference rather than by value.

> > > The easiest way seems to be the "pass-by-reference" technique, where 
> > > one simply passes the name of the array and then use the P flag to 
> > > deal with it.

That's one way.  Another way is simply to make use of dynamic scoping, so
that the called function treats the variable as global, and the calling
function restricts the scope when necessary.  Part of the function's API
then becomes the name of the variable that it expects to manipulate.

(This is one reason why ksh has "namerefs" so that you can explicitly 
alias two names to the same value, which is after all what happens 
implicitly in other languages when a call-by-reference parameter is 
passed.)

Or am I misreading the question?  Are you asking how to pass-by-value an
associative array?

> > You could use "${${(@qqkv)A}[*]}"
> >
> > So that in the function you can have
> >
> > typeset -A local_hash
> > local_hash=("${(Q@)${(z)1}}")
> 
> Aha, double quotation and then dequoting.  What a bitch...is this
> seriously the simplest/only ways to do it?

If you want to pass its entire value as a single positional parameter, 
that's pretty close to the only way.  However, you have the entire set
of positional parameters to play with.

Think like a Perl programmer, and imagine you're trying to pass a set of 
name-value pairs as @_.  You'd probably write something like

 sub blather {
   my $unnamed1 = shift;
   my $unnamed2 = shift;
   my %named = @_;
   if ($named{'winnie'} eq 'pooh') { print "Oh, stuff and bother\n"; }
 }

So in zsh that'd be

 function blather {
   local unnamed1=$1; shift
   local unnamed2=$2; shift
   local -A named; set -A named "$@"
   if [[ $named[winnie] = pooh ]]; then print "Oh, stuff and bother\n"; fi
 }

> I'd say that shell programming would be a lot simpler as a whole if this 
> was simpler.

Hey, it's only been a few years now that shells have had associative 
arrays AT ALL.  Imagine what shell programming was like in the old days.

