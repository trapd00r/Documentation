From zsh-users-return-5817-mason-zsh=primenet.com.au@sunsite.dk Fri Jan 24 10:43:37 2003
Return-Path: <zsh-users-return-5817-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7549 invoked from network); 24 Jan 2003 10:43:37 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 24 Jan 2003 10:43:37 -0000
Received: (qmail 26982 invoked by alias); 24 Jan 2003 10:43:06 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5817
Received: (qmail 26974 invoked from network); 24 Jan 2003 10:43:06 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 24 Jan 2003 10:43:06 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [192.35.17.14] by sunsite.dk (MessageWall 1.0.8) with SMTP; 24 Jan 2003 10:43:6 -0000
Received: from mail3.siemens.de (mail3.siemens.de [139.25.208.14])
	by david.siemens.de (8.11.6/8.11.6) with ESMTP id h0OAh8l29632;
	Fri, 24 Jan 2003 11:43:08 +0100 (MET)
Received: from MOWD019A.mow.siemens.ru ([163.242.196.119])
	by mail3.siemens.de (8.11.6/8.11.6) with ESMTP id h0OAh7q24738;
	Fri, 24 Jan 2003 11:43:07 +0100 (MET)
Received: by mowd019a.mow.siemens.ru with Internet Mail Service (5.5.2653.19)
	id <DRB8GJ3J>; Fri, 24 Jan 2003 13:43:55 +0300
Received: from mw2b210c (163.242.193.12 [163.242.193.12]) by MOWD019A.mow.siemens.ru with SMTP (Microsoft Exchange Internet Mail Service Version 5.5.2653.13)
	id DRB8GJ32; Fri, 24 Jan 2003 13:43:49 +0300
From: Borzenkov Andrey <Andrey.Borzenkov@siemens.com>
To: "'clemens fischer'" <ino-qc@spotteswoode.de.eu.org>, zsh-users@sunsite.dk
Subject: RE: bash convert:  new completion system skeleton?
Date: Fri, 24 Jan 2003 13:42:48 +0300
Message-ID: <6134254DE87BD411908B00A0C99B044F03A0B5FE@mowd019a.mow.siemens.ru>
MIME-Version: 1.0
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
X-Priority: 3 (Normal)
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook, Build 10.0.4510
In-Reply-To: <8yxj3oiq.fsf@ID-23066.news.dfncis.de>
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1106
Importance: Normal


> i have lots of bash completers for my daily needs that i can't live
> without.  but bash-style completers resemble zsh's old completion
> style, which is inferiour to zsh's new system.
>=20
> my completers have the following properties:  the program which's
> arguments have to be completed have some help or list function which
> i can use to enumerate the possible completions, then i just grep(1)
> out the likely candidates.
>=20

First, _arguments has direct support for some simple cases when a =
command is
using --help; look in Completion/Unix/Command/_configure for direct =
example.
In short, you describe patterns how to interpret command help output =
and
what functions to use to complete specific parameters.

This works for simple case but does not allow you to supply description =
text
for a particular argument.

Speaking in general, if you need just to complete a list of command
arguments, you simply call _arguments passing it array of arguments =
names.
There are many examples, look in _texinfo (at the end, case $state =
item) )
for a perverse example of using shell substitutions :)) or _cvs where =
it
completes available commands.

But preferred way (if you know command arguments in advance) is to use
_arguments together with table of command arguments and descriptions. =
Like


#compdef foo
_arguments \
  'foo-arg-1[Argument 1]' \
  'foo-arg-2[Argument that takes some
parameters]::_function_to_complete_parameters'

in the simplest case it is just=20

_arguments foo-arg-1 foo-arg-2

but then you won't ever get descriptions :)

> example:  there's an anti-spam system called qconfirm
> <URL:http://smarden.org/qconfirm/>, the bash completer for which is:
>=20

For you specific function, look at _cvs or _rpm completion, i.e. =
completion
of command with subcommands. In general this would be like something =
like
following (unverified), see _cvs for excellent example and technique =
how to
dynamically call subcommands.

=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D
#compdef qconfirm

_qconfirm_subcommand ()
{
   local which
   case $line[2] in
     ac*|b[ao]*|dr*)
		which=3Dpending
	;;
    re*|pe*)
 		which=3Dok
	;;
    *)
 		which=3Dok
	;;
  esac
  compadd "$@" -- $(qconfirm $opt_args list $which | sed ... | egrep =
...)
  # note that both sed and grep cam be replaced
  # with internal Zsh substitution. See _texinfo (near bottom) for
absolutely
  # braindamage example that really works :)
}

_qconfirm ()
{
  _arguments \
     '-arg1[It is arg1 that does useful thing]' \
     '-arg2[It is arg 2 that does even more useful thing]' \
     '::possible subcommands:(cmd1:"description 1" cmd2:"Description 2"
...)' \
     '*::completin subcommand:_qconfirm_subcommand'
}

_qconfirm "$@"

=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D

and call _qconfirm and put somewhere in your fpath. Note that =
_arguments
already extracts options so you need not worry about it and it will =
format
output according to your styles etc etc. In general, _arguments is what =
you
need for your own custom completion.

Of course, if subcommand may take flags you may need write completion =
for
each one separately etc Again look in _cvs for excellent example.

> {
> 	local i cur qopts qcmd
 	local -a COMPREPLY
> 	qopts=3D""
 	qcmd=3D${words[2]}
>         # collect possible options to hand over 1:1
> 	for (( i=3D1 ; i<=3DCOMP_CWORD ; i++ ))
> 	do
> 		cur=3D"${COMP_WORDS[$i]}"
> 		#echo $cur >&2
> 		case $cur in
> 		    -*)
> 			qopts=3D"$qopts $cur"
> 			;;
> 		    *)
> 			qcmd=3D${cur}
> 			break
> 			;;
> 		esac
> 	done
>         # select the database depending on the subcommand used
> 	case $qcmd in
> 	    ac*|b[ao]*|dr*)
> 		which=3Dpending
> 		;;
> 	    re*|pe*)
> 		which=3Dok
> 		;;
> 	    *)
> 		which=3Dok
> 		;;
> 	esac
>         # here's the meat:  list the relevant database and pick the
>         # right completion
> 	cur=3D${COMP_WORDS[COMP_CWORD]}
> 	COMPREPLY=3D( $(qconfirm $qopts list "${which}" |
> 		cut -d" " -s -f2 |
> 		egrep -i "${cur}" ))
> 	return 0
> }
> # tell the completion system which function is responsible for =
qconfirm
> complete -F _qconfirm qconfirm
>=20
> similiar code exists for gnu-make, autoconf's configure, openssl etc.

All of them are already included with zsh.

>=20
> could somebody please offer the skeleton of a completer for the new
> system, complete with which share/zsh/4.0.6/function/_<FUNC>s to
> call, how to name the zstyle and the contexts?
>=20
> i'm simply lost in all the files of the distribution, especially
> those _<helper> functions.  any pointers appreciated.  is there
> already a wiki for zsh specialists and users?
>

the only one known to me is at zsh site, it is a good start anyway.

=20
>   clemens

