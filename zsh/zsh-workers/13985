From zsh-workers-return-13985-mason-zsh=primenet.com.au@sunsite.dk Sat Apr 14 00:20:04 2001
Return-Path: <zsh-workers-return-13985-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 26538 invoked from network); 14 Apr 2001 00:20:03 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Apr 2001 00:20:03 -0000
Received: (qmail 6457 invoked by alias); 14 Apr 2001 00:20:02 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13985
Received: (qmail 6432 invoked from network); 14 Apr 2001 00:20:01 -0000
Date: Fri, 13 Apr 2001 19:42:55 -0400
From: Clint Adams <schizo@debian.org>
To: zsh-workers@sunsite.dk
Subject: PATCH: termcap special param
Message-ID: <20010413194255.A31289@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i

Is there a configure test we can use instead of the NCURSES_VERSION
check?

Index: Src/Modules/termcap.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/termcap.c,v
retrieving revision 1.4
diff -u -r1.4 termcap.c
--- Src/Modules/termcap.c	2001/04/13 16:29:28	1.4
+++ Src/Modules/termcap.c	2001/04/13 23:41:02
@@ -30,7 +30,13 @@
 #define USES_TERMCAP_H 1
 #include "termcap.mdh"
 #include "termcap.pro"
+#ifdef HAVE_TERM_H
+#include <term.h>
+#endif
 
+static char termcap_nam[] = "termcap";
+static Param termcap_pm;
+
 /* echotc: output a termcap */
 
 #ifdef HAVE_TGETENT
@@ -116,10 +122,213 @@
     BUILTIN("echotc", 0, bin_echotc, 1, -1, 0, NULL, NULL),
 };
 
+static int incleanup;
+
+/* Empty dummy function for special hash parameters. */
+
+/**/
+static void
+shempty(void)
+{
+}
+
+/* Create a simple special hash parameter. */
+
+/**/
+static Param
+createtchash()
+{
+    Param pm;
+    HashTable ht;
+
+    unsetparam(termcap_nam);
+
+    if (!(pm = createparam(termcap_nam, PM_SPECIAL|PM_HIDE|PM_HIDEVAL|
+			   PM_REMOVABLE|PM_HASHED)))
+	return NULL;
+
+    pm->level = pm->old ? locallevel : 0;
+    pm->gets.hfn = hashgetfn;
+    pm->sets.hfn = hashsetfn;
+    pm->unsetfn = stdunsetfn;
+    pm->u.hash = ht = newhashtable(7, termcap_nam, NULL);
+
+    ht->hash        = hasher;
+    ht->emptytable  = (TableFunc) shempty;
+    ht->filltable   = NULL;
+    ht->addnode     = (AddNodeFunc) shempty;
+    ht->getnode     = ht->getnode2 = gettermcap;
+    ht->removenode  = (RemoveNodeFunc) shempty;
+    ht->disablenode = NULL;
+    ht->enablenode  = NULL;
+    ht->freenode    = (FreeNodeFunc) shempty;
+    ht->printnode   = printparamnode;
+    ht->scantab     = scantermcap;
+
+    return (termcap_pm = pm);
+}
+
 /**/
+static HashNode
+gettermcap(HashTable ht, char *name)
+{
+    int len, num;
+    char *tcstr, buf[2048], *u;
+    Param pm = NULL;
+
+    /* This depends on the termcap stuff in init.c */
+    if (termflags & TERM_BAD)
+	return NULL;
+    if ((termflags & TERM_UNKNOWN) && (isset(INTERACTIVE) || !init_term()))
+	return NULL;
+
+    unmetafy(name, &len);
+
+    pm = (Param) zhalloc(sizeof(struct param));
+    pm->nam = dupstring(name);
+    pm->flags = PM_READONLY;
+    pm->sets.cfn = NULL;
+    pm->gets.cfn = strgetfn;
+    pm->unsetfn = NULL;
+    pm->ct = 0;
+    pm->env = NULL;
+    pm->ename = NULL;
+    pm->old = NULL;
+    pm->level = 0;
+    u = buf;
+
+    if ((num = tgetnum(name)) != -1) {
+	pm->u.val = num;
+	pm->flags |= PM_INTEGER;
+    }
+    /* will this break? */
+    else if ((num = tgetflag(name)) != -1) {
+	pm->u.str = num ? dupstring("yes") : dupstring("no");
+	pm->flags |= PM_SCALAR;
+    }
+    else if ((tcstr = (char *)tgetstr(name, &u)) != 0 && tcstr != (char *)-1)
+    {
+	pm->u.str = dupstring(tcstr);
+	pm->flags |= PM_SCALAR;
+    }
+    else
+    {
+	/* zwarn("no such capability: %s", name, 0); */
+	pm->u.str = dupstring("");
+	pm->flags |= PM_UNSET;
+    }
+    return (HashNode) pm;
+}
+
+/**/
+static void
+scantermcap(HashTable ht, ScanFunc func, int flags)
+{
+    Param pm = NULL;
+    int num;
+    char **capcode, *tcstr, buf[2048], *u;
+
+#ifndef HAVE_BOOLCODES
+    static char *boolcodes[] = {
+	"bw", "am", "ut", "cc", "xs", "YA", "YF", "YB", "xt", "xn", "eo",
+	"gn", "hc", "HC", "km", "YC", "hs", "hl", "in", "YG", "da", "db",
+	"mi", "ms", "nx", "xb", "NP", "ND", "NR", "os", "5i", "YD", "YE",
+	"es", "hz", "ul", "xo", NULL};
+#endif
+    
+#ifndef HAVE_NUMCODES
+    static char *numcodes[] = {
+	"co", "it", "lh", "lw", "li", "lm", "sg", "ma", "Co", "pa", "MW",
+	"NC", "Nl", "pb", "vt", "ws", "Yo", "Yp", "Ya", "BT", "Yc", "Yb",
+	"Yd", "Ye", "Yf", "Yg", "Yh", "Yi", "Yk", "Yj", "Yl", "Ym", "Yn",
+	NULL};
+#endif
+
+#ifndef HAVE_STRCODES
+    static char *strcodes[] = {
+	"ac", "bt", "bl", "cr", "ZA", "ZB", "ZC", "ZD", "cs", "rP", "ct",
+	"MC", "cl", "cb", "ce", "cd", "ch", "CC", "CW", "cm", "do", "ho",
+	"vi", "le", "CM", "ve", "nd", "ll", "up", "vs", "ZE", "dc", "dl",
+	"DI", "ds", "DK", "hd", "eA", "as", "SA", "mb", "md", "ti", "dm",
+	"mh", "ZF", "ZG", "im", "ZH", "ZI", "ZJ", "ZK", "ZL", "mp", "mr",
+	"mk", "ZM", "so", "ZN", "ZO", "us", "ZP", "SX", "ec", "ae", "RA",
+	"me", "te", "ed", "ZQ", "ei", "ZR", "ZS", "ZT", "ZU", "se", "ZV",
+	"ZW", "ue", "ZX", "RX", "PA", "fh", "vb", "ff", "fs", "WG", "HU",
+	"i1", "is", "i3", "if", "iP", "Ic", "Ip", "ic", "al", "ip", "K1",
+	"K3", "K2", "kb", "@1", "kB", "K4", "K5", "@2", "ka", "kC", "@3",
+	"@4", "@5", "@6", "kt", "kD", "kL", "kd", "kM", "@7", "@8", "kE",
+	"kS", "@9", "k0", "k1", "k;", "F1", "F2", "F3", "F4", "F5", "F6",
+	"F7", "F8", "F9", "k2", "FA", "FB", "FC", "FD", "FE", "FF", "FG",
+	"FH", "FI", "FJ", "k3", "FK", "FL", "FM", "FN", "FO", "FP", "FQ",
+	"FR", "FS", "FT", "k4", "FU", "FV", "FW", "FX", "FY", "FZ", "Fa",
+	"Fb", "Fc", "Fd", "k5", "Fe", "Ff", "Fg", "Fh", "Fi", "Fj", "Fk",
+	"Fl", "Fm", "Fn", "k6", "Fo", "Fp", "Fq", "Fr", "k7", "k8", "k9",
+	"@0", "%1", "kh", "kI", "kA", "kl", "kH", "%2", "%3", "%4", "%5",
+	"kN", "%6", "%7", "kP", "%8", "%9", "%0", "&1", "&2", "&3", "&4",
+	"&5", "kr", "&6", "&9", "&0", "*1", "*2", "*3", "*4", "*5", "*6",
+	"*7", "*8", "*9", "kF", "*0", "#1", "#2", "#3", "#4", "%a", "%b",
+	"%c", "%d", "%e", "%f", "kR", "%g", "%h", "%i", "%j", "!1", "!2",
+	"kT", "!3", "&7", "&8", "ku", "ke", "ks", "l0", "l1", "la", "l2",
+	"l3", "l4", "l5", "l6", "l7", "l8", "l9", "Lf", "LF", "LO", "mo",
+	"mm", "ZY", "ZZ", "Za", "Zb", "Zc", "Zd", "nw", "Ze", "oc", "op",
+	"pc", "DC", "DL", "DO", "Zf", "IC", "SF", "AL", "LE", "Zg", "RI",
+	"Zh", "SR", "UP", "Zi", "pk", "pl", "px", "pn", "ps", "pO", "pf",
+	"po", "PU", "QD", "RC", "rp", "RF", "r1", "r2", "r3", "rf", "rc",
+	"cv", "sc", "sf", "sr", "Zj", "sa", "Sb", "Zk", "Zl", "SC", "sp",
+	"Sf", "ML", "Zm", "MR", "Zn", "st", "Zo", "Zp", "wi", "Zq", "Zr",
+	"Zs", "Zt", "Zu", "Zv", "ta", "Zw", "ts", "TO", "uc", "hu", "u0",
+	"u1", "u2", "u3", "u4", "u5", "u6", "u7", "u8", "u9", "WA", "XF",
+	"XN", "Zx", "S8", "Yv", "Zz", "Xy", "Zy", "ci", "Yw", "Yx", "dv",
+	"S1", "Yy", "S2", "S4", "S3", "S5", "Gm", "Km", "Mi", "S6", "xl",
+	"RQ", "S7", "s0", "s1", "s2", "s3", "AB", "AF", "Yz", "ML", "YZ",
+	"MT", "Xh", "Xl", "Xo", "Xr", "Xt", "Xv", "sA", "sL", NULL};
+#endif
+
+    pm = (Param) zhalloc(sizeof(struct param));
+    pm->sets.cfn = NULL;
+    pm->gets.cfn = strgetfn;
+    pm->unsetfn = NULL;
+    pm->ct = 0;
+    pm->env = NULL;
+    pm->ename = NULL;
+    pm->old = NULL;
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    for (capcode = (char **)boolcodes; *capcode; capcode++) {
+	if ((num = tgetflag(*capcode)) != -1) {
+	    pm->u.str = num ? dupstring("yes") : dupstring("no");
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_INTEGER;
+    for (capcode = (char **)numcodes; *capcode; capcode++) {
+	if (((num = tgetnum(*capcode)) != -1) && (num != -2)) {
+	    pm->u.val = num;
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    u = buf;
+    for (capcode = (char **)strcodes; *capcode; capcode++) {
+	if ((tcstr = (char *)tgetstr(*capcode, &u)) != 0 &&
+	    tcstr != (char *)-1) {
+	    pm->u.str = dupstring(tcstr);
+	    pm->nam = dupstring(*capcode);
+	    func((HashNode) pm, flags);
+	}
+    }
+}
+
+/**/
 int
 setup_(Module m)
 {
+    incleanup = 0;
+
     return 0;
 }
 
@@ -127,6 +336,9 @@
 int
 boot_(Module m)
 {
+    if (!createtchash())
+            return 1;
+
     return !addbuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
 }
 
@@ -134,6 +346,16 @@
 int
 cleanup_(Module m)
 {
+    Param pm;
+
+    incleanup = 1;
+
+    if ((pm = (Param) paramtab->getnode(paramtab, termcap_nam)) &&
+	pm == termcap_pm) {
+	pm->flags &= ~PM_READONLY;
+	unsetparam_pm(pm, 0, 1);
+    }
+
     deletebuiltins(m->nam, bintab, sizeof(bintab)/sizeof(*bintab));
     return 0;
 }
Index: Src/Modules/termcap.mdd
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/termcap.mdd,v
retrieving revision 1.4
diff -u -r1.4 termcap.mdd
--- Src/Modules/termcap.mdd	2001/04/09 17:26:59	1.4
+++ Src/Modules/termcap.mdd	2001/04/13 23:41:02
@@ -13,5 +13,6 @@
 load=yes
 
 autobins="echotc"
+autoparams="termcap"
 
 objects="termcap.o"

