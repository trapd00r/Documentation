From zsh-workers-return-16862-mason-zsh=primenet.com.au@sunsite.dk Tue Mar 19 14:21:47 2002
Return-Path: <zsh-workers-return-16862-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24159 invoked from network); 19 Mar 2002 14:21:46 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 19 Mar 2002 14:21:46 -0000
Received: (qmail 18133 invoked by alias); 19 Mar 2002 14:21:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 16862
Received: (qmail 18120 invoked from network); 19 Mar 2002 14:21:36 -0000
X-VirusChecked: Checked
Date: Tue, 19 Mar 2002 14:21:06 +0000
From: Oliver Kiddle <okiddle@yahoo.co.uk>
To: zsh-workers@sunsite.dk
Subject: PATCH: print -f with -s/-z
Message-ID: <20020319142106.GA19527@logica.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.3.27i
Sender: Oliver Kiddle <kiddleo@logica.com>

This patch is basically the same as 16259 except that I've sorted
out those things which held me back from committing it before
(open_memstream prototype and use of gettempname()).

Oliver

Index: zshconfig.ac
===================================================================
RCS file: /cvsroot/zsh/zsh/zshconfig.ac,v
retrieving revision 1.25
diff -u -r1.25 zshconfig.ac
--- zshconfig.ac	19 Feb 2002 02:14:08 -0000	1.25
+++ zshconfig.ac	19 Mar 2002 14:12:35 -0000
@@ -951,7 +951,7 @@
 	       tgetent tigetflag tigetnum tigetstr setupterm \
 	       pcre_compile pcre_study pcre_exec \
 	       nl_langinfo \
-	       erand48)
+	       erand48 open_memstream)
 AC_FUNC_STRCOLL
 
 dnl  Check if tgetent accepts NULL (and will allocate its own termcap buffer)
Index: Src/builtin.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/builtin.c,v
retrieving revision 1.71
diff -u -r1.71 builtin.c
--- Src/builtin.c	4 Mar 2002 15:52:00 -0000	1.71
+++ Src/builtin.c	19 Mar 2002 14:12:35 -0000
@@ -27,6 +27,9 @@
  *
  */
 
+/* this is defined so we get the prototype for open_memstream */
+#define _GNU_SOURCE 1
+
 #include "zsh.mdh"
 #include "builtin.pro"
 
@@ -2909,10 +2912,11 @@
     int flen, width, prec, type, argc, n, narg;
     int nnl = 0, ret = 0, maxarg = 0;
     int flags[5], *len;
-    char *start, *endptr, *c, *d, *flag, spec[11], *fmt = NULL;
+    char *start, *endptr, *c, *d, *flag, *buf, *tmpf, spec[11], *fmt = NULL;
     char **first, *curarg, *flagch = "0+- #", save = '\0', nullstr = '\0';
-    zlong count;
+    size_t rcount, mcount, count = 0;
     FILE *fout = stdout;
+    Histent ent;
     
     mnumber mnumval;
     double doubleval;
@@ -2984,61 +2988,6 @@
 	}
     }
     
-    /* -o and -O -- sort the arguments */
-    if (ops['o']) {
-	if (fmt && !*args) return 0;
-	if (ops['i'])
-	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);
-	else
-	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
-    } else if (ops['O']) {
-	if (fmt && !*args) return 0;
-	if (ops['i'])
-	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);
-	else
-	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
-    }
-    /* after sorting arguments, recalculate lengths */
-    if(ops['o'] || ops['O'])
-	for(n = 0; n < argc; n++)
-	    len[n] = strlen(args[n]);
-
-    /* -z option -- push the arguments onto the editing buffer stack */
-    if (ops['z']) {
-	queue_signals();
-	zpushnode(bufstack, sepjoin(args, NULL, 0));
-	unqueue_signals();
-	return 0;
-    }
-    /* -s option -- add the arguments to the history list */
-    if (ops['s']) {
-	int nwords = 0, nlen, iwords;
-	char **pargs = args;
-	Histent ent;
-
-	queue_signals();
-	ent = prepnexthistent();
-	while (*pargs++)
-	    nwords++;
-	if ((ent->nwords = nwords)) {
-	    ent->words = (short *)zalloc(nwords*2*sizeof(short));
-	    nlen = iwords = 0;
-	    for (pargs = args; *pargs; pargs++) {
-		ent->words[iwords++] = nlen;
-		nlen += strlen(*pargs);
-		ent->words[iwords++] = nlen;
-		nlen++;
-	    }
-	} else
-	    ent->words = (short *)NULL;
-	ent->text = zjoin(args, ' ', 0);
-	ent->stim = ent->ftim = time(NULL);
-	ent->flags = 0;
-	addhistnode(histtab, ent->text, ent);
-	unqueue_signals();
-	return 0;
-    }
-
     /* -u and -p -- output to other than standard output */
     if (ops['u'] || ops['p']) {
 	int fd;
@@ -3061,6 +3010,25 @@
 	}
     }
 
+    /* -o and -O -- sort the arguments */
+    if (ops['o']) {
+	if (fmt && !*args) return 0;
+	if (ops['i'])
+	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);
+	else
+	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
+    } else if (ops['O']) {
+	if (fmt && !*args) return 0;
+	if (ops['i'])
+	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);
+	else
+	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
+    }
+    /* after sorting arguments, recalculate lengths */
+    if(ops['o'] || ops['O'])
+	for(n = 0; n < argc; n++)
+	    len[n] = strlen(args[n]);
+
     /* -c -- output in columns */
     if (ops['c']) {
 	int l, nc, nr, sc, n, t, i;
@@ -3099,6 +3067,41 @@
     
     /* normal output */
     if (!fmt) {
+	/* -z option -- push the arguments onto the editing buffer stack */
+	if (ops['z']) {
+	    queue_signals();
+	    zpushnode(bufstack, sepjoin(args, NULL, 0));
+	    unqueue_signals();
+	    return 0;
+	}
+	/* -s option -- add the arguments to the history list */
+	if (ops['s']) {
+	    int nwords = 0, nlen, iwords;
+	    char **pargs = args;
+
+	    queue_signals();
+	    ent = prepnexthistent();
+	    while (*pargs++)
+		nwords++;
+	    if ((ent->nwords = nwords)) {
+		ent->words = (short *)zalloc(nwords*2*sizeof(short));
+		nlen = iwords = 0;
+		for (pargs = args; *pargs; pargs++) {
+		    ent->words[iwords++] = nlen;
+		    nlen += strlen(*pargs);
+		    ent->words[iwords++] = nlen;
+		    nlen++;
+		}
+	    } else
+		ent->words = (short *)NULL;
+	    ent->text = zjoin(args, ' ', 0);
+	    ent->stim = ent->ftim = time(NULL);
+	    ent->flags = 0;
+	    addhistnode(histtab, ent->text, ent);
+	    unqueue_signals();
+	    return 0;
+	}
+
 	for (; *args; args++, len++) {
 	    fwrite(*args, *len, 1, fout);
 	    if (args[1])
@@ -3115,10 +3118,22 @@
 	return ret;
     }
     
+    if (ops['z'] || ops['s']) {
+#ifdef HAVE_OPEN_MEMSTREAM
+    	if ((fout = open_memstream(&buf, &mcount)) == NULL)
+	    zwarnnam(name, "open_memstream failed", NULL, 0);
+#else
+	tmpf = gettempname();
+    	if ((fout = fopen(tmpf, "w+")) == NULL)
+	    zwarnnam(name, "can't open temp file: %e", NULL, errno);
+	unlink(tmpf);
+#endif
+    } 
+    
     /* printf style output */
     *spec='%';
     do {
-    	count = 0;
+    	rcount = count;
     	if (maxarg) {
 	    first += maxarg;
 	    argc -= maxarg;
@@ -3287,7 +3302,7 @@
 		type=3;
 		break;
 	    case 'n':
-		if (curarg) setiparam(curarg, count);
+		if (curarg) setiparam(curarg, count - rcount);
 		break;
 	    default:
 	        if (*c) {
@@ -3363,6 +3378,31 @@
     	if (maxarg) args = first + maxarg;
 	/* if there are remaining args, reuse format string */
     } while (*args && args != first && !ops['r']);
+
+    if (ops['z'] || ops['s']) {
+#ifdef HAVE_OPEN_MEMSTREAM
+	putc(0, fout);
+	fflush(fout);
+	count = mcount;
+#else
+	rewind(fout);
+	buf = (char *)zalloc(count + 1);
+	fread(buf, count, 1, fout);
+	buf[count] = '\0';
+#endif
+	queue_signals();
+	if (ops['z']) {
+	    zpushnode(bufstack, buf);
+	} else {
+	    ent = prepnexthistent();
+	    ent->text = buf;
+	    ent->stim = ent->ftim = time(NULL);
+	    ent->flags = 0;
+	    ent->words = (short *)NULL;
+	    addhistnode(histtab, ent->text, ent);
+	}
+	unqueue_signals();
+    }
 
     /* Testing EBADF special-cases >&- redirections */
     if ((fout != stdout) ? (fclose(fout) != 0) :
-- 

This e-mail and any attachment is for authorised use by the intended recipient(s) only.  It may contain proprietary material, confidential information and/or be subject to legal privilege.  It should not be copied, disclosed to, retained or used by, any other party.  If you are not an intended recipient then please promptly delete this e-mail and any attachment and all copies and inform the sender.  Thank you.

