From zsh-workers-request@math.gatech.edu  Wed Nov  8 20:46:24 1995
Received: from math.gatech.edu (euclid.skiles.gatech.edu [130.207.146.50]) by werple.net.au (8.7/8.7.1) with SMTP id UAA28507 for <mason@werple.mira.net.au>; Wed, 8 Nov 1995 20:46:16 +1100 (EST)
Received: by math.gatech.edu (5.x/SMI-SVR4)
	id AA18375; Wed, 8 Nov 1995 04:21:55 -0500
Resent-Date: Wed, 8 Nov 1995 10:22:27 +0100 (MET)
Old-Return-Path: <pws@ifh.de>
From: pws@ifh.de (Peter William Stephenson)
Message-Id: <9511080922.AA18272@sgi.ifh.de>
Subject: better subshell patch
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Date: Wed, 8 Nov 1995 10:22:27 +0100 (MET)
X-Mailer: ELM [version 2.4 PL24]
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"cL5_22.0.-U4.oQ7em"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/562
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

At Richard's suggestion, here is an improved version of the subshell
patch.  It adds an extra flag to entersubsh() indicating if the
subshell is a fake... i.e. we are still in the parent shell but are
preparing to exec an external programme.  In that case, the subsh
variable is not set and there will be a real `exit' call after a final
shell function in the parent shell (only).

As I noted in the comments, a `fake' subshell is not the same as a
`fake' exec: even a `real' exec means that we are not really in a
subshell so that entersubsh() gets the fake flag.  In the case where
we were having problems yesterday, an internal shell command running
as the last part of a subshell, the subsh flag doesn't get set in the
subshell itself for this reason (and indeed no exec of any kind takes
place; execcmd() doesn't actually test whether the `fake exec' is
actually going to happen, i.e. if it is executing an external command,
which in this case it isn't --- if it had been the problem wouldn't
have arisen); however it has already been set when the command
substitution subshell was originally forked and that is what is being
relied on for the test for _exit.  (Alles klar??)

I've also deleted what appear to be a couple of bogus `subsh = 1'
statements just before calls to entersubsh() in hunks 8 and 9.  I can
see no reference to subsh between these statements and where it gets
set anyway in entersubsh().

*** Src/exec.c.subsh	Tue Nov  7 04:43:04 1995
--- Src/exec.c	Wed Nov  8 10:05:22 1995
***************
*** 734,740 ****
  		    }
  		    else {
  			close(synch[0]);
! 			entersubsh(Z_ASYNC, 0);
  			setpgrp(0L, mypgrp = jobtab[list_pipe_job].gleader);
  			close(synch[1]);
  			kill(getpid(), SIGSTOP);
--- 734,740 ----
  		    }
  		    else {
  			close(synch[0]);
! 			entersubsh(Z_ASYNC, 0, 0);
  			setpgrp(0L, mypgrp = jobtab[list_pipe_job].gleader);
  			close(synch[1]);
  			kill(getpid(), SIGSTOP);
***************
*** 816,822 ****
  	    } else {
  		close(pipes[0]);
  		close(synch[0]);
! 		entersubsh(how, 1);
  		close(synch[1]);
  		execcmd(pline->left, input, pipes[1], how, 0);
  		_exit(lastval);
--- 816,822 ----
  	    } else {
  		close(pipes[0]);
  		close(synch[0]);
! 		entersubsh(how, 1, 0);
  		close(synch[1]);
  		execcmd(pline->left, input, pipes[1], how, 0);
  		_exit(lastval);
***************
*** 1315,1321 ****
  
  	/* pid == 0 */
  	close(synch[0]);
! 	entersubsh(how, 1);
  	close(synch[1]);
  	forked = 1;
  	if (sigtrapped[SIGINT] == 2)
--- 1315,1321 ----
  
  	/* pid == 0 */
  	close(synch[0]);
! 	entersubsh(how, 1, 0);
  	close(synch[1]);
  	forked = 1;
  	if (sigtrapped[SIGINT] == 2)
***************
*** 1322,1329 ****
  	    holdintr();
  
      } else if ((cmd->flags & (CFLAG_EXEC|CFLAG_FAKE_EXEC)) && !nullexec) {
! 	/* this is an `exec' (real or fake) that contains a command */
! 	entersubsh(how, 1);
      } else {
  	/* Job is running in current shell. */
  	jobtab[thisjob].stat |= STAT_CURSH;
--- 1322,1332 ----
  	    holdintr();
  
      } else if ((cmd->flags & (CFLAG_EXEC|CFLAG_FAKE_EXEC)) && !nullexec) {
! 	/* this is an `exec' (real or fake) that contains a command:  *
! 	 * note that any form of exec means that the subshell is fake *
!          * (but we may be in a subshell already).                     *
! 	 */
! 	entersubsh(how, 1, 1);
      } else {
  	/* Job is running in current shell. */
  	jobtab[thisjob].stat |= STAT_CURSH;
***************
*** 1514,1520 ****
  		/* only save the history file on a real exec */
  		if ((cmd->flags & CFLAG_EXEC) && unset(NORCS) && interact)
  		    savehistfile(getsparam("HISTFILE"), 1, isset(APPENDHISTORY) ? 3 : 0);
! 		exit(lastval);
  	    }
  
  	    if (!forked && !assign)
--- 1517,1526 ----
  		/* only save the history file on a real exec */
  		if ((cmd->flags & CFLAG_EXEC) && unset(NORCS) && interact)
  		    savehistfile(getsparam("HISTFILE"), 1, isset(APPENDHISTORY) ? 3 : 0);
! 		if (subsh)
! 		    _exit(lastval);
! 		else
! 		    exit(lastval);
  	    }
  
  	    if (!forked && !assign)
***************
*** 1634,1640 ****
  
  /**/
  void
! entersubsh(int how, int cl)
  {
      if (sigtrapped[SIGEXIT])
  	unsettrap(SIGEXIT);
--- 1640,1646 ----
  
  /**/
  void
! entersubsh(int how, int cl, int fake)
  {
      if (sigtrapped[SIGEXIT])
  	unsettrap(SIGEXIT);
***************
*** 1675,1681 ****
  	} else
  	    setpgrp(0L, jobtab[thisjob].gleader);
      }
!     subsh = 1;
      if (SHTTY != -1) {
  	close(SHTTY);
  	SHTTY = -1;
--- 1681,1688 ----
  	} else
  	    setpgrp(0L, jobtab[thisjob].gleader);
      }
!     if (!fake)
! 	subsh = 1;
      if (SHTTY != -1) {
  	close(SHTTY);
  	SHTTY = -1;
***************
*** 1929,1938 ****
  	return NULL;
      }
      child_unblock();
-     subsh = 1;
      close(pipes[0]);
      redup(pipes[1], 1);
!     entersubsh(Z_SYNC, 1);
      signal_ignore(SIGTSTP);
      execlist(list, 1);
      close(1);
--- 1936,1944 ----
  	return NULL;
      }
      child_unblock();
      close(pipes[0]);
      redup(pipes[1], 1);
!     entersubsh(Z_SYNC, 1, 0);
      signal_ignore(SIGTSTP);
      execlist(list, 1);
      close(1);
***************
*** 2028,2036 ****
  	}
  	return nam;
      }
-     subsh = 1;
      close(1);
!     entersubsh(Z_SYNC, 1);
      signal_ignore(SIGTSTP);
      (void)creat(nam, 0600);
      execlist(list, 1);
--- 2034,2041 ----
  	}
  	return nam;
      }
      close(1);
!     entersubsh(Z_SYNC, 1, 0);
      signal_ignore(SIGTSTP);
      (void)creat(nam, 0600);
      execlist(list, 1);
***************
*** 2096,2102 ****
  	popheap();
  	return pnam;
      }
!     entersubsh(Z_ASYNC, 1);
      closem();
      fd = open(pnam, O_WRONLY);
      if (fd == -1) {
--- 2101,2107 ----
  	popheap();
  	return pnam;
      }
!     entersubsh(Z_ASYNC, 1, 0);
      closem();
      fd = open(pnam, O_WRONLY);
      if (fd == -1) {
***************
*** 2148,2154 ****
  	popheap();
  	return pnam;
      }
!     entersubsh(Z_ASYNC, 1);
      closem();
      fd = open(pnam, O_RDONLY);
      redup(fd, 0);
--- 2153,2159 ----
  	popheap();
  	return pnam;
      }
!     entersubsh(Z_ASYNC, 1, 0);
      closem();
      fd = open(pnam, O_RDONLY);
      redup(fd, 0);
***************
*** 2182,2188 ****
      }
      close(pipes[0]);
      closem();
!     entersubsh(Z_ASYNC, 1);
      redup(pipes[1], 1);
      execlist(list, 1);
      _exit(lastval);
--- 2187,2193 ----
      }
      close(pipes[0]);
      closem();
!     entersubsh(Z_ASYNC, 1, 0);
      redup(pipes[1], 1);
      execlist(list, 1);
      _exit(lastval);
***************
*** 2213,2219 ****
  	return pipes[1];
      }
      close(pipes[1]);
!     entersubsh(Z_ASYNC, 1);
      redup(pipes[0], 0);
      closem();
      execlist(list, 1);
--- 2218,2224 ----
  	return pipes[1];
      }
      close(pipes[1]);
!     entersubsh(Z_ASYNC, 1, 0);
      redup(pipes[0], 0);
      closem();
      execlist(list, 1);

-- 
Peter Stephenson <pws@ifh.de>       Tel: +49 33762 77366
WWW:  http://www.ifh.de/~pws/       Fax: +49 33762 77330
Deutches Electronen-Synchrotron --- Institut fuer Hochenergiephysik Zeuthen
DESY-IfH, 15735 Zeuthen, Germany.

