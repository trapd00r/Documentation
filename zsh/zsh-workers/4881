From zsh-workers-request@math.gatech.edu Tue Jan 05 16:00:20 1999
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8897 invoked from network); 5 Jan 1999 16:00:16 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 5 Jan 1999 16:00:16 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id KAA07627;
	Tue, 5 Jan 1999 10:45:12 -0500 (EST)
Resent-Date: Tue, 5 Jan 1999 10:45:12 -0500 (EST)
Date: Tue, 5 Jan 1999 16:43:53 +0100 (MET)
Message-Id: <199901051543.QAA28269@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
In-reply-to: Sven Wischnowsky's message of Fri, 18 Dec 1998 16:59:21 +0100
	(MET)
Subject: Re:  experimental new style completion
Resent-Message-ID: <"Ql9Ka3.0.6t1.8EZas"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4881
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Below is the first patch that goes on top of my patch for the
experimental new style completion stuff. Of course all this is only
interesting if you have installed that patch.

Things changed:

- The example file now uses a normal array for pattern completions
  (dunno why I used an associative array in the first place... we even 
  had discussed this, sigh).
- The compadd builtin has some new options (to really make everything
  available):
  - `-W <path>' sets the path to use for checking file types. I used
    `-W' since this is one of the things `-W' does for compctl and
    complist.
  - `-a' makes the given completions be stored in the alternative set
    of completions. This has *nothing* to do with xor'ed
    completion. In this case the `alternative set' is the one built
    internally for matches with fignore ignored.
  - `--' ends the list of options. Anything after that will be
    considered to be a match to add (of course, this is important to
    have if all matches you want to add start with a `-').
- When completing in subscripts on the left side of an parameter
  assignment the CONTEXT is now set to `subscr' (this is still a bit
  hackish)
- The file compctl.mdd now contains definitions for complist, compadd, 
  and the conditions.
- The patch also contains some fixes for things that were not yet
  working (namely `compadd -n').

Bye
 Sven

*** Src/Zle/compctl.c.old	Tue Jan  5 14:52:10 1999
--- Src/Zle/compctl.c	Tue Jan  5 15:25:35 1999
***************
*** 1699,1707 ****
  bin_compadd(char *name, char **argv, char *ops, int func)
  {
      char *p, **sp, *e;
!     char *ipre = NULL, *ppre = NULL, *psuf = NULL;
      char *pre = NULL, *suf = NULL, *group = NULL;
!     int f = 0, q = 0, m = 0, ns = 0;
  
      if (!incompfunc) {
  	zerrnam(name, "can only be called from completion function", NULL, 0);
--- 1699,1707 ----
  bin_compadd(char *name, char **argv, char *ops, int func)
  {
      char *p, **sp, *e;
!     char *ipre = NULL, *ppre = NULL, *psuf = NULL, *prpre = NULL;
      char *pre = NULL, *suf = NULL, *group = NULL;
!     int f = 0, q = 0, m = 0, ns = 0, a = 0;
  
      if (!incompfunc) {
  	zerrnam(name, "can only be called from completion function", NULL, 0);
***************
*** 1756,1761 ****
--- 1756,1771 ----
  		sp = &psuf;
  		e = "string expected after -%c";
  		break;
+ 	    case 'W':
+ 		sp = &prpre;
+ 		e = "string expected after -%c";
+ 		break;
+ 	    case 'a':
+ 		a = 1;
+ 		break;
+ 	    case '-':
+ 		argv++;
+ 		goto ca_args;
  	    default:
  		zerrnam(name, "bad option: -%c", NULL, *p);
  		return 1;
***************
*** 1778,1788 ****
  	    }
  	}
      }
      if (!*argv) {
  	zerrnam(name, "missing completions", NULL, 0);
  	return 1;
      }
!     addmatches(ipre, ppre, psuf, pre, suf, group, f, q, m, ns, argv);
      return 0;
  }
  
--- 1788,1800 ----
  	    }
  	}
      }
+  ca_args:
      if (!*argv) {
  	zerrnam(name, "missing completions", NULL, 0);
  	return 1;
      }
!     addmatches(ipre, ppre, psuf, prpre, pre, suf, group,
! 	       f, q, m, ns, a, argv);
      return 0;
  }
  
*** Src/Zle/compctl.mdd.old	Tue Jan  5 14:15:24 1999
--- Src/Zle/compctl.mdd	Tue Jan  5 16:26:44 1999
***************
*** 1,5 ****
  moddeps="comp1"
  
! autobins="compctl"
  
  objects="compctl.o"
--- 1,7 ----
  moddeps="comp1"
  
! autobins="compctl complist compadd"
! 
! autoprefixconds="prefix iprefix position word mword current mcurrent string class words between mbetween after mafter nmatches"
  
  objects="compctl.o"
*** Src/Zle/zle_tricky.c.old	Tue Jan  5 14:19:02 1999
--- Src/Zle/zle_tricky.c	Tue Jan  5 16:11:22 1999
***************
*** 2394,2405 ****
  
  /**/
  void
! addmatches(char *ipre, char *ppre, char *psuf, char *pre, char *suf, char *group,
! 	   int flags, int quote, int menu, int nosort, char **argv)
  {
!     char *s, *t, *prpre;
      int lpl, lsl, i;
!     Aminfo ai = ainfo;
      Cmatch cm;
  
      if (menu && isset(AUTOMENU))
--- 2394,2406 ----
  
  /**/
  void
! addmatches(char *ipre, char *ppre, char *psuf, char *prpre, char *pre,
! 	   char *suf, char *group,
! 	   int flags, int quote, int menu, int nosort, int alt, char **argv)
  {
!     char *s, *t;
      int lpl, lsl, i;
!     Aminfo ai = (alt ? fainfo : ainfo);
      Cmatch cm;
  
      if (menu && isset(AUTOMENU))
***************
*** 2422,2431 ****
  		pre = dupstring(pre);
  	    if (suf)
  		suf = dupstring(suf);
! 	    if ((prpre = ppre)) {
  		singsub(&prpre);
  		untokenize(prpre);
! 	    }
  	    if (group) {
  		endcmgroup(NULL);
  		begcmgroup(group, nosort);
--- 2423,2433 ----
  		pre = dupstring(pre);
  	    if (suf)
  		suf = dupstring(suf);
! 	    if (!prpre && (prpre = ppre)) {
  		singsub(&prpre);
  		untokenize(prpre);
! 	    } else
! 		prpre = dupstring(prpre);
  	    if (group) {
  		endcmgroup(NULL);
  		begcmgroup(group, nosort);
***************
*** 2493,2499 ****
  		cm->flags = flags;
  		cm->brpl = brpl;
  		cm->brsl = brsl;
! 		addlinknode(matches, cm);
  
  		if (expl)
  		    expl->fcount++;
--- 2495,2501 ----
  		cm->flags = flags;
  		cm->brpl = brpl;
  		cm->brsl = brsl;
! 		addlinknode((alt ? fmatches : matches), cm);
  
  		if (expl)
  		    expl->fcount++;
***************
*** 2682,2688 ****
      }
      if (!test)
  	return;
! 
      if (!ms && !ispattern && ai->firstm) {
  	if ((test = sl - pfxlen(ai->firstm->str, s)) < ai->prerest)
  	    ai->prerest = test;
--- 2684,2691 ----
      }
      if (!test)
  	return;
!     if (incompfunc)
! 	s = dupstring(s);
      if (!ms && !ispattern && ai->firstm) {
  	if ((test = sl - pfxlen(ai->firstm->str, s)) < ai->prerest)
  	    ai->prerest = test;
***************
*** 3235,3241 ****
  		zsfree(compcommand);
  		compcommand = "";
  		if (lincmd)
! 		    compcontext = "cmd";
  		else if (linredir)
  		    compcontext = "redir";
  		else
--- 3238,3244 ----
  		zsfree(compcommand);
  		compcommand = "";
  		if (lincmd)
! 		    compcontext = (insubscr ? "subscr" : "cmd");
  		else if (linredir)
  		    compcontext = "redir";
  		else
***************
*** 4842,4851 ****
  	    for (bp = ap; bp[1] && matcheq(*ap, bp[1]); bp++, n--);
  	    ap = bp;
  	    /* Mark those, that would show the same string in the list. */
! 	    for (; bp[1] && !strcmp((*ap)->str, (bp[1])->str); bp++) {
! 		(bp[1])->flags |= CMF_NOLIST; nl++;
! 	    }
  	}
  	*cp = NULL;
      }
      if (np)
--- 4845,4856 ----
  	    for (bp = ap; bp[1] && matcheq(*ap, bp[1]); bp++, n--);
  	    ap = bp;
  	    /* Mark those, that would show the same string in the list. */
! 	    for (; bp[1] && !strcmp((*ap)->str, (bp[1])->str); bp++)
! 		(bp[1])->flags |= CMF_NOLIST;
  	}
+ 	for (ap = rp; *ap; ap++)
+ 	    if ((*ap)->flags & CMF_NOLIST)
+ 		nl++;
  	*cp = NULL;
      }
      if (np)
***************
*** 5781,5787 ****
  		}
  		if (n) {
  		    putc('\n', shout);
! 		    p = skipnolist(p + 1);
  		}
  	    }
  	}
--- 5786,5793 ----
  		}
  		if (n) {
  		    putc('\n', shout);
! 		    if (n && nl)
! 			p = skipnolist(p + 1);
  		}
  	    }
  	}
*** Src/example.old	Tue Jan  5 13:32:32 1999
--- Src/example	Tue Jan  5 16:28:15 1999
***************
*** 10,16 ****
  
  # One associative array for normal completions and one for patterns.
  
! typeset -A comps patcomps
  
  
  # These may be used to define completion handlers.
--- 10,16 ----
  
  # One associative array for normal completions and one for patterns.
  
! typeset -A comps
  
  
  # These may be used to define completion handlers.
***************
*** 24,30 ****
  }
  
  defpatcomp() {
!   patcomps[$1]="$2"
  }
  
  
--- 24,34 ----
  }
  
  defpatcomp() {
!   if [[ ${+patcomps} == 1 ]] then
!     patcomps=("$patcomps[@]" "$1 $2" )
!   else
!     patcomps=( "$1 $2" )
!   fi
  }
  
  
***************
*** 68,74 ****
  
    # An entry for `--first--' is the replacement for `compctl -T'
    # The `|| return 1' is used throughout: if a function producing matches
!   # non-zero this is interpreted as `do not try to produce more matches'
    # (this is the replacement for `compctl -t').
  
    comp="$comps[--first--]"
--- 72,78 ----
  
    # An entry for `--first--' is the replacement for `compctl -T'
    # The `|| return 1' is used throughout: if a function producing matches
!   # returns non-zero this is interpreted as `do not try to produce more matches'
    # (this is the replacement for `compctl -t').
  
    comp="$comps[--first--]"
***************
*** 104,110 ****
  # arguments).
  
  do-complete() {
!   local comp cmd1 cmd2
  
    # Completing in command position? If not we set up `cmd1' and `cmd2' as
    # two strings we have search in the completion definition arrays (e.g.
--- 108,114 ----
  # arguments).
  
  do-complete() {
!   local comp cmd1 cmd2 pat val
  
    # Completing in command position? If not we set up `cmd1' and `cmd2' as
    # two strings we have search in the completion definition arrays (e.g.
***************
*** 127,135 ****
  
    # See if there are any matching pattern completions.
  
!   for pat in "${(k)patcomps[@]}"; do
      if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]] then
!       call-complete "$patcomps[$pat]" "$@" || return 1
      fi
    done
  
--- 131,141 ----
  
    # See if there are any matching pattern completions.
  
!   for i in "$patcomps[@]"; do
!     pat="${i% *}"
!     val="${i#* }"
      if [[ "$cmd1" == $~pat || "$cmd2" == $~pat ]] then
!       call-complete "$val" "$@" || return 1
      fi
    done
  
***************
*** 163,175 ****
    compsub
  }
  
! # Simple default and command completion defined with variables.
  
  defcomp --default-- __default
  __default=( -f )
  
  defcomp --command-- __command
  __command=( -c )
  
  # A simple pattern completion, just as an example.
  
--- 169,185 ----
    compsub
  }
  
! # Simple default, command, and math completion defined with variables.
  
  defcomp --default-- __default
  __default=( -f )
  
  defcomp --command-- __command
  __command=( -c )
+ 
+ defcomp --math-- __math
+ defcomp --subscr-- __math
+ __math=( -v )
  
  # A simple pattern completion, just as an example.
  

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

