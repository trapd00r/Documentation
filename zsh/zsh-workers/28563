From zsh-workers-return-28563-mason-zsh=primenet.com.au@zsh.org Fri Dec 31 20:42:07 2010
Return-Path: <zsh-workers-return-28563-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8711 invoked by alias); 31 Dec 2010 20:42:07 -0000
Mailing-List: contact zsh-workers-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Workers List <zsh-workers.zsh.org>
List-Post: <mailto:zsh-workers@zsh.org>
List-Help: <mailto:zsh-workers-help@zsh.org>
Delivered-To: mailing list zsh-workers@zsh.org
X-Seq: 28563
Received: (qmail 4383 invoked from network); 31 Dec 2010 20:41:54 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.7 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,RCVD_IN_DNSWL_LOW autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at _spf.google.com designates 209.85.212.43 as permitted sender)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:mime-version:received:received:in-reply-to
         :references:date:message-id:subject:from:to:content-type
         :content-transfer-encoding;
        bh=nrhzmWQpe0gfgrk9qcbydYAKmB9b7FYHyfFHFj1V4v8=;
        b=mnmiR7PirOfcmheF11gjAckVQMmFuaOw26R9r+bK/L0IGjWCS1z7/QyZdSmNuNZ23K
         IYvh1MKgOMmb+SRmBNr4OLCT1/Hr07oPe2Rg8Fkq3sPEpN85MDwf2bCMcfVigp8Wk35j
         ivfB1RCYgkdjZHnWO3yOraI7C920gQkyDXUaU=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=mime-version:in-reply-to:references:date:message-id:subject:from:to
         :content-type:content-transfer-encoding;
        b=j/yjnQikc2wh+yCVRm7Ubtanxcrv/K/YQYcvp0MjlFIK2Jf0Prw7b9GkavhBixAh1E
         7Y9ZuxbaGFnICN5bmAKEysuxq0n4oMmqUoguTJ2K8JVu8xGNcPiMaWf1hQ6Z5TXggwjI
         +kFnU21da6bXgwL5rrGIfDFpSFgDUUU0GJe70=
MIME-Version: 1.0
In-Reply-To: <101231122149.ZM8730@torch.brasslantern.com>
References: <997733.11083.qm@web65612.mail.ac4.yahoo.com>
	<AANLkTi=T73W8vi3PJDH8=AWeCq-YG=iK_42MeBmU2Z-F@mail.gmail.com>
	<AANLkTin8mo_VSXuaO1gijGJr0yDUoD0_AMFq4XoxM22w@mail.gmail.com>
	<101231122149.ZM8730@torch.brasslantern.com>
Date: Fri, 31 Dec 2010 21:33:42 +0100
Message-ID: <AANLkTikYqtUsza5guE4h+rRHTNMDepzquBkqvAFV2cka@mail.gmail.com>
Subject: Re: How to get syntax highlighting working??
From: Mikael Magnusson <mikachu@gmail.com>
To: Zsh list <zsh-workers@zsh.org>
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

On 31 December 2010 21:21, Bart Schaefer <schaefer@brasslantern.com> wrote:
> On Dec 31, 10:28am, Wayne Davison wrote:
> }
> } While playing with this syntax highlighting code, I've come to the
> } conclusion that it would be much nicer to have a hook where the zle cod=
e
> } asks for a changed line to be highlighted.
>
> I've been thinking for a couple of days now about some related ideas.
>
> I loaded the zsh-syntax-highlighting script from github but found it
> to be *agonizingly* slow when running zed (or on any other significant
> multi-line buffer), because it recomputes the colorization of the whole
> buffer in shell code on every keystroke -- including movement up or
> down in the buffer.
>
> Several changes could improve this; (1) don't re-highlight if the buffer
> hasn't changed [your edit to _zsh_highlight-zle-buffer]; (2) highlight
> incrementally based on $CURSOR rather than starting over with a fresh
> ${(z)BUFFER} on every change; and (3) get some help from the C code,
> which presently isn't available.
>
> This is exactly the reason that completion has so many helper builtins
> to figure out the context around the cursor position. =C2=A0Perhaps the c=
ode
> for completion could be repurposed for this; in fact perhaps a way to
> approach it without hacking new C code directly, is to restructure the
> colorize-zle-buffer function such that it becomes a completion widget
> (one which always succeeds without adding any matches), and then invoke
> that with "zle colorize-zle-buffer" instead of a direct call.
>
> } This avoids having to create functions for an ever-changing plethora
> } of zle functions, and makes things like push-line, yank, yank-pop,
> } delete-char-or-list, and who-knows-what-else Just Work (all of which
> } have issues when using override widgets).
>
> Aside: =C2=A0It appears the thread beginning users/15493 then workers/283=
69
> never went anywhere (about making the zle hooks into arrays of function
> or widget names).
>
> } Here's a patch for zsh:
> }
> } =C2=A0 http://opencoder.net/zle-set-highlight-hook.patch
> }
> } Thoughts? =C2=A0I really like this single hook point for highlighting.
>
> Yes, this makes good sense.

I haven't compared the two approaches, or even tried the stuff
mentioned in this thread, but this is what I've done.
http://git.mika.l3ib.org/?p=3Dzsh-cvs.git;a=3Dcommitdiff;h=3D74e0abb29894d8=
7a7cfe045bc01167e9a56f73e3
patch to zsh adding a hook in zrefresh. As you may be able to tell,
all it does is highlight matching braces.

My general experience fiddling with adding new hooks is that some
stuff you do has unexpected consequences in completely unrelated
places, as the first comment mentions, due to almost nothing in zsh
being re-entrant.

#This uses =3D~ to avoid conflicting with isearch (some static vars get
overwritten)
function _line_redraw_brace_detect() {
  local char=3D$BUFFER[pos]
  if [[ $char =3D~ '\(' ]]; then
    dir=3D1
    that=3D')'
  elif [[ $char =3D~ '\)' ]]; then
    dir=3D-1
    that=3D'('
  elif [[ $char =3D~ '\[' ]]; then
    dir=3D1
    that=3D']'
  elif [[ $char =3D~ '\]' ]]; then
    dir=3D-1
    that=3D'['
  elif [[ $char =3D~ '\{' ]]; then
    dir=3D1
    that=3D'}'
  elif [[ $char =3D~ '\}' ]]; then
    dir=3D-1
    that=3D'{'
  fi
}

function _line_redraw() {
  unset region_highlight
  [[ $_IS_PASTING =3D 1 ]] && return

  [[ $__zle_line_accepted -gt 0 ]] && {
    (( __zle_line_accepted-- ))
    return
  }
  #this stuff is so slow
  [[ $#BUFFER -gt 250 ]] && { zle -D zle-line-pre-redraw; return }

  #hilight matching parens,braces,brackets
  local ct=3D1 pos=3D$((CURSOR+1)) cpos dir this that
  _line_redraw_brace_detect
  (( ! dir )) && {
    (( pos-- ))
    _line_redraw_brace_detect
  }
  (( ! dir )) && return
  this=3D$BUFFER[pos]
  cpos=3D$pos
  while (( ((dir > 0) ? (pos < $#BUFFER) : pos > 0) && ct )) {
    (( pos+=3Ddir ))
    [[ $BUFFER[pos] =3D=3D $that ]] && (( ct-- ))
    [[ $BUFFER[pos] =3D=3D $this ]] && (( ct++ ))
  }
  (( ct )) ||
    region_highlight=3D("$((cpos-1)) $cpos bold,bg=3Dcyan,fg=3Dblack"
                      "$((pos-1)) $pos bold,bg=3Dcyan,fg=3Dblack")
}

Now that I look at it, I could probably replace the while loop with a
(I:something:b:something:) subscript...

--=20
Mikael Magnusson

