From zsh-workers-return-11317-mason-zsh=primenet.com.au@sunsite.auc.dk Thu May 11 00:48:18 2000
Return-Path: <zsh-workers-return-11317-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1757 invoked from network); 11 May 2000 00:48:17 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 May 2000 00:48:17 -0000
Received: (qmail 27076 invoked by alias); 11 May 2000 00:48:10 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11317
Received: (qmail 27056 invoked from network); 11 May 2000 00:48:09 -0000
Sender: ken@mail2.mailbank.com
Message-ID: <391A0376.F6A947F5@smith.net>
Date: Thu, 11 May 2000 02:48:54 +0200
From: Ken Smith <ken@smith.net>
X-Mailer: Mozilla 4.7 [en] (X11; I; Linux 2.2.14 i686)
X-Accept-Language: en
MIME-Version: 1.0
To: zsh-workers@sunsite.auc.dk
Subject: Unexpected Results/Heisenbug
Content-Type: multipart/mixed;
 boundary="------------3921E07F8C393807C9BC2D6C"

This is a multi-part message in MIME format.
--------------3921E07F8C393807C9BC2D6C
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

Attached is a script which surprised me when I tested it.  When run with
DEBUG=0, the output is as I would expect.  When run with DEBUG=1, the
for loop sets ${each} to "continue:" after the debugging code executes. 
Is this a problem with my nubile scripting skills or does this signify a
problem with zsh?  Please cc responses to ken at smith.net as I am not a
subscriber of the zsh-workers mailing list.

Thank you for any tips.
--------------3921E07F8C393807C9BC2D6C
Content-Type: text/plain; charset=us-ascii;
 name="zsh_for_test"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="zsh_for_test"

#!/bin/zsh

DEBUG=1

function debugging
{
	[[ ${+DEBUG} == 1 && ${DEBUG} == 1 ]]
}
function format_output
{
	function arg_len
	{
		echo $1 | wc -c
	}

	heading_separator=": "
	prefix=${1}${heading_separator}
	prefix_len=`arg_len ${prefix}`
	if [[ ${+COLUMNS} == 1 ]]; then
	columns=${COLUMNS}
	else
		columns=80
	fi

	terminal_position=0
	first_argument=1
	just_wrote_prefix=0
	for each in $*; do
		if [[ ${first_argument} == 1 ]]; then
			first_argument=0
			continue
		fi
		if [[ ${terminal_position} == 0 ]]; then
			echo -n ${prefix}
			just_wrote_prefix=1
		fi
		token_len=`arg_len ${each}`
		((terminal_position += token_len + 1))
		if [[ ${terminal_position} > ${columns} ]]; then
			# If we just wrote the prefix, then we
			# have to write this token where it stands
			# even though it will wrap.
			if [[ ${just_wrote_prefix} == 1 ]]; then
				echo ${each}
				just_wrote_prefix=0
				((terminal_position = 0))
			else
				echo -n "\n${prefix}${each} "
				((terminal_position =
					prefix_len + token_len))
				just_wrote_prefix=0
			fi
		else
			echo -n "${each} "
			just_wrote_prefix=0
		fi
	done
	echo
}

if debugging; then
	format_output DEBUG Executing \"${0} ${*}\"
fi

for each in test1 test2 test3; do
	echo "***each=${each}"
	if debugging; then
		format_output DEBUG press enter to continue:
		read
	fi
	echo "***each=${each}"
done

--------------3921E07F8C393807C9BC2D6C--

