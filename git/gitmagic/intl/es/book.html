<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 25 March 2009), see www.w3.org">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8">

  <title>Git Magic</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
alink="#0000FF">
  <div lang="es" class="book" title="Git Magic">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="id2610901" id=
          "id2610901"></a>Git Magic</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="firstname">Ben</span>
            <span class="surname">Lynn</span></h3>
          </div>
        </div>

        <div>
          <div class="revhistory">
            <table border="1" width="100%" summary=
            "Revision history">
              <tr>
                <th align="left" valign="top" colspan="3">
                <b>Historial de revisiones</b></th>
              </tr>

              <tr>
                <td align="left"></td>

                <td align="left">August 2007</td>

                <td align="left">BL</td>
              </tr>
            </table>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Tabla de contenidos</b></p>

      <dl>
        <dt><span class="preface"><a href=
        "#_pr_logo">Prólogo</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_gracias">Gracias!</a></span></dt>

            <dt><span class="section"><a href=
            "#_licencia">Licencia</a></span></dt>

            <dt><span class="section"><a href=
            "#_hosting_git_gratuito">Hosting Git
            gratuito</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_introducci_n">1.
        Introducción</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_trabajar_es_jugar">Trabajar Es Jugar</a></span></dt>

            <dt><span class="section"><a href=
            "#_control_de_versiones">Control De
            Versiones</a></span></dt>

            <dt><span class="section"><a href=
            "#_control_distribu_do">Control
            Distribuído</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href=
                "#_una_tonta_superstici_n">Una Tonta
                Superstición</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href=
            "#_conflictos_al_fusionar">Conflictos al
            fusionar</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_trucos_b_sicos">2.
        Trucos Básicos</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_guardando_estados">Guardando Estados</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href=
                "#_agrega_elimina_renombra">Agrega, Elimina,
                Renombra</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href=
            "#_deshacer_rehacer_avanzado">Deshacer/Rehacer
            Avanzado</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href=
                "#_revirtiendo">Revirtiendo</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href=
            "#_descargando_archivos">Descargando
            Archivos</a></span></dt>

            <dt><span class="section"><a href="#_lo_m_s_nuevo">Lo
            Más Nuevo</a></span></dt>

            <dt><span class="section"><a href=
            "#_publicaci_n_al_instante">Publicación Al
            Instante</a></span></dt>

            <dt><span class="section"><a href=
            "#_que_es_lo_que_hice">Que es lo que
            hice?</a></span></dt>

            <dt><span class="section"><a href=
            "#_ejercicio">Ejercicio</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_clonando">3.
        Clonando</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_sincronizar_computadoras">Sincronizar
            Computadoras</a></span></dt>

            <dt><span class="section"><a href=
            "#_control_cl_sico_de_fuentes">Control Clásico de
            Fuentes</a></span></dt>

            <dt><span class="section"><a href=
            "#_bifurcando_fork_un_proyecto">Bifurcando (fork) un
            proyecto</a></span></dt>

            <dt><span class="section"><a href=
            "#_respaldos_definitivos">Respaldos
            Definitivos</a></span></dt>

            <dt><span class="section"><a href=
            "#_multitask_a_la_velocidad_de_la_luz">Multitask A La
            Velocidad De La Luz</a></span></dt>

            <dt><span class="section"><a href=
            "#_control_guerrillero_de_versiones">Control
            Guerrillero De Versiones</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_magia_con_los_branches">4. Magia Con Los
        Branches</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_la_tecla_del_jefe">La Tecla Del Jefe</a></span></dt>

            <dt><span class="section"><a href=
            "#_trabajo_sucio">Trabajo Sucio</a></span></dt>

            <dt><span class="section"><a href=
            "#_arreglos_r_pidos">Arreglos Rápidos</a></span></dt>

            <dt><span class="section"><a href=
            "#_flujo_de_trabajo_ininterrumpido">Flujo De Trabajo
            Ininterrumpido</a></span></dt>

            <dt><span class="section"><a href=
            "#_reorganizando_una_mezcla">Reorganizando Una
            Mezcla</a></span></dt>

            <dt><span class="section"><a href=
            "#_administrando_branches">Administrando
            branches</a></span></dt>

            <dt><span class="section"><a href=
            "#_branches_temporales">Branches
            Temporales</a></span></dt>

            <dt><span class="section"><a href=
            "#_trabaja_como_quieras">Trabaja como
            quieras</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_lecciones_de_historia">5. Lecciones de
        Historia</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#_me_corrijo">Me
            corrijo</a></span></dt>

            <dt><span class="section"><a href="#_8230_y_algo_m_s">…
            Y Algo Más</a></span></dt>

            <dt><span class="section"><a href=
            "#_los_cambios_locales_al_final">Los Cambios Locales Al
            Final</a></span></dt>

            <dt><span class="section"><a href=
            "#_reescribiendo_la_historia">Reescribiendo la
            Historia</a></span></dt>

            <dt><span class="section"><a href=
            "#_haciendo_historia">Haciendo Historia</a></span></dt>

            <dt><span class="section"><a href=
            "#_d_nde_nos_equivocamos">¿Dónde Nos
            Equivocamos?</a></span></dt>

            <dt><span class="section"><a href=
            "#_qui_n_se_equivoc">¿Quién Se
            Equivocó?</a></span></dt>

            <dt><span class="section"><a href=
            "#_experiencia_personal">Experiencia
            Personal</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_git_multijugador">6.
        Git Multijugador</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_qui_n_soy_yo">¿Quién Soy Yo?</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_sobre_ssh_http">Git Sobre SSH,
            HTTP</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_sobre_cualquier_cosa">Git Sobre Cualquier
            Cosa</a></span></dt>

            <dt><span class="section"><a href=
            "#_parches_la_moneda_global">Parches: La Moneda
            Global</a></span></dt>

            <dt><span class="section"><a href=
            "#_lo_siento_nos_hemos_movido">Lo Siento, Nos Hemos
            Movido</a></span></dt>

            <dt><span class="section"><a href=
            "#_ramas_remotas">Ramas Remotas</a></span></dt>

            <dt><span class="section"><a href=
            "#_m_ltiples_remotes">Múltiples Remotes</a></span></dt>

            <dt><span class="section"><a href=
            "#_mis_preferencias">Mis Preferencias</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href=
        "#_gran_maestr_a_en_git">7. Gran Maestría en
        Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_lanzamientos_de_c_digo">Lanzamientos de
            Código</a></span></dt>

            <dt><span class="section"><a href=
            "#_commit_de_lo_que_cambi">Commit De Lo Que
            Cambió</a></span></dt>

            <dt><span class="section"><a href=
            "#_mi_commit_es_muy_grande">¡Mi Commit Es Muy
            Grande!</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href=
                "#_cambios_en_el_emphasis_stage_emphasis">Cambios
                en el <span class=
                "emphasis"><em>stage</em></span></a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href=
            "#_no_pierdas_la_cabeza">No Pierdas La
            Cabeza</a></span></dt>

            <dt><span class="section"><a href=
            "#_cazando_cabezas">Cazando Cabezas</a></span></dt>

            <dt><span class="section"><a href=
            "#_construyendo_sobre_git">Construyendo sobre
            Git</a></span></dt>

            <dt><span class="section"><a href=
            "#_acrobacias_peligrosas">Acrobacias
            Peligrosas</a></span></dt>

            <dt><span class="section"><a href=
            "#_mejora_tu_imagen_p_blica">Mejora Tu Imagen
            Pública</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#_secrets_revealed">8.
        Secrets Revealed</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_invisibility">Invisibility</a></span></dt>

            <dt><span class="section"><a href=
            "#_integrity">Integrity</a></span></dt>

            <dt><span class="section"><a href=
            "#_intelligence">Intelligence</a></span></dt>

            <dt><span class="section"><a href=
            "#_indexing">Indexing</a></span></dt>

            <dt><span class="section"><a href=
            "#_git_8217_s_origins">Git’s Origins</a></span></dt>

            <dt><span class="section"><a href=
            "#_the_object_database">The Object
            Database</a></span></dt>

            <dt><span class="section"><a href=
            "#_blobs">Blobs</a></span></dt>

            <dt><span class="section"><a href=
            "#_trees">Trees</a></span></dt>

            <dt><span class="section"><a href=
            "#_commits">Commits</a></span></dt>

            <dt><span class="section"><a href=
            "#_indistinguishable_from_magic">Indistinguishable From
            Magic</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href="#_defectos_de_git">A.
        Defectos de Git</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href=
            "#_debilidades_de_sha1">Debilidades De
            SHA1</a></span></dt>

            <dt><span class="section"><a href=
            "#_microsoft_windows">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href=
            "#_archivos_no_relacionados">Archivos No
            Relacionados</a></span></dt>

            <dt><span class="section"><a href=
            "#_qui_n_edita_qu">¿Quién Edita Qué?</a></span></dt>

            <dt><span class="section"><a href=
            "#_historia_por_archivo">Historia Por
            Archivo</a></span></dt>

            <dt><span class="section"><a href=
            "#_clonado_inicial">Clonado inicial</a></span></dt>

            <dt><span class="section"><a href=
            "#_proyectos_vol_tiles">Proyectos
            Volátiles</a></span></dt>

            <dt><span class="section"><a href=
            "#_contador_global">Contador Global</a></span></dt>

            <dt><span class="section"><a href=
            "#_subdirectorios_vac_os">Subdirectorios
            Vacíos</a></span></dt>

            <dt><span class="section"><a href=
            "#_commit_inicial">Commit Inicial</a></span></dt>

            <dt><span class="section"><a href=
            "#_rarezas_de_la_interfaz">Rarezas De La
            Interfaz</a></span></dt>
          </dl>
        </dd>

        <dt><span class="appendix"><a href=
        "#_translating_this_guide">B. Translating This
        Guide</a></span></dt>
      </dl>
    </div>

    <div class="preface" title="Prólogo">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="_pr_logo"></a>Prólogo</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_gracias">Gracias!</a></span></dt>

          <dt><span class="section"><a href=
          "#_licencia">Licencia</a></span></dt>

          <dt><span class="section"><a href=
          "#_hosting_git_gratuito">Hosting Git
          gratuito</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target=
      "_top">Git</a> es la navaja suiza del control de versiones.
      Una herramienta de control de revisiones confiable, versátil
      y multipropósito, que por su extraordinaria flexibilidad es
      complicada de aprender, y más aún de dominar. Estoy
      documentando lo que he aprendido hasta ahora en estas
      páginas, porque inicialmente tuve dificultades para
      comprender <a class="ulink" href=
      "http://www.kernel.org/pub/software/scm/git/docs/user-manual.html"
      target="_top">el manual de usuario de Git</a>.</p>

      <p>Tal como observó Arthur C. Clarke, cualquier tecnología
      suficientemente avanzada, es indistinguible de la magia. Este
      es un gran modo de acercarce a Git: los novatos pueden
      ignorar su funcionamiento interno, y ver a Git como un
      artefacto que puede asombrar a los amigos y enfurecer a los
      enemigos con sus maravillosas habilidades.</p>

      <p>En lugar de ser detallados, proveemos instrucciones
      generales para efectos particulares. Luego de un uso
      reiterado, gradualmente irás entendiendo como funciona cada
      truco, y como adaptar las recetas a tus necesidades.</p>

      <div class="itemizedlist" title="Otras ediciones">
        <p class="title"><b>Otras ediciones</b></p>

        <ul class="itemizedlist" type="disc">
          <li class="listitem"><a class="ulink" href=
          "http://docs.google.com/View?id=dfwthj68_675gz3bw8kj"
          target="_top">Traducción al chino</a>: por JunJie, Meng y
          JiangWei.</li>

          <li class="listitem"><a class="ulink" href="book.html"
          target="_top">Una única página</a>: HTML simple, sin
          CSS.</li>

          <li class="listitem"><a class="ulink" href="book.pdf"
          target="_top">Archivo PDF</a>: Listo para imprimir.</li>

          <li class="listitem"><a class="ulink" href=
          "http://packages.debian.org/search?searchon=names&amp;keywords=gitmagic"
          target="_top">Paquete gitmagic para Debian</a>: Consigue
          una copia rápida y local de este sitio. <a class="ulink"
          href="http://packages.ubuntu.com/jaunty/gitmagic" target=
          "_top">Paquete para Ubuntu (Jaunty Jackalope)</a> también
          disponible. Útil <a class="ulink" href=
          "http://csdcf.stanford.edu/status/" target="_top">cuando
          este servidor está offline para mantenimiento</a>.</li>
        </ul>
      </div>

      <div class="section" title="Gracias!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_gracias"></a>Gracias!</h2>
            </div>
          </div>
        </div>

        <p>Agradezco a Dustin Sallings, Alberto Bertogli, James
        Cameron, Douglas Livingstone, Michael Budde, Richard
        Albury, Tarmigan, Derek Mahar y Frode Aannevik por
        sugerencias y mejoras. Gracias a Daniel Baumann por crear y
        mantener el paquete para Debian. También gracias a JunJie,
        Meng y JiangWei por la traduccción al chino. [Si me olvidé
        de tí, por favor recuérdamelo, porque suelo olvidarme de
        actualizar esta sección]</p>

        <p>Estoy muy agradecido por todos los que me han dado apoyo
        y elogios. Me gustaría que este fuera un libro real
        impreso, para poder citar sus generosas palabras en la tapa
        a modo de promoción. Hablando en serio, aprecio enormemente
        cada mensaje. El leerlos siempre ilumina mi ánimo.</p>
      </div>

      <div class="section" title="Licencia">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_licencia"></a>Licencia</h2>
            </div>
          </div>
        </div>

        <p>Esta guía se publica bajo la <a class="ulink" href=
        "http://www.gnu.org/licenses/gpl-3.0.html" target=
        "_top">GNU General Public License versión 3</a>.
        Naturalmente, los fuentes se guardan en un repositorio Git,
        y pueden ser obtenidos escribiendo:</p>
        <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git  # Crea el directorio "gitmagic".
</pre>

        <p>Ver debajo por otros mirrors.</p>
      </div>

      <div class="section" title="Hosting Git gratuito">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_hosting_git_gratuito"></a>Hosting Git gratuito</h2>
            </div>
          </div>
        </div>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://repo.or.cz/" target=
            "_top">http://repo.or.cz/</a> hospeda proyectos
            gratuitos, <a class="ulink" href=
            "http://repo.or.cz/w/gitmagic.git" target=
            "_top">incluyendo esta guía</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://gitorious.org/" target=
            "_top">http://gitorious.org/</a> es un sitio que apunta
            al hosting de proyectos open-source.</li>

            <li class="listitem"><a class="ulink" href=
            "http://github.com/" target=
            "_top">http://github.com/</a> hospeda proyectos
            open-source gratis, <a class="ulink" href=
            "http://github.com/blynn/gitmagic/tree/master" target=
            "_top">incluyendo esta guía</a>, y proyectos privados
            por una cuota.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="chapter" title="Capítulo 1. Introducción">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="_introducci_n"></a>Capítulo
            1. Introducción</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_trabajar_es_jugar">Trabajar Es Jugar</a></span></dt>

          <dt><span class="section"><a href=
          "#_control_de_versiones">Control De
          Versiones</a></span></dt>

          <dt><span class="section"><a href=
          "#_control_distribu_do">Control
          Distribuído</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href=
              "#_una_tonta_superstici_n">Una Tonta
              Superstición</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href=
          "#_conflictos_al_fusionar">Conflictos al
          fusionar</a></span></dt>
        </dl>
      </div>

      <p>Voy a usar una analogía para explicar el control de
      versiones. Mira <a class="ulink" href=
      "http://es.wikipedia.org/wiki/Control_de_versiones" target=
      "_top">el artículo de wikipedia sobre control de
      versiones</a> para una explicación más cuerda.</p>

      <div class="section" title="Trabajar Es Jugar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_trabajar_es_jugar"></a>Trabajar Es Jugar</h2>
            </div>
          </div>
        </div>

        <p>He jugado juegos de PC casi toda mi vida. En cambio,
        empecé a usar sistemas de control de versiones siendo
        adulto. Sospecho que no soy el único, y comparar ambas
        cosas puede hacer que estos conceptos sean más fáciles de
        explicar y entender.</p>

        <p>Piensa en editar tu código o documento, o lo que sea,
        como si fuera jugar un juego. Una vez que progresaste
        mucho, te gustaría guardar. Para lograrlo, haces click en
        el botón de "Guardar" en tu editor de confianza.</p>

        <p>Pero esto va a sobreescribir tu versión antigua. Es como
        esos viejos juegos que solo tenían un slot para guardar: se
        podía guardar, pero nunca podías volver a un estado
        anterior. Esto era una pena, porque tu versión anterior
        podía haber estado justo en una parte que era
        particularmente divertida, y podías querer volver a jugarla
        algún día. O peor aún, tu partida actual está en un estado
        donde es imposible ganar, y tienes que volver a
        empezar.</p>
      </div>

      <div class="section" title="Control De Versiones">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_control_de_versiones"></a>Control De Versiones</h2>
            </div>
          </div>
        </div>

        <p>Cuando estás editando, puedes "Guardar Como…" un archivo
        diferente, o copiar el archivo a otro lugar antes de
        guardar si quieres probar versiones viejas. También puedes
        usar compresión para ahorrar espacio. Esta es una forma
        primitiva y muy trabajosa de control de versiones. Los
        videojuegos han mejorado esto hace ya tiempo, muchas veces
        permitiendo guardar en varios slots, fechados
        automáticamente.</p>

        <p>Hagamos que el problema sea un poco más complejo.
        Imagina que tienes un montón de archivos que van juntos,
        como el código fuente de un proyecto, o archivos para un
        sitio web. Ahora, si quieres mantener una vieja versión,
        debes archivar un directorio completo. Tener muchar
        versiones a mano es inconveniente y rápidamente se vuelve
        costoso.</p>

        <p>Con algunos juegos, una partida guardada en realidad
        consiste de un directorio lleno de archivos. Estos
        videojuegos ocultan este detalle del jugador y presentan
        una interfaz conveniente para administrar diferentes
        versiones de este directorio.</p>

        <p>Los sistemas de control de versiones no son diferentes.
        Todos tienen lindas interfaces para administrar un
        directorio de cosas. Puedes guardar el estado del
        directorio tantas veces como quieras, y tiempo después
        puedes cargar cualquiera de los estados guardados. A
        diferencia de la mayoría de los juegos, normalmente estos
        sistemas son inteligentes en cuanto la conservación del
        espacio. Por lo general, solo algunos pocos archivos
        cambian de versión a versión, y no es un gran cambio.
        Guardar las diferencias en lugar de nuevas copias ahorra
        espacio.</p>
      </div>

      <div class="section" title="Control Distribuído">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_control_distribu_do"></a>Control Distribuído</h2>
            </div>
          </div>
        </div>

        <p>Ahora imagina un juego muy difícil. Tan difícil para
        terminar, que muchos jugadores experientes alrededor del
        mundo deciden agruparse e intercambiar sus juegos guardados
        para intentar terminarlo. Los "Speedruns" son ejemplos de
        la vida real: los jugadores se especializan en diferents
        niveles del mismo juego y colaboran para lograr resultados
        sorprendentes. ¿Cómo armarías un sistema para que puedan
        descargar las partidas de los otros de manera simple? ¿Y
        para que suban las nuevas?</p>

        <p>Antes, cada proyecto usaba un control de versiones
        centralizado. Un servidor en algún lado contenía todos los
        juegos salvados. Nadie más los tenía. Cada jugador tenía a
        lo sumo un un par de juegos guardados en su máquina. Cuando
        un jugador quería progresar, obtenía la última versión del
        servidor principal, jugaba un rato, guardaba y volvía a
        subir al servidor para que todos los demás pudieran
        usarlo.</p>

        <p>¿Qué pasa si un jugador quería obtener un juego anterior
        por algún motivo? Tal vez el juego actual está en un estado
        donde es imposible ganar, porque alguien olvidó obtener un
        objeto antes de pasar el nivel tres, por que que se quiere
        obtener el último juego guardado donde todavía es posible
        completarlo. O tal vez quieren comparar dos estados
        antiguos, para ver cuánto trabajo hizo un jugador en
        particular.</p>

        <p>Puede haber varias razones para querer ver una revisión
        antigua, pero el resultado es siempre el mismo. Tienen que
        pedirle esa vieja partida al servidor central. Mientras mas
        juegos guardados se quieran, más se necesita esa
        comunicación.</p>

        <p>La nueva generación de sistemas de control de versiones,
        de la cual Git es miembro, se conoce como sistemas
        distribuídos, y se puede pensar en ella como una
        generalización de sistemas centralizados. Cuando los
        jugadores descargan del servidor central, obtienen todos
        los juegos guardados, no solo el último. Es como si
        tuvieran un mirror del servidor central.</p>

        <p>Esta operación inicial de clonado, puede ser cara,
        especialmente si el historial es largo, pero a la larga
        termina siendo mejor. Un beneficio inmediato es que cuando
        se quiere una versión vieja por el motivo que sea, la
        comunicación con el servidor es innecesaria.</p>

        <div class="section" title="Una Tonta Superstición">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name=
                "_una_tonta_superstici_n"></a>Una Tonta
                Superstición</h3>
              </div>
            </div>
          </div>

          <p>Una creencia popular errónea es que los sistemas
          distribuídos son poco apropiados para proyectos que
          requieren un repositorio central oficial. Nada podría
          estar más lejos de la verdad. Fotografiar a alguien no
          hace que su alma sea robada, clonar el repositorio
          central no disminuye su importancia.</p>

          <p>Una buena aproximación inicial, es que cualquier cosa
          que se puede hacer con un sistema de control de versiones
          centralizado, se puede hacer mejor con un sistema de
          versiones distribuído que esté bien diseñado. Los
          recursos de red son simplemente más costosos que los
          recursos locales. Aunque luego veremos que hay algunas
          desventajas para un sistema distribuído, hay menos
          probabilidad de hacer comparaciones erroneas al tener
          esto en cuenta.</p>

          <p>Un proyecto pequeño, puede necesitar solo una fracción
          de de las características que un sistema así ofrece.
          Pero, ¿usarías números romanos si solo necesitas usar
          números pequeños?. Además, tu proyecto puede crecer más
          allá de tus expectativas originales. Usar Git desde el
          comienzo, es como llevar una navaja suiza, aunque solo
          pretendas usarla para abrir botellas. El día que
          necesites desesperadamente un destornillador, vas a
          agradecer el tener más que un simple destapador.</p>
        </div>
      </div>

      <div class="section" title="Conflictos al fusionar">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_conflictos_al_fusionar"></a>Conflictos al
              fusionar</h2>
            </div>
          </div>
        </div>

        <p>Para este tema, habría que estirar demasiado nuestra
        analogía con un videojuego. En lugar de eso, esta vez
        consideremos editar un documento.</p>

        <p>Supongamos que Alice inserta una línea al comienzo de un
        archivo, y Bob agrega una línea al final de su copia. Ambos
        suben sus cambios. La mayoría de los sistemas
        automáticamente van a deducir un accionar razonable:
        aceptar y hacer merge (Nota del Traductor: fusionar en
        inglés) de los cambios, para que tanto la edición de Alice
        como la de Bob sean aplicadas.</p>

        <p>Ahora supongamos que Alice y Bob han hecho ediciones
        distintas sobre la misma línea. Entonces es imposible
        resolver el conflicto sin intervención humana.Se le informa
        a la segunda persona en hacer upload que hay un conflicto
        de merge, y ellos deben elegir entre ambas ediciones, o
        cambiar la línea por completo.</p>

        <p>Pueden surgir situaciones más complejas. Los sistemas de
        control de versiones manejan automáticamente los casos
        simples, y dejan los más complejos para los humanos.
        Usualmente este comportamiento es configurable.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 2. Trucos Básicos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_trucos_b_sicos"></a>Capítulo 2. Trucos Básicos</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_guardando_estados">Guardando Estados</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href=
              "#_agrega_elimina_renombra">Agrega, Elimina,
              Renombra</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href=
          "#_deshacer_rehacer_avanzado">Deshacer/Rehacer
          Avanzado</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href=
              "#_revirtiendo">Revirtiendo</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href=
          "#_descargando_archivos">Descargando
          Archivos</a></span></dt>

          <dt><span class="section"><a href="#_lo_m_s_nuevo">Lo Más
          Nuevo</a></span></dt>

          <dt><span class="section"><a href=
          "#_publicaci_n_al_instante">Publicación Al
          Instante</a></span></dt>

          <dt><span class="section"><a href=
          "#_que_es_lo_que_hice">Que es lo que
          hice?</a></span></dt>

          <dt><span class="section"><a href=
          "#_ejercicio">Ejercicio</a></span></dt>
        </dl>
      </div>

      <p>En lugar de sumergirte en un mar de comandos de Git, usa
      estos ejemplos elementales para mojarte los pies. A pesar de
      sus simplicidad, todos son útiles. De hecho, en mis primeros
      meses con Git nunca fui más allá del material en este
      capítulo.</p>

      <div class="section" title="Guardando Estados">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_guardando_estados"></a>Guardando Estados</h2>
            </div>
          </div>
        </div>

        <p>Estás a punto de intentar algo drástico? Antes de
        hacerlo, toma una instantánea de todos los archivos en el
        directorio actual con:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "My first backup"
</pre>

        <p>Ahora, si tu edición se vuelve irrecuperable,
        ejecuta:</p>
        <pre class="literallayout">
$ git reset --hard
</pre>

        <p>para volver a donde estabas. Para volver a salvar el
        estado:</p>
        <pre class="literallayout">
$ git commit -a -m "Otro respaldo"
</pre>

        <div class="section" title="Agrega, Elimina, Renombra">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name=
                "_agrega_elimina_renombra"></a>Agrega, Elimina,
                Renombra</h3>
              </div>
            </div>
          </div>

          <p>El comando anterior solo seguirá la pista de los
          archivos que estaban presentes la primera vez que
          ejecutaste <span class="strong"><strong>git
          add</strong></span>. Si añades nuevos archivos o
          subdirectorios, deberás decirle a Git:</p>
          <pre class="literallayout">
$ git add ARCHIVOSNUEVOS...
</pre>

          <p>De manera similar, si quieres que Git se olvide de
          determinados archivos, porque (por ejemplo) los
          borraste:</p>
          <pre class="literallayout">
$ git rm ARCHIVOSVIEJOS...
</pre>

          <p>Renombrar un archivo es lo mismo que eliminar el
          nombre anterior y agregar el nuevo. También puedes usar
          <span class="strong"><strong>git mv</strong></span> que
          tiene la misma sintaxis que el comando <span class=
          "strong"><strong>mv</strong></span>. Por ejemplo:</p>
          <pre class="literallayout">
$ git mv ARCHIVOVIEJO ARCHIVONUEVO
</pre>
        </div>
      </div>

      <div class="section" title="Deshacer/Rehacer Avanzado">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_deshacer_rehacer_avanzado"></a>Deshacer/Rehacer
              Avanzado</h2>
            </div>
          </div>
        </div>

        <p>Algunas veces solo quieres ir hacia atrás y olvidarte de
        todos los cambios a partir de cierto punto, porque estaban
        todos mal. Entonces:</p>
        <pre class="literallayout">
$ git log
</pre>

        <p>te muestra una lista de commits recientes, y sus hashes
        SHA1. A continuación, escribe:</p>
        <pre class="literallayout">
$ git reset --hard SHA1_HASH
</pre>

        <p>para recuperar el estado de un commit dado, y borrar
        para siempre cualquier recuerdo de commits más nuevos.</p>

        <p>Otras veces, quieres saltar a un estado anterior
        temporalmente. En ese caso escribe:</p>
        <pre class="literallayout">
$ git checkout SHA1_HASH
</pre>

        <p>Esto te lleva atrás en el tiempo, sin tocar los commits
        más nuevos. Sin embargo, como en los viajes en el tiempo de
        las películas de ciencia ficción, estarás en una realidad
        alternativa, porque tus acciones fueron diferentes a las de
        la primera vez.</p>

        <p>Esta realidad alternativa se llama <span class=
        "emphasis"><em>branch</em></span> (rama), y <a class="link"
        href="#branch">tendremos más cosas para decir al respecto
        luego</a>. Por ahora solo recuerda que</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>te llevará al presente. También, para que Git no se
        queje, siempre haz un commit o resetea tus cambios antes de
        ejecutar checkout.</p>

        <p>Para retomar la analogía de los videojuegos:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git reset
            \--hard</code></strong></span>: carga un juego viejo y
            borra todos los que son mas nuevos que el que acabas de
            cargar.</li>

            <li class="listitem"><span class=
            "strong"><strong><code class="literal">git
            checkout</code></strong></span>: carga un juego viejo,
            pero si continúas jugando, el estado del juego se
            desviará de los juegos que salvaste la primera vez.
            Cualquierpartido nuevo que guardes, terminará en una
            branch separada, representando la realidad alternativa
            a la que entraste. <a class="link" href="#branch">Luego
            nos encargaremos de esto</a></li>
          </ul>
        </div>

        <p>Puedes elegir el restaurar solo archivos o directorios
        en particular, al agregarlos al final del comando: You can
        choose only to restore particular files and subdirectories
        by appending them after the command:</p>
        <pre class="literallayout">
$ git checkout SHA1_HASH algun.archivo otro.archivo
</pre>

        <p>Ten cuidado, esta forma de <span class=
        "strong"><strong>checkout</strong></span> puede
        sobreescribir archivos sin avisar. Para prevenir
        accidentes, haz commit antes de ejecutar cualquier comando
        de checkout, especialmente cuando estás aprendiendo a usar
        Git. En general, cuando te sientas inseguro del resultado
        de una operación, sea o no de Git, ejecuta antes
        <span class="strong"><strong>git commit
        -a</strong></span>.</p>

        <p>¿No te gusta cortar y pegar hashes? Entonces usa:</p>
        <pre class="literallayout">
$ git checkout :/"Mi primer r"
</pre>

        <p>para saltar al commit que comienza con el mensaje
        dado.</p>

        <p>También puedes pedir el 5to estado hacia atrás:</p>
        <pre class="literallayout">
$ git checkout master~5
</pre>

        <div class="section" title="Revirtiendo">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name=
                "_revirtiendo"></a>Revirtiendo</h3>
              </div>
            </div>
          </div>

          <p>En una corte, los eventos pueden ser eliminados del
          registro. Igualmente, puedes elegir commits específicos
          para deshacer.</p>
          <pre class="literallayout">
$ git commit -a
$ git revert SHA1_HASH
</pre>

          <p>va a deshacer solo el commit con el hash dado.
          Ejecutar <span class="strong"><strong>git
          log</strong></span> revela que el revert es registrado
          como un nuevo commit.</p>
        </div>
      </div>

      <div class="section" title="Descargando Archivos">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_descargando_archivos"></a>Descargando Archivos</h2>
            </div>
          </div>
        </div>

        <p>Obtén una copia de un proyecto administrado por git
        escribiendo:</p>
        <pre class="literallayout">
$ git clone git://servidor/ruta/a/los/archivos
</pre>

        <p>Por ejemplo, para bajar todos los archivos que usé para
        crear este sitio:</p>
        <pre class="literallayout">
$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>Pronto tendremos más para decir acerca del comando
        <span class="strong"><strong>clone</strong></span>.</p>
      </div>

      <div class="section" title="Lo Más Nuevo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_lo_m_s_nuevo"></a>Lo Más Nuevo</h2>
            </div>
          </div>
        </div>

        <p>Si ya descargaste una copia de un proyecto usando
        <span class="strong"><strong>git clone</strong></span>,
        puedes actualizarte a la última versión con:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Publicación Al Instante">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_publicaci_n_al_instante"></a>Publicación Al
              Instante</h2>
            </div>
          </div>
        </div>

        <p>Imagina que has escrito un script que te gustaría
        compartir con otros. Puedes decirles que simplemente lo
        bajen de tu computadora, pero si lo hacen mientras estás
        haciendo una modificación, pueden terminar en problemas. Es
        por esto que existen los ciclos de desarrollo. Los
        programadores pueden trabajar en un proyecto de manera
        frecuente, pero solo hacen público el código cuando
        consideran que es presentable.</p>

        <p>Para hacer esto con Git, en el directorio donde guardas
        tu script:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Primer lanzamiento"
</pre>

        <p>Entonces puedes decirle a tus usuarios que ejecuten:</p>
        <pre class="literallayout">
$ git clone tu.maquina:/ruta/al/script
</pre>

        <p>para descargar tu script. Esto asume que tienen acceso
        por ssh. Si no es así, ejecuta <span class=
        "strong"><strong>git daemon</strong></span> y dile a tus
        usuarios que usen:</p>
        <pre class="literallayout">
$ git clone git://tu.maquina/ruta/al/script
</pre>

        <p>De ahora en más, cada vez que tu script esté listo para
        el lanzamiento, escribe:</p>
        <pre class="literallayout">
$ git commit -a -m "Siguiente lanzamiento"
</pre>

        <p>y tus usuarios puede actualizar su versión yendo al
        directorio que tiene tu script y ejecutando:</p>
        <pre class="literallayout">
$ git pull
</pre>

        <p>Tus usuarios nunca terminarán usando una versión de tu
        script que no quieres que vean. Obviamente este truco
        funciona para lo que sea, no solo scripts.</p>
      </div>

      <div class="section" title="Que es lo que hice?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_que_es_lo_que_hice"></a>Que es lo que hice?</h2>
            </div>
          </div>
        </div>

        <p>Averigua que cambios hiciste desde el último commit
        con:</p>
        <pre class="literallayout">
$ git diff
</pre>

        <p>O desde ayer:</p>
        <pre class="literallayout">
$ git diff "@{yesterday}"
</pre>

        <p>O entre una versión en particular y 2 versiones hacia
        atrás:</p>
        <pre class="literallayout">
$ git diff SHA1_HASH "master~2"
</pre>

        <p>En cado caso la salida es un patch (parche) que puede
        ser aplicado con <span class="strong"><strong>git
        apply</strong></span> Para ver cambios desde hace 2
        semanas, puedes intentar:</p>
        <pre class="literallayout">
$ git whatchanged --since="2 weeks ago"
</pre>

        <p>Usualmente recorro la historia con <a class="ulink"
        href="http://sourceforge.net/projects/qgit" target=
        "_top">qgit</a> , dada su interfaz pulida y fotogénica, o
        <a class="ulink" href="http://jonas.nitro.dk/tig/" target=
        "_top">tig</a>, una interfaz en modo texto que funciona
        bien a través conexiones lentas. Como alternativa, puedes
        instalar un servidor web, ejecutar <span class=
        "strong"><strong>git instaweb</strong></span> y utilizar
        cualquier navegador web.</p>
      </div>

      <div class="section" title="Ejercicio">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ejercicio"></a>Ejercicio</h2>
            </div>
          </div>
        </div>

        <p>Siendo A, B, C, y D cuatro commits sucesivos, donde B es
        el mismo que A pero con algunos archivos eliminados.
        Queremos volver a agregar los archivos en D pero no en B.
        ¿Cómo podemos hacer esto?</p>

        <p>Hay por lo menos tres soluciones. Asumiendo que estamos
        en D:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p class="simpara">La diferencia entre A y B son los
              archivos eliminados. Podemos crear un patch
              representando esta diferencia y aplicarlo:</p>
              <pre class="literallayout">
$ git diff B A | git apply
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Como en A tenemos los archivos
              guardados, podemos recuperarlos :</p>
              <pre class="literallayout">
$ git checkout A ARCHIVOS...
</pre>
            </li>

            <li class="listitem">
              <p class="simpara">Podemos ver el pasaje de A a B
              como un cambio que queremos deshacer:</p>
              <pre class="literallayout">
$ git revert B
</pre>
            </li>
          </ol>
        </div>

        <p>¿Cuál alternativa es la mejor? Cualquiera que prefieras.
        Es fácil obtener lo que quieres con Git, y normalmente hay
        varias formas de hacerlo.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 3. Clonando">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="_clonando"></a>Capítulo 3.
            Clonando</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_sincronizar_computadoras">Sincronizar
          Computadoras</a></span></dt>

          <dt><span class="section"><a href=
          "#_control_cl_sico_de_fuentes">Control Clásico de
          Fuentes</a></span></dt>

          <dt><span class="section"><a href=
          "#_bifurcando_fork_un_proyecto">Bifurcando (fork) un
          proyecto</a></span></dt>

          <dt><span class="section"><a href=
          "#_respaldos_definitivos">Respaldos
          Definitivos</a></span></dt>

          <dt><span class="section"><a href=
          "#_multitask_a_la_velocidad_de_la_luz">Multitask A La
          Velocidad De La Luz</a></span></dt>

          <dt><span class="section"><a href=
          "#_control_guerrillero_de_versiones">Control Guerrillero
          De Versiones</a></span></dt>
        </dl>
      </div>

      <p>En sistemas de control de versiones antiguos, checkout es
      la operación standard para obtener archivos. Obtienes un
      conjunto de archivos en estado guardado que solicistaste.</p>

      <p>En Git, y otros sistemas de control de versiones
      distribuídos, clonar es la operación standard. Para obtener
      archivos se crea un clon de un repositorio entero. En otras
      palabras, practicamente se crea una copia idéntica del
      servidor central. Todo lo que se pueda hacer en el
      repositorio principal, también podrás hacerlo.</p>

      <div class="section" title="Sincronizar Computadoras">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_sincronizar_computadoras"></a>Sincronizar
              Computadoras</h2>
            </div>
          </div>
        </div>

        <p>Este es el motivo por el que usé Git por primera vez.
        Puedo tolerar hacer tarballs o usar <span class=
        "strong"><strong>rsync</strong></span> para backups y
        sincronización básica. Pero algunas veces edito en mi
        laptop, otras veces en mi desktop, y ambas pueden no
        haberse comunicado en el medio.</p>

        <p>Inicializa un repositorio de Git y haz haz commit de tus
        archivos en una máquina, luego en la otra:</p>
        <pre class="literallayout">
$ git clone otra.computadora:/ruta/a/archivos
</pre>

        <p>para crear una segunda copia de los archivos y el
        repositorio Git. De ahora en más,</p>
        <pre class="literallayout">
$ git commit -a
$ git pull otra.computadora:/ruta/a/archivos HEAD
</pre>

        <p>va a traer (pull) el estado de los archivos desde la
        otra máquina hacia la que estás trabajando. Si haz hecho
        cambios que generen conflictos en un archivo, Git te va a
        avisar y deberías hacer commit luego de resolverlos.</p>
      </div>

      <div class="section" title="Control Clásico de Fuentes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_control_cl_sico_de_fuentes"></a>Control Clásico de
              Fuentes</h2>
            </div>
          </div>
        </div>

        <p>Inicializa un repositorio de Git para tus archivos:</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Commit Inicial"
</pre>

        <p>En el servidor central, inicializa un repositorio vacío
        de Git con algún nombre, y abre el Git daemon si es
        necesario:</p>
        <pre class="literallayout">
$ GIT_DIR=proj.git git init
$ git daemon --detach  # podría ya estar corriendo
</pre>

        <p>Algunos servidores publicos, como <a class="ulink" href=
        "http://repo.or.cz" target="_top">repo.or.cz</a>, tienen un
        método diferente para configurar el repositorio
        inicialmente vacío de Git, como llenar un formulario en una
        página.</p>

        <p>Empuja (push) tu proyecto hacia el servidor central
        con:</p>
        <pre class="literallayout">
$ git push git://servidor.central/ruta/al/proyecto.git HEAD
</pre>

        <p>Ya estamos listos. Para copiarse los fuentes, un
        desarrollador escribe:</p>
        <pre class="literallayout">
$ git clone git://servidor.central/ruta/al/proyecto.git
</pre>

        <p>Luego de hacer cambios, el código en envía al servidor
        central con:</p>
        <pre class="literallayout">
$ git commit -a
$ git push
</pre>

        <p>Si hubo actualizaciones en el servidor principal, la
        última versión debe ser traída antes de enviar lo nuevo.
        Para sincronizar con la última versión:</p>
        <pre class="literallayout">
$ git commit -a
$ git pull
</pre>
      </div>

      <div class="section" title="Bifurcando (fork) un proyecto">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_bifurcando_fork_un_proyecto"></a>Bifurcando (fork)
              un proyecto</h2>
            </div>
          </div>
        </div>

        <p>¿Harto de la forma en la que se maneja un
        proyecto?¿Crees que podrías hacerlo mejor? Entonces en tu
        servidor:</p>
        <pre class="literallayout">
$ git clone git://servidor.principal/ruta/a/archivos
</pre>

        <p>Luego avísale a todos de tu fork del proyecto en tu
        servidor.</p>

        <p>Luego, en cualquier momento, puedes unir (merge) los
        cambios del proyecto original con:</p>
        <pre class="literallayout">
$ git pull
</pre>
      </div>

      <div class="section" title="Respaldos Definitivos">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_respaldos_definitivos"></a>Respaldos
              Definitivos</h2>
            </div>
          </div>
        </div>

        <p>¿Quieres varios respaldos redundantes a prueba de
        manipulación y geográficamente diversos? Si tu proyecto
        tiene varios desarrolladores, ¡no hagas nada! Cada clon de
        tu código es un backup efectivo. No sólo del estado actual,
        sino que también de la historia completa de tu proyecto.
        Gracias al hashing criptográfico, si hay corrupción en
        cualquiera de los clones, va a ser detectado tan pronto
        como intente comunicarse con otros.</p>

        <p>Si tu proyecto no es tan popular, busca tantos
        servidores como puedas para hospedar tus clones.</p>

        <p>El verdadero paranoico debería siempre escribir el
        último hash SHA1 de 20-bytes de su HEAD en algún lugar
        seguro. Tiene que ser seguro, no privado. Por ejemplo,
        publicarlo en un diario funcionaría bien, porque es difícil
        para un atacante el alterar cada copia de un diario.</p>
      </div>

      <div class="section" title=
      "Multitask A La Velocidad De La Luz">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_multitask_a_la_velocidad_de_la_luz"></a>Multitask A
              La Velocidad De La Luz</h2>
            </div>
          </div>
        </div>

        <p>Digamos que quieres trabajar en varias prestaciones a la
        vez. Haz commit de tu proyecto y ejecuta:</p>
        <pre class="literallayout">
$ git clone . /un/nuevo/directorio
</pre>

        <p>Git se aprovecha de los hard links y de compartir
        archivos de la manera mas segura posible para crear este
        clon, por lo que estará listo en un segundo, y podrás
        trabajar en dos prestaciones independientes de manera
        simultánea. Por ejemplo, puedes editar un clon mientras el
        otro está compilando.</p>

        <p>En cualquier momento, puedes hacer commit y pull de los
        cambios desde el otro clon.</p>
        <pre class="literallayout">
$ git pull /el/otro/clon HEAD
</pre>
      </div>

      <div class="section" title=
      "Control Guerrillero De Versiones">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_control_guerrillero_de_versiones"></a>Control
              Guerrillero De Versiones</h2>
            </div>
          </div>
        </div>

        <p>¿Estás trabajando en un proyecto que usa algún otro
        sistema de control de versiones y extrañas mucho a Git?
        Entonces inicializa un repositorio de Git en tu directorio
        de trabajo.</p>
        <pre class="literallayout">
$ git init
$ git add .
$ git commit -m "Commit Inicial"
</pre>

        <p>y luego clónalo:</p>
        <pre class="literallayout">
$ git clone . /un/nuevo/directorio
</pre>

        <p>Ahora debes trabajar en el nuevo directorio, usando Git
        como te sea más cómodo. Cada tanto, querrás sincronizar con
        los demás, en ese caso, ve al directorio original,
        sincroniza usando el otro sistema de control de versiones y
        escribe:</p>
        <pre class="literallayout">
$ git add .
$ git commit -m "Sincronizo con los demás"
</pre>

        <p>Luego ve al nuevo directorio y escribe:</p>
        <pre class="literallayout">
$ git commit -a -m "Descripción de mis cambios"
$ git pull
</pre>

        <p>El procedimiento para pasarle tus cambios a los demás
        depende de cuál es tu otro sistema de control de versiones.
        El nuevo directorio contiene los archivos con tus cambios.
        Ejecuta los comandos que sean necesarios para subirlos al
        repositorio central del otro sistema de control de
        versiones.</p>

        <p>El comando <span class="strong"><strong>git
        svn</strong></span> automatiza lo anterior para
        repositorios de Subversion, y también puede ser usado para
        <a class="ulink" href=
        "http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html"
        target="_top">exportar un proyecto de Git a un repositorio
        de Subversion</a>.</p>
      </div>
    </div>

    <div class="chapter" title=
    "Capítulo 4. Magia Con Los Branches">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_magia_con_los_branches"></a>Capítulo 4. Magia Con Los
            Branches</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_la_tecla_del_jefe">La Tecla Del Jefe</a></span></dt>

          <dt><span class="section"><a href=
          "#_trabajo_sucio">Trabajo Sucio</a></span></dt>

          <dt><span class="section"><a href=
          "#_arreglos_r_pidos">Arreglos Rápidos</a></span></dt>

          <dt><span class="section"><a href=
          "#_flujo_de_trabajo_ininterrumpido">Flujo De Trabajo
          Ininterrumpido</a></span></dt>

          <dt><span class="section"><a href=
          "#_reorganizando_una_mezcla">Reorganizando Una
          Mezcla</a></span></dt>

          <dt><span class="section"><a href=
          "#_administrando_branches">Administrando
          branches</a></span></dt>

          <dt><span class="section"><a href=
          "#_branches_temporales">Branches
          Temporales</a></span></dt>

          <dt><span class="section"><a href=
          "#_trabaja_como_quieras">Trabaja como
          quieras</a></span></dt>
        </dl>
      </div>

      <p>El hacer branches (ramificar) y merges (unir) de manera
      instantánea, son dos de las prestaciones más letales de
      Git.</p>

      <p><span class="strong"><strong>Problema</strong></span>:
      Factores externos necesitan inevitablemente de cambios de
      contexto. Un bug severo se manifiesta en la última versión
      sin previo aviso. El plazo para alguna prestación se acorta.
      Un desarrollador que tiene que ayudar en una sección
      indispensable del proyecto está por tomar licencia. En
      cualquier caso, debes soltar abruptamente lo que estás
      haciendo y enfocarte en una tarea completamente
      diferente.</p>

      <p>Interrumpir tu línea de pensamiento puede ser negativo
      para tu productividad, y cuanto más engorroso sea el cambiar
      contextos, mayor es la pérdida. Con los sistemas
      centralizados, debemos descargar una nueva copia. Los
      sistemas distribuídos se comportan mejor, dado que podemos
      clonar la versión deseada localmente.</p>

      <p>Pero el clonar igual implica copiar todo el directorio
      junto con toda la historia hasta el momento. Aunque Git
      reduce el costousando hard links y el compartir archivos, los
      archivos del proyecto deben ser recreados enteramente en el
      nuevo directorio.</p>

      <p><span class="strong"><strong>Solución</strong></span>: Git
      tiene una mejor herramienta para estas situaciones que es
      mucho más rápida y eficiente en tamaño que clonar
      <span class="strong"><strong>git branch</strong></span>.</p>

      <p>Con esta palabra mágica, los archivos en tu directorio se
      transforman súbitamente de una versión en otra. Esta
      transformación puede hacer más que simplemente ir hacia atrás
      o adelante en la historia. Tus archivos pueden mutar desde la
      última versión lanzada, a la versión experimental, a la
      versión en desarrollo, a la versión de un amigo y así
      sucesivamente.</p>

      <div class="section" title="La Tecla Del Jefe">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_la_tecla_del_jefe"></a>La Tecla Del Jefe</h2>
            </div>
          </div>
        </div>

        <p>¿Alguna vez jugaste uno de esos juegos donde con solo
        presionar un botón ("la tecla del jefe"), la pantalla
        inmediatamente muestra una hoja de cálculo o algo así? La
        idea es que si el jefe entra a la oficina mientras estás en
        el juego, lo puedes esconder rápidamente.</p>

        <p>En algún directorio:</p>
        <pre class="literallayout">
$ echo "Soy más inteligente que mi jefe" &gt; miarchivo.txt
$ git init
$ git add .
$ git commit -m "Commit inicial"
</pre>

        <p>Creamos un repositorio de Git que guarda un archivo de
        texto conteniendo un mensaje dado. Ahora escribe:</p>
        <pre class="literallayout">
$ git checkout -b jefe  # nada parece cambiar luego de esto
$ echo "Mi jefe es más inteligente que yo" &gt; miarchivo.txt
$ git commit -a -m "Otro commit"
</pre>

        <p>Parecería que sobreescribimos nuestro archivo y le
        hicimos commit. Pero es una ilusión. Escribe:</p>
        <pre class="literallayout">
$ git checkout master  # cambia a la versión original del archivo
</pre>

        <p>y presto! El archivo de texto es restaurado. Y si el
        jefe decide investigar este directorio, escribimos:</p>
        <pre class="literallayout">
$ git checkout jefe  # cambia a la versión adecuada para los ojos del jefe
</pre>

        <p>Puedes cambiar entre ambas versiones del archivo cuantas
        veces quieras, y hacer commit en ambas de manera
        independiente.</p>
      </div>

      <div class="section" title="Trabajo Sucio">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_trabajo_sucio"></a>Trabajo Sucio</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a>Supongamos que estás
        trabajando en alguna prestación, y que por alguna razón,
        necesitas volver a una versión vieja y poner temporalmente
        algunos "print" para ver como funciona algo. Entonces:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout SHA1_HASH
</pre>

        <p>Ahora puedes agregar cualquier código temporal horrible
        por todos lados. Incluso puedes hacer commit de estos
        cambios. Cuando termines,</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>para volver a tu trabajo original. Observa que
        arrastrarás cualquier cambio del que no hayas hecho
        commit.</p>

        <p>¿Que pasa si quisieras cambiar los cambios temporales?
        Facil:</p>
        <pre class="literallayout">
$ git checkout -b sucio
</pre>

        <p>y haz commit antes de volver a la branch master. Cuando
        quieras volver a los cambios sucios, simplemente
        escribe:</p>
        <pre class="literallayout">
$ git checkout sucio
</pre>

        <p>Mencionamos este comando en un capítulo anterior, cuando
        discutíamos sobre cargar estados antiguos. Al fin podemos
        contar toda la historia:los archivos cambian al estado
        pedido, pero debemos dejar la branch master. Cualquier
        commit de aquí en adelante, llevan tus archivos por un
        nuevo camino, el podrá ser nombrado posteriormente.</p>

        <p>En otras palabras, luego de traer un estado viejo, Git
        automáticamente te pone en una nueva branch sin nombre, la
        cual puede ser nombrada y salvada con <span class=
        "strong"><strong>git checkout -b</strong></span>.</p>
      </div>

      <div class="section" title="Arreglos Rápidos">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_arreglos_r_pidos"></a>Arreglos Rápidos</h2>
            </div>
          </div>
        </div>

        <p>Estás en medio de algo cuando te piden que dejes todo y
        soluciones un bug recién descubierto:</p>
        <pre class="literallayout">
$ git commit -a
$ git checkout -b arreglos SHA1_HASH
</pre>

        <p>Luego, una vez que solucionaste el bug:</p>
        <pre class="literallayout">
$ git commit -a -m "Bug arreglado"
$ git push  # al repositorio central
$ git checkout master
</pre>

        <p>y continúa con el trabajo en tu tarea original.</p>
      </div>

      <div class="section" title="Flujo De Trabajo Ininterrumpido">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_flujo_de_trabajo_ininterrumpido"></a>Flujo De
              Trabajo Ininterrumpido</h2>
            </div>
          </div>
        </div>

        <p>Algunos proyectos requieren que tu código sea evaluado
        antes de que puedas subirlo. Para hacer la vida más fácil
        para aquellos que revisan tu código, si tienes algún cambio
        grande para hacer, puedes partirlo en dos o mas partes, y
        hacer que cada parte sea evaluada por separado.</p>

        <p>¿Que pasa si la segunda parte no puede ser escrita hasta
        que la primera sea aprobada y subida? En muchos sistemas de
        control de versiones, deberías enviar primero el código a
        los evaluadores, y luego esperar hasta que esté aprobado
        antes de empezar con la segunda parte.</p>

        <p>En realidad, eso no es del todo cierto, pero en estos
        sistemas, editar la Parte II antes de subir la Parte I
        involucra sufrimiento e infortunio. En Git, los branches y
        merges son indoloros (un termino técnico que significa
        rápidos y locales). Entonces, luego de que hayas hecho
        commit de la primera parte y la hayas enviado a ser
        revisada:</p>
        <pre class="literallayout">
$ git checkout -b parte2
</pre>

        <p>Luego, escribe la segunda parte del gran cambio sin
        esperar a que la primera sea aceptada. Cuando la primera
        parte sea aprobada y subida,</p>
        <pre class="literallayout">
$ git checkout master
$ git merge parte2
$ git branch -d parte2  # ya no se necesita esta branch
</pre>

        <p>y la segunda parte del cambio está lista para la
        evaluación.</p>

        <p>¡Pero esperen! ¿Qué pasa si no fuera tan simple? Digamos
        que tuviste un error en la primera parte, el cual hay que
        corregir antes de subir los cambios. ¡No hay problema!
        Primero, vuelve a la branch master usando</p>
        <pre class="literallayout">
$ git checkout master
</pre>

        <p>Soluciona el error en la primera parte del cambio y
        espera que sea aprobado. Si no lo es, simplemente repite
        este paso. Probablemente quieras hacer un merge de la
        versión arreglada de la Parte I con la Parte II:</p>
        <pre class="literallayout">
$ git checkout parte2
$ git merge master
</pre>

        <p>Ahora es igual que lo anterior. Una vez que la primera
        parte sea aprobada:</p>
        <pre class="literallayout">
$ git checkout master
$ git merge parte2
$ git branch -d parte2
</pre>

        <p>y nuevamente, la segunda parte está lista para ser
        revisada.</p>

        <p>Es fácil extender este truco para cualquier cantidad de
        partes.</p>
      </div>

      <div class="section" title="Reorganizando Una Mezcla">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_reorganizando_una_mezcla"></a>Reorganizando Una
              Mezcla</h2>
            </div>
          </div>
        </div>

        <p>Quizás quieras trabajar en todos los aspectos de un
        proyecto sobre la misma branch. Quieres dejar los
        trabajos-en-progreso para ti y quieres que otros vean tus
        commits solo cuando han sido pulcramente organizados.
        Inicia un par de branches:</p>
        <pre class="literallayout">
$ git checkout -b prolijo
$ git checkout -b mezcla
</pre>

        <p>A continuación, trabaja en lo que sea: soluciona bugs,
        agrega prestaciones, agrega código temporal o lo que
        quieras, haciendo commits seguidos a medida que avanzas.
        Entonces:</p>
        <pre class="literallayout">
$ git checkout prolijo
$ git cherry-pick SHA1_HASH
</pre>

        <p>aplica un commit dado a la branch "prolijo". Con
        cherry-picks apropiados, puedes construir una rama que
        contenga solo el código permanente, y los commits
        relacionados juntos en un grupo.</p>
      </div>

      <div class="section" title="Administrando branches">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_administrando_branches"></a>Administrando
              branches</h2>
            </div>
          </div>
        </div>

        <p>Lista todas las branches escribiendo:</p>
        <pre class="literallayout">
$ git branch
</pre>

        <p>Siempre hay una branch llamada "master", y es en la que
        comienzas por defecto. Algunos aconsejan dejar la rama
        "master" sin tocar y el crear nuevas branches para tus
        propios cambios.</p>

        <p>Las opciones <span class=
        "strong"><strong>-d</strong></span> y <span class=
        "strong"><strong>-m</strong></span> te permiten borrar y
        mover (renombrar) branches. Mira en <span class=
        "strong"><strong>git help branch</strong></span></p>

        <p>La branch "master" es una convención útil. Otros pueden
        asumir que tu repositorio tiene una branch con este nombre,
        y que contiene la versión oficial del proyecto. Puedes
        renombrar o destruir la branch "master", pero también
        podrías respetar esta costumbre.</p>
      </div>

      <div class="section" title="Branches Temporales">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_branches_temporales"></a>Branches Temporales</h2>
            </div>
          </div>
        </div>

        <p>Después de un rato puedes notar que estás creando
        branches de corta vida de manera frecuente por razones
        similares: cada branch sirve simplemente para salvar el
        estado actual y permitirte saltar a un estado anterior para
        solucionar un bug de alta prioridad o algo.</p>

        <p>Es análogo a cambiar el canal de la TV temporalmente,
        para ver que otra cosa están dando. Pero en lugar de
        apretar un par de botones, tienes que crear, hacer checkout
        y eliminar branches y commits temporales. Por suerte, Git
        tiene un aatajo que es tan conveniente como un control
        remoto de TV:</p>
        <pre class="literallayout">
$ git stash
</pre>

        <p>Esto guarda el estado actual en un lugar temporal (un
        <span class="emphasis"><em>stash</em></span>) y restaura el
        estado anterior. Tu directorio de trabajo se ve idéntico a
        como estaba antes de que comenzaras a editar, y puedes
        solucionar bugs, traer cambios desde otros repositorios,
        etc. Cuando quieras volver a los cambios del stash,
        escribe:</p>
        <pre class="literallayout">
$ git stash apply  # Puedes necesitar corregir conflictos
</pre>

        <p>Puedes tener varios stashes, y manipularlos de varias
        maneras. Mira <span class="strong"><strong>git help
        stash</strong></span>. Como es de imaginar, Git mantiene
        branches de manera interna para lograr este truco
        mágico.</p>
      </div>

      <div class="section" title="Trabaja como quieras">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_trabaja_como_quieras"></a>Trabaja como quieras</h2>
            </div>
          </div>
        </div>

        <p>Aplicaciones como <a class="ulink" href=
        "http://www.mozilla.com/" target="_top">Mozilla Firefox</a>
        permiten tener varias pestañas y ventanas abiertas. Cambiar
        de pestaña te da diferente contenido en la misma ventana.
        Los branches en git son como pestañas para tu directorio de
        trabajo. Siguiendo esta analogía, el clonar es como abrir
        una nueva ventana. La posibilidad de ambas cosas es lo que
        mejora la experiencia del usuario.</p>

        <p>En un nivel más alto, varios window managers en Linux
        soportan múltiples escritorios. Usar branches en Git es
        similar a cambiar a un escritorio diferente, mientras
        clonar es similar a conectar otro monitor para ganar un
        nuevo escritorio.</p>

        <p>Otro ejemplo es el programa <a class="ulink" href=
        "http://www.gnu.org/software/screen/" target=
        "_top"><span class=
        "strong"><strong>screen</strong></span></a>. Esta joya
        permite crear, destruir e intercambiar entre varias
        sesiones de terminal sobre la misma terminal. En lugar de
        abrir terminales nuevas (clone), puedes usar la misma si
        ejecutas <span class=
        "strong"><strong>screen</strong></span> (branch). De hecho,
        puedes hacer mucho más con <span class=
        "strong"><strong>screen</strong></span>, pero eso es un
        asunto para otro manual.</p>

        <p>Usar clone, branch y merge, es rápido y local en Git,
        animándote a usar la combinación que más te favorezca. Git
        te permite trabajar exactamente como prefieras.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 5. Lecciones de Historia">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_lecciones_de_historia"></a>Capítulo 5. Lecciones de
            Historia</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href="#_me_corrijo">Me
          corrijo</a></span></dt>

          <dt><span class="section"><a href="#_8230_y_algo_m_s">… Y
          Algo Más</a></span></dt>

          <dt><span class="section"><a href=
          "#_los_cambios_locales_al_final">Los Cambios Locales Al
          Final</a></span></dt>

          <dt><span class="section"><a href=
          "#_reescribiendo_la_historia">Reescribiendo la
          Historia</a></span></dt>

          <dt><span class="section"><a href=
          "#_haciendo_historia">Haciendo Historia</a></span></dt>

          <dt><span class="section"><a href=
          "#_d_nde_nos_equivocamos">¿Dónde Nos
          Equivocamos?</a></span></dt>

          <dt><span class="section"><a href=
          "#_qui_n_se_equivoc">¿Quién Se Equivocó?</a></span></dt>

          <dt><span class="section"><a href=
          "#_experiencia_personal">Experiencia
          Personal</a></span></dt>
        </dl>
      </div>

      <p>Una consecuencia de la naturaleza distribuída de git, es
      que la historia puede ser editada facilmente. Pero si
      manipulas el pasado, ten cuidado: solo reescribe la parte de
      la historia que solamente tú posees. Así como las naciones
      discuten eternamente sobre quién cometió qué atrocidad, si
      otra persona tiene un clon cuya versión de la historia
      difiere de la tuya, vas a tener problemas para reconciliar
      ambos árboles cuando éstos interactúen.</p>

      <p>Por supuesto, si también controlas todos los demás
      árboles, puedes simplemente sobreescribirlos.</p>

      <p>Algunos desarrolladores están convencidos de que la
      historia debería ser inmutable, incluso con sus defectos.
      Otros sienten que los árboles deberían estar presentables
      antes de ser mostrados en público. Git satisface ambos puntos
      de vista. Al igual que el clonar, hacer branches y hacer
      merges, reescribir la historia es simplemente otro poder que
      Git te da. Está en tus manos usarlo con sabiduría.</p>

      <div class="section" title="Me corrijo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_me_corrijo"></a>Me corrijo</h2>
            </div>
          </div>
        </div>

        <p>¿Hiciste un commit, pero preferirías haber escrito un
        mensaje diferente? Entonces escribe:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>para cambiar el último mensaje. ¿Te olvidaste de agregar
        un archivo? Ejecuta <span class="strong"><strong>git
        add</strong></span> para agregarlo, y luego corre el
        comando de arriba.</p>

        <p>¿Quieres incluir algunas ediciones mas en ese último
        commit? Edita y luego escribe:</p>
        <pre class="literallayout">
$ git commit --amend -a
</pre>
      </div>

      <div class="section" title="… Y Algo Más">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_8230_y_algo_m_s"></a>… Y Algo Más</h2>
            </div>
          </div>
        </div>

        <p>Supongamos que el problema anterior es diez veces peor.
        Luego de una larga sesión hiciste unos cuantos commits.
        Pero no estás conforme con la forma en que están
        organizados, y a algunos de los mensajes de esos commits
        les vendría bien una reescritura. Entonces escribe:</p>
        <pre class="literallayout">
$ git rebase -i HEAD~10
</pre>

        <p>y los últimos 10 commits van a aparecer en tu $EDITOR
        favorito. Un fragmento de muestra:</p>
        <pre class="literallayout">
pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Entonces:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem">Elimina commits borrando
            líneas.</li>

            <li class="listitem">Reordena commits reordenando
            líneas.</li>

            <li class="listitem">Reemplaza "pick" por "edit" para
            marcar un commit para arreglarlo.</li>

            <li class="listitem">Reemplaza "pick" por "squash" para
            unir un commit con el anterior.</li>
          </ul>
        </div>

        <p>Si marcaste un commit para edición, entonces
        ejecuta:</p>
        <pre class="literallayout">
$ git commit --amend
</pre>

        <p>En caso contrario, corre:</p>
        <pre class="literallayout">
$ git rebase --continue
</pre>

        <p>Por lo tanto, es bueno hacer commits temprano y seguido:
        siempre se puede acomodar después usando rebase.</p>
      </div>

      <div class="section" title="Los Cambios Locales Al Final">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_los_cambios_locales_al_final"></a>Los Cambios
              Locales Al Final</h2>
            </div>
          </div>
        </div>

        <p>Estás trabajando en un proyecto activo. Haces algunos
        commits locales por un tiempo, y entonces sincronizas con
        el árbol oficial usando un merge. Este ciclo se repite unas
        cuantas veces antes de estar listo para hacer push hacia el
        árbol central.</p>

        <p>El problema es que ahora la historia en tu clon local de
        Git, es un entrevero de tus cambios y los cambios
        oficiales. Preferirías ver todos tus cambios en una sección
        contigua, luego de todos los cambios oficiales.</p>

        <p>Lo descrito arriba es un trabajo para <span class=
        "strong"><strong>git rebase</strong></span>. En muchos
        casos se puede usar la bandera <span class=
        "strong"><strong>--onto</strong></span> y evitar la
        interacción.</p>

        <p>Ver <span class="strong"><strong>git help
        rebase</strong></span> para ejemplos detallados de este
        asombroso comando. Se pueden partir commits. Incluso se
        pueden reordenar las branches de un árbol.</p>
      </div>

      <div class="section" title="Reescribiendo la Historia">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_reescribiendo_la_historia"></a>Reescribiendo la
              Historia</h2>
            </div>
          </div>
        </div>

        <p>Ocasionalmente, se necesita algo equivalente a borrar
        gente de fotos oficiales, pero para control de código, para
        borrar cosas de la historia de manera Stalinesca. Por
        ejemplo, supongamos que queremos lanzar un proyecto, pero
        involucra un archivo que debería ser privado por alguna
        razón. Quizás dejé mi número de tarjeta de crédito en un
        archivo de texto y accidentalmente lo agregué al proyecto.
        Borrar el archivo es insuficiente, dado que se puede
        acceder a él en commits viejos. Debemos eliminar el archivo
        de todos los commits:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'rm archivo/secreto' HEAD
</pre>

        <p>Ver <span class="strong"><strong>git help
        filter-branch</strong></span>, donde se discute este
        ejemplo y se da un método más rápido. En general,
        <span class="strong"><strong>filter-branch</strong></span>
        permite alterar grandes secciones de la historia con un
        solo comando.</p>

        <p>Luego, el directorio <code class=
        "literal">.git/refs/original</code> describe el estado de
        las cosas antes de la operación. Revisa que el comando
        filter-branch hizo lo que querías, y luego borra este
        directorio si deseas ejecutar más comandos
        filter-branch.</p>

        <p>Por último, reemplaza los clones de tu proyecto con tu
        versión revisada si pretendes interactuar con ellos en un
        futuro.</p>
      </div>

      <div class="section" title="Haciendo Historia">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_haciendo_historia"></a>Haciendo Historia</h2>
            </div>
          </div>
        </div>

        <p><a name="makinghistory" id="makinghistory"></a>¿Quieres
        migrar un proyecto a Git? Si está siendo administrado con
        alguno de los sistemas más conocidos, hay grandes
        posibilidades de que alguien haya escrito un script para
        exportar la historia completa a Git.</p>

        <p>Si no lo hay, revisa <span class="strong"><strong>git
        fast-import</strong></span>, que lee una entrada de texto
        en un formato específico para crear una historia de Git
        desde la nada. Típicamente un script que usa este comando
        se acomoda de apuro y se corre una sola vez, migrando el
        proyecto de un solo tiro.</p>

        <p>Como ejemplo, pega el texto a continuación en un archivo
        temporal, como ser <code class=
        "literal">/tmp/history</code>:</p>
        <pre class="screen">
commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Initial commit.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Luego crea un repositorio Git desde este archivo
        temporal escribiendo:</p>
        <pre class="literallayout">
$ mkdir project; cd project; git init
$ git fast-import &lt; /tmp/history
</pre>

        <p>Puedes hacer checkout de la última versión del proyecto
        con:</p>
        <pre class="literallayout">
$ git checkout master .
</pre>

        <p>El comando <span class="strong"><strong>git
        fast-export</strong></span> convierte cualquier repositorio
        de git al formato de <span class="strong"><strong>git
        fast-import</strong></span>, y puedes estudiar su salida
        para escribir exportadores, y también para transportar
        repositorios de git en un formato legible por humanos. De
        hecho estos comandos pueden enviar repositorios de archivos
        de texto sobre canales de solo texto.</p>
      </div>

      <div class="section" title="¿Dónde Nos Equivocamos?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_d_nde_nos_equivocamos"></a>¿Dónde Nos
              Equivocamos?</h2>
            </div>
          </div>
        </div>

        <p>Acabas de descubrir una prestación rota en tu programa,
        y estás seguro que hace unos pocos meses funcionaba. ¡Argh!
        ¿De donde salió este bug? Si solo hubieras ido testeando a
        medida que desarrollabas.</p>

        <p>Es demasiado tarde para eso ahora. De todos modos, dado
        que haz ido haciendo commits seguido, Git puede señalar la
        ubicación del problema.</p>
        <pre class="literallayout">
$ git bisect start
$ git bisect bad SHA1_DE_LA_VERSION_MALA
$ git bisect good SHA1_DE_LA_VERSION_BUENA
</pre>

        <p>Git hace checkout de un estado a mitad de camino. Prueba
        la funcionalidad, y si aún está rota:</p>
        <pre class="literallayout">
$ git bisect bad
</pre>

        <p>Si no lo está, reemplaza "bad" por "good". Git una vez
        más te transporta a un estado en mitad de camino de las
        versiones buena y mala, acortando las posibilidades. Luego
        de algunas iteraciones, esta búsqueda binaria va a llevarte
        al commit que causó el problema. Una vez que hayas
        terminado tu investigación, vuelve a tu estado original
        escribiendo:</p>
        <pre class="literallayout">
$ git bisect reset
</pre>

        <p>En lugar de testear cada cambio a mano, automatiza la
        búsquea escribiendo:</p>
        <pre class="literallayout">
$ git bisect run COMANDO
</pre>

        <p>Git utiliza el valor de retorno del comando dado,
        típicamente un script hecho solo para eso, para decidir si
        un cambio es bueno o malo: el comando debería salir con
        código 0 si es bueno, 125 si el cambio se debería saltear,
        y cualquier cosa entre 1 y 127 si es malo. Un valor
        negativo aborta el bisect.</p>

        <p>Puedes hacer mucho más: la página de ayuda explica como
        visualizar bisects, examinar o reproducir el log de un
        bisect, y eliminar cambios inocentes conocidos para que la
        búsqueda sea más rápida.</p>
      </div>

      <div class="section" title="¿Quién Se Equivocó?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_n_se_equivoc"></a>¿Quién Se Equivocó?</h2>
            </div>
          </div>
        </div>

        <p>Como muchos otros sistemas de control de versiones, Git
        tiene un comando blame:</p>
        <pre class="literallayout">
$ git blame ARCHIVO
</pre>

        <p>que anota cada línea en el archivo dado mostrando quién
        fue el último en cambiarlo y cuando. A diferencia de muchos
        otros sistemas de control de versiones, esta operación
        trabaja desconectada, leyendo solo del disco local.</p>
      </div>

      <div class="section" title="Experiencia Personal">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_experiencia_personal"></a>Experiencia Personal</h2>
            </div>
          </div>
        </div>

        <p>En un sistema de control de versiones centralizado, la
        modificación de la historia es una operación dificultosa, y
        solo disponible para administradores. Clonar, hacer
        branches y merges, es imposible sin comunicación de red. Lo
        mismo para operaciones básicas como explorar la historia, o
        hacer commit de un cambio. En algunos sistemas, los
        usuarios requieren conectividad de red solo para ver sus
        propios cambios o abrir un archivo para edición.</p>

        <p>Los sistemas centralizados no permiten trabajar
        desconectado, y necesitan una infraestructura de red más
        cara, especialmente a medida que aumenta el número de
        desarrolladores. Lo más importante, todas las operaciones
        son más lentas de alguna forma, usualmente al punto donde
        los usuarios evitan comandos avanzados a menos que sean
        absolutamente necesarios. En casos extremos esto se da
        incluso para los comandos más básicos. Cuando los usuarios
        deben correr comandos lentos, la productividad sufre por
        culpa de un flujo de trabajo interrumpido.</p>

        <p>Yo experimenté estos fenómenos de primera mano. Git fue
        el primer sistema de control de versiones que usé. Me
        acostumbré rápidamente a él, dando por ciertas varias
        funcionalidades. Simplemente asumí que otros sistemas eran
        similares: elegir un sistema de control de versiones no
        debería ser diferente de elegir un editor de texto o
        navegador web.</p>

        <p>Cuando me vi obligado a usar un sistema centralizado me
        sorprendí. Una mala conexión a internet importa poco con
        Git, pero hace el desarrollo insoportable cuando se
        necesita que sea confiable como un disco local.
        Adicionalmente me encontré condicionado a evitar ciertos
        comandos por las latencias involucradas, lo que terminó
        evitando que pudiera seguir mi flujo de trabajo
        deseado.</p>

        <p>Cuando tenía que correr un comando lento, la
        interrupción de mi tren de pensamiento generaba una
        cantidad de daño desproporcionada. Mientras esperaba que se
        complete la comunicación con el servidor, hacía alguna otra
        cosa para pasar el tiempo, como revisar el e-mail o
        escribir documentación. A la hora de volver a la tarea
        original, el comando había terminado hace tiempo, y yo
        perdía más tiempo intentando recordar qué era lo que estaba
        haciendo. Los humanos no son buenos para el cambio de
        contexto.</p>

        <p>También había un interesante efecto
        tragediad-de-los-comunes: anticipando la congestión de la
        red, la gente consume más ancho de banda que el necesario
        en varias operaciones, intentando anticipar futuras
        demoras. El esfuerzo combinado intensifica la congestión,
        alentando a las personas a consumir aún más ancho de banda
        la próxima vez para evitar demoras incluso más largas.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 6. Git Multijugador">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_git_multijugador"></a>Capítulo 6. Git
            Multijugador</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href="#_qui_n_soy_yo">¿Quién
          Soy Yo?</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_sobre_ssh_http">Git Sobre SSH,
          HTTP</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_sobre_cualquier_cosa">Git Sobre Cualquier
          Cosa</a></span></dt>

          <dt><span class="section"><a href=
          "#_parches_la_moneda_global">Parches: La Moneda
          Global</a></span></dt>

          <dt><span class="section"><a href=
          "#_lo_siento_nos_hemos_movido">Lo Siento, Nos Hemos
          Movido</a></span></dt>

          <dt><span class="section"><a href="#_ramas_remotas">Ramas
          Remotas</a></span></dt>

          <dt><span class="section"><a href=
          "#_m_ltiples_remotes">Múltiples Remotes</a></span></dt>

          <dt><span class="section"><a href=
          "#_mis_preferencias">Mis Preferencias</a></span></dt>
        </dl>
      </div>

      <p>Inicialmente usaba Git en un proyecto privado donde yo era
      el único desarrollador. Entre los comandos relacionados a la
      naturaleza distribuida de Git, sólo necesitaba <span class=
      "strong"><strong>pull</strong></span> y <span class=
      "strong"><strong>clone</strong></span> así yo podía mantener
      el mismo proyecto en diferentes lugares.</p>

      <p>Más tarde quize publicar mi código con Git, e incluir
      cambios de los contribuyentes. Tuve que aprender a
      administrar proyectos con múltiples desarrolladores de todo
      el mundo. Afortunadamente, esta es la fortaleza de Git, y
      podría decirse que su razón de ser.</p>

      <div class="section" title="¿Quién Soy Yo?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_n_soy_yo"></a>¿Quién Soy Yo?</h2>
            </div>
          </div>
        </div>

        <p>Cada commit tiene un nombre de autor y email, los cuales
        son mostrados por <span class="strong"><strong>git
        log</strong></span>. Por defecto, Git usa la configuración
        del sistema para rellenar estos campos. Para decirle
        explícitamente, escribe:</p>
        <pre class="literallayout">
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</pre>

        <p>Omite la bandera global para poner estas opciones sólo
        para el repositorio actual.</p>
      </div>

      <div class="section" title="Git Sobre SSH, HTTP">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_sobre_ssh_http"></a>Git Sobre SSH, HTTP</h2>
            </div>
          </div>
        </div>

        <p>Supón que tienes acceso SSH a un servidor web, pero Git
        no está instalado. Aunque es menos eficiente que su
        protocolo nativo, Git se puede comuncar por HTTP.</p>

        <p>Descarga, compila e instala Git en tu cuenta, y crea un
        repositorio en tu directorio web:</p>
        <pre class="literallayout">
$ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample hooks/post-update
</pre>

        <p>En versiones antiguas de Git, el comando cp falla y
        debes ejecutar:</p>
        <pre class="literallayout">
$ chmod a+x hooks/post-update
</pre>

        <p>Ahora tú puedes publicar tus últimas ediciones via SSH
        desde cualquier clon:</p>
        <pre class="literallayout">
$ git push web.server:/path/to/proj.git master
</pre>

        <p>y cualquiera puede obtener tu proyecto con:</p>
        <pre class="literallayout">
$ git clone http://web.server/proj.git
</pre>
      </div>

      <div class="section" title="Git Sobre Cualquier Cosa">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_sobre_cualquier_cosa"></a>Git Sobre Cualquier
              Cosa</h2>
            </div>
          </div>
        </div>

        <p>¿Quieres sincronizar repositorios sin servidores, o
        incluso sin conexión de red? ¿Necesitas improvisar durante
        una emergencia? Hemos visto cómo <a class="link" href=
        "#makinghistory"><span class="strong"><strong>git
        fast-export</strong></span> y <span class=
        "strong"><strong>git fast-import</strong></span> pueden
        convertir repositorios a un único archivo y viceversa</a>.
        Podríamos transportar tales archivos de ida y vuelta para
        enviar repositorios git sobre cualquier medio, pero una
        herramienta más eficiente es <span class=
        "strong"><strong>git bundle</strong></span>.</p>

        <p>El emisor crea un <span class=
        "emphasis"><em>paquete</em></span>:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD
</pre>

        <p>luego envía el paquete, <code class=
        "literal">somefile</code>, a la otra parte de alguna forma:
        email, pendrive, una impresión <span class=
        "strong"><strong>xxd</strong></span> y un escáner OCR,
        leyendo bits a través del teléfono, señales de humo, etc.
        El receptor recupera los commits del paquete
        escribiendo:</p>
        <pre class="literallayout">
$ git pull somefile
</pre>

        <p>El receptor puede incluso hacer esto desde un
        repositorio vacío. A pesar de su tamaño, <code class=
        "literal">somefile</code> contiene el repositorio git
        original completo.</p>

        <p>En proyectos más grandes, elimina la basura empaquetando
        sólo los cambios de los que carece el otro repositorio. Por
        ejemplo, supón que el commit “1b6d…” es commit compartido
        más reciente compartido por ambas partes:</p>
        <pre class="literallayout">
$ git bundle create somefile HEAD ^1b6d
</pre>

        <p>Si se hace a menudo, uno puede olvidar fácilmente cual
        commit fue el último enviado. La página de ayuda sugiere
        usar tags para resolver esto. Es decir, después de que
        envías un paquete, escribe:</p>
        <pre class="literallayout">
$ git tag -f lastbundle HEAD
</pre>

        <p>y crea nuevos paquetes de actualización con:</p>
        <pre class="literallayout">
$ git bundle create newbundle HEAD ^lastbundle
</pre>
      </div>

      <div class="section" title="Parches: La Moneda Global">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_parches_la_moneda_global"></a>Parches: La Moneda
              Global</h2>
            </div>
          </div>
        </div>

        <p>Los parches son representaciones de texto de tus cambios
        que pueden ser fácilmente entendidos por computadores y
        humanos por igual. Esto les da una calidad universal.
        Puedes enviar por email un parche a los desarrolladores sin
        importar qué sistema de control de versiones estén usando.
        Mientras tu audiencia pueda leer su email, ella puede ver
        tus ediciones. Similarmente, por tu lado, todo lo que
        requieres es una cuenta de correo: no hay necesidad de
        crear un repositorio Git en línea.</p>

        <p>Recuerda del primer capítulo:</p>
        <pre class="literallayout">
$ git diff 1b6d &gt; my.patch
</pre>

        <p>obtiene un parche que puede se pegado en un email para
        discusión. En un repositorio Git, escribe:</p>
        <pre class="literallayout">
$ git apply &lt; my.patch
</pre>

        <p>para aplicar el parche.</p>

        <p>En un ambiente más formal, cuando los nombres de los
        autores y quizás las firmas deben ser guardadas, genera los
        parches correspondientes pasados un cierto punto
        escribiendo:</p>
        <pre class="literallayout">
$ git format-patch 1b6d
</pre>

        <p>Los archivos resultantes pueden ser enviados a
        <span class=
        "strong"><strong>git-send-email</strong></span>, o enviado
        a mano. También puedes especificar un rango de commits:</p>
        <pre class="literallayout">
$ git format-patch 1b6d..HEAD^^
</pre>

        <p>En el extremo receptor, guarda el mensaje a un archivo,
        luego escribe:</p>
        <pre class="literallayout">
$ git am &lt; email.txt
</pre>

        <p>Esto aplica el parche entrante y también crea el commit,
        incluyendo información tal como el autor.</p>

        <p>Con un cliente de correo, puedes necesitar hacer clic en
        un botón para ver el mensaje en su forma original antes de
        guardar el parche a un archivo.</p>

        <p>Hay algunas ligeras diferencias para los clientes
        basados en casillas de correo, pero si tú usas uno de esos,
        ¡eres probablemente la persona que puede deducirlo
        fácilmente sin leer tutoriales!</p>
      </div>

      <div class="section" title="Lo Siento, Nos Hemos Movido">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_lo_siento_nos_hemos_movido"></a>Lo Siento, Nos
              Hemos Movido</h2>
            </div>
          </div>
        </div>

        <p>Después de clonar un repositorio, correr <span class=
        "strong"><strong>git push</strong></span> o <span class=
        "strong"><strong>git pull</strong></span> hará push hacia o
        pull desde la URL original. ¿Cómo Git hace esto? El secreto
        está en las opciones de configuración creadas con el clone.
        Echemos un vistazo:</p>
        <pre class="literallayout">
$ git config --list
</pre>

        <p>La opción <code class="literal">remote.origin.url</code>
        controla la URL fuente; “origin” es un alias dado al
        repositorio fuente. Al igual que con la convención de la
        rama “master”, podemos cambiar o borrar este alias, pero
        usualmente no hay razón para hacerlo.</p>

        <p>Si el repositorio original se mueve, podemos actualizar
        la URL con:</p>
        <pre class="literallayout">
$ git config remote.origin.url git://new.url/proj.git
</pre>

        <p>La opción <code class=
        "literal">branch.master.merge</code> especifica la rama
        remota por defecto en un <span class="strong"><strong>git
        pull</strong></span>. Durante la clonación inicial, se
        configura a la rama actual del repositorio fuente, incluso
        si el HEAD del repositorio fuente se mueve posteriormente a
        una rama diferente, más tarde un pull va a seguir fielmente
        la rama original.</p>

        <p>Esta opción sólo se aplica al repositorio en la primera
        vez que se clona, que es guardado en la opción <code class=
        "literal">branch.master.remote</code>. Si tiramos desde
        otros repositorios debemos decirle explícitamente que rama
        queremos:</p>
        <pre class="literallayout">
$ git pull git://example.com/other.git master
</pre>

        <p>El ejemplo de más arriba explica por qué algunos de
        nuestros ejemplos anteriores de push y pull no tenían
        argumentos.</p>
      </div>

      <div class="section" title="Ramas Remotas">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_ramas_remotas"></a>Ramas Remotas</h2>
            </div>
          </div>
        </div>

        <p>Cuando clonas un repositorio, también clonas todas sus
        ramas. Tú puedes no haber notado esto porque Git los
        esconde: debes consultar por ellos específicamente. Esto
        evita que las ramas en el repositorio remoto interfieran
        con tus ramas, y también hace a Git más fácil para los
        principiantes.</p>

        <p>Lista las ramas remotas con:</p>
        <pre class="literallayout">
$ git branch -r
</pre>

        <p>Deberías ver algo como esto:</p>
        <pre class="literallayout">
origin/HEAD
origin/master
origin/experimental
</pre>

        <p>Estas representan ramas y el HEAD del repositorio
        remoto, y pueden ser usados en los comandos regulares de
        Git. Por ejemplo, supón que has hecho muchos commits, y
        deseas compararlos con la última versión traída. Tú podrías
        buscar en los registros (logs) por el hash SHA1 adecuado,
        pero es mucho más fácil escribir:</p>
        <pre class="literallayout">
$ git diff origin/HEAD
</pre>

        <p>O puedes ver lo que ha sucedido con la rama
        “experimental”:</p>
        <pre class="literallayout">
$ git log origin/experimental
</pre>
      </div>

      <div class="section" title="Múltiples Remotes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_m_ltiples_remotes"></a>Múltiples Remotes</h2>
            </div>
          </div>
        </div>

        <p>Supón que otros dos desarrolladores están trabajando en
        nuestro proyecto, y queremos mantener pestañas en ambos.
        Podemos seguir más de un repositorio a la vez con:</p>
        <pre class="literallayout">
$ git remote add other git://example.com/some_repo.git
$ git pull other some_branch
</pre>

        <p>Ahora hemos mezclado una rama desde el segundo
        repositorio, y tenemos acceso fácil a todas las ramas de
        todos los repositorios:</p>
        <pre class="literallayout">
$ git diff origin/experimental^ other/some_branch~5
</pre>

        <p>Pero ¿Qué pasa si queremos comparar sus cambios sin
        afectar nuestro propio trabajo? En otras palabras, queremos
        examinar las ramas evitando que sis cambios invadan nuestro
        directorio de trabajo. Entonces, en vez de pull, corre:</p>
        <pre class="literallayout">
$ git fetch        # Fetch from origin, the default.
$ git fetch other  # Fetch from the second programmer.
</pre>

        <p>Esto sólo obtiene historias. Aunque el directorio de
        trabajo permanece intacto, podemos referirnos a cualquier
        rama de cualquier repositorio en un comando Git ya que
        ahora poseemos una copia local.</p>

        <p>Recuerda que detrás de las cámaras, un pull es
        simplemente un <span class=
        "strong"><strong>fetch</strong></span> luego <span class=
        "strong"><strong>merge</strong></span>. Usualmente hacemos
        <span class="strong"><strong>pull</strong></span> porque
        queremos mezclar el último commit después de un fetch; esta
        situación es una excepción notable.</p>

        <p>Vea <span class="strong"><strong>git help
        remote</strong></span> para saber cómo remover
        repositorios, ignorar ciertas ramas, y más.</p>
      </div>

      <div class="section" title="Mis Preferencias">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mis_preferencias"></a>Mis Preferencias</h2>
            </div>
          </div>
        </div>

        <p>En mis proyectos, me gusta que los contribuyentes
        preparen los repositorios desde los cuales voy a hacer
        pull. Algunos servicios de hosting Git te permiten hospedar
        tu propia bifurcación de un proyecto con el clic de un
        botón.</p>

        <p>Después de que obtengo un árbol, uso comandos Git para
        navegar y examinar los cambios, los que idealmente están
        bien organizados y biein descritos. Mezclo mis propios
        cambios, y quizás hago más ediciones. Una vez satisfecho,
        los empujo al repositorio principal.</p>

        <p>Aunque rara vez recibo contribuciones, creo que este
        enfoque escala bien. Vea <a class="ulink" href=
        "http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html"
        target=
        "_top">http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html</a>
        [esta entrada de blog por Linus Torvalds].</p>

        <p>Permanecer en el mundo Git es ligeramente más
        conveniente que parchar archivos, dado que me ahorra
        convertirlos a commits de Git. Además, Git maneja detalles
        como grabar el nombre y dirección de email del autor, así
        como la hora y fecha, y le pide al autor desdribir sus
        propios cambios.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 7. Gran Maestría en Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_gran_maestr_a_en_git"></a>Capítulo 7. Gran Maestría
            en Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_lanzamientos_de_c_digo">Lanzamientos de
          Código</a></span></dt>

          <dt><span class="section"><a href=
          "#_commit_de_lo_que_cambi">Commit De Lo Que
          Cambió</a></span></dt>

          <dt><span class="section"><a href=
          "#_mi_commit_es_muy_grande">¡Mi Commit Es Muy
          Grande!</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href=
              "#_cambios_en_el_emphasis_stage_emphasis">Cambios en
              el <span class=
              "emphasis"><em>stage</em></span></a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href=
          "#_no_pierdas_la_cabeza">No Pierdas La
          Cabeza</a></span></dt>

          <dt><span class="section"><a href=
          "#_cazando_cabezas">Cazando Cabezas</a></span></dt>

          <dt><span class="section"><a href=
          "#_construyendo_sobre_git">Construyendo sobre
          Git</a></span></dt>

          <dt><span class="section"><a href=
          "#_acrobacias_peligrosas">Acrobacias
          Peligrosas</a></span></dt>

          <dt><span class="section"><a href=
          "#_mejora_tu_imagen_p_blica">Mejora Tu Imagen
          Pública</a></span></dt>
        </dl>
      </div>

      <p>Esta página con nombre pretencioso es el cajón donde dejar
      los trucos de Git no categorizados.</p>

      <div class="section" title="Lanzamientos de Código">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_lanzamientos_de_c_digo"></a>Lanzamientos de
              Código</h2>
            </div>
          </div>
        </div>

        <p>Para mis proyectos, Git controla únicamente los ficheros
        que me gustaría archivar y enviar a los usuarios. Para
        crear un tarball del código fuente, ejecuto:</p>
        <pre class="literallayout">
$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" title="Commit De Lo Que Cambió">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_commit_de_lo_que_cambi"></a>Commit De Lo Que
              Cambió</h2>
            </div>
          </div>
        </div>

        <p>Decirle a Git cuándo agregaste, eliminaste o renombraste
        archivos es complicado para ciertos proyectos. En cambio,
        puedes escribir:</p>
        <pre class="literallayout">
$ git add .
$ git add -u
</pre>

        <p>Git va a mirar los archivos en el directorio actual y
        resolver los detalles por si mismo. En lugar del segundo
        comando add, corre <code class="literal">git commit
        -a</code> si estás en condiciones de hacer commit. Ver en
        <span class="strong"><strong>git help
        ignore</strong></span> como especificar archivos que
        deberían ser ignorados.</p>

        <p>Puedes hacer lo de arriba en un único paso con:</p>
        <pre class="literallayout">
$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>Las opciones <span class=
        "strong"><strong>-z</strong></span> y <span class=
        "strong"><strong>-0</strong></span> previenen efectos
        secundarios adversos de archivos que contienen caracteres
        extraños. Como este comando agrega archivos ignorados,
        podrías querer usar la opción <code class=
        "literal">-x</code> or <code class="literal">-X</code>.</p>
      </div>

      <div class="section" title="¡Mi Commit Es Muy Grande!">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mi_commit_es_muy_grande"></a>¡Mi Commit Es Muy
              Grande!</h2>
            </div>
          </div>
        </div>

        <p>¿Postergaste hacer un commit por demasiado tiempo?
        ¿Estabas enfervorizado escribiendo código y te olvidaste
        del control de fuentes hasta ahora? ¿Hiciste una serie de
        cambios no relacionados, simplemente porque es tu
        estilo?</p>

        <p>No te preocupes, ejecuta:</p>
        <pre class="literallayout">
$ git add -p
</pre>

        <p>Por cada edición que hiciset, Git va a mostrar el pedazo
        de código que fue cambiado, y preguntar si debería ser
        parte del próximo commit. Contesta con "y" o "n". Hay otras
        opciones, como posponer la decisión; escribe "?" para saber
        más.</p>

        <p>Una vez satisfecho, escribe</p>
        <pre class="literallayout">
$ git commit
</pre>

        <p>para hacer un commit que solo contiene los cambios
        seleccionados (los cambios <span class=
        "emphasis"><em>staged</em></span>). Asegúrate de omitir la
        opción <span class="strong"><strong>-a</strong></span>, o
        Git va a poner todo lo editado en el commit.</p>

        <p>¿Que pasa si editaste varios archivos en varios lugares?
        Revisar cada cambio uno por uno se vuelve frustrante y
        adormecedor. En este caso, usa <span class=
        "strong"><strong>git add -i</strong></span>, cuya interfaz
        es menos clara pero más flexible. Con solo presionar un par
        de teclas, puedes poner o sacar del <span class=
        "emphasis"><em>stage</em></span> varios archivos a la vez,
        o revisar y seleccionar cambios solamente en archivos
        particulares. Como alternativa se puede usar <span class=
        "strong"><strong>git commit --interactive</strong></span>,
        el cual hace commit luego de que terminas.</p>

        <div class="section" title="Cambios en el stage">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name=
                "_cambios_en_el_emphasis_stage_emphasis"></a>Cambios
                en el <span class=
                "emphasis"><em>stage</em></span></h3>
              </div>
            </div>
          </div>

          <p>Hasta ahora hemos evitado el famoso <span class=
          "emphasis"><em>indice</em></span> de git, pero ahora
          debermos enfrentarlo para explicar lo de arriba. El
          indice es un area temporal de montaje. Git evita enviar
          datos directamente entre tu proyecto y su historia. En su
          lugar, Git primero escribe datos al índice, y luego copia
          los datos del índice a su destino final.</p>

          <p>Por ejemplo, <span class="strong"><strong>commit
          -a</strong></span> es en realidad un proceso de 2 pasos.
          El primer paso pone una foto del estado actual de cada
          archivo administrado en el índice. El segundo paso graba
          de forma permanente esa foto que está en el índice. Un
          commit hecho sin <span class=
          "strong"><strong>-a</strong></span> solo efectúa el
          segundo paso, y solo tiene sentido luego de haber
          ejecutado comandos que de alguna forma alteran el índice,
          como <span class="strong"><strong>git
          add</strong></span>.</p>

          <p>Usualmente podemos ignorar el índice y pretender que
          estamos leyendo y escribiendo directo en la historia. En
          esta ocasión, queremos un control más fino de lo que se
          escribe en la historia, y nos vemos forzados a manipular
          el índice. Guardamos una foto de algunos, pero no todos,
          de nuestros cambios en el índice, y luego grabamos de
          forma permanenta esta instantánea cuidadosamente
          organizada.</p>
        </div>
      </div>

      <div class="section" title="No Pierdas La Cabeza">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_no_pierdas_la_cabeza"></a>No Pierdas La Cabeza</h2>
            </div>
          </div>
        </div>

        <p>El tag HEAD (Cabeza) es como un cursor que normalmente
        apunta al último commit, avanzando con cada nuevo commit.
        Algunos comandos de Git te dejan moverlo. Por ejemplo:</p>
        <pre class="literallayout">
$ git reset HEAD~3
</pre>

        <p>mueve el HEAD tres commits hacia atrás. Por lo tanto
        todos los comandos de Git ahora actúan como si no hubieras
        hecho esos últimos tres commits, mientras tus archivos
        permanecen en el presente. Ver la página de ayuda para
        algunas aplicaciones.</p>

        <p>¿Como hago para volver al futuro? Los commits del pasado
        nada saben del futuro.</p>

        <p>Teniendo el SHA1 del HEAD original, hacemos:</p>
        <pre class="literallayout">
$ git reset SHA1
</pre>

        <p>Pero supongamos que nunca lo anotaste. No te preocupes,
        para comandos como este, Git guarda el HEAD original como
        un tag llamado ORIG_HEAD, y puedes volver sano y salvo
        con:</p>
        <pre class="literallayout">
$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" title="Cazando Cabezas">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_cazando_cabezas"></a>Cazando Cabezas</h2>
            </div>
          </div>
        </div>

        <p>Quizás ORIG_HEAD no es suficiente. Quizás acabas de
        descubrir que cometiste un error monumental y que hay que
        volver a un commit antiguo en una rama olvidada hace largo
        tiempo.</p>

        <p>Por defecto, Git guarda un commit por al menos 2
        semanas, incluso si le ordenaste destruir la rama que lo
        contenía. El problema es encontra el hash apropiado.
        Podrías mirar todos los hashes en <code class=
        "literal">.git/objects</code> y usar prueba y error para
        encontrar el que buscas. Pero hay una forma mucho más
        fácil.</p>

        <p>Git guarda el hash de cada commit que hace en
        <code class="literal">.git/logs</code>. El subdirectorio
        <code class="literal">refs</code> contiene la historia de
        la actividad en todas las ramas, mientras que el archivo
        <code class="literal">HEAD</code> tiene cada hash que
        alguna vez ha tomado. Este último puede usarse para
        encontrar hashes de commits en branches que se han borrado
        de manera accidental.</p>

        <p>El comando reflog provee una interfaz amigable para
        estos logs. Prueba</p>
        <pre class="literallayout">
$ git reflog
</pre>

        <p>En lugar de cortar y pegar hashes del reflog,
        intenta:</p>
        <pre class="literallayout">
$ git checkout "@{10 minutes ago}"
</pre>

        <p>O prueba un checkout del 5to commit que visitaste hacia
        atrás:</p>
        <pre class="literallayout">
$ git checkout "@{5}"
</pre>

        <p>Ver la sección “Specifying Revisions” de <span class=
        "strong"><strong>git help rev-parse</strong></span> por mas
        datos.</p>

        <p>Podrías querer configurar un periodo de gracia mayor
        para los commits condenados. Por ejemplo:</p>
        <pre class="literallayout">
$ git config gc.pruneexpire "30 days"
</pre>

        <p>significa que un commmit eliminado se va a perder de
        forma permanente solo cuando hayan pasado 30 dáis y se
        ejecute <span class="strong"><strong>git
        gc</strong></span>.</p>

        <p>También podrías querer deshabilitar invocaciones
        automáticas de <span class="strong"><strong>git
        gc</strong></span>:</p>
        <pre class="literallayout">
$ git config gc.auto 0
</pre>

        <p>en cuyo caso los commits solo serán borrados cuando
        ejecutes <span class="strong"><strong>git
        gc</strong></span> de forma manual.</p>
      </div>

      <div class="section" title="Construyendo sobre Git">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_construyendo_sobre_git"></a>Construyendo sobre
              Git</h2>
            </div>
          </div>
        </div>

        <p>Siguiendo la tradición UNIX, el diseño de Git permite
        ser facilmente usado como un componente de bajo nivel de
        otros programas, como GUI e interfaces web, interfaces de
        linea de comandos alternativas, herramientas de manejo de
        patches, herramientas de importación y conversión, etc. De
        hecho, algunos de los comandos de Git son ellos mismos
        scripts parados sobre los hombros de gigantes. Con unos
        pocos ajustes, puedes personalizar Git para cubrir tus
        necesidades.</p>

        <p>Un truco simple es usar los alias incluidos en git para
        acortar los comandos usados de forma más frecuente:</p>
        <pre class="literallayout">
$ git config --global alias.co checkout
$ git config --global --get-regexp alias  # muestra los alias actuales
alias.co checkout
$ git co foo                              # igual a 'git checkout foo'
</pre>

        <p>Otro es imprimir la rama actual en el prompt, o en el
        título de la ventana.</p>

        <p>Usar</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD
</pre>

        <p>muestra el nombre de la rama actual. En la práctica, es
        probable que quieras quitar el "refs/heads/" e ignorar los
        errores:</p>
        <pre class="literallayout">
$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>El subdirectorio <code class="literal">contrib</code> es
        la cueva de los tesoros de las herramientas hechas con Git.
        Con tiempo, algunas de ellas pueden ser promovidas a
        comandos oficiales. En Debian y Ubuntu, este directorio
        está en <code class=
        "literal">/usr/share/doc/git-core/contrib</code>.</p>

        <p>Un residente popular es <code class=
        "literal">workdir/git-new-workdir</code>. Usando symlinks
        inteligentes, este script crea un nuevo directorio de
        trabajo cuya historia es compartida con el repositorio
        original: $ git-new-workdir repositorio/existente
        nuevo/directorio</p>

        <p>El nuevo directorio y sus archivos interiores pueden ser
        vistos como un clon, excepto que como la historia es
        compartida, ambos árboles se mantienen sincronizados de
        forma automática. No hay necesidad de merges, push ni
        pull.</p>
      </div>

      <div class="section" title="Acrobacias Peligrosas">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_acrobacias_peligrosas"></a>Acrobacias
              Peligrosas</h2>
            </div>
          </div>
        </div>

        <p>En estos dias, Git hace difícil que el usuario destruya
        datos de manera accidental. Pero si sabes lo que estás
        haciendo, puedes hacer caso omiso de las trabas de
        seguridad para los comandos comunes.</p>

        <p><span class="strong"><strong>Checkout</strong></span>:
        Los cambios no commiteados hacen que checkout falle. Para
        destruir tus cambios, y hacer checkout de un commit dado,
        usa la opción de forzar:</p>
        <pre class="literallayout">
$ git checkout -f COMMIT
</pre>

        <p>Por otro lado, si especificas una ruta específica para
        hacer checkout, no hay chequeos de seguridad. Las rutas
        suministradas son sobre-escritas de forma silenciosa. Hay
        que tener cuidado al usar checkout de esta forma:</p>

        <p><span class="strong"><strong>Reset</strong></span>:
        Reset también falla en presencia de cambios sin commmitear.
        Para hacerlo a la fuerza, ejecuta:</p>
        <pre class="literallayout">
$ git reset --hard [COMMIT]
</pre>

        <p><span class="strong"><strong>Branch</strong></span>: El
        borrado de una rama falla si esto causa que se pierdan
        cambios, para forzarlo escribe:</p>
        <pre class="literallayout">
$ git branch -D BRANCH  # en lugar de -d
</pre>

        <p>De forma similar, intentar sobreescribir una rama
        moviendo otra, falla si esto resultase en pérdida de datos.
        Para forzar el mover una rama, corre:</p>
        <pre class="literallayout">
  $ git branch -M [ORIGEN] DESTINO  # en lugar de -m
A diferencia de checkout y reset, estos dos comandos evitan la destrucción de datos.
Los cambios están aún guardados en el subdirectorio .git, y pueden obtenerse
recuperando el has apropiado de `.git/logs` (ver "Cazando Cabezas" arriba).
Por defecto, serán guardados por al menos dos semanas.
</pre>

        <p><span class="strong"><strong>Clean</strong></span>:
        Algunos comandos de Git se rehúsan a proceder porque están
        preocupados de destruir archivos no monitoreados. Si tienes
        la certeza de que todos los archivos y directorios sin
        monitorear son prescindibles, se pueden borrar sin piedad
        con:</p>
        <pre class="literallayout">
$ git clean -f -d
</pre>

        <p>¡La próxima vez, ese comando molesto va a funcionar!</p>
      </div>

      <div class="section" title="Mejora Tu Imagen Pública">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_mejora_tu_imagen_p_blica"></a>Mejora Tu Imagen
              Pública</h2>
            </div>
          </div>
        </div>

        <p>Los errores estúpidos abundan en la historia de muchos
        proyectos. El más preocupante son los archivos perdidos por
        el olvido de ejecutar <span class="strong"><strong>git
        add</strong></span>. Por suerte nunca perdí datos cruciales
        por omisión accidental, dado que muy rara vez elimino
        directorios de trabajo originales. Lo normal es que note el
        error un par de commits mas adelante, por lo que el único
        daño es un poco de historia perdida y el tener que admitir
        la culpa.</p>

        <p>También me preocupo por no tenes espacios en blanco al
        final de las líneas. Aunque son inofensivos, procuro que
        nunca aparezcan en la historia pública.</p>

        <p>Además, si bien nunca me sucedió, me preocupo por no
        dejar conflictos de merge sin resolver. Usualmente los
        descubro al compilar el proyecto, pero hay algunos casos en
        los que se puede no notar.</p>

        <p>Es útil comprar un seguro contra la idiotez, usando un
        <span class="emphasis"><em>hook</em></span> para alertarme
        de estos problemas:</p>
        <pre class="literallayout">
$ cd .git/hooks
$ cp pre-commit.sample pre-commit  # En versiones mas viejas de Git: chmod +x pre-commit
</pre>

        <p>Ahora Git aborta un commit si se detectan espacios
        inútiles en blanco o conflictos de merge sin resolver.</p>

        <p>Para esta guía, eventualmente agregué lo siguiente al
        inicio del hook <span class=
        "strong"><strong>pre-commit</strong></span>, pare
        prevenirme de la desatención.</p>
        <pre class="literallayout">
if git ls-files -o | grep '\.txt$'; then
  echo FALLA! Archivos .txt sin monitorear.
  exit 1
fi
</pre>

        <p>Varias operaciones de git soportan hooks; ver
        <span class="strong"><strong>git help
        hooks</strong></span>. Se pueden escribir hooks para
        quejarse de errores ortográficos en los mensajes de commit,
        agregar nuevos archivos, indentar párrafos, agregar una
        entrada en una página, reproducir un sonido, etc.</p>

        <p>Habíamos encontrado el hook <span class=
        "strong"><strong>post-update</strong></span> antes, cuando
        discutíamos como usar Git sobre HTTP. Este hook actualiza
        algunos archivos que Git necesita para comunicación no
        nativa.</p>
      </div>
    </div>

    <div class="chapter" title="Capítulo 8. Secrets Revealed">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_secrets_revealed"></a>Capítulo 8. Secrets
            Revealed</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_invisibility">Invisibility</a></span></dt>

          <dt><span class="section"><a href=
          "#_integrity">Integrity</a></span></dt>

          <dt><span class="section"><a href=
          "#_intelligence">Intelligence</a></span></dt>

          <dt><span class="section"><a href=
          "#_indexing">Indexing</a></span></dt>

          <dt><span class="section"><a href=
          "#_git_8217_s_origins">Git’s Origins</a></span></dt>

          <dt><span class="section"><a href=
          "#_the_object_database">The Object
          Database</a></span></dt>

          <dt><span class="section"><a href=
          "#_blobs">Blobs</a></span></dt>

          <dt><span class="section"><a href=
          "#_trees">Trees</a></span></dt>

          <dt><span class="section"><a href=
          "#_commits">Commits</a></span></dt>

          <dt><span class="section"><a href=
          "#_indistinguishable_from_magic">Indistinguishable From
          Magic</a></span></dt>
        </dl>
      </div>

      <p>We take a peek under the hood and explain how Git performs
      its miracles. I will skimp over details. For in-depth
      descriptions refer to <a class="ulink" href=
      "http://www.kernel.org/pub/software/scm/git/docs/user-manual.html"
      target="_top">the user manual</a>.</p>

      <div class="section" title="Invisibility">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_invisibility"></a>Invisibility</h2>
            </div>
          </div>
        </div>

        <p>How can Git be so unobtrusive? Aside from occasional
        commits and merges, you can work as if you were unaware
        that version control exists. That is, until you need it,
        and that’s when you’re glad Git was watching over you the
        whole time.</p>

        <p>Other version control systems force you to constantly
        struggle with red tape and bureaucracy. Permissions of
        files may be read-only unless you explicitly tell a central
        server which files you intend to edit. The most basic
        commands may slow to a crawl as the number of users
        increases. Work grinds to a halt when the network or the
        central server goes down.</p>

        <p>In contrast, Git simply keeps the history of your
        project in the <code class="literal">.git</code> directory
        in your working directory. This is your own copy of the
        history, so you can stay offline until you want to
        communicate with others. You have total control over the
        fate of your files because Git can easily recreate a saved
        state from <code class="literal">.git</code> at any
        time.</p>
      </div>

      <div class="section" title="Integrity">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_integrity"></a>Integrity</h2>
            </div>
          </div>
        </div>

        <p>Most people associate cryptography with keeping
        information secret, but another equally important goal is
        keeping information safe. Proper use of cryptographic hash
        functions can prevent accidental or malicious data
        corruption.</p>

        <p>A SHA1 hash can be thought of as a unique 160-bit ID
        number for every string of bytes you’ll encounter in your
        life. Actually more than that: every string of bytes that
        any human will ever use over many lifetimes.</p>

        <p>As a SHA1 hash is itself a string of bytes, we can hash
        strings of bytes containing other hashes. This simple
        observation is surprisingly useful: look up <span class=
        "emphasis"><em>hash chains</em></span>. We’ll later see how
        Git uses it to efficiently guarantee data integrity.</p>

        <p>Briefly, Git keeps your data in the <code class=
        "literal">.git/objects</code> subdirectory, where instead
        of normal filenames, you’ll find only IDs. By using IDs as
        filenames, as well as a few lockfiles and timestamping
        tricks, Git transforms any humble filesystem into an
        efficient and robust database.</p>
      </div>

      <div class="section" title="Intelligence">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_intelligence"></a>Intelligence</h2>
            </div>
          </div>
        </div>

        <p>How does Git know you renamed a file, even though you
        never mentioned the fact explicitly? Sure, you may have run
        <span class="strong"><strong>git mv</strong></span>, but
        that is exactly the same as a <span class=
        "strong"><strong>git rm</strong></span> followed by a
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git heuristically ferrets out renames and copies between
        successive versions. In fact, it can detect chunks of code
        being moved or copied around between files! Though it
        cannot cover all cases, it does a decent job, and this
        feature is always improving. If it fails to work for you,
        try options enabling more expensive copy detection, and
        consider upgrading.</p>
      </div>

      <div class="section" title="Indexing">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_indexing"></a>Indexing</h2>
            </div>
          </div>
        </div>

        <p>For every tracked file, Git records information such as
        its size, creation time and last modification time in a
        file known as the <span class=
        "emphasis"><em>index</em></span>. To determine whether a
        file has changed, Git compares its current stats with those
        cached in the index. If they match, then Git can skip
        reading the file again.</p>

        <p>Since stat calls are considerably faster than file
        reads, if you only edit a few files, Git can update its
        state in almost no time.</p>

        <p>We stated earlier that the index is a staging area. Why
        is a bunch of file stats a staging area? Because the add
        command puts files into Git’s database and updates these
        stats, while the commit command, without options, creates a
        commit based only on these stats and the files already in
        the database.</p>
      </div>

      <div class="section" title="Git’s Origins">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_git_8217_s_origins"></a>Git’s Origins</h2>
            </div>
          </div>
        </div>

        <p>This <a class="ulink" href=
        "http://lkml.org/lkml/2005/4/6/121" target="_top">Linux
        Kernel Mailing List post</a> describes the chain of events
        that led to Git. The entire thread is a fascinating
        archaeological site for Git historians.</p>
      </div>

      <div class="section" title="The Object Database">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_the_object_database"></a>The Object Database</h2>
            </div>
          </div>
        </div>

        <p>Every version of your data is kept in the <span class=
        "emphasis"><em>object database</em></span>, which lives in
        the subdirectory <code class="literal">.git/objects</code>;
        the other residents of <code class="literal">.git/</code>
        hold lesser data: the index, branch names, tags,
        configuration options, logs, the current location of the
        head commit, and so on. The object database is elementary
        yet elegant, and the source of Git’s power.</p>

        <p>Each file within <code class=
        "literal">.git/objects</code> is an <span class=
        "emphasis"><em>object</em></span>. There are 3 kinds of
        objects that concern us: <span class=
        "emphasis"><em>blob</em></span> objects, <span class=
        "emphasis"><em>tree</em></span> objects, and <span class=
        "emphasis"><em>commit</em></span> objects.</p>
      </div>

      <div class="section" title="Blobs">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_blobs"></a>Blobs</h2>
            </div>
          </div>
        </div>

        <p>First, a magic trick. Pick a filename, any filename. In
        an empty directory:</p>
        <pre class="literallayout">
$ echo sweet &gt; YOUR_FILENAME
$ git init
$ git add .
$ find .git/objects -type f
</pre>

        <p>You’ll see <code class=
        "literal">.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d</code>.</p>

        <p>How do I know this without knowing the filename? It’s
        because the SHA1 hash of:</p>
        <pre class="literallayout">
"blob" SP "6" NUL "sweet" LF
</pre>

        <p>is aa823728ea7d592acc69b36875a482cdf3fd5c8d, where SP is
        a space, NUL is a zero byte and LF is a linefeed. You can
        verify this by typing:</p>
        <pre class="literallayout">
$ printf "blob 6\000sweet\n" | sha1sum
</pre>

        <p>Git is <span class=
        "emphasis"><em>content-addressable</em></span>: files are
        not stored according to their filename, but rather by the
        hash of the data they contain, in a file we call a
        <span class="emphasis"><em>blob object</em></span>. We can
        think of the hash as a unique ID for a file’s contents, so
        in a sense we are addressing files by their content. The
        initial <code class="literal">blob 6</code> is merely a
        header consisting of the object type and its length in
        bytes; it simplifies internal bookkeeping.</p>

        <p>Thus I could easily predict what you would see. The
        file’s name is irrelevant: only the data inside is used to
        construct the blob object.</p>

        <p>You may be wondering what happens to identical files.
        Try adding copies of your file, with any filenames
        whatsoever. The contents of <code class=
        "literal">.git/objects</code> stay the same no matter how
        many you add. Git only stores the data once.</p>

        <p>By the way, the files within <code class=
        "literal">.git/objects</code> are compressed with zlib so
        you should not stare at them directly. Filter them through
        <a class="ulink" href="http://www.zlib.net/zpipe.c" target=
        "_top">zpipe -d</a>, or type:</p>
        <pre class="literallayout">
$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>which pretty-prints the given object.</p>
      </div>

      <div class="section" title="Trees">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_trees"></a>Trees</h2>
            </div>
          </div>
        </div>

        <p>But where are the filenames? They must be stored
        somewhere at some stage. Git gets around to the filenames
        during a commit:</p>
        <pre class="literallayout">
$ git commit  # Type some message.
$ find .git/objects -type f
</pre>

        <p>You should now see 3 objects. This time I cannot tell
        you what the 2 new files are, as it partly depends on the
        filename you picked. We’ll proceed assuming you chose
        “rose”. If you didn’t, you can rewrite history to make it
        look like you did:</p>
        <pre class="literallayout">
$ git filter-branch --tree-filter 'mv YOUR_FILENAME rose'
$ find .git/objects -type f
</pre>

        <p>Now you should see the file <code class=
        "literal">.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9</code>,
        because this is the SHA1 hash of its contents:</p>
        <pre class="literallayout">
"tree" SP "32" NUL "100644 rose" NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d
</pre>

        <p>Check this file does indeed contain the above by
        typing:</p>
        <pre class="literallayout">
$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch
</pre>

        <p>With zpipe, it’s easy to verify the hash:</p>
        <pre class="literallayout">
$ zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum
</pre>

        <p>Hash verification is trickier via cat-file because its
        output contains more than the raw uncompressed object
        file.</p>

        <p>This file is a <span class=
        "emphasis"><em>tree</em></span> object: a list of tuples
        consisting of a file type, a filename, and a hash. In our
        example, the file type is 100644, which means ‘rose` is a
        normal file, and the hash is the blob object that contains
        the contents of `rose’. Other possible file types are
        executables, symlinks or directories. In the last case, the
        hash points to a tree object.</p>

        <p>If you ran filter-branch, you’ll have old objects you no
        longer need. Although they will be jettisoned automatically
        once the grace period expires, we’ll delete them now to
        make our toy example easier to follow:</p>
        <pre class="literallayout">
$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune
</pre>

        <p>For real projects you should typically avoid commands
        like this, as you are destroying backups. If you want a
        clean repository, it is usually best to make a fresh clone.
        Also, take care when directly manipulating <code class=
        "literal">.git</code>: what if a Git command is running at
        the same time, or a sudden power outage occurs? In general,
        refs should be deleted with <span class=
        "strong"><strong>git update-ref -d</strong></span>, though
        usually it’s safe to remove <code class=
        "literal">refs/original</code> by hand.</p>
      </div>

      <div class="section" title="Commits">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_commits"></a>Commits</h2>
            </div>
          </div>
        </div>

        <p>We’ve explained 2 of the 3 objects. The third is a
        <span class="emphasis"><em>commit</em></span> object. Its
        contents depend on the commit message as well as the date
        and time it was created. To match what we have here, we’ll
        have to tweak it a little:</p>
        <pre class="literallayout">
$ git commit --amend -m Shakespeare  # Change the commit message.
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # Rig timestamps and authors.
$ find .git/objects -type f
</pre>

        <p>You should now see <code class=
        "literal">.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187</code>
        which is the SHA1 hash of its contents:</p>
        <pre class="literallayout">
"commit 158" NUL
"tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9" LF
"author Alice &lt;alice@example.com&gt; 1234567890 -0800" LF
"committer Bob &lt;bob@example.com&gt; 1234567890 -0800" LF
LF
"Shakespeare" LF
</pre>

        <p>As before, you can run zpipe or cat-file to see for
        yourself.</p>

        <p>This is the first commit, so there are no parent
        commits, but later commits will always contain at least one
        line identifying a parent commit.</p>
      </div>

      <div class="section" title="Indistinguishable From Magic">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_indistinguishable_from_magic"></a>Indistinguishable
              From Magic</h2>
            </div>
          </div>
        </div>

        <p>Git’s secrets seem too simple. It looks like you could
        mix together a few shell scripts and add a dash of C code
        to cook it up in a matter of hours: a melange of basic
        filesystem operations and SHA1 hashing, garnished with lock
        files and fsyncs for robustness. In fact, this accurately
        describes the earliest versions of Git. Nonetheless, apart
        from ingenious packing tricks to save space, and ingenious
        indexing tricks to save time, we now know how Git deftly
        changes a filesystem into a database perfect for version
        control.</p>

        <p>For example, if any file within the object database is
        corrupted by a disk error, then its hash will no longer
        match, alerting us to the problem. By hashing hashes of
        other objects, we maintain integrity at all levels. Commits
        are atomic, that is, a commit can never only partially
        record changes: we can only compute the hash of a commit
        and store it in the database after we already have stored
        all relevant trees, blobs and parent commits. The object
        database is immune to unexpected interruptions such as
        power outages.</p>

        <p>We defeat even the most devious adversaries. Suppose
        somebody attempts to stealthily modify the contents of a
        file in an ancient version of a project. To keep the object
        database looking healthy, they must also change the hash of
        the corresponding blob object since it’s now a different
        string of bytes. This means they’ll have to change the hash
        of any tree object referencing the file, and in turn change
        the hash of all commit objects involving such a tree, in
        addition to the hashes of all the descendants of these
        commits. This implies the hash of the official head differs
        to that of the bad repository. By following the trail of
        mismatching hashes we can pinpoint the mutilated file, as
        well as the commit where it was first corrupted.</p>

        <p>In short, so long as the 20 bytes representing the last
        commit are safe, it’s impossible to tamper with a Git
        repository.</p>

        <p>What about Git’s famous features? Branching? Merging?
        Tags? Mere details. The current head is kept in the file
        <code class="literal">.git/HEAD</code>, which contains a
        hash of a commit object. The hash gets updated during a
        commit as well as many other commands. Branches are almost
        the same: they are files in <code class=
        "literal">.git/refs/heads</code>. Tags too: they live in
        <code class="literal">.git/refs/tags</code> but they are
        updated by a different set of commands.</p>
      </div>
    </div>

    <div class="appendix" title="Apéndice A. Defectos de Git">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_defectos_de_git"></a>Apéndice A. Defectos de Git</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Tabla de contenidos</b></p>

        <dl>
          <dt><span class="section"><a href=
          "#_debilidades_de_sha1">Debilidades De
          SHA1</a></span></dt>

          <dt><span class="section"><a href=
          "#_microsoft_windows">Microsoft Windows</a></span></dt>

          <dt><span class="section"><a href=
          "#_archivos_no_relacionados">Archivos No
          Relacionados</a></span></dt>

          <dt><span class="section"><a href=
          "#_qui_n_edita_qu">¿Quién Edita Qué?</a></span></dt>

          <dt><span class="section"><a href=
          "#_historia_por_archivo">Historia Por
          Archivo</a></span></dt>

          <dt><span class="section"><a href=
          "#_clonado_inicial">Clonado inicial</a></span></dt>

          <dt><span class="section"><a href=
          "#_proyectos_vol_tiles">Proyectos
          Volátiles</a></span></dt>

          <dt><span class="section"><a href=
          "#_contador_global">Contador Global</a></span></dt>

          <dt><span class="section"><a href=
          "#_subdirectorios_vac_os">Subdirectorios
          Vacíos</a></span></dt>

          <dt><span class="section"><a href=
          "#_commit_inicial">Commit Inicial</a></span></dt>

          <dt><span class="section"><a href=
          "#_rarezas_de_la_interfaz">Rarezas De La
          Interfaz</a></span></dt>
        </dl>
      </div>

      <p>Hay algunos problema con Git que barrí bajo la alfombra.
      Algunos pueden ser manejados con facilidad utilizando scripts
      y hooks, otros requieren reorganizar or redefinir el
      proyecto, y por las molestias que quedan, uno simplemente va
      a tener que esperar. ¡O mejor aún, unirse y ayudar!</p>

      <div class="section" title="Debilidades De SHA1">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_debilidades_de_sha1"></a>Debilidades De SHA1</h2>
            </div>
          </div>
        </div>

        <p>A medida que pasa el tiempo, los criptógrafos descubren
        más y más debilidades de SHA1. Al día de hoy, encontrar
        colisiones en los hashes es feasible para organizaciones
        con buenos fondos. En unos años, quizás incluso una PC
        típica tendrá suficiente poder de cómputo para corromper un
        repositorio de Git de manera silenciosa.</p>

        <p>Esperemos que Git migre a una función de hash mejor
        antes de que nuevas investigaciones destruyan el SHA1.</p>
      </div>

      <div class="section" title="Microsoft Windows">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_microsoft_windows"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Git en Microsoft Windows puede ser engorroso:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" type="disc">
            <li class="listitem"><a class="ulink" href=
            "http://cygwin.com/" target="_top">Cygwin</a>, un
            ambiente similar a Linux para Windows, contiene
            <a class="ulink" href="http://cygwin.com/packages/git/"
            target="_top">una versión de Git para Windows</a>.</li>

            <li class="listitem"><a class="ulink" href=
            "http://code.google.com/p/msysgit/" target="_top">Git
            en MSys</a> es una alternativa que requiere un soporte
            mínimo para la ejecución, aunqeu algunos de los
            comandos necesitan cierto trabajo.</li>
          </ul>
        </div>
      </div>

      <div class="section" title="Archivos No Relacionados">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_archivos_no_relacionados"></a>Archivos No
              Relacionados</h2>
            </div>
          </div>
        </div>

        <p>Si tu proyecto es muy grande y contiene muchos archivos
        no relacionados que están siendo cambiados de manera
        constante, Git puede estar en desventaja ante otros
        sistemas, porque no se monitorean archivos simples. Git
        maneja proyectos enteros, lo cual suele ser
        beneficioso.</p>

        <p>Una solución es partir tu proyecto en pedazos, cada uno
        consistiendo de archivos relacionados. Usa <span class=
        "strong"><strong>git submodule</strong></span> si quieres
        mantener todo en un único repositorio.</p>
      </div>

      <div class="section" title="¿Quién Edita Qué?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_qui_n_edita_qu"></a>¿Quién Edita Qué?</h2>
            </div>
          </div>
        </div>

        <p>Algunos sistemas de control de versiones te fuerzan a
        marcar un archivo de manera explícita antes de editarlo. Si
        bien esto es especialmente molesto cuando esto involucra
        comunicarse con un servidor central, también tiene dos
        beneficios:</p>

        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">Los diffs son rápidos porque solo
            se precisa examinar los archivos marcados.</li>

            <li class="listitem">Uno puede descubrir quién más está
            trabajando en el archivo preguntándole al servidor
            central quien lo marcó para edición.</li>
          </ol>
        </div>

        <p>Con scripts apropiados, se puede alcanzar lo mismo con
        Git. Esto requiere cooperación del programador, quien
        debería ejecutar ciertos scripts cuando edita un
        archivo.</p>
      </div>

      <div class="section" title="Historia Por Archivo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_historia_por_archivo"></a>Historia Por Archivo</h2>
            </div>
          </div>
        </div>

        <p>Como Git guarda cambios por proyecto, reconstruir la
        historia de un archivo dado requiere más trabajo que en
        sistemas de control de versiones que administran archivos
        individuales.</p>

        <p>El problema suele ser leve, y vale tenerlo dado que
        otras operaciones son increíblemente eficientes. Por
        ejemplo, <code class="literal">git checkout</code> es más
        rápido que <code class="literal">cp -a</code>, y los deltas
        de un proyecto completo comprimen mejor que colecciones de
        deltas por archivo.</p>
      </div>

      <div class="section" title="Clonado inicial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_clonado_inicial"></a>Clonado inicial</h2>
            </div>
          </div>
        </div>

        <p>Cuando hay una historia larga, crear un clon es más
        costoso que hacer checkout de código en otros sistemas de
        control de versiones.</p>

        <p>El costo inicial lo vale a la larga, dado que la mayoría
        de las operaciones futuras van a ser rápidas y
        desconectado. De todos modos, en algunas situaciones, seria
        preferible crear un clon sin profundidad usando la opción
        <code class="literal">--depth</code>. Esto es mucho más
        rápido, pero el clon resultante tiene su funcionalidad
        reducida.</p>
      </div>

      <div class="section" title="Proyectos Volátiles">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_proyectos_vol_tiles"></a>Proyectos Volátiles</h2>
            </div>
          </div>
        </div>

        <p>Git fue escrito para ser rápido respecto al tamaño de
        los cambios. Los humanos hacen pequeñas ediciones de
        versión a versión. Un bugfix de una línea acá, una nueva
        funcionalidad allá, comentarios retocados, y así en
        adelante. Pero si tus archivos son radicalmente diferentes
        en revisiones sucesivas, entonces en cada commit, tu
        historia crece necesariamente igual que tu proyecto
        entero.</p>

        <p>No hay nada que ningún sistema de control de versiones
        pueda hacer sobre esto, pero los usuarios standard de Git
        van a sufrir más, dado que las historias son clonadas.</p>

        <p>La razón por la que los cambios son tan grandes deberían
        ser examinadas. Tal vez los formatos de los archivos
        deberían ser cambiados, ediciones pequeñas deberían causar
        cambios menores en a lo sumo unos pocos archivos.</p>

        <p>O tal vez una base de datos o una solución de
        backup/archivado es lo que realmente se necesita, no un
        sistema de control de versiones. Por ejemplo, un el control
        de versiones es poco adecuado para administrar fotos
        tomadas periódicamente con una webcam.</p>

        <p>Si los archivos deben cambiar constantemente, y
        realmente se necesita que estén versionados, una
        posibilidad es usar Git de una forma centralizada. Uno
        puede crear clones sin profundidad, lo cual acarrea poco y
        nada de la historia del proyecto. Por supuesto, muchas
        herramientas de git no van a estar disponibles, y los
        arreglos deben ser enviados como patches. Esto probablement
        no sea problema, dado que no está claro por qué alguien
        quisiera un historial de archivos salvajemente
        inestables.</p>

        <p>Otro ejemplo es un proyecto que depende de firmware, que
        toma la forma de un archivo binario enorme. La historia de
        este firmware no es de interés para los usuarios, y las
        actualizaciones comprimen de forma insatisfactoria, por lo
        que las revisiones de firmware aumentarían el tamaño del
        repositorio de manera innecesaria.</p>

        <p>En este caso, el código fuente debe ser guardado en un
        repositorio de Git, y el archivo binario debe ser mantenido
        de forma separada. Para hacer la vida más fácil, uno puede
        distribuír un script que usa Git para clonar el código y
        rsync o un clon sin profundidad de Git para el
        firmware.</p>
      </div>

      <div class="section" title="Contador Global">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_contador_global"></a>Contador Global</h2>
            </div>
          </div>
        </div>

        <p>Algunos sistemas de control de versiones centralizados,
        mantienen un entero positivo que aumenta cuando un nuevo
        commit es aceptado. Git se refiere a los cambios por su
        hash, lo que es mejor en muchas circunstancias.</p>

        <p>Pero a algunas personas les gusta tener este entero a
        mano. Por suerte es fácil escribir scripts de forma que con
        cada update, el repositorio central de git incrementa un
        entero, tal vez en un tag, y lo asocia con el hash del
        último commit.</p>

        <p>Cada clon podría mantener esete contador, pero esto
        sería probablemente inútil, dado que solo el repositorio
        central y su contador son los que importan.</p>
      </div>

      <div class="section" title="Subdirectorios Vacíos">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_subdirectorios_vac_os"></a>Subdirectorios
              Vacíos</h2>
            </div>
          </div>
        </div>

        <p>Los subdirectorios vacíos no pueden ser administrados.
        Crea archivos dummy para evitar este problema.</p>

        <p>La implementación actual de Git, y no su diseño, es
        quien tiene la culpa de este problema. Con suerte, una vez
        que Git gane más tracción, más usuarios van a clamar por
        esta funcionalidad y va a ser implementada.</p>
      </div>

      <div class="section" title="Commit Inicial">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_commit_inicial"></a>Commit Inicial</h2>
            </div>
          </div>
        </div>

        <p>El estereotipo de de un informático teórico cuenta desde
        0, en lugar de desde 1. Lamentablemente, con respecto a los
        commit, Git no mantiene esta convención. Muchos comandos
        son poco amigables antes del commit inicial. Adicionalmente
        algunos casos borde deben ser manejados de forma especial,
        como hacer rebase de una rama con un commit inicial
        distinto.</p>

        <p>Git se beneficiaría al definiri el commit cero: tan
        pronto como se construye un repositorio, HEAD debería ser
        un string conteniendo 20 bytes de 0. Este commit especial
        representa un árbol vacío, sin padre, que en algún momento
        es parte de todos los repositorios de Git.</p>

        <p>Entonces el correr git log, por ejemplo, informaría al
        usuario que no se han hecho commits aún, en lugar de salir
        con un error fatal. Algo similar pasaría con otras
        herramientas.</p>

        <p>Cada commit inicial es de forma implícita un
        descendiente de este commit cero.</p>

        <p>Lamentablemente igual hay algunos casos que presentan
        problemas. Si varias ramas con commits iniciales diferentes
        se mergean juntas, entonces un rebase del resultado
        requiere una buena cantidad de intervención manual.</p>
      </div>

      <div class="section" title="Rarezas De La Interfaz">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a name=
              "_rarezas_de_la_interfaz"></a>Rarezas De La
              Interfaz</h2>
            </div>
          </div>
        </div>

        <p>Para los commits A y B, el significado de las
        expresiones "A..B" y "A…B" depende de si el comando espera
        dos puntas o un rango. Ver <span class="strong"><strong>git
        help diff</strong></span> y <span class=
        "strong"><strong>git help rev-parse</strong></span></p>
      </div>
    </div>

    <div class="appendix" title=
    "Apéndice B. Translating This Guide">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name=
            "_translating_this_guide"></a>Apéndice B. Translating
            This Guide</h2>
          </div>
        </div>
      </div>

      <p>I recommend the following steps for translating this
      guide, so my scripts can quickly produce HTML and PDF
      versions, and all translations can live in the same
      repository.</p>

      <p>Clone the source, then create a directory corresponding to
      the target language’s IETF tag: see <a class="ulink" href=
      "http://www.w3.org/International/articles/language-tags/Overview.en.php"
      target="_top">the W3C article on internationalization</a>.
      For example, English is "en" and Japanese is "ja". In the new
      directory, and translate the <code class="literal">txt</code>
      files from the "en" subdirectory.</p>

      <p>For instance, to translate the guide into <a class="ulink"
      href="http://en.wikipedia.org/wiki/Klingon_language" target=
      "_top">Klingon</a>, you might type:</p>
      <pre class="literallayout">
$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh  # "tlh" is the IETF language code for Klingon.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Translate the file.
</pre>

      <p>and so on for each text file.</p>

      <p>Edit the Makefile and add the language code to the
      <code class="literal">TRANSLATIONS</code> variable. You can
      now review your work incrementally:</p>
      <pre class="literallayout">
$ make tlh
$ firefox book-tlh/index.html
</pre>

      <p>Commit your changes often, then let me know when they’re
      ready. GitHub has an interface that facilitates this: fork
      the "gitmagic" project, push your changes, then ask me to
      merge.</p>
    </div>
  </div>
</body>
</html>
