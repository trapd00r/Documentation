### Ruby core {{{
# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby
	# encoding: utf-8
snippet enc
	#${1: -*-} encoding: utf-8$1${2}
snippet req
	require '${1}'${2}
snippet inc
	include ${1}
snippet ext
	extend ${1}
snippet #
	# => ${1}
snippet case
	case ${1:object}
	when ${2:condition}${3}
	end
snippet def
	def ${1}
	end
snippet ini
	def initialize${1}
	end
snippet if
	if ${1}
	end
snippet el
	elsif ${1}
snippet un
	unless ${1}
	end
snippet wh
	while ${1}
	end
snippet until
	until ${1}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
	end
snippet clae
	class ${1:MyException} < ${2:StandardError}; end${3}
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
	end
snippet r
	attr_reader :${1:attr_names}
snippet w
	attr_writer :${1:attr_names}
snippet rw
	attr_accessor :${1:attr_names}
snippet defs
	def self.${1:class_method_name}
	end
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eak
	each_key { |${1:key}| ${2} }
snippet eal
	each_line { |${1:line}| ${2} }
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet eav
	each_value { |${1:val}| ${2} }
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet map
	map { |${1:e}| ${2} }
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }${1}
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet det
	detect { |${1:e}| ${2} }
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet fina
	find_all { |${1:e}| ${2} }
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet max
	max { |a, b| ${1} }
snippet min
	min { |a, b| ${1} }
snippet par
	partition { |${1:e}| ${2} }
snippet rej
	reject { |${1:e}| ${2} }
snippet sel
	select { |${1:e}| ${2} }
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1}|${2}
	end
snippet :
	:${1:key} => ${2:'value'}${3}
snippet exp
	File.expand_path${1}
snippet File.exp
	File.expand_path${1}
snippet exe
	File.executable? ${1}
snippet File.exe
	File.executable? ${1}
snippet ope
	open ${1:'path/or/url/or/pipe'}, '${2:w}' do |${3:io}|
		${4}
	end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
	desc '${1:Task description}'
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end
snippet tasd
	task :default => :${1}
snippet deb
	###
	require 'ruby-debug'; $stdout.tty? ? Debugger.start : (Debugger.wait_connection = true; Debugger.start_remote); debugger
	###${1}
snippet rpp
	require 'pp'; pp ${1}
snippet rap
	require 'ap'; ap ${1}
snippet bm
	Benchmark.${1:bm} do |${2:test}|
		$2.report ${3}
	end
snippet {
	{ |${1}| ${2} 
snippet y
	yield${1}
snippet bg
	block_given?${1}
snippet opt
	${1:opt}.on '-${2:o}', '--${3:option}',${4: 'Class',}${5: 'Desc'} do${6: |arg|}
		${7}
	end
snippet opt.sw
	opt.summary_width = ${1}
snippet 2
	2>/dev/null${1}
snippet &
	&>/dev/null${1}
snippet re
	return ${1}
snippet mf
	module_function :${1}
snippet grb
	group_by { |${1}| ${2} }
snippet beg
	begin
		${2}
	${1:rescue}
	end
snippet ins
	inspect${1}
snippet fu
	FileUtils${1}
snippet mkd
	FileUtils.mkdir_p${1}
snippet FileUtils.mkd
	FileUtils.mkdir_p${1}
# FIXME: How do you enter literal `$0'? \$0 and $$0 don't work
# CLI scaffold
snippet APP
	#!/usr/bin/env ruby
	# encoding: utf-8
	#
	# Copyright (c) `system('date +%Y')` Sung Pae <sung@metablu.com>
	# Distributed under the MIT license.
	# http://www.opensource.org/licenses/mit-license.php

	require 'optparse'

	class ${1:`Filename()`}
		def initialize args = []
			@args = args${2}
		end

		def options
			OptionParser.new do |opt|
				opt.banner = %Q(\
					Usage: #{File.basename $${0:0}} [options]

					Options:
				).gsub /^ +/, ''
			end
		end

		def run
			args = options.parse @args
		end
	end

	$1.new(ARGV).run if $${0:0} == __FILE__
# }}}
### Rails {{{
snippet l
	Rails.logger.debug ${1}
snippet v
	validates ${1}
snippet V
	class ${1:Example}Validator < ActiveModel::EachValidator
		def validate_each rec, att, val
			unless ${3:val passes test}
				rec.errors[att] << '${2:must be valid}'
			end
		end
	end
snippet hm
	has_many ${1}
snippet bt
	belongs_to ${1}
snippet hmt
	has_many ${1}, :through => ${2}
snippet habtm
	has_and_belongs_to_many ${1}
# }}}
### Rspec, MiniTest::Spec {{{
snippet des
	describe :${1} do
		${2}
	end
snippet it
	it '${1}' do
		${2}
	end
snippet bef
	before do
		${1}
	end
snippet aft
	after do
		${1}
	end
snippet mb
	must_be ${1}
snippet mbct
	must_be_close_to ${1}
snippet mbe
	must_be_empty ${1}
snippet mbio
	must_be_instance_of ${1}
snippet mbko
	must_be_kind_of ${1}
snippet mbn
	must_be_nil ${1}
snippet mbsa
	must_be_same_as ${1}
snippet mbwd
	must_be_within_delta ${1}
snippet mbwe
	must_be_within_epsilon ${1}
snippet me
	must_equal ${1}
snippet mi
	must_include ${1}
snippet mm
	must_match ${1}
snippet mr
	must_raise ${1}
snippet mrt
	must_respond_to ${1}
snippet ms
	must_send ${1}
snippet mt
	must_throw ${1}
snippet wb
	wont_be ${1}
snippet wbct
	wont_be_close_to ${1}
snippet wbe
	wont_be_empty ${1}
snippet wbio
	wont_be_instance_of ${1}
snippet wbko
	wont_be_kind_of ${1}
snippet wbn
	wont_be_nil ${1}
snippet wbsa
	wont_be_same_as ${1}
snippet wbwd
	wont_be_within_delta ${1}
snippet wbwe
	wont_be_within_epsilon ${1}
snippet we
	wont_equal ${1}
snippet wi
	wont_include ${1}
snippet wm
	wont_match ${1}
# }}}
