Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Wed, 3 Feb 1999 09:02:45 +0100 (MET)
Message-Id: <199902030802.JAA10576@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 2 Feb 1999 09:41:24 -0800
Subject: Re:  ${(P)${foo}} (Re: Associative array ordering)
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5192


Bart Schaefer wrote:

> On Feb 2,  5:58pm, Sven Wischnowsky wrote:
> } Subject: Re:  Associative array ordering and selective unset (Re: Example 
> }
> } I wrote:
> } 
> } > Maybe yet another flag? E.g.: `P' makes the thing after the
> } > flags be used as the name of a parameter. So `${(P)foo}' is the same
> } > as `$foo', but `${(P)${foo}}' will take the value of `foo' as the name 
> } > of a parameter and work on it.
> } 
> } The patch below does this (it was quite easy).
> 
> Well, you got to that before I got around to responding to that particular
> tidbit.
> 
> The other day someone asked about ksh namerefs in zsh, and I said that with
> ${(e)...} you didn't really need them.  Here's a case where they would have
> been exactly what the doctor ordered; in an appropriate muddle of ksh and
> zsh syntax,
> 
> 	nameref ref=$arg[1]
> 	echo ${(t)!ref}
> 
> which is a whole lot easier on the eyes, it must be admitted.

Yes, but in cases where you need it only once, this is a bit verbose,
don't you think?

> } With it you can do
> } things like the above or `${(P)+${foo}}' to see if the parameter whose 
> } name is stored in `foo' is set.
> 
> There are actually several ways we can go from here.
> 
> We can keep Sven's syntax as is.
> 
> We can modify Sven's syntax so that ${(P)foo} is the same as ${(P)${foo}},
> and make ${!foo} a synonym for it in ksh compatibility mode.  This is
> almost like ksh namerefs except that they don't get their own namespace.

I first thought about implementing ${(P)foo}, but implementing only the one 
I did, seemed easier. Now that I had a deeper look into the substitution 
code again, making ${(P)foo} work doesn't look that complicated, too.
Although that would be less powerful, so keeping the thing I
implemented may still be useful.
Making ${!foo} a synonym may be useful, and as far as I can this we
wouldn't have to restrict this to ksh compatibility mode (am I missing 
something?).

> We can make ${!foo} a synonym for ${(P)${foo}} (either in ksh mode or all
> the time), leaving ${(P)foo} alone.  I'm not too thrilled about this one.

Neither am I.

> We can add another hash table to be the nameref namespace, implement the
> nameref and `typeset -n' builtins, and make ${(P)foo} [or another letter]
> and ${!foo} synonyms where `foo' must be a nameref.  That would deprecate
> ${(P)${foo}}.

Namerefs may be useful anyway. But, as I said above I wouldn't like to
have to invent a nameref just to use this double-lookup once.

So, I'd vote for the ${!foo}=${(P)foo}=${(P)${foo}}-but-${(P)${foo#*=}}-
still-works suggestion, or for the last one (without the deprecation
bit). Those two can be combined anyway.

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

