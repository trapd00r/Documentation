From zsh-workers-return-9076-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Dec 16 08:42:38 1999
Return-Path: <zsh-workers-return-9076-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3797 invoked from network); 16 Dec 1999 08:42:37 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Dec 1999 08:42:37 -0000
Received: (qmail 10019 invoked by alias); 16 Dec 1999 08:42:28 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9076
Received: (qmail 10012 invoked from network); 16 Dec 1999 08:42:27 -0000
Date: Thu, 16 Dec 1999 09:42:26 +0100 (MET)
Message-Id: <199912160842.JAA11997@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Wed, 15 Dec 1999 14:16:21 +0300
Subject: PATCH: Re: _approximate and _path_files


Andrej Borsenkow wrote:

> Do they work together? Assuming that I have directory /archive/sni/mr,
> 
> cd /archive; l sin<TAB>
> 
> gives me `sni'
> 
> but simple
> 
> l /ar/sin<TAB>
> 
> after *very* long time beeps.
> 
> If not - it's really a pity.

This is as far as I could think yesterday evening. It makes the code
explicitly move globbing flags after the prefix if that could be
matched. It is probably not perfect and not very clean, but since *do* 
explicitly match the prefix (and suffix) since some time it's probably 
ok to make it handle globbing flags this way.

Dunno if I ever find a better way... 

Bye
 Sven

diff -ru ../z.old/Src/Zle/compcore.c Src/Zle/compcore.c
--- ../z.old/Src/Zle/compcore.c	Thu Dec 16 09:28:46 1999
+++ Src/Zle/compcore.c	Thu Dec 16 09:36:53 1999
@@ -1662,8 +1662,26 @@
 	    } else
 		lsl = 0;
 	    if (dat->aflags & CAF_MATCH) {
-		int ml;
+		int ml, gfl = 0;
+		char *globflag = NULL;
 
+		if (comppatmatch && *comppatmatch &&
+		    dat->ppre && lpre[0] == '(' && lpre[1] == '#') {
+		    char *p;
+
+		    for (p = lpre + 2; *p && *p != ')'; p++);
+
+		    if (*p == ')') {
+			char sav = p[1];
+
+			p[1] = '\0';
+			globflag = dupstring(lpre);
+			gfl = p - lpre + 1;
+			p[1] = sav;
+
+			lpre = p + 1;
+		    }
+		}
 		s = dat->ppre ? dat->ppre : "";
 		if ((ml = match_str(lpre, s, &bpl, 0, NULL, 0, 0, 1)) >= 0) {
 		    if (matchsubs) {
@@ -1688,11 +1706,11 @@
 			*argv = NULL;
 		    bcp = lpl;
 		}
-
 		s = dat->psuf ? dat->psuf : "";
 		if ((ml = match_str(lsuf, s, &bsl, 0, NULL, 1, 0, 1)) >= 0) {
 		    if (matchsubs) {
-			Cline tmp = get_cline(NULL, 0, NULL, 0, NULL, 0, CLF_SUF);
+			Cline tmp = get_cline(NULL, 0, NULL, 0, NULL, 0,
+					      CLF_SUF);
 
 			tmp->suffix = matchsubs;
 			if (matchlastpart)
@@ -1715,17 +1733,21 @@
 		}
 		if (comppatmatch && *comppatmatch) {
 		    int is = (*comppatmatch == '*');
-		    char *tmp = (char *) zhalloc(2 + llpl + llsl);
+		    char *tmp = (char *) zhalloc(2 + llpl + llsl + gfl);
 
-		    strcpy(tmp, lpre);
-		    tmp[llpl] = 'x';
-		    strcpy(tmp + llpl + is, lsuf);
+		    if (gfl) {
+			strcpy(tmp, globflag);
+			strcat(tmp, lpre);
+		    } else
+			strcpy(tmp, lpre);
+		    tmp[llpl + gfl] = 'x';
+		    strcpy(tmp + llpl + gfl + is, lsuf);
 
 		    tokenize(tmp);
 		    remnulargs(tmp);
 		    if (haswilds(tmp)) {
 			if (is)
-			    tmp[llpl] = Star;
+			    tmp[llpl + gfl] = Star;
 			if ((cp = patcompile(tmp, 0, NULL)))
 			    haspattern = 1;
 		    }

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

