From zsh-workers-return-7716-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Sep 08 09:35:21 1999
Return-Path: <zsh-workers-return-7716-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2103 invoked from network); 8 Sep 1999 09:35:19 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Sep 1999 09:35:19 -0000
Received: (qmail 9169 invoked by alias); 8 Sep 1999 09:35:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7716
Received: (qmail 9159 invoked from network); 8 Sep 1999 09:35:04 -0000
Date: Wed, 8 Sep 1999 11:35:01 +0200 (MET DST)
Message-Id: <199909080935.LAA00621@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Tue, 07 Sep 1999 16:48:32 +0200
Subject: Re: PATCH: 3.1.6-pws-3: _precommand


Peter Stephenson wrote:

> _normal sets _compskip to `pattern' before starting a completion; when
> _precommand shifts the input array to start a new normal completion,
> that means that pattern completions defined for the new command word
> aren't recognised.  I haven't understood all the logic for _compskip
> by a long way, but it seems as if it is wrong in this case, at least,
> since completing after `noglob' etc. should be exactly the same as if
> the precommand word wasn't there.

Yes, it's a bit messy, maybe we should think about something more
powerful some day.
Anyway, the problem is that `_compskip' should be reset to an empty
string whenever `_normal' is called from a normal completion function
(not from `_complete'). (At least, I think so, because otherwise
pattern functions aren't used for things like `find . -exec foo <TAB>',
either).

Bye
 Sven

diff -u -r oldcompletion/Base/_precommand Completion/Base/_precommand
--- oldcompletion/Base/_precommand	Wed Sep  8 11:29:45 1999
+++ Completion/Base/_precommand	Wed Sep  8 11:29:55 1999
@@ -3,7 +3,4 @@
 shift words
 (( CURRENT-- ))
 
-# We now want to go back to doing ordinary completion on the new word,
-# so restore the default _compskip.
-_compskip=''
 _normal
diff -u -r oldcompletion/Core/_complete Completion/Core/_complete
--- oldcompletion/Core/_complete	Wed Sep  8 09:03:52 1999
+++ Completion/Core/_complete	Wed Sep  8 11:27:06 1999
@@ -31,7 +31,7 @@
 # For arguments and command names we use the `_normal' function.
 
 if [[ "$compstate[context]" = command ]]; then
-  _normal
+  _normal -s
 else
   # Let's see if we have a special completion definition for the other
   # possible contexts.
diff -u -r oldcompletion/Core/_normal Completion/Core/_normal
--- oldcompletion/Core/_normal	Wed Sep  8 09:03:53 1999
+++ Completion/Core/_normal	Wed Sep  8 11:32:26 1999
@@ -2,6 +2,13 @@
 
 local comp command cmd1 cmd2 pat val name i ret=1 _compskip="$_compskip"
 
+# If we get the option `-s', we don't reset `_compskip'. This ensures
+# that a value set in the function for the `-first-' context is kept,
+# but that we still use pattern functions when we were called form
+# another completion function.
+
+[[ "$1" = -s ]] || _compskip=''
+
 # Completing in command position? If not we set up `cmd1' and `cmd2' as
 # two strings we have to search in the completion definition arrays (e.g.
 # a path and the last path name component).

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

