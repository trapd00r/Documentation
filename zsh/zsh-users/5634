From zsh-users-return-5634-mason-zsh=primenet.com.au@sunsite.dk Fri Jan 03 05:57:36 2003
Return-Path: <zsh-users-return-5634-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10526 invoked from network); 3 Jan 2003 05:57:35 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 3 Jan 2003 05:57:35 -0000
Received: (qmail 578 invoked by alias); 3 Jan 2003 05:57:23 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 5634
Received: (qmail 560 invoked from network); 3 Jan 2003 05:57:22 -0000
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <1030103055654.ZM28760@candle.brasslantern.com>
Date: Fri, 3 Jan 2003 05:56:53 +0000
In-Reply-To: <20030103043321.GC14622@gulag.guild.uwa.edu.au>
Comments: In reply to James Devenish <j-devenish@users.sourceforge.net>
        "Reinsertion of file prefix for accepted completion?" (Jan  3, 12:33pm)
References: <20030103043321.GC14622@gulag.guild.uwa.edu.au>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-users@sunsite.dk
Subject: Re: Reinsertion of file prefix for accepted completion?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Jan 3, 12:33pm, James Devenish wrote:
} 
} Is there some way (that isn't too outrageous, but perhaps involves the
} calling of a 'fixup' function) to reinsert a compadd -W file prefix when
} the completion is accepted?

Not really, no.

It's a completion system, not an abbreviation system.  The focus is on
producing on the command line an argument in the form that is expected
by the command.  If the command expects a full path, then the completer
should insert the full path.

In other words, instead of

    _path_files -W "( . /not/current/directory )" -g '*(.)'

you should be using something like

    _alternative \
	"local-files:: _path_files -g '*(.)'" \
	"other-files:: _path_files -g '/not/current/directory/*(.)'"

If you have a particular command for which you'd like to be able to use
abbreviated file names as arguments, then write a wrapper function for
that command; e.g. (crudely, for a command named "foo"):

    foo () {
	setopt localoptions noksharrays noshwordsplit
	integer i=$ARGC
	while ((--i))
	do
	    if [[ -f ./$argv[i] ]]; then
		continue
	    elif [[ -f /not/current/directory/$argv[i] ]]; then
		argv[i]=/not/current/directory/$argv[i]
	    fi
	done
	command foo $*
    }

However, you don't both get to use the abbreviations *and* see the full
paths in the command history.

If you *really* wanted to work for it, you could write a new ZLE widget
to replace accept-line, which would walk through the command buffer
every time you press enter to do this same sort of rewriting before
finally calling `zle .accept-line'.  I'm not going to attempt to show
an example of that, because it's fraught with potential problems, but
it could be done.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

