From zsh-workers-return-12773-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Sep 07 15:32:17 2000
Return-Path: <zsh-workers-return-12773-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21203 invoked from network); 7 Sep 2000 15:32:15 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 7 Sep 2000 15:32:15 -0000
Received: (qmail 2984 invoked by alias); 7 Sep 2000 15:31:57 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12773
Received: (qmail 2977 invoked from network); 7 Sep 2000 15:31:53 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1000907153147.ZM31321@candle.brasslantern.com>
Date: Thu, 7 Sep 2000 15:31:47 +0000
In-Reply-To: <20000906192536.22161.qmail@web1106.mail.yahoo.com>
Comments: In reply to Felix Rosencrantz <f_rosencrantz@yahoo.com>
        "Adding smart-insert-last-word to archives?" (Sep  6, 12:25pm)
References: <20000906192536.22161.qmail@web1106.mail.yahoo.com>
X-Mailer: Z-Mail (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: Re: Adding smart-insert-last-word to archives?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Sep 6, 12:25pm, Felix Rosencrantz wrote:
} 
} I was wondering if you might add smart-insert-last-word to the zsh
} distribution.

This also changes several of the "completion style" index entries to use
"widget style" instead.

Index: Doc/Zsh/contrib.yo
===================================================================
@@ -417,6 +417,27 @@
 bindkey '^X^Z' predict-on
 bindkey '^Z' predict-off)
 )
+findex(smart-insert-last-word)
+item(tt(smart-insert-last-word))(
+This function may replace the tt(insert-last-word) widget, like so:
+
+example(zle -N insert-last-word smart-insert-last-word)
+
+With a numeric prefix, it behaves like tt(insert-last-word), except that
+words in comments are ignored when tt(INTERACTIVE_COMMENTS) is set.
+
+Otherwise, the rightmost ``interesting'' word from the previous command is
+found and inserted.  The default definition of ``interesting'' is that the
+word contains at least one alphabetic character, slash, or backslash.
+This definition may be overridden by use of the tt(match) style.  The
+context used to look up the style is the widget name, so usually the
+context is tt(:insert-last-word).  However, you can bind this function to
+different widgets to use different patterns:
+
+example(zle -N insert-last-assignment smart-insert-last-word
+zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'
+bindkey '\e=' insert-last-assignment)
+)
 enditem()
 
 subsect(Styles)
@@ -427,7 +448,7 @@
 they invoke.
 
 startitem()
-kindex(break-keys, completion style)
+kindex(break-keys, widget style)
 item(tt(break-keys))(
 This style is used by the tt(incremental-complete-word) widget. Its value
 should be a pattern, and all keys matching this pattern will cause the
@@ -486,7 +507,7 @@
 Any other value for this style unconditionally leaves the cursor at the
 position where the completion code left it.
 )
-kindex(list, completion style)
+kindex(list, widget style)
 item(tt(list))(
 When using the tt(incremental-complete-word) widget, this style says
 if the matches should be listed on every key press (if they fit on the 
@@ -496,8 +517,28 @@
 completion should be shown even if there is only one possible completion.
 This is done if the value of this style is the string tt(always).  In this
 case the context is `tt(:predict)' (em(not) `tt(:completion:predict)').
+)
+kindex(match, widget style)
+item(tt(match))(
+This style is used by tt(smart-insert-last-word) to provide a pattern
+(using full tt(EXTENDED_GLOB) syntax) that matches an interesting word.
+The context is the name of the widget to which tt(smart-insert-last-word)
+is bound (see above).  The default behavior of tt(smart-insert-last-word)
+is equivalent to:
+
+example(zstyle :insert-last-word match '*[[:alpha:]/\\]*')
+
+However, you might want to include words that contain spaces:
+
+example(zstyle :insert-last-word match '*[[:alpha:][:space:]/\\]*')
+
+Or include numbers as long as the word is at least two characters long:
+
+example(zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\])*')
+
+The above example causes redirections like "2>" to be included.
 )
-kindex(prompt, completion style)
+kindex(prompt, widget style)
 item(tt(prompt))(
 The tt(incremental-complete-word) widget shows the value of this
 style in the status line during incremental completion.  The string
@@ -532,7 +573,7 @@
 
 Like `tt(break-keys)', this uses the `tt(:incremental)' context.
 )
-kindex(stop-keys, completion style)
+kindex(stop-keys, widget style)
 item(tt(stop-keys))(
 This style is used by the tt(incremental-complete-word) widget.  Its value
 is treated similarly to the one for the tt(break-keys) style (and uses 
@@ -540,7 +581,7 @@
 this case all keys matching the pattern given as its value will stop
 incremental completion and will then execute their usual function.
 )
-kindex(toggle, completion style)
+kindex(toggle, widget style)
 item(tt(toggle))(
 This boolean style is used by tt(predict-on) and its related widgets in
 the context `tt(:predict)'.  If set to one of the standard `true' values,
@@ -550,7 +591,7 @@
 default is to leave prediction turned on until an explicit call to
 tt(predict-off).
 )
-kindex(verbose, completion style)
+kindex(verbose, widget style)
 item(tt(verbose))(
 This boolean style is used by tt(predict-on) and its related widgets in
 the context `tt(:predict)'.  If set to one of the standard `true' values,
Index: Functions/Zle/smart-insert-last-word
===================================================================
@@ -0,0 +1,79 @@
+# smart-insert-last-word
+# Inspired by Christoph Lange <langec@gmx.de> from zsh-users/3265;
+# rewritten to correct multiple-call behavior after zsh-users/3270.
+#
+# This function as a ZLE widget can replace insert-last-word, like so:
+#
+#   zle -N insert-last-word smart-insert-last-word
+#
+# With a numeric prefix, behaves like insert-last-word, except that words
+# in comments are ignored when interactive_comments is set.
+#
+# Otherwise, the rightmost "interesting" word from the previous command is
+# found and inserted.  The default definition of "interesting" is that the
+# word contains at least one alphabetic character, slash, or backslash.
+# This definition can be overridden by use of a style like so:
+#
+#   zstyle :insert-last-word match '*[[:alpha:]/\\]*'
+#
+# For example, you might want to include words that contain spaces:
+#
+#   zstyle :insert-last-word match '*[[:alpha:][:space:]/\\]*'
+#
+# Or include numbers as long as the word is at least two characters long:
+#
+#   zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\])*'
+#
+# That causes redirections like "2>" to be included.
+#
+# Note also that the style is looked up based on the widget name, so you
+# can bind this function to different widgets to use different patterns:
+#
+#   zle -N insert-last-assignment smart-insert-last-word
+#   zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'
+#   bindkey '\e=' insert-last-assignment
+
+emulate -L zsh
+setopt extendedglob
+
+# Not strictly necessary:
+# (($+_ilw_hist)) || integer -g _ilw_hist _ilw_count _ilw_cursor _ilw_lcursor
+
+integer cursor=$CURSOR lcursor=$CURSOR
+local lastcmd pattern numeric=$NUMERIC
+
+# Save state for repeated calls
+if (( HISTNO == _ilw_hist && cursor == _ilw_cursor )); then
+    NUMERIC=$[_ilw_count+1]
+    lcursor=$_ilw_lcursor
+else
+    NUMERIC=1
+    _ilw_lcursor=$lcursor
+fi
+_ilw_hist=$HISTNO
+_ilw_count=$NUMERIC
+
+zle .up-history || return 1   # Retrieve previous command
+lastcmd=( ${(z)BUFFER} )      # Split into shell words
+zle .down-history             # Return to current command
+CURSOR=$cursor                # Restore cursor position
+NUMERIC=${numeric:-1}         # In case of fall through
+
+(( NUMERIC > $#lastcmd )) && return 1
+
+if [[ -z "$numeric" ]]
+then
+    integer i=1
+    zstyle -s :$WIDGET match pattern ||
+	pattern='*[[:alpha:]/\\]*'
+    while ((i <= $#lastcmd)); do
+	if [[ $lastcmd[-i] == $~pattern ]]; then
+	    NUMERIC=$i
+	    break
+	else
+	    ((++i))
+	fi
+    done
+fi
+LBUFFER[lcursor+1,cursor+1]=$lastcmd[-NUMERIC]
+_ilw_cursor=$CURSOR

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

