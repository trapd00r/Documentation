From zsh-workers-return-12964-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Oct 11 14:48:51 2000
Return-Path: <zsh-workers-return-12964-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 544 invoked from network); 11 Oct 2000 14:48:50 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 11 Oct 2000 14:48:50 -0000
Received: (qmail 16691 invoked by alias); 11 Oct 2000 14:47:04 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 12964
Received: (qmail 16669 invoked from network); 11 Oct 2000 14:46:55 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <1001011144642.ZM3333@candle.brasslantern.com>
Date: Wed, 11 Oct 2000 14:46:42 +0000
In-Reply-To: <200010110732.JAA26002@beta.informatik.hu-berlin.de>
Comments: In reply to Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
        "multiple-commands-functions" (Oct 11,  9:32am)
References: <200010110732.JAA26002@beta.informatik.hu-berlin.de>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>,
        zsh-workers@sunsite.auc.dk
Subject: Re: multiple-commands-functions
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Oct 11,  9:32am, Sven Wischnowsky wrote:
} 
} Then Bart and I more-or-less suggested to use those `services' as an
} abstraction so that functions could use `#compdef rsh remsh=rsh...'.
} The service name would then be given as an argument to the function
} and it could decide what to do with it.
} 
} But that has an ugly side-effect: some of the functions already use
} the arguments, for options.

Hrm.  That's easily fixable, though.  E.g. in _pbm, you'd just have to add
an extra argument as $1 when making the recursive call, to identify it as
"the recursive call service".

But it would be just as easy to put the service name in a non-positional.

} Another problem of some of the solutions suggested is that they 
} modify $_comps which may make re-loading impossible.

That was only necessary to implement one of the suggestions in terms of
the other one, but nevertheless ...
 
} That made me think about ways to simplify it, or to report the service 
} somewhere else, in a (completion-system-)global parameter. From there
} it was only a small step to the patch below. It allows to define
} `completion aliases' (there it is again, `aliases' -- well, we could
} change that name, of course). For example, in an autoloaded function,
} `#compdef rsh remsh=rsh' defines the alias `remsh=rsh'. The code
} calling completion functions checks if $words[1] is equal to `remsh'
} and if it is, it will call the completion function for `rsh', but
} before that, it sets $words[1] to `rsh'. I.e. the function only has to 
} check for $words[1] = rsh. Put the other way, `rsh' is the `service'.

Hmm.  What happens if the completion is attempted like:

zsh% /usr/local/bin/krsh <TAB>

??  It doesn't look as though that will work properly.

Are there any other cases where the format of $words[1] could mess up a 
simple aliasing scheme?  The advantage of the previous proposals was
that they changed the call to the completion function, not the way it
was looked up, so there wasn't any chance for this kind of confusion.

If we do go with this sort of aliasing, one other thing I'd suggest is
that it be possible to combine this with -p so that the left-hand-side
could be a pattern, e.g.

	compadd -p -A '*r(em|)sh=rsh'

but perhaps that's not useful enough to be worth the effort.

} The only thing we would have to worry about is functions that call the 
} command we are completing for. Since this is needed less often than
} finding the `service', it would probably make sense to put the
} original command name into a (completion-system-)global parameter and
} use that everywhere we need to call the command.

In spite of the "needed less often" argument, I'd still recommend putting
the service in a different parameter and leaving $words alone.  If the
positionals won't work, then invent another parameter (local to _normal
but "global" to the called functions) to store the service.  Most of the
time there'll be a one-to-one mapping between functions and services and
neither the service parameter nor $words[1] will be looked at.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

Zsh: http://www.zsh.org | PHPerl Project: http://phperl.sourceforge.net   

