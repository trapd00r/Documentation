From zsh-workers-return-9776-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Feb 17 13:49:54 2000
Return-Path: <zsh-workers-return-9776-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18562 invoked from network); 17 Feb 2000 13:49:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 17 Feb 2000 13:49:53 -0000
Received: (qmail 17579 invoked by alias); 17 Feb 2000 13:49:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9776
Received: (qmail 17569 invoked from network); 17 Feb 2000 13:49:43 -0000
Date: Thu, 17 Feb 2000 14:49:41 +0100 (MET)
Message-Id: <200002171349.OAA26252@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Thu, 17 Feb 2000 11:30:51 +0100
	(MET)
Subject: PATCH: Re: Oh no, parameter expansion


I wrote:

> Remember our fight to get arrays in nested parameter expansions right?
> I just found another on of those:
> 
>   % a=(aaa b c)
>   % echo ${(M)a[1,1]:#aaa}
>   3
> 
> That's because $a[1,1] gives a string instead of an array. We could
> remove the `a == b' in params.c:1160 to avoid that, but I don't know
> what this would break.

The patch below should make it return a string only if the subscript
does not contain a comma. I.e. with $a being an array, $a[1] gives a
string and $a[1,1] gives an array. Seems sensible, doesn't it?

> And one more:
> 
>   % a=::: b=_foo
>   % echo ${a/::/:${b#_}:}
>   :::
> 
> It works with $b[2,-1], haven't investigated any further.

compgetmatch() parsed the pattern in the static pattern buffer which
was then overwritten by the singsub(). The patch makes it return a
heap duplicate for the pattern if there is a replstr. It's a pity.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Thu Feb 17 13:37:18 2000
+++ Completion/Core/_main_complete	Thu Feb 17 14:05:11 2000
@@ -66,8 +66,7 @@
 _completer_num=1
 
 for _completer; do
-  _matcher="${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}"
-  zstyle -a ":completion:${curcontext/::/:${_matcher}:}:" matcher-list _matchers ||
+  zstyle -a ":completion:${curcontext/::/:${_completer[2,-1]}-${(M)#_completers[1,_completer_num]:#$_completer}:}:" matcher-list _matchers ||
       _matchers=( '' )
 
   _matcher_num=1
diff -ru ../z.old/Src/glob.c Src/glob.c
--- ../z.old/Src/glob.c	Thu Feb 17 13:36:48 2000
+++ Src/glob.c	Thu Feb 17 14:47:49 2000
@@ -1936,7 +1936,14 @@
      * have one pattern at a time; we will try the must-match test ourselves,
      * so tell the pattern compiler we are scanning.
      */
-    int patflags = PAT_STATIC|PAT_SCAN|PAT_NOANCH;
+
+    /* int patflags = PAT_STATIC|PAT_SCAN|PAT_NOANCH;*/
+
+    /* Unfortunately, PAT_STATIC doesn't work if we have a replstr with
+     * something like ${x#...} in it which will be singsub()ed below because
+     * that would overwrite the pattern buffer. */
+
+    int patflags = PAT_SCAN|PAT_NOANCH | (*replstrp ? 0 : PAT_STATIC);
 
     /*
      * Search is anchored to the end of the string if we want to match
diff -ru ../z.old/Src/params.c Src/params.c
--- ../z.old/Src/params.c	Thu Feb 17 13:36:50 2000
+++ Src/params.c	Thu Feb 17 14:41:42 2000
@@ -1145,9 +1145,11 @@
 	    if (*s == ']' || *s == Outbrack)
 		s++;
 	} else {
+	    int com;
+
 	    if (a > 0)
 		a--;
-	    if (*s == ',') {
+	    if ((com = (*s == ','))) {
 		s++;
 		b = getarg(&s, &inv, v, 1, &dummy);
 		if (b > 0)
@@ -1157,7 +1159,7 @@
 	    }
 	    if (*s == ']' || *s == Outbrack) {
 		s++;
-		if (v->isarr && a == b && 
+		if (v->isarr && a == b && !com &&
 		    (!(v->isarr & SCANPM_MATCHMANY) ||
 		     !(v->isarr & (SCANPM_MATCHKEY | SCANPM_MATCHVAL |
 				   SCANPM_KEYMATCH))))

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

