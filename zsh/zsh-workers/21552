From zsh-workers-return-21552-mason-zsh=primenet.com.au@sunsite.dk Sun Jul 31 13:29:51 2005
Return-Path: <zsh-workers-return-21552-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25535 invoked from network); 31 Jul 2005 13:29:48 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 31 Jul 2005 13:29:48 -0000
Received: (qmail 26336 invoked from network); 31 Jul 2005 13:29:40 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 31 Jul 2005 13:29:40 -0000
Received: (qmail 26284 invoked by alias); 31 Jul 2005 13:29:38 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 21552
Received: (qmail 26274 invoked from network); 31 Jul 2005 13:29:37 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 31 Jul 2005 13:29:37 -0000
Received: (qmail 26120 invoked from network); 31 Jul 2005 13:29:37 -0000
Received: from mail.gmx.de (HELO mail.gmx.net) (213.165.64.20)
  by a.mx.sunsite.dk with SMTP; 31 Jul 2005 13:29:33 -0000
Received: (qmail invoked by alias); 31 Jul 2005 13:29:01 -0000
Received: from Bcb32.b.pppool.de (EHLO pcdahl4201) [213.7.203.50]
  by mail.gmx.net (mp014) with SMTP; 31 Jul 2005 15:29:01 +0200
X-Authenticated: #21620914
Message-ID: <002501c595d4$fd8cddc0$bb1dfea9@pcdahl4201>
From: "Thorsten Dahlheimer" <tdahlheim@gmx.net>
To: <zsh-workers@sunsite.dk>
Subject: PATCH: various fixes to print builtin
Date: Sun, 31 Jul 2005 15:36:33 +0200
MIME-Version: 1.0
Content-Type: multipart/mixed;
	boundary="----=_NextPart_000_0022_01C595E5.A16DBC60"
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 6.00.2800.1409
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1409
X-Y-GMX-Trusted: 0
X-Spam-Checker-Version: SpamAssassin 3.0.4 (2005-06-05) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00,
	MIME_QP_LONG_LINE autolearn=ham version=3.0.4

This is a multi-part message in MIME format.

------=_NextPart_000_0022_01C595E5.A16DBC60
Content-Type: text/plain;
	charset="Windows-1252"
Content-Transfer-Encoding: 7bit

When I prepared the \c handling patch for the print builtin, I noticed
a couple of other (mostly minor) issues, which I've addressed in the
attached patch.  They are:

- The '%b' specifier of printf gets the character count wrong when a
  width is given:

      % printf '%5b%n\n' abc count; echo $count
        abc
      3

- The output of a '%%' specifier and padding spaces from '%b' go to
  stdout even if output has been redirected with one of the -u, -p,
  -z, -s options:

      % print -u3 -f 'a%3bc%%d\n' 'b' 3>fd3.out
        %
      % cat fd3.out
      abcd

- When there's no argument left for a '%b', it does not behave as if
  the argument were an empty string, but rather nothing is output at
  all.  This makes a difference if a width is given:

      % printf '%s!%5b!\n' abc
      abc!!

  vs.

      % printf '%s!%5b!\n' abc ''
      abc!     !

- The argument to a '%b' specifier gets passed to getkeystring() in
  unmetafied form, and that may lead to wrong output:

      % printf '%b\n' $'\x83 ' | od -tx1
      0000000 00 0a
      0000002

  vs.

      % echo $'\x83 ' | od -tx1
      0000000 83 20 0a
      0000003

- If both the -f and -c/-C options are given to print, the -f inhibits
  the initial expansion of escape sequences in the argument strings,
  but is then simply ignored:

      % print -f 'arg: %b\n' -C2 '\x41' '\x42' '\x43'       
      \x41  \x43
      \x42

  vs.

      % print -C2 '\x41' '\x42' '\x43'           
      A  C
      B

  I've resolved this strange interaction by having -f completely
  override -c/-C.

- If print -f output has been redirected with -u, -p, -z, or -s, and
  an error aborts execution, the fout file isn't closed.

- In the builtins[] table, the BINF_PRINTOPTS flag is not necessary
  for the echo and pushln commands, since these don't support the -R
  option.

- I've replaced two (unsigned char) casts to STOUC invocations,
  according to the advice in the zsh-development-guide.

- I've removed the 'count=mcount' assignment (in the last hunk)
  because it is (a) unnecessary and (b) off by one, I think.

- I've slightly tweaked formatting in a few places.

Regards,
Thorsten Dahlheimer

------=_NextPart_000_0022_01C595E5.A16DBC60
Content-Type: application/octet-stream;
	name="print1.patch"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="print1.patch"

Index: Src/builtin.c=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvsroot/zsh/zsh/Src/builtin.c,v=0A=
retrieving revision 1.141=0A=
diff -u -p -r1.141 builtin.c=0A=
--- Src/builtin.c	26 Jul 2005 00:07:11 -0000	1.141=0A=
+++ Src/builtin.c	30 Jul 2005 15:01:47 -0000=0A=
@@ -57,7 +57,7 @@ static struct builtin builtins[] =3D=0A=
     BUILTIN("dirs", 0, bin_dirs, 0, -1, 0, "clpv", NULL),=0A=
     BUILTIN("disable", 0, bin_enable, 0, -1, BIN_DISABLE, "afmrs", =
NULL),=0A=
     BUILTIN("disown", 0, bin_fg, 0, -1, BIN_DISOWN, NULL, NULL),=0A=
-    BUILTIN("echo", BINF_PRINTOPTS | BINF_SKIPINVALID, bin_print, 0, =
-1, BIN_ECHO, "neE", "-"),=0A=
+    BUILTIN("echo", BINF_SKIPINVALID, bin_print, 0, -1, BIN_ECHO, =
"neE", "-"),=0A=
     BUILTIN("emulate", 0, bin_emulate, 1, 1, 0, "LR", NULL),=0A=
     BUILTIN("enable", 0, bin_enable, 0, -1, BIN_ENABLE, "afmrs", NULL),=0A=
     BUILTIN("eval", BINF_PSPECIAL, bin_eval, 0, -1, BIN_EVAL, NULL, =
NULL),=0A=
@@ -102,7 +102,7 @@ static struct builtin builtins[] =3D=0A=
     BUILTIN("print", BINF_PRINTOPTS, bin_print, 0, -1, BIN_PRINT, =
"abcC:Df:ilmnNoOpPrRsu:z-", NULL),=0A=
     BUILTIN("printf", 0, bin_print, 1, -1, BIN_PRINTF, NULL, NULL),=0A=
     BUILTIN("pushd", BINF_SKIPINVALID | BINF_SKIPDASH | =
BINF_DASHDASHVALID, bin_cd, 0, 2, BIN_PUSHD, "sPL", NULL),=0A=
-    BUILTIN("pushln", BINF_PRINTOPTS, bin_print, 0, -1, BIN_PRINT, =
NULL, "-nz"),=0A=
+    BUILTIN("pushln", 0, bin_print, 0, -1, BIN_PRINT, NULL, "-nz"),=0A=
     BUILTIN("pwd", 0, bin_pwd, 0, 0, 0, "rLP", NULL),=0A=
     BUILTIN("r", 0, bin_fc, 0, -1, BIN_R, "nrl", NULL),=0A=
     BUILTIN("read", 0, bin_read, 0, -1, 0, "cd:ek:%lnpqrst:%zu:AE", =
NULL),=0A=
@@ -3283,11 +3283,11 @@ mod_export LinkList bufstack;=0A=
 int=0A=
 bin_print(char *name, char **args, Options ops, int func)=0A=
 {=0A=
-    int flen, width, prec, type, argc, n, narg;=0A=
+    int flen, width, prec, type, argc, n, narg, curlen;=0A=
     int nnl =3D 0, fmttrunc =3D 0, ret =3D 0, maxarg =3D 0;=0A=
     int flags[5], *len;=0A=
     char *start, *endptr, *c, *d, *flag, *buf, spec[13], *fmt =3D NULL;=0A=
-    char **first, *curarg, *flagch =3D "0+- #", save =3D '\0', nullstr =
=3D '\0';=0A=
+    char **first, **argp, *curarg, *flagch =3D "0+- #", save =3D '\0', =
nullstr =3D '\0';=0A=
     size_t rcount, count =3D 0;=0A=
 #ifdef HAVE_OPEN_MEMSTREAM=0A=
     size_t mcount;=0A=
@@ -3330,7 +3330,7 @@ bin_print(char *name, char **args, Optio=0A=
 	tokenize(*args);=0A=
 	if (!(pprog =3D patcompile(*args, PAT_STATIC, NULL))) {=0A=
 	    untokenize(*args);=0A=
-	    zwarnnam(name, "bad pattern : %s", *args, 0);=0A=
+	    zwarnnam(name, "bad pattern: %s", *args, 0);=0A=
 	    return 1;=0A=
 	}=0A=
 	for (t =3D p =3D ++args; *p; p++)=0A=
@@ -3440,7 +3440,7 @@ bin_print(char *name, char **args, Optio=0A=
 	    len[n] =3D strlen(args[n]);=0A=
 =0A=
     /* -c -- output in columns */=0A=
-    if (OPT_ISSET(ops,'c') || OPT_ISSET(ops,'C')) {=0A=
+    if (!fmt && (OPT_ISSET(ops,'c') || OPT_ISSET(ops,'C'))) {=0A=
 	int l, nc, nr, sc, n, t, i;=0A=
 	char **ap;=0A=
 =0A=
@@ -3528,7 +3528,7 @@ bin_print(char *name, char **args, Optio=0A=
 		    l =3D strlen(*ap);=0A=
 		    fprintf(fout, "%s", *ap);=0A=
 		    for (t =3D nr; t && *ap; t--, ap++);=0A=
-		    if(*ap)=0A=
+		    if (*ap)=0A=
 			for (; l < sc; l++)=0A=
 			    fputc(' ', fout);=0A=
 		} while (*ap);=0A=
@@ -3613,7 +3613,8 @@ bin_print(char *name, char **args, Optio=0A=
     } =0A=
     =0A=
     /* printf style output */=0A=
-    *spec=3D'%';=0A=
+    *spec =3D '%';=0A=
+    argp =3D args;=0A=
     do {=0A=
     	rcount =3D count;=0A=
     	if (maxarg) {=0A=
@@ -3621,7 +3622,7 @@ bin_print(char *name, char **args, Optio=0A=
 	    argc -=3D maxarg;=0A=
     	    maxarg =3D 0;=0A=
 	}=0A=
-	for (c =3D fmt;c-fmt < flen;c++) {=0A=
+	for (c =3D fmt; c-fmt < flen; c++) {=0A=
 	    if (*c !=3D '%') {=0A=
 		putc(*c, fout);=0A=
 		++count;=0A=
@@ -3630,7 +3631,7 @@ bin_print(char *name, char **args, Optio=0A=
 =0A=
 	    start =3D c++;=0A=
 	    if (*c =3D=3D '%') {=0A=
-		putchar('%');=0A=
+		putc('%', fout);=0A=
 		++count;=0A=
 		continue;=0A=
 	    }=0A=
@@ -3648,14 +3649,16 @@ bin_print(char *name, char **args, Optio=0A=
 		    if (narg > argc) {=0A=
 		    	zwarnnam(name, "%d: argument specifier out of range",=0A=
 				 0, narg);=0A=
+			if (fout !=3D stdout)=0A=
+			    fclose(fout);=0A=
 			return 1;=0A=
 		    } else {=0A=
 		    	if (narg > maxarg) maxarg =3D narg;=0A=
 		    	curarg =3D *(first + narg - 1);=0A=
+			curlen =3D len[first - args + narg - 1];=0A=
 		    }=0A=
 		}=0A=
 	    }=0A=
-		    =0A=
 	    =0A=
 	    /* copy only one of each flag as spec has finite size */=0A=
 	    memset(flags, 0, sizeof(flags));=0A=
@@ -3679,15 +3682,17 @@ bin_print(char *name, char **args, Optio=0A=
 		    	    zwarnnam(name,=0A=
 				     "%d: argument specifier out of range",=0A=
 				     0, narg);=0A=
+			    if (fout !=3D stdout)=0A=
+				fclose(fout);=0A=
 			    return 1;=0A=
 			} else {=0A=
 		    	    if (narg > maxarg) maxarg =3D narg;=0A=
-		    	    args =3D first + narg - 1;=0A=
+		    	    argp =3D first + narg - 1;=0A=
 			}=0A=
 		    }=0A=
 		}=0A=
-		if (*args) {=0A=
-		    width =3D (int)mathevali(*args++);=0A=
+		if (*argp) {=0A=
+		    width =3D (int)mathevali(*argp++);=0A=
 		    if (errflag) {=0A=
 			errflag =3D 0;=0A=
 			ret =3D 1;=0A=
@@ -3706,16 +3711,18 @@ bin_print(char *name, char **args, Optio=0A=
 		    		zwarnnam(name,=0A=
 					 "%d: argument specifier out of range",=0A=
 					 0, narg);=0A=
+				if (fout !=3D stdout)=0A=
+				    fclose(fout);=0A=
 				return 1;=0A=
 			    } else {=0A=
 		    		if (narg > maxarg) maxarg =3D narg;=0A=
-		    		args =3D first + narg - 1;=0A=
+		    		argp =3D first + narg - 1;=0A=
 			    }=0A=
 			}=0A=
 		    }=0A=
 		    =0A=
-		    if (*args) {=0A=
-			prec =3D (int)mathevali(*args++);=0A=
+		    if (*argp) {=0A=
+			prec =3D (int)mathevali(*argp++);=0A=
 			if (errflag) {=0A=
 			    errflag =3D 0;=0A=
 			    ret =3D 1;=0A=
@@ -3731,7 +3738,10 @@ bin_print(char *name, char **args, Optio=0A=
 	    /* ignore any size modifier */=0A=
 	    if (*c =3D=3D 'l' || *c =3D=3D 'L' || *c =3D=3D 'h') c++;=0A=
 =0A=
-	    if (!curarg && *args) curarg =3D *args++;=0A=
+	    if (!curarg && *argp) {=0A=
+		curarg =3D *argp;=0A=
+		curlen =3D len[argp++ - args];=0A=
+	    }=0A=
 	    d[1] =3D '\0';=0A=
 	    switch (*d =3D *c) {=0A=
 	    case 'c':=0A=
@@ -3748,24 +3758,24 @@ bin_print(char *name, char **args, Optio=0A=
 	    case 'b':=0A=
 		if (curarg) {=0A=
 		    int l;=0A=
-		    char *b =3D getkeystring(curarg, &l, =0A=
+		    char *b =3D getkeystring(metafy(curarg, curlen, META_USEHEAP), &l,=0A=
 					   OPT_ISSET(ops,'b') ? 2 : 0, &nnl);=0A=
 		    /* handle width/precision here and use fwrite so that=0A=
 		     * nul characters can be output */=0A=
 		    if (prec >=3D 0 && prec < l) l =3D prec;=0A=
 		    if (width > 0 && flags[2]) width =3D -width;=0A=
 		    if (width > 0 && l < width)=0A=
-		    	printf("%*c", width - l, ' ');=0A=
-		    fwrite(b, l, 1, fout);=0A=
+		    	count +=3D fprintf(fout, "%*c", width - l, ' ');=0A=
+		    count +=3D fwrite(b, 1, l, fout);=0A=
 		    if (width < 0 && l < -width)=0A=
-		    	printf("%*c", -width - l, ' ');=0A=
-		    count +=3D l;=0A=
+		    	count +=3D fprintf(fout, "%*c", -width - l, ' ');=0A=
 		    if (nnl) {=0A=
 			/* If the %b arg had a \c escape, truncate the fmt. */=0A=
 			flen =3D c - fmt + 1;=0A=
 			fmttrunc =3D 1;=0A=
 		    }=0A=
-		}=0A=
+		} else=0A=
+		    count +=3D fprintf(fout, "%*c", width, ' ');=0A=
 		break;=0A=
 	    case 'q':=0A=
 		stringval =3D curarg ? bslashquote(curarg, NULL, 0) : &nullstr;=0A=
@@ -3810,10 +3820,10 @@ bin_print(char *name, char **args, Optio=0A=
 	    if (type > 0) {=0A=
 		if (curarg && (*curarg =3D=3D '\'' || *curarg =3D=3D '"' )) {=0A=
 		    if (type =3D=3D 2) {=0A=
-			doubleval =3D (unsigned char)curarg[1];=0A=
+			doubleval =3D STOUC(curarg[1]);=0A=
 			print_val(doubleval);=0A=
 		    } else {=0A=
-			intval =3D (unsigned char)curarg[1];=0A=
+			intval =3D STOUC(curarg[1]);=0A=
 			print_val(intval);=0A=
 		    }=0A=
 		} else {=0A=
@@ -3859,19 +3869,18 @@ bin_print(char *name, char **args, Optio=0A=
 		    }=0A=
 		}=0A=
 	    }=0A=
-	    if (maxarg && (args - first > maxarg))=0A=
-	    	maxarg =3D args - first;=0A=
+	    if (maxarg && (argp - first > maxarg))=0A=
+	    	maxarg =3D argp - first;=0A=
 	}=0A=
 =0A=
-    	if (maxarg) args =3D first + maxarg;=0A=
+    	if (maxarg) argp =3D first + maxarg;=0A=
 	/* if there are remaining args, reuse format string */=0A=
-    } while (*args && args !=3D first && !fmttrunc && =
!OPT_ISSET(ops,'r'));=0A=
+    } while (*argp && argp !=3D first && !fmttrunc && =
!OPT_ISSET(ops,'r'));=0A=
 =0A=
     if (OPT_ISSET(ops,'z') || OPT_ISSET(ops,'s')) {=0A=
 #ifdef HAVE_OPEN_MEMSTREAM=0A=
 	putc(0, fout);=0A=
 	fflush(fout);=0A=
-	count =3D mcount;=0A=
 #else=0A=
 	rewind(fout);=0A=
 	buf =3D (char *)zalloc(count + 1);=0A=

------=_NextPart_000_0022_01C595E5.A16DBC60--

