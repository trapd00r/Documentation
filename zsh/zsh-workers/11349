From zsh-workers-return-11349-mason-zsh=primenet.com.au@sunsite.auc.dk Fri May 12 14:34:20 2000
Return-Path: <zsh-workers-return-11349-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7969 invoked from network); 12 May 2000 14:34:19 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 May 2000 14:34:19 -0000
Received: (qmail 21072 invoked by alias); 12 May 2000 14:34:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11349
Received: (qmail 20955 invoked from network); 12 May 2000 14:33:58 -0000
Date: Fri, 12 May 2000 16:33:56 +0200 (MET DST)
Message-Id: <200005121433.QAA00724@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Fri, 12 May 2000 14:10:59 +0100
Subject: Re: PATCH: use of _arguments for hash


Oliver Kiddle wrote:

> This adds _arguments based completion for the hash (and rehash)
> builtins. Why does rehash accept the -v option when as far as I can
> tell, it can never do anything? Would it be useful to add a -L option
> to hash similar to alias -L?

Seems reasonable, but personally I don't care much...

> I'm getting one problem with this completion: when I type hash -r<tab>,
> it is completed to 'hash -d '. I would expect it to complete to
> 'hash -rd '.

Yes, a bit of confusion over the options that still could be
completed. The next step, completing `-rd<TAB>' wasn't correct either, 
for similar reasons.

> I also get 'no more arguments' duplicated after
> 'hash -d -v<tab>'.

Oops. That was `caused' by _approximate defining `compadd' which used
a different group.

Bye
 Sven

Index: Completion/Base/_arguments
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Base/_arguments,v
retrieving revision 1.16
diff -u -r1.16 _arguments
--- Completion/Base/_arguments	2000/05/11 11:27:40	1.16
+++ Completion/Base/_arguments	2000/05/12 14:33:08
@@ -184,12 +184,16 @@
     else
       noargs='no arguments'
     fi
-    if ! comparguments -O next direct odirect equal; then
+    if comparguments -O next direct odirect equal; then
+      opts=yes
+      _tags options
+    elif [[ $? -eq 2 ]]; then
+        compadd -Q - "${PREFIX}${SUFFIX}"
+        return 0
+    else
       _message "$noargs"
       return 1
     fi
-    opts=yes
-    _tags options
   fi
 
   context=()
Index: Completion/Core/_message
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_message,v
retrieving revision 1.3
diff -u -r1.3 _message
--- Completion/Core/_message	2000/05/05 11:21:50	1.3
+++ Completion/Core/_message	2000/05/12 14:33:08
@@ -15,6 +15,6 @@
 
 if [[ -n "$format$raw" ]]; then
   [[ -z "$raw" ]] && zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
-  compadd -x "$format"
+  builtin compadd -x "$format"
   _comp_mesg=yes
 fi
Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.20
diff -u -r1.20 computil.c
--- Src/Zle/computil.c	2000/05/11 11:27:40	1.20
+++ Src/Zle/computil.c	2000/05/12 14:33:12
@@ -1124,7 +1124,7 @@
     Cadef d;
     int nopts;
     Caarg def, ddef;
-    Caopt curopt;
+    Caopt curopt, dopt;
     int opt, arg, argbeg, optbeg, nargbeg, restbeg, curpos, argend;
     int inopt, inrest, inarg, nth, doff, singles, oopt, actopts;
     LinkList args;
@@ -1140,7 +1140,7 @@
 ca_parse_line(Cadef d, int multi)
 {
     Caarg adef, ddef;
-    Caopt ptr, wasopt;
+    Caopt ptr, wasopt, dopt;
     struct castate state;
     char *line, *pe, **argxor = NULL;
     int cur, doff, argend;
@@ -1174,7 +1174,7 @@
     state.d = d;
     state.nopts = d->nopts;
     state.def = state.ddef = NULL;
-    state.curopt = NULL;
+    state.curopt = state.dopt = NULL;
     state.argbeg = state.optbeg = state.nargbeg = state.restbeg = state.actopts =
 	state.nth = state.inopt = state.inarg = state.opt = state.arg = 1;
     state.argend = argend = arrlen(compwords) - 1;
@@ -1198,6 +1198,7 @@
     for (line = compwords[1], cur = 2, state.curopt = NULL, state.def = NULL;
 	 line; line = compwords[cur++]) {
 	ddef = adef = NULL;
+	dopt = NULL;
 	doff = state.singles = 0;
 
 	if (ca_inactive(d, argxor, cur, 0) ||
@@ -1251,9 +1252,11 @@
 	     (state.curopt->type == CAO_EQUAL ?
 	      (pe[-1] == '=' || !pe[0]) : 1))) {
 
-	    ddef = state.def = ((state.curopt->type != CAO_EQUAL ||
-				 pe[-1] == '=') ?
-				state.curopt->args : NULL);
+	    if ((ddef = state.def = ((state.curopt->type != CAO_EQUAL ||
+				      pe[-1] == '=') ?
+				     state.curopt->args : NULL)))
+		dopt = state.curopt;
+
 	    doff = pe - line;
 	    state.optbeg = state.argbeg = state.inopt = cur;
 	    state.argend = argend;
@@ -1296,6 +1299,7 @@
 	    Caopt tmpopt;
 
 	    ddef = state.def = state.curopt->args;
+	    dopt = state.curopt;
 	    doff = pe - line;
 	    state.optbeg = state.argbeg = state.inopt = cur;
 	    state.argend = argend;
@@ -1355,6 +1359,7 @@
 
 		memcpy(&ca_laststate, &state, sizeof(state));
 		ca_laststate.ddef = NULL;
+		ca_laststate.dopt = NULL;
 		ca_laststate.doff = 0;
 		break;
 	    }
@@ -1389,6 +1394,7 @@
 		    zaddlinknode(l, ztrdup(line));
 
 		ca_laststate.ddef = NULL;
+		ca_laststate.dopt = NULL;
 		ca_laststate.doff = 0;
 		break;
 	    }
@@ -1402,12 +1408,14 @@
 	if (cur + 1 == compcurrent) {
 	    memcpy(&ca_laststate, &state, sizeof(state));
 	    ca_laststate.ddef = NULL;
+	    ca_laststate.dopt = NULL;
 	    ca_laststate.doff = 0;
 	} else if (cur == compcurrent && !ca_laststate.def) {
 	    if ((ca_laststate.def = ddef)) {
 		ca_laststate.singles = state.singles;
 		if (state.curopt && state.curopt->type == CAO_NEXT) {
 		    ca_laststate.ddef = ddef;
+		    ca_laststate.dopt = dopt;
 		    ca_laststate.def = NULL;
 		    ca_laststate.opt = 1;
 		    state.curopt->active = 1;
@@ -1418,6 +1426,7 @@
 	    } else {
 		ca_laststate.def = adef;
 		ca_laststate.ddef = NULL;
+		ca_laststate.dopt = NULL;
 		ca_laststate.optbeg = state.nargbeg;
 		ca_laststate.argbeg = state.restbeg;
 		ca_laststate.argend = state.argend;
@@ -1705,7 +1714,7 @@
 
 	    return 0;
 	}
-	return 1;
+	return (ca_laststate.singles ? 2 : 1);
     case 'L':
 	{
 	    Caopt opt = ca_get_opt(ca_laststate.d, args[1], 1, NULL);
@@ -1719,13 +1728,13 @@
 	}
     case 's':
 	if (ca_laststate.d->single && ca_laststate.singles &&
-	    ca_laststate.actopts > 1 && ca_laststate.opt) {
+	    ca_laststate.actopts && ca_laststate.opt) {
 	    setsparam(args[1],
-		      ztrdup(ca_laststate.ddef ?
-			     (ca_laststate.ddef->type == CAO_DIRECT ?
+		      ztrdup((ca_laststate.ddef && ca_laststate.dopt) ?
+			     (ca_laststate.dopt->type == CAO_DIRECT ?
 			      "direct" :
-			      ((ca_laststate.ddef->type == CAO_OEQUAL ||
-				ca_laststate.ddef->type == CAO_EQUAL) ?
+			      ((ca_laststate.dopt->type == CAO_OEQUAL ||
+				ca_laststate.dopt->type == CAO_EQUAL) ?
 			       "equal" : "next")) : ""));
 	    return 0;
 	}

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

