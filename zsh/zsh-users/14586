From zsh-users-return-14586-mason-zsh=primenet.com.au@zsh.org Fri Nov 20 20:23:54 2009
Return-Path: <zsh-users-return-14586-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5384 invoked by alias); 20 Nov 2009 20:23:53 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 14586
Received: (qmail 25389 invoked from network); 20 Nov 2009 20:23:50 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <091120112303.ZM15117@torch.brasslantern.com>
Date: Fri, 20 Nov 2009 11:23:03 -0800
In-reply-to: <alpine.LNX.2.01.0911201034070.24555@hp.internal>
Comments: In reply to "Benjamin R. Haskell" <zsh@benizi.com>
 "Zsh functionality similar to Perl 'map'?" (Nov 20, 11:03am)
References: <alpine.LNX.2.01.0911201034070.24555@hp.internal>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: Zsh Users <zsh-users@zsh.org>
Subject: Re: Zsh functionality similar to Perl 'map'?
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

On Nov 20, 11:03am, Benjamin R. Haskell wrote:
}
} Ideally, it'd end up as something like:
} 
} diff -ur =({do-something1,do-something2} | filter)
} or
} diff -ur =(filter {file1,file2})
} 
} ...and, yes, I know that's a *huge* stretch.  And, maybe my Perl bias for 
} map'ping everything is showing, but still, figured I'd ask.

Have a look at http://www.zsh.org/mla/users/2006/msg00832.html

There's a trick to replacing $(...) with =(...).  If I write

    setopt extendedglob
    x=(a b c)
    cat ${x/(#b)(*)/=(echo foo $match)}

I get 

    foo match
    foo match
    foo match

because $match is being expanded before it has been set by the (#b)
operator.  It's entirely possible this is a bug.  The workaround is to
single-quote the contents as in =('...'):

    cat ${x/(#b)(*)/=('echo foo $match')}

    foo a
    foo b
    foo c

I haven't delved into whether this is explainable with the normal
order-of-expansion rules.  Anyway, throwing this all together in a
very non-obvious way, you can write:

diff -ur ${${(A)reply::={file1,file2}}/(#b)(*)/=('filter $match')}

Where the parts you care about manipulating are names in {file1,file2}
and of course the filter.  "reply" is used as a dummy array variable
for the ::= assigment, pick any name that won't clobber something you
are interested in.  Quoting of spaces or other special characters in
the file names may be a fairly unpleasant exercise.

