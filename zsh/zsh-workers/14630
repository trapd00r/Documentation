From zsh-workers-return-14630-mason-zsh=primenet.com.au@sunsite.dk Fri Jun 01 08:52:59 2001
Return-Path: <zsh-workers-return-14630-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1616 invoked from network); 1 Jun 2001 08:52:57 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 1 Jun 2001 08:52:57 -0000
Received: (qmail 15919 invoked by alias); 1 Jun 2001 08:52:47 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 14630
Received: (qmail 15903 invoked from network); 1 Jun 2001 08:52:46 -0000
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
Date: Fri, 1 Jun 2001 10:51:49 +0200 (MET DST)
Message-Id: <200106010851.KAA13819@beta.informatik.hu-berlin.de>
To: zsh-workers@sunsite.dk
Subject: Re: completion function for Ruby and exclusion list problem.
In-Reply-To: <hvohey07on1.fsf@flux.etl.go.jp>

Tanaka Akira wrote:

> It almost works, but I found a problem with exclusion list.
> 
> Z(3):akr@flux% Src/zsh -f
> flux% fpath=(Completion Completion/**/*(/)); bindkey -e; autoload -U compinit; compinit -D
> flux% zstyle '*' group-name ''
> flux% zstyle '*:messages' format '%d'
> flux% zstyle '*:descriptions' format '%d'
> flux% compdef _tst tst
> flux% _tst () {
> function> _arguments '(1)-x' ':a:' ':b:'
> function> }
> flux% tst -x <TAB>
> a
> 
> I think it should show `b' instead of `a' because non-option first
> argument is excluded by `-x'.

Yes.  Uff.  We lost that when we learned to handle cases where we might
have to use more than one action.


Bye
  Sven

Index: Src/Zle/computil.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/computil.c,v
retrieving revision 1.57
diff -u -r1.57 computil.c
--- Src/Zle/computil.c	2001/05/31 12:38:34	1.57
+++ Src/Zle/computil.c	2001/06/01 08:51:34
@@ -1130,9 +1130,11 @@
     if (d->argsactive) {
 	Caarg a = d->args;
 
-	while (a && (n < a->min || n > a->num))
+	while (a && (!a->active || n < a->min || n > a->num)) {
+            if (!a->active)
+                n++;
 	    a = a->next;
-
+        }
 	if (a && a->min <= n && a->num >= n && a->active)
 	    return a;
 
@@ -1154,7 +1156,7 @@
 	int sl = (d->set ? strlen(d->set) : -1), set = 0;
 
 	for (; (x = (opts ? "-" : *xor)); xor++) {
-            if (optname && strcmp(optname, x))
+            if (optname && optname[0] == x[0] && strcmp(optname, x))
                 continue;
 	    if (ca_xor)
 		addlinknode(ca_xor, x);
@@ -1403,7 +1405,8 @@
 	    if (!state.oargs[state.curopt->num])
 		state.oargs[state.curopt->num] = znewlinklist();
 
-	    if (ca_inactive(d, state.curopt->xor, cur, 0, state.curopt->name))
+	    if (ca_inactive(d, state.curopt->xor, cur, 0,
+                            (cur == compcurrent ? state.curopt->name : NULL)))
 		return 1;
 
 	    /* Collect the argument strings. Maybe. */
@@ -1456,7 +1459,8 @@
 		    if (!state.oargs[tmpopt->num])
 			state.oargs[tmpopt->num] = znewlinklist();
 
-		    if (ca_inactive(d, tmpopt->xor, cur, 0, tmpopt->name))
+		    if (ca_inactive(d, tmpopt->xor, cur, 0,
+                                    (cur == compcurrent ? tmpopt->name : NULL)))
 			return 1;
 		}
 	    }
@@ -1523,6 +1527,8 @@
 		break;
 	    }
 	    zaddlinknode(state.args, ztrdup(line));
+            if (adef)
+                state.oopt = adef->num - state.nth;
 
 	    if (state.def)
 		argxor = state.def->xor;

-- 
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

