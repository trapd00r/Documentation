From zsh-workers-return-15768-mason-zsh=primenet.com.au@sunsite.dk Sun Sep 09 22:02:53 2001
Return-Path: <zsh-workers-return-15768-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 13868 invoked from network); 9 Sep 2001 22:02:53 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Sep 2001 22:02:53 -0000
Received: (qmail 2706 invoked by alias); 9 Sep 2001 22:02:44 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15768
Received: (qmail 2684 invoked from network); 9 Sep 2001 22:02:42 -0000
Date: Sun, 9 Sep 2001 18:01:16 -0400
From: Clint Adams <clint@zsh.org>
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: zsh-workers@sunsite.dk
Subject: Re: PATCH: ztcp
Message-ID: <20010909180116.A16035@dman.com>
References: <20010908170712.A31748@dman.com> <1010909183141.ZM21909@candle.brasslantern.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i
In-Reply-To: <1010909183141.ZM21909@candle.brasslantern.com>; from schaefer@brasslantern.com on Sun, Sep 09, 2001 at 06:31:41PM +0000

> Rather than print this to stdout, you'd be better off stuffing it into
> te value of the $REPLY parameter, or allowing the caller to pass a
> parameter name into which the fd number would be stuffed.
> 
> Even better, allow the caller to pass in an fd number to which the new
> connection will be dup2'd.

This does the first.  Also lets you use service names in lieu of
port numbers.

I don't understand what fd duplication buys you.

Index: Src/Modules/tcp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.c,v
retrieving revision 1.7
diff -u -r1.7 tcp.c
--- Src/Modules/tcp.c	2001/09/09 09:39:25	1.7
+++ Src/Modules/tcp.c	2001/09/09 21:40:37
@@ -384,6 +384,7 @@
     int herrno, err=1, destport, force=0, verbose=0, len, rfd;
     char **addrp, *desthost, *localname, *remotename;
     struct hostent *zthost = NULL, *ztpeer = NULL;
+    struct servent *srv;
     Tcp_session sess;
 
     if (ops['f'])
@@ -419,18 +420,22 @@
 	}
     }
     else if (ops['l']) {
-	int lport;
+	int lport = 0;
 
 	if (!args[0]) {
 	    zwarnnam(nam, "-l requires an argument", NULL, 0);
 	    return 1;
 	}
-	lport = atoi(args[0]);
-	if (!lport) {
-	    zwarnnam(nam, "bad port number", NULL, 0);
-	    return 1;
+
+	srv = getservbyname(args[0],"tcp");
+	if (srv)
+	    lport = srv->s_port;
+	else
+	    lport = htons(atoi(args[0]));
+	if (!lport) { zwarnnam(nam, "bad service name or port number", NULL, 0);
+	return 1;
 	}
-	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, 0);
+	sess = tcp_socket(PF_INET, SOCK_STREAM, 0, ZTCP_INBOUND);
 
 	if (!sess) {
 	    zwarnnam(nam, "unable to allocate a TCP session slot", NULL, 0);
@@ -447,7 +452,7 @@
 	}
 
 	sess->sock.in.sin_family = AF_INET;
-	sess->sock.in.sin_port = htons(lport);
+	sess->sock.in.sin_port = lport;
 
 
 	if (bind(sess->fd, (struct sockaddr *)&sess->sock.in, sizeof(struct sockaddr_in)))
@@ -481,8 +486,11 @@
 	    return -1;
 	}
 	sess->fd = rfd;
+
+	setiparam("REPLY", sess->fd);
 
-	fprintf(shout, "%d is on fd %d\n", ntohs(sess->peer.in.sin_port), sess->fd);
+	if(verbose)
+	    fprintf(shout, "%d is on fd %d\n", ntohs(sess->peer.in.sin_port), sess->fd);
 
 	return 0;
 
@@ -504,16 +512,21 @@
 			remotename = ztpeer->h_name;
 		    else
 			remotename = ztrdup(inet_ntoa(sess->sock.in.sin_addr));
-		    fprintf(shout, "%s:%d -> %s:%d is on fd %d%s%s\n", localname, ntohs(sess->sock.in.sin_port), remotename, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "", (sess->flags & ZTCP_INBOUND) ? "INBOUND" : "");
+		    fprintf(shout, "%s:%d %s %s:%d is on fd %d%s\n", localname, ntohs(sess->sock.in.sin_port), (sess->flags & ZTCP_INBOUND) ? "<-" : "->", remotename, ntohs(sess->peer.in.sin_port), sess->fd, (sess->flags & ZTCP_ZFTP) ? " ZFTP" : "");
 		}
 	    }
 	    return 0;
 	}
 	else if (!args[1]) {
-	    destport = 23;
+	    destport = htons(23);
 	}
 	else {
-	    destport = atoi(args[1]);
+
+	    srv = getservbyname(args[1],"tcp");
+	    if (srv)
+		destport = srv->s_port;
+	    else
+		destport = htons(atoi(args[1]));
 	}
 	
 	desthost = ztrdup(args[0]);
@@ -547,7 +560,7 @@
 	    if (zthost->h_length != 4)
 		zwarnnam(nam, "address length mismatch", NULL, 0);
 	    do {
-		err = tcp_connect(sess, *addrp, zthost, htons(destport));
+		err = tcp_connect(sess, *addrp, zthost, destport);
 	    } while (err && errno == EINTR && !errflag);
 	}
 	
@@ -555,10 +568,10 @@
 	    zwarnnam(nam, "connection failed: %e", NULL, errno);
 	else
 	{
+	    setiparam("REPLY", sess->fd);
+
 	    if (verbose)
 		fprintf(shout, "%s:%d is now on fd %d\n", desthost, destport, sess->fd);
-	    else
-		fprintf(shout, "%d\n", sess->fd);
 	}
 	
 	zsfree(desthost);

