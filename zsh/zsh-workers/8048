From zsh-workers-return-8048-mason-zsh=primenet.com.au@sunsite.auc.dk Sun Sep 26 14:17:50 1999
Return-Path: <zsh-workers-return-8048-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 782 invoked from network); 26 Sep 1999 14:17:47 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 26 Sep 1999 14:17:47 -0000
Received: (qmail 472 invoked by alias); 26 Sep 1999 14:17:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8048
Received: (qmail 465 invoked from network); 26 Sep 1999 14:17:24 -0000
Date: Sun, 26 Sep 1999 15:17:23 +0100
From: Adam Spiers <adam@thelonious.new.ox.ac.uk>
To: zsh workers mailing list <zsh-workers@sunsite.auc.dk>
Subject: PATCH: improvement to user@host completions
Message-ID: <19990926151723.F1246@thelonious.new.ox.ac.uk>
Reply-To: Adam Spiers <adam@spiers.net>
Mail-Followup-To: zsh workers mailing list <zsh-workers@sunsite.auc.dk>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailer: Mutt 1.0pre2i
X-URL: http://www.new.ox.ac.uk/~adam/
X-OS: Linux 2.2.9 i686

This patch harnesses the power of Tanaka's _combination in _rlogin, _ssh
and other functions.

The user should put something similar to the following in his .zshrc:

# All my accounts:
my_accounts=(
    joe:
    {joe,root}:mymachine.com
    jbloggs:myothermachine.com
)

# Other people's accounts:
other_accounts=(
    bob:
    {fred,root}:hismachine.com
    vera:hermachine.com
)

and then a whole family of commands will then intelligently complete
(user, host) pairs, in both `-l user host' (where appropriate) and
`user@host' style.  Currently the rlogin and ssh family are affected,
and also ytalk and finger.

If the user wishs to override this completion behaviour for any of
these commands, he can set `FOO_accounts' to a new array, where FOO is
the command in question.

The patch also includes a _users_on completion function for completing
users currently logged on; `write' will complete using this.

P.S. Why does cvs diff not put the full path in the +++ line for newly
added files?  And why doesn't patch understand `Index:' ?


Index: Completion/User/_my_accounts
===================================================================
RCS file: _my_accounts
diff -N _my_accounts
--- /dev/null	Tue May  5 21:32:27 1998
+++ _my_accounts	Sun Sep 26 12:58:55 1999
@@ -0,0 +1,14 @@
+#autoload
+
+local expl nm="$compstate[nmatches]"
+local accounts_users_hosts
+
+local varname="$words[1]_accounts"
+
+if [[ ${(P)+varname} -eq 1 ]]; then
+  accounts_users_hosts=( ${(P)varname} )
+else
+  accounts_users_hosts=( $my_accounts )
+fi
+
+_user@host
Index: Completion/User/_other_accounts
===================================================================
RCS file: _other_accounts
diff -N _other_accounts
--- /dev/null	Tue May  5 21:32:27 1998
+++ _other_accounts	Sun Sep 26 12:56:46 1999
@@ -0,0 +1,14 @@
+#compdef ytalk finger
+
+local expl nm="$compstate[nmatches]"
+local accounts_users_hosts
+
+local varname="$words[1]_accounts"
+
+if [[ ${(P)+varname} -eq 1 ]]; then
+  accounts_users_hosts=( ${(P)varname} )
+else
+  accounts_users_hosts=( $other_accounts )
+fi
+
+_user@host
Index: Completion/User/_rlogin
===================================================================
RCS file: /usr/local/cvsroot/zsh/Completion/User/_rlogin,v
retrieving revision 1.1.1.3
diff -u -r1.1.1.3 _rlogin
--- Completion/User/_rlogin	1999/09/21 12:15:43	1.1.1.3
+++ Completion/User/_rlogin	1999/09/26 12:57:21
@@ -1,51 +1,82 @@
 #compdef rlogin rsh remsh rcp
 
-case "$words[1]" in
-rlogin)
-  _arguments -s \
-    '-8[allow 8-Bit data]' \
-    '-e-[specify escape character]:escape character:' \
-    '-l[specify login user name]:login as:_users' \
-    ':remote host name:_hosts'
-  ;;
-rsh|remsh)
-  local state line ret=1
-  typeset -A options
-
-  _arguments -s \
-    '-n[ignore stdin]' \
-    '-l[specify login user name]:login as:_users' \
-    ':remote host name:_hosts' \
-    ':command: _command_names -e' \
-    '*::command:->command' && ret=0
-
-  if [[ -n "$state" ]]; then
-    shift 1 words
-    (( CURRENT-- ))
-    _normal && ret=0
+_rlogin () {
+  local accounts_users_hosts
+
+  local varname="$words[1]_accounts"
+
+  if (( ${(P)+varname} )); then
+    accounts_users_hosts=( ${(P)varname} )
+  else
+    accounts_users_hosts=( $my_accounts )
   fi
-  return ret
-  ;;
-rcp)
-  local state line ret=1
-  typeset -A options
-
-  _arguments -s \
-    '-p[preserve modification times]' \
-    '-r[recursively copy directories]' \
-    '*:files:->files' && ret=0
-
-  if [[ -n "$state" ]]; then
-    if compset -P '*:'; then
-      _files && ret=0
-    elif compset -P '*@'; then
-      _hosts -S: && ret=0
-    else
-      _files && ret=0
-      _hosts -S: && ret=0
-      _users -S@ && ret=0
+
+  case "$words[1]" in
+  rlogin)
+    _arguments -s \
+      '-8[allow 8-Bit data]' \
+      '-e-[specify escape character]:escape character:' \
+      '-l[specify login user name]:login as:_rlogin_users' \
+      ':remote host name:_rlogin_hosts'
+    ;;
+  rsh|remsh)
+    local state line ret=1
+    typeset -A options
+
+    _arguments -s \
+      '-n[ignore stdin]' \
+      '-l[specify login user name]:login as:_rlogin_users' \
+      ':remote host name:_rlogin_hosts' \
+      ':command: _command_names -e' \
+      '*::command:->command' && ret=0
+
+    if [[ -n "$state" ]]; then
+      shift 1 words
+      (( CURRENT-- ))
+      _normal && ret=0
+    fi
+    return ret
+    ;;
+  rcp)
+    local state line ret=1
+    typeset -A options
+
+    _arguments -s \
+      '-p[preserve modification times]' \
+      '-r[recursively copy directories]' \
+      '*:files:->files' && ret=0
+
+    if [[ -n "$state" ]]; then
+      if compset -P '*:'; then
+	_files && ret=0
+      elif compset -P '*@'; then
+	_rlogin_hosts -S: -q && ret=0
+      else
+	_files && ret=0
+	_rlogin_all_hosts -S: -q && ret=0
+	_rlogin_users -S@ -q && ret=0
+      fi
     fi
+    return ret
+    ;;    
+  esac
+}
+
+_rlogin_users () {
+  _combination accounts_users_hosts users "$@"
+}
+
+_rlogin_hosts () {
+  if [[ "$IPREFIX" == *@ ]]; then
+    _combination accounts_users_hosts "users=${IPREFIX/@}" hosts "$@"
+  else
+    _combination accounts_users_hosts \
+      ${options[-l]:+"users=${options[-l]:q}"} hosts "$@"
   fi
-  return ret
-  ;;    
-esac
+}
+
+_rlogin_all_hosts () {
+  _combination accounts_users_hosts hosts "$@"
+}
+
+_rlogin "$@"
Index: Completion/User/_ssh
===================================================================
RCS file: /usr/local/cvsroot/zsh/Completion/User/_ssh,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 _ssh
--- Completion/User/_ssh	1999/09/21 12:15:43	1.1.1.1
+++ Completion/User/_ssh	1999/09/26 13:47:56
@@ -1,208 +1,237 @@
 #compdef ssh slogin scp ssh-add ssh-agent ssh-keygen
 
-local state lstate line ret=1 expl args
-typeset -A options
+_ssh () {
+  local state lstate line ret=1 expl args
+  typeset -A options
+
+  local accounts_users_hosts
+
+  local varname="$words[1]_accounts"
+
+  if (( ${(P)+varname} )); then
+    accounts_users_hosts=( ${(P)varname} )
+  else
+    accounts_users_hosts=( $my_accounts )
+  fi
 
-args=()
+  args=()
 
-# ssh-opt is a pseudo-command used to complete ssh options for `scp -o'.
+  # ssh-opt is a pseudo-command used to complete ssh options for `scp -o'.
 
-case "$words[1]" in
-ssh|slogin)
-  args=(
-    ':remote host name:->userhost'
-    ':command: _command_names -e'
-    '*::args:->command'
-  )
-  ;&
-ssh-opt)
-  _arguments -s \
-    '-a[disable forwarding of authentication agent connection]' \
-    '-c[select encryption cipher]:encryption cipher:(idea des 3des blowfish arcfour tss none)' \
-    '-e[set escape character]:escape character (or `none'"'"'):' \
-    '(-n)-f[go to background]' \
-    '-i[select identity file]:SSH identity file:_files' \
-    '-k[disable forwarding of kerberos tickets]' \
-    '-l[specify login name]:login name:_users' \
-    '-n[redirect stdin from /dev/null]' \
-    '*-o[specify extra options]:option string:->option' \
-    '-p[specify port on remote host]:port number on remote host:' \
-    '-q[quiet operation]' \
-    '-P[use non priviledged port]' \
-    '-t[force pseudo-tty allocation]' \
-    '-v[verbose mode]' \
-    '-V[show version number]' \
-    '-x[disable X11 forwarding]' \
-    '-C[compress all data]' \
-    '-L[specify local port forwarding]:local port forwarding:->forward' \
-    '-R[specify remote port forwarding]:remote port forwarding:->forward' \
-    "$args[@]" && ret=0
-
-  while [[ -n "$state" ]]; do
-    lstate="$state"
-    state=''
-
-    case "$lstate" in
-    option)
-      if compset -P '*[= ]'; then
-        case "$IPREFIX" in
-        *(#i)(batchmode|compression|fallbacktorsh|forward(agent|x11)|keepalive|passwordauthentication|rhosts(|rsa)authentication|rsaauthentication|usersh|kerberos(authetication|tgtparsing)|usepriviledgedport)*)
-          compadd yes no && ret=0
-  	;;
-        *(#i)cipher*)
-          _description expl 'encryption cipher'
-          compadd "$expl[@]" idea des 3des blowfish arcfour tss none && ret=0
-          ;;
-        *(#i)globalknownhostsfile*)
-          _description expl 'global file with known hosts'
-          _files "$expl[@]" && ret=0
-          ;;
-        *(#i)hostname*)
-          _description expl 'real host name to log into'
-          _hosts "$expl[@]" && ret=0
-          ;;
-        *(#i)identityfile*)
-          _description expl 'SSH identity file'
-          _files "$expl[@]" && ret=0
-          ;;
-        *(#i)(local|remote)forward*)
-          state=forward
-          ;;
-        *(#i)proxycommand*)
-          compset -q
-  	  shift 1 words
-	  (( CURRENT-- ))
-          _normal && ret=0
-          ;;
-        *(#i)stricthostkeychecking*)
-          compadd yes no ask
-          ;;
-        *(#i)userknownhostsfile*)
-          _description expl 'user file with known hosts'
-          _files "$expl[@]" && ret=0
-          ;;
-        *(#i)user*)
-          _description expl 'user to log in as'
-          _users "$expl[@]" && ret=0
-          ;;
-        *(#i)xauthlocation*)
-          _description expl 'xauth program'
-          _files "$expl[@]" -g '*(*)' && ret=0
-          ;;
-        esac
-      else
-        _description expl 'configure file option'
-        compadd "$expl[@]" -M 'm:{a-z}={A-Z}' -S '=' - \
-                BatchMode ClearAllForwardings Cipher Compression CompressionLevel \
-	        Host ConnectionAttempts EscapeChar FallBackToRsh ForwardAgent \
-	        ForwardX11 GlobalKnownHostsFile HostName IdentityFile KeepAlive \
-	        KerberosAuthentication KerberosTgtPassing LocalForward \
-	        NumberOfPasswordPrompts PasswordAuthentication Port ProxyCommand \
-	        RemoteForward RhostsAuthentication RhostsRSAAuthentication \
-	        RSAAuthentication StrictHostKeyChecking TISAuthentication \
-	        UsePriviledgedPort User UserKnownHostsFile UseRsh \
-                XAuthLocation && ret=0
-      fi
-      ;;
-    forward)
-      if compset -P 1 '*:'; then
-        if compset -P '*:'; then
-          _message 'port number'
+  case "$words[1]" in
+  ssh|slogin)
+    args=(
+      ':remote host name:->userhost'
+      ':command: _command_names -e'
+      '*::args:->command'
+    )
+    ;&
+  ssh-opt)
+    _arguments -s \
+      '-a[disable forwarding of authentication agent connection]' \
+      '-c[select encryption cipher]:encryption cipher:(idea des 3des blowfish arcfour tss none)' \
+      '-e[set escape character]:escape character (or `none'"'"'):' \
+      '(-n)-f[go to background]' \
+      '-i[select identity file]:SSH identity file:_files' \
+      '-k[disable forwarding of kerberos tickets]' \
+      '-l[specify login name]:login name:_ssh_users' \
+      '-n[redirect stdin from /dev/null]' \
+      '*-o[specify extra options]:option string:->option' \
+      '-p[specify port on remote host]:port number on remote host:' \
+      '-q[quiet operation]' \
+      '-P[use non priviledged port]' \
+      '-t[force pseudo-tty allocation]' \
+      '-v[verbose mode]' \
+      '-V[show version number]' \
+      '-x[disable X11 forwarding]' \
+      '-C[compress all data]' \
+      '-L[specify local port forwarding]:local port forwarding:->forward' \
+      '-R[specify remote port forwarding]:remote port forwarding:->forward' \
+      "$args[@]" && ret=0
+
+    while [[ -n "$state" ]]; do
+      lstate="$state"
+      state=''
+
+      case "$lstate" in
+      option)
+        if compset -P '*[= ]'; then
+          case "$IPREFIX" in
+          *(#i)(batchmode|compression|fallbacktorsh|forward(agent|x11)|keepalive|passwordauthentication|rhosts(|rsa)authentication|rsaauthentication|usersh|kerberos(authetication|tgtparsing)|usepriviledgedport)*)
+            compadd yes no && ret=0
+            ;;
+          *(#i)cipher*)
+            _description expl 'encryption cipher'
+            compadd "$expl[@]" idea des 3des blowfish arcfour tss none && ret=0
+            ;;
+          *(#i)globalknownhostsfile*)
+            _description expl 'global file with known hosts'
+            _files "$expl[@]" && ret=0
+            ;;
+          *(#i)hostname*)
+            _description expl 'real host name to log into'
+            _ssh_hosts "$expl[@]" && ret=0
+            ;;
+          *(#i)identityfile*)
+            _description expl 'SSH identity file'
+            _files "$expl[@]" && ret=0
+            ;;
+          *(#i)(local|remote)forward*)
+            state=forward
+            ;;
+          *(#i)proxycommand*)
+            compset -q
+            shift 1 words
+            (( CURRENT-- ))
+            _normal && ret=0
+            ;;
+          *(#i)stricthostkeychecking*)
+            compadd yes no ask
+            ;;
+          *(#i)userknownhostsfile*)
+            _description expl 'user file with known hosts'
+            _files "$expl[@]" && ret=0
+            ;;
+          *(#i)user*)
+            _description expl 'user to log in as'
+            _ssh_users "$expl[@]" && ret=0
+            ;;
+          *(#i)xauthlocation*)
+            _description expl 'xauth program'
+            _files "$expl[@]" -g '*(*)' && ret=0
+            ;;
+          esac
         else
-          _hosts -S:
+          _description expl 'configure file option'
+          compadd "$expl[@]" -M 'm:{a-z}={A-Z}' -S '=' - \
+              BatchMode ClearAllForwardings Cipher Compression \
+              CompressionLevel Host ConnectionAttempts EscapeChar \
+              FallBackToRsh ForwardAgent ForwardX11 \
+              GlobalKnownHostsFile HostName IdentityFile KeepAlive \
+              KerberosAuthentication KerberosTgtPassing LocalForward \
+              NumberOfPasswordPrompts PasswordAuthentication Port \
+              ProxyCommand RemoteForward RhostsAuthentication \
+              RhostsRSAAuthentication RSAAuthentication \
+              StrictHostKeyChecking TISAuthentication \
+              UsePriviledgedPort User UserKnownHostsFile UseRsh \
+              XAuthLocation \
+            && ret=0
         fi
-      else
-        _message 'listen-port number'
-      fi
-      return
-      ;;
-    command)
-      shift 1 words
-      (( CURRENT-- ))
-      _normal
-      return
-      ;;
-    userhost)
-      if compset -P '*@'; then
-        _description expl 'remote host name'
-        _hosts "$expl[@]"
-	return
-      else
-        _description expl 'remote host name'
-        _hosts "$expl[@]" && ret=0
-	if (( ! $+options[-l] )); then
-	  _description expl 'login name'
-	  _users "$expl[@]" -S@ && ret=0
+        ;;
+      forward)
+        if compset -P 1 '*:'; then
+          if compset -P '*:'; then
+            _message 'port number'
+          else
+            _ssh_hosts -S: -q
+          fi
+        else
+          _message 'listen-port number'
         fi
-      fi
-      ;;
-    esac
+        return
+        ;;
+      command)
+        shift 1 words
+        (( CURRENT-- ))
+        _normal
+        return
+        ;;
+      userhost)
+        if compset -P '*@'; then
+          _description expl 'remote host name'
+          _ssh_hosts "$expl[@]" && ret=0
+        else
+          _description expl 'remote host name'
+          _ssh_hosts "$expl[@]" && ret=0
+          if (( ! $+options[-l] )); then
+            _description expl 'login name'
+            _ssh_users "$expl[@]" -S@ -q && ret=0
+          fi
+        fi
+        ;;
+      esac
 
-    break;
-  done
+      break;
+    done
 
-  return ret
-  ;;
-scp)
-  _arguments -s \
-    '-c[select encryption cipher]:encryption cipher:(idea des 3des blowfish arcfour tss none)' \
-    '-P[specify port on remote host]:port number on remote host:' \
-    '-i[select identity file]:SSH identity file:_files' \
-    '-S[specify path to ssh]:path to ssh:_files -g \*\(\*\)' \
-    '-o[give SSH options]:options:->options' \
-    '-p[preserve modification times]' \
-    '-r[recursively copy directories]' \
-    '-v[verbose mode]' \
-    '-B[batch mode]' \
-    '-C[compress data]' \
-    '*:file:->file' && ret=0
-
-  if [[ "$state" = options ]]; then
-    compset -q
-    words=(ssh-opt "$words[@]" )
-    (( CURRENT++ ))
-    _ssh
-    return
-  elif [[ -n "$state" ]]; then
-    if compset -P '*:'; then
-      _files && ret=0
-    elif compset -P '*@'; then
-      _hosts -S: && ret=0
-    else
-      _files && ret=0
-      _hosts -S: && ret=0
-      _users -S@ && ret=0
+    return ret
+    ;;
+  scp)
+    _arguments -s \
+      '-c[select encryption cipher]:encryption cipher:(idea des 3des blowfish arcfour tss none)' \
+      '-P[specify port on remote host]:port number on remote host:' \
+      '-i[select identity file]:SSH identity file:_files' \
+      '-S[specify path to ssh]:path to ssh:_files -g \*\(\*\)' \
+      '-o[give SSH options]:options:->options' \
+      '-p[preserve modification times]' \
+      '-r[recursively copy directories]' \
+      '-v[verbose mode]' \
+      '-B[batch mode]' \
+      '-C[compress data]' \
+      '*:file:->file' && ret=0
+
+    if [[ "$state" = options ]]; then
+      compset -q
+      words=(ssh-opt "$words[@]" )
+      (( CURRENT++ ))
+      _ssh
+      return
+    elif [[ -n "$state" ]]; then
+      if compset -P '*:'; then
+        _files && ret=0
+      elif compset -P '*@'; then
+        _ssh_hosts -S: && ret=0
+      else
+        _files && ret=0
+        _ssh_hosts -S: && ret=0
+        _ssh_users -S@ && ret=0
+      fi
     fi
+    return ret
+    ;;
+  ssh-add)
+    _arguments -s \
+      '-p[read passphrase from stdin]' \
+      '-l[list all identities]' \
+      '-d[remove identity]' \
+      '-D[delete all identities]' \
+      '*:SSH identity file:_files'
+    return
+    ;;
+  ssh-agent)
+    _arguments -s \
+      '(:)-k[kill agent automatically]' \
+      '(:)-s[force sh-style shell]' \
+      '(:)-c[force csh-style shell]' \
+      '*::command: _normal'
+    return
+    ;;
+  ssh-keygen)
+    _arguments \
+      '(-p -c -u -P)-b[specify number of bits in key]:bits in key:' \
+      '(-p -c)-f[key file]:key file:_files' \
+      '(-c -u)-N[specify new passphrase]:new passphrase:' \
+      '(-b -u -f)-P[specify old passphrase]:old passphrase:' \
+      '(-p -u)-C[specify new comment]:new comment:' \
+      '(-b -f -C -u -c)-p[change passphrase of private key file]' \
+      '(-b -f -N -p -u)-c[change comment in private and public key files]' \
+      '(-b -N -C -p -c)-u[change key cipher to default]'
+    return
+    ;;
+  esac
+}
+
+_ssh_users () {
+  _combination accounts_users_hosts users "$@"
+}
+
+_ssh_hosts () {
+  if [[ "$IPREFIX" == *@ ]]; then
+    _combination accounts_users_hosts "users=${IPREFIX/@}" hosts "$@"
+  else
+    _combination accounts_users_hosts \
+      ${options[-l]:+"users=${options[-l]:q}"} hosts "$@"
   fi
-  return ret
-  ;;
-ssh-add)
-  _arguments -s \
-    '-p[read passphrase from stdin]' \
-    '-l[list all identities]' \
-    '-d[remove identity]' \
-    '-D[delete all identities]' \
-    '*:SSH identity file:_files'
-  return
-  ;;
-ssh-agent)
-  _arguments -s \
-    '(:)-k[kill agent automatically]' \
-    '(:)-s[force sh-style shell]' \
-    '(:)-c[force csh-style shell]' \
-    '*::command: _normal'
-  return
-  ;;
-ssh-keygen)
-  _arguments \
-    '(-p -c -u -P)-b[specify number of bits in key]:bits in key:' \
-    '(-p -c)-f[key file]:key file:_files' \
-    '(-c -u)-N[specify new passphrase]:new passphrase:' \
-    '(-b -u -f)-P[specify old passphrase]:old passphrase:' \
-    '(-p -u)-C[specify new comment]:new comment:' \
-    '(-b -f -C -u -c)-p[change passphrase of private key file]' \
-    '(-b -f -N -p -u)-c[change comment in private and public key files]' \
-    '(-b -N -C -p -c)-u[change key cipher to default]'
-  return
-  ;;
-esac
+}
+
+_ssh "$@"
Index: Completion/User/_users_on
===================================================================
RCS file: _users_on
diff -N _users_on
--- /dev/null	Tue May  5 21:32:27 1998
+++ _users_on	Sun Sep 26 13:48:42 1999
@@ -0,0 +1,11 @@
+#autoload write
+
+local expl
+
+if which users >/dev/null; then
+  _description expl users logged on
+  compadd "$@" "$expl[@]" - $(users) && return 0
+else
+  # Other methods of finding out users logged on should be added here
+  return 1
+fi

