From zsh-workers-return-13189-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Nov 24 08:06:17 2000
Return-Path: <zsh-workers-return-13189-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 267 invoked from network); 24 Nov 2000 08:06:16 -0000
Received: from sunsite.dk (HELO sunsite.auc.dk) (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 24 Nov 2000 08:06:16 -0000
Received: (qmail 15216 invoked by alias); 24 Nov 2000 08:06:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 13189
Received: (qmail 15209 invoked from network); 24 Nov 2000 08:06:06 -0000
Date: Fri, 24 Nov 2000 09:06:04 +0100 (MET)
Message-Id: <200011240806.JAA17838@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Thu, 23 Nov 2000 19:14:20 +0000
Subject: Re: PATCH: Re: Allowing traps


Bart Schaefer wrote:

> ...
> 
> The short answer would be "everywhere that we manipulate global variables
> that are pointers."  That's a bit strong, as simple dereferencing should
> be OK.  Based on a grep of *.(c|h|e#pro) files, there appear to be at least
> 234 such variables (including structs that may contain pointers, though I
> may have missed some of those), of which 44 are static and 57 are part of
> the completion system.  Another 35 are part of ZLE.
> 
> So 25% of the global pointers are in the completion system, and I'd be
> willing to bet that it modifies its globals a lot more heavily than just
> about anything except the memory allocators.  That makes the completion
> system an awfully large target for an interactive shell that's receiving
> SIGALRM once every second; no wonder Thomas is seeing problems.
> 
> The other pesky bits are the parameter tables, which could mostly be
> covered by doctoring params.c.

Judging from the debugging output I got from Thomas I think it was
this part that finally caused the SEGVs (if I remember correctly).

And hence I'm not convinced that the completion code (note: `code',
not `system') is really a problem. In fact, it should be easy to make
safe once the other code is safe. Because nowadays we have only very
few entry points to the completion code that can be guarded to
disallow invoking the code while it is still being executed (i.e. make 
sure that trap handlers can't call it -- that wouldn't make much sense 
anyway, I think).

And later we can put all the completion state in a struct and use that 
to make it reentrant. Something I've been wishing to have for the
lexing, parsing and execution code for years (there we use structs to
safe and restore the state, copying it from/to global variables).

Bye
 Sven


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

