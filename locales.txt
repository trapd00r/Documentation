Date: Sun, 13 Mar 2011 18:33:48 -0600
From: Tom Christiansen <tchrist@perl.com>
To: demerphq <demerphq@gmail.com>
cc: Karl Williamson <public@khwilliamson.com>,
        Perl5 Porters Mailing List <perl5-porters@perl.org>,
        Dave Mitchell <davem@iabyn.com>
Subject: Re: RESOLVED: C<use locale> Considered Harmful
X-Mailer: nmh v1.3 && nvi v1.79 (duh!)

Here's a summary of pros and cons I've picked up on about locales.

What else am I forgetting?

thanks,

--tom

CONS:

   1. Locales may or may not exist; e.g. Linux has 726, Darwin 203,
      Solaris 21, and OpenBSD has 0 locales.

   2. There is no formal standard for locales’ naming conventions.

   3. You are at the mercy of your platform provider’s implementation
      bugs; there is zero guarantee that locale XX_yy will behave in any
      particular fashion, apart from LC_ALL=C.

   4. Locales encourage a return to those painful pre-Unicode days
      when the same code point means one character on locale A and
      another under locale B.  This is terrible.

   5. Under Perl’s current design, only 8-bit locales *can* ever work
      correctly, even if absolutely everything else is peachy.  That
      means UTF-8 can never work.

   6. They do not offer anything like the flexibility available under
      the Unicode Collating Algorithm.

   7. They conflate many disparate ideas, like charset vs encoding; e.g,
      there are ASCII, Latin1, and UTF-8 locales for various country and
      language pairs, and yet there are no "cp1252" or "macroman" locales.

PROS:

   1. They allow processing of (some!) legacy datasets without
      any special handling.

   2. Locales can have characters whose code points have no assigned
      Unicode mapping.  You’d have to invent some private-use mapping,
      and then define semantics for those.  Where *should* something
      lke ‹›, MacRoman 0xF0 (maybe U+F8FF?) sort to, anyway? :)

   2. Perl’s builtin sort under C<use locale> is fully two orders of
      magnitude faster than using Unicode::Collate::Locale, itself even
      slower than the already-phlegmatic Unicode::Collate.  So if you
      have something in an old legacy 8-bit encoding, you can sort it
      much, much faster.  It just doesn’t work with modern Unicode text.

   3. Just because POSIX locales have issues doesn’t mean the idea
      itself is inherently flawed.  Indeed, it seems inescapable that
      locale-specific tailorings *must* be possible.  The question then
      is how—and whether—they integrate with language-agnostic Unicode.

   4. I18N != L10N: Locales are about *much* more than LC_CYTPE and
      LC_COLLATE. There’s also LC_MESSAGES, LC_MONETARY, LC_NUMERIC,
      and LC_TIME. On some systems, there may also be such things as
      LC_ADDRESS, LC_IDENTIFICATION, LC_MEASUREMENT, LC_NAME,
      LC_NUMERIC, LC_PAPER, and LC_TELEPHONE.  There is strong support
      in the Perl core for some of those:

        % corelist /Locale/
        Locale::Codes was first released with perl v5.13.1
        Locale::Codes::Country was first released with perl v5.13.1
        Locale::Codes::Currency was first released with perl v5.13.1
        Locale::Codes::Language was first released with perl v5.13.1
        Locale::Codes::Script was first released with perl v5.13.1
        Locale::Constants was first released with perl v5.7.3
        Locale::Country was first released with perl v5.7.3
        Locale::Currency was first released with perl v5.7.3
        Locale::Language was first released with perl v5.7.3
        Locale::Maketext was first released with perl v5.7.3
        Locale::Maketext::Guts was first released with perl v5.8.1
        Locale::Maketext::GutsLoader was first released with perl v5.8.1
        Locale::Maketext::Simple was first released with perl v5.9.5
        Locale::Script was first released with perl v5.7.3
        Unicode::Collate::Locale was first released with perl v5.13.4
