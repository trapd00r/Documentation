From zsh-workers-request@euclid.skiles.gatech.edu  Sat Nov 16 00:40:30 1996
Return-Path: zsh-workers-request@euclid.skiles.gatech.edu
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.6/8.7.3) with ESMTP id AAA02440 for <mason@primenet.com.au>; Sat, 16 Nov 1996 00:40:26 +1100 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id IAA16852; Fri, 15 Nov 1996 08:35:28 -0500 (EST)
Resent-Date: Fri, 15 Nov 1996 08:35:28 -0500 (EST)
From: Zefram <zefram@dcs.warwick.ac.uk>
Message-Id: <6342.199611151335@stone.dcs.warwick.ac.uk>
Subject: dynamic multios
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Fri, 15 Nov 1996 13:35:38 +0000 (GMT)
X-Patch: 124
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]8427.83
X-US-Congress: Moronic fuckers
Content-Type: text
Resent-Message-ID: <"EkTU92.0.B74.V67Zo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2414
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

This patch makes multios dynamically resizeable.  The recent patch to
make zsh warn instead of running off the end of the struct should *not*
be applied first; back it out if you've already applied it.

I implement this by resizing the struct multio as required.  This causes
some overhead when building up a very large multio (order n^2 ultimately),
but there is no overhead for multios less than 9 files, and the overhead
is quite small in any usual case.  It is certainly preferable to the
other obvious method, of forking off an intermediate cat/tee process,
as could be done by calling closemn() when the struct fills up.

 -zefram

      Index: Src/exec.c
      ===================================================================
      RCS file: /home/zefram/usr/cvsroot/zsh/Src/exec.c,v
      retrieving revision 1.36
      diff -c -r1.36 exec.c
      *** exec.c	1996/11/15 00:40:12	1.36
      --- exec.c	1996/11/15 03:10:19
      ***************
      *** 1047,1054 ****
        	    mfds[fd1]->pipe = pipes[1 - rflag];
        	    redup(pipes[rflag], fd1);
        	    mfds[fd1]->ct = 2;
      ! 	} else			/* add another fd to an already split stream */
        	    mfds[fd1]->fds[mfds[fd1]->ct++] = movefd(fd2);
            }
            if (subsh_close >= 0 && !fdtable[subsh_close])
        	subsh_close = -1;
      --- 1047,1060 ----
        	    mfds[fd1]->pipe = pipes[1 - rflag];
        	    redup(pipes[rflag], fd1);
        	    mfds[fd1]->ct = 2;
      ! 	} else {		/* add another fd to an already split stream */
      ! 	    if(!(mfds[fd1]->ct % MULTIOUNIT)) {
      ! 		int new = sizeof(struct multio) + sizeof(int) * mfds[fd1]->ct;
      ! 		int old = new - sizeof(int) * MULTIOUNIT;
      ! 		mfds[fd1] = hrealloc((char *)mfds[fd1], old, new);
      ! 	    }
        	    mfds[fd1]->fds[mfds[fd1]->ct++] = movefd(fd2);
      + 	}
            }
            if (subsh_close >= 0 && !fdtable[subsh_close])
        	subsh_close = -1;
      Index: Src/zsh.h
      ===================================================================
      RCS file: /home/zefram/usr/cvsroot/zsh/Src/zsh.h,v
      retrieving revision 1.25
      diff -c -r1.25 zsh.h
      *** zsh.h	1996/11/08 01:23:12	1.25
      --- zsh.h	1996/11/15 03:09:36
      ***************
      *** 480,488 ****
            List loop;			/* list to execute until condition met */
        };
        
      ! /* The maximum number of redirections you *
      !  * can have on a single file descriptor.  */
      ! #define MAXREDIRECT 16
        
        /* A multio is a list of fds associated with a certain fd.       *
         * Thus if you do "foo >bar >ble", the multio for fd 1 will have *
      --- 480,488 ----
            List loop;			/* list to execute until condition met */
        };
        
      ! /* The number of fds space is allocated for  *
      !  * each time a multio must increase in size. */
      ! #define MULTIOUNIT 8
        
        /* A multio is a list of fds associated with a certain fd.       *
         * Thus if you do "foo >bar >ble", the multio for fd 1 will have *
      ***************
      *** 496,508 ****
            int ct;			/* # of redirections on this fd                 */
            int rflag;			/* 0 if open for reading, 1 if open for writing */
            int pipe;			/* fd of pipe if ct > 1                         */
      !     int fds[MAXREDIRECT];	/* list of src/dests redirected to/from this fd */
        };
      - 
      - struct fdpair {
      -     int fd1, fd2;
      - };
      - 
        
        /* variable assignment tree element */
        
      --- 496,503 ----
            int ct;			/* # of redirections on this fd                 */
            int rflag;			/* 0 if open for reading, 1 if open for writing */
            int pipe;			/* fd of pipe if ct > 1                         */
      !     int fds[MULTIOUNIT];	/* list of src/dests redirected to/from this fd */
        };
        
        /* variable assignment tree element */
        

-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBMovig3D/+HJTpU/hAQF64AP9GnytLZP9Dwo/hlltw3ICCQM9BzKjHWOn
lENcSFXdIEpIWoKPDDN4pHYNe5x08WU54xUJZDerEEtarCzMYFzrGNTGKkiqSOf0
Qo3swujwKR5p58E3jQjL4khtGiLtft2YbBWFGbO005+BmQ02iBQatFH1m8VKGnWy
HgEdjPR/Rgk=
=sTKP
-----END PGP SIGNATURE-----

