Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Wed, 3 Feb 1999 16:00:52 +0100 (MET)
Message-Id: <199902031500.QAA12969@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 2 Feb 1999 08:54:15 -0800
Subject: Re: Fun with zsh (Re: Associative array ordering (Re: Example function))
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5206


Bart Schaefer wrote:

> Following application of your patch, using 3.1.5-pws-6 zsh -f,
> 
>     zsh% foo=('(I*)<TAB>
> 
> only feeps, but
> 
>     zsh% foo(
>     array> '(I*)<TAB>
> 
> autolists the entire contents of the current directory.
> 
> This is the same as the 3.0.5 behavior, but it still seems odd to me.

Whew. The first behavior is the correct one, since the completion code 
should take the `(I*)' as the prefix of the string to complete and as
long as you don't have a file with a name starting with this, nothing
should be matched.

Making this work in every position in arrays wasn't that easy since
the lexer sometimes reported that it was in command position and there 
it started to parse the string itself instead of reporting it as one
string token. In fact, to avoid fiddling with the lexer, I had to add
an in-array-value-flag in get_comp_string (to recognise the end if you 
are completing something like `foo=( ... ); frob <TAB>').

People using the new style completion stuff (and the new-completion-examples
find) who test the thing quoted above will notice that it completes
files beginning with `I' in this case. This is due to the parameter
handling in pfiles(). More precisely, this is due to the fact that we
still haven't got a way to quote strings resulting from a parameter
expansion (supporting the `q' modifier for parameter expansion has
long been on the wish list but still isn't implemented).

Bye
 Sven

diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Wed Feb  3 12:07:22 1999
+++ Src/Zle/zle_tricky.c	Wed Feb  3 15:46:24 1999
@@ -919,7 +919,7 @@
 static char *
 get_comp_string(void)
 {
-    int t0, tt0, i, j, k, cp, rd, sl, ocs, ins, oins;
+    int t0, tt0, i, j, k, cp, rd, sl, ocs, ins, oins, inarr, ia, parct;
     char *s = NULL, *linptr, *tmp, *p, *tt = NULL;
 
     zsfree(brbeg);
@@ -982,7 +982,7 @@
 	inpush(dupstrspace((char *) linptr), 0, NULL);
 	strinbeg();
 	stophist = 2;
-	i = tt0 = cp = rd = ins = oins = 0;
+	i = tt0 = cp = rd = ins = oins = inarr = parct = ia = 0;
 
 	/* This loop is possibly the wrong way to do this.  It goes through *
 	 * the previously massaged command line using the lexer.  It stores *
@@ -1001,7 +1001,21 @@
 	    linredir = (inredir && !ins);
 	    oins = ins;
 	    /* Get the next token. */
+	    if (inarr)
+		incmdpos = 0;
 	    ctxtlex();
+	    if (tok == ENVARRAY) {
+		inarr = 1;
+		zsfree(varname);
+		varname = ztrdup(tokstr);
+	    } else if (tok == INPAR)
+		parct++;
+	    else if (tok == OUTPAR) {
+		if (parct)
+		    parct--;
+		else
+		    inarr = 0;
+	    }
 	    if (inredir)
 		rdstr = tokstrings[tok];
 	    if (tok == DINPAR)
@@ -1043,6 +1057,7 @@
 		clwpos = i;
 		cp = lincmd;
 		rd = linredir;
+		ia = inarr;
 		if (inwhat == IN_NOTHING && incond)
 		    inwhat = IN_COND;
 	    } else if (linredir)
@@ -1084,8 +1099,13 @@
 	zsfree(clwords[clwnum]);
 	clwords[clwnum] = NULL;
 	t0 = tt0;
-	lincmd = cp;
-	linredir = rd;
+	if (ia) {
+	    lincmd = linredir = 0;
+	    inwhat = IN_ENV;
+	} else {
+	    lincmd = cp;
+	    linredir = rd;
+	}
 	strinend();
 	inpop();
 	errflag = zleparse = 0;
@@ -3313,7 +3333,12 @@
 	    case IN_ENV:
 		compcontext = "value";
 		compcommand = varname;
-		usea = 0;
+		if (!clwpos) {
+		    clwpos = 1;
+		    zsfree(clwords[1]);
+		    clwords[1] = ztrdup(s);
+		}
+		aadd = 1;
 		break;
 	    case IN_COND:
 		compcontext = "condition";

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

