From zsh-workers-request@math.gatech.edu Thu Nov 27 07:33:38 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 5970 invoked from network); 27 Nov 1997 07:33:36 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 27 Nov 1997 07:33:36 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id CAA03773;
	Thu, 27 Nov 1997 02:17:04 -0500 (EST)
Resent-Date: Thu, 27 Nov 1997 02:17:04 -0500 (EST)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <971126231649.ZM786@candle.brasslantern.com>
Date: Wed, 26 Nov 1997 23:16:49 -0800
In-Reply-To: <199711262005.UAA10159@dal-tsa15-34.cyberramp.net>
Comments: In reply to TGAPE! <tgape@cyberramp.net>
        "night of the living dead (processes)?" (Oct 22, 12:14am)
References: <199711262005.UAA10159@dal-tsa15-34.cyberramp.net>
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: TGAPE! <tgape@cyberramp.net>, zsh-workers@math.gatech.edu
Subject: Re: night of the living dead (processes)?
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"KRJ5_.0.uw.lvHVq"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3635
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Oct 22, 12:14am, TGAPE! wrote:
} Subject: night of the living dead (processes)?
}
} Is there any way to handle the children produced in the <() construct
} (and similar ones, as well) in zsh, instead of tossing them to init?

The only way a process should ever get "tossed" is if its parent exits
without wait()ing for it.  The top-level zsh obviously isn't exiting (is
it?), so that must mean zsh fork()ed and then the subshell fork()ed again
before the orphaned process was finally exec()d.  That in turn means (at
least I think it must) that you have a pipeline inside the <(...).

The only way to avoid orphaning those jobs would be to have intermediate
subshells fork() an additional time, rather than exec()ing the last job
in the pipeline directly, and then hang around doing nothing but wait()
until all the piped jobs have exited.  Only init and the immediate parent
of a job may wait() for it.  So you either have to burn an extra slot in
the process table (and swap space for a duplicate of the shell) for the
full duration of every subshelled pipeline, or do what zsh (and bash, it
seems) does.

I suppose which is best depends on whether your performance is CPU-limited
or process-space-limited.

} I'm running ZSH_VERSION 3.1.1.  I contemplated upgrading to 3.0.5

Changing to 3.0.5 would not alter this process management behavior.

> but it's
} slower for all of my longest running tasks (**/glob stuff, and such) as
} well as all other so I did not make install.

What do you mean "as well as all other"?

Can you give some more specific examples, and some statistics?  Is there
an earlier 3.0.x that shows the performance you expect, or is there some
reason why all 3.1.y should be faster than 3.0.x?  I haven't noticed any
particular difference from earlier 3.0s with 3.0.5.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

