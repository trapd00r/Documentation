From zsh-users-return-11130-mason-zsh=primenet.com.au@sunsite.dk Thu Jan 18 19:53:37 2007
Return-Path: <zsh-users-return-11130-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9248 invoked from network); 18 Jan 2007 19:53:32 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.7 (2006-10-05) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=BAYES_00,FORGED_RCVD_HELO,
	HTML_MESSAGE autolearn=ham version=3.1.7
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 18 Jan 2007 19:53:32 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 64099 invoked from network); 18 Jan 2007 19:53:26 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 18 Jan 2007 19:53:26 -0000
Received: (qmail 4405 invoked by alias); 18 Jan 2007 19:53:13 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 11130
Received: (qmail 4392 invoked from network); 18 Jan 2007 19:53:12 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 18 Jan 2007 19:53:12 -0000
Received: (qmail 62331 invoked from network); 18 Jan 2007 19:53:11 -0000
Received: from nz-out-0506.google.com (64.233.162.237)
  by a.mx.sunsite.dk with SMTP; 18 Jan 2007 19:53:06 -0000
Received: by nz-out-0506.google.com with SMTP id s1so224345nze
        for <zsh-users@sunsite.dk>; Thu, 18 Jan 2007 11:53:04 -0800 (PST)
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=beta;
        h=received:message-id:date:from:to:subject:mime-version:content-type;
        b=qypmxEQMbZU5epinGLYTakxkeqZOJwpSzqAeBTgahuOd4w7KQtIFz+L6Sx0p9A1gJ7JaaqoMwKEV6qdxSvypnjjuZ9dDn8pq31E6teTBHoZpIZ0FUNFCZM+S55wynKZ7i4cItk6tCv9Ckov5QrGYYY7YZ9vKnvbutVkPLLV6dPU=
Received: by 10.35.93.19 with SMTP id v19mr2188587pyl.1169149984690;
        Thu, 18 Jan 2007 11:53:04 -0800 (PST)
Received: by 10.35.121.16 with HTTP; Thu, 18 Jan 2007 11:53:04 -0800 (PST)
Message-ID: <e5d50bd20701181153j4ac7faeajd0ec871ea02af518@mail.gmail.com>
Date: Thu, 18 Jan 2007 11:53:04 -0800
From: "Gerald Lai" <laigera@gmail.com>
To: zsh-users@sunsite.dk
Subject: Case statement with ";|" [not implemented]
MIME-Version: 1.0
Content-Type: multipart/alternative; 
	boundary="----=_Part_117686_4062270.1169149984657"

------=_Part_117686_4062270.1169149984657
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello all :)

I'm new to the mailing list.

I'm trying to convert the (simplified) code below to a case statement
structure:
===
  if [[ $mycase -eq 0 ]]; then
      echo "mycase is 0"
  else
      if [[ $mycase -eq 1 ]]; then
          echo "mycase is 1"
      else
          echo "mycase is 2"
      fi
      echo "mycase is 1 or 2"
  fi
===

And this is what I got:
===
  case $mycase in
      0)
          echo "mycase is 0"
          ;;

      1)
          echo "mycase is 1"
          ;;

      2)
          echo "mycase is 2"
  esac
  if [[ $mycase -gt 0 ]] echo "mycase is 1 or 2"
===

My question is, shouldn't there be a way to do this:
===
  case $mycase in
      0)
          echo "mycase is 0"
          ;;

      1)
          echo "mycase is 1"
          ;|

      2)
          echo "mycase is 2"
          ;|

      *)
          echo "mycase is 1 or 2"
  esac
===

Note that ";|" provides an OR-like separator (as opposed to the AND-like
";&" separator) that goes through the case statements. However, unlike ";&",
it checks $mycase against 1) and 2) instead of blindly executing case
statements 1 & 2.

Wouldn't this be a good addition to ZSH? It certainly seems more useful than
";&".
--
Gerald Lai

------=_Part_117686_4062270.1169149984657
Content-Type: text/html; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hello all :)<br><br>I&#39;m new to the mailing list.<br><br>I&#39;m trying to convert the (simplified) code below to a case statement structure:<br>===<br>&nbsp; if [[ $mycase -eq 0 ]]; then<br>&nbsp; &nbsp; &nbsp; echo &quot;mycase is 0&quot;
<br>&nbsp; else<br>&nbsp; &nbsp; &nbsp; if [[ $mycase -eq 1 ]]; then<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; echo &quot;mycase is 1&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;mycase is 2&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi<br>&nbsp;&nbsp; &nbsp;&nbsp; echo &quot;mycase is 1 or 2&quot;<br>&nbsp; fi<br>===<br><br>
And this is what I got:<br>===<br>&nbsp; case $mycase in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 0&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 1&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 2&quot;
<br>&nbsp; esac<br>&nbsp; if [[ $mycase -gt 0 ]] echo &quot;mycase is 1 or 2&quot;<br>===<br><br>My question is, shouldn&#39;t there be a way to do this:<br>===<br>&nbsp; case $mycase in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 0&quot;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 1&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;|<br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 2&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;|<br>
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo &quot;mycase is 1 or 2&quot;<br>
&nbsp; esac<br>===<br><br>Note that &quot;;|&quot; provides an OR-like separator (as opposed to the AND-like &quot;;&amp;&quot; separator) that goes through the case statements. However, unlike &quot;;&amp;&quot;, it checks $mycase against 1) and 2) instead of blindly executing case statements 1 &amp; 2.
<br><br>Wouldn&#39;t this be a good addition to ZSH? It certainly seems more useful than &quot;;&amp;&quot;.<br>--<br>Gerald Lai<br>

------=_Part_117686_4062270.1169149984657--

