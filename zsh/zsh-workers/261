From zsh-workers-request@math.gatech.edu  Sun Jul 23 12:45:14 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.mira.net.au (8.6.12/8.6.9) with SMTP id MAA11724 for <mason@werple.mira.net.au>; Sun, 23 Jul 1995 12:45:04 +1000
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA01120
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Sat, 22 Jul 1995 22:43:25 -0400
Received: by math (5.x/SMI-SVR4)
	id AA27670; Sat, 22 Jul 1995 22:39:23 -0400
Resent-Date: Sun, 23 Jul 1995 03:40:03 +0100 (BST)
Old-Return-Path: <zefram@dcs.warwick.ac.uk>
From: Zefram <A.Main@dcs.warwick.ac.uk>
Message-Id: <23313.199507230240@stone.dcs.warwick.ac.uk>
Subject: Minibuffer patch
To: zsh-workers@math.gatech.edu (Z Shell workers mailing list)
Date: Sun, 23 Jul 1995 03:40:03 +0100 (BST)
X-Loop: zefram@dcs.warwick.ac.uk
X-Stardate: [-31]6020.55
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-Id: <"_y9t61.0.Gm6.QPR4m"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/261
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

-----BEGIN PGP SIGNED MESSAGE-----

The patch below improves the three minibuffer functions.  It increases
the number of commands that will work.  It also makes the history
search minibuffers accept arbitrarily long search strings.  After this
patch, the three minibuffers consistently accept clear-screen and
redisplay as editing functions, all start editing in insert mode, and
all have an _ cursor.

 -zefram

      *** 1.7	1995/07/22 18:40:04
      --- Src/zle_misc.c	1995/07/23 00:32:19
      ***************
      *** 557,575 ****
            return ol;
        }
        
      ! #define NAMLEN 70
        
        /**/
        int
        executenamedcommand(char *prmt)
        {
      -     char buf[NAMLEN+1], *ptr;
            int len, cmd, t0, l = strlen(prmt);
        
            strcpy(buf, prmt);
      -     ptr = buf + l;
      -     len = 0;
            statusline = buf;
            for (;;) {
        	ptr[0] = '_';
        	ptr[1] = '\0';
      --- 557,577 ----
            return ol;
        }
        
      ! #define NAMLEN 60
        
        /**/
        int
        executenamedcommand(char *prmt)
        {
            int len, cmd, t0, l = strlen(prmt);
      +     char *ptr, *buf = halloc(l + NAMLEN + 2);
      +     int *obindtab = bindtab;
        
            strcpy(buf, prmt);
            statusline = buf;
      +     bindtab = mainbindtab;
      +     ptr = buf += l;
      +     len = 0;
            for (;;) {
        	ptr[0] = '_';
        	ptr[1] = '\0';
      ***************
      *** 577,585 ****
      --- 579,603 ----
        	*ptr = '\0';
        	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
        	    statusline = NULL;
      + 	    bindtab = obindtab;
        	    return z_undefinedkey;
        	}
        	switch (cmd) {
      + 	case z_sendstring:
      + 	    sendstring();
      + 	    break;
      + 	case z_clearscreen:
      + 	    clearscreen();
      + 	    break;
      + 	case z_redisplay:
      + 	    redisplay();
      + 	    break;
      + 	case z_quotedinsert:
      + 	    if((c = getkey(0)) == EOF || !c || len == NAMLEN)
      + 		feep();
      + 	    else
      + 		*ptr++ = c, len++;
      + 	    break;
        	case z_backwarddeletechar:
        	case z_vibackwarddeletechar:
        	    if (len)
      ***************
      *** 594,613 ****
        	case z_vikillline:
        	case z_backwardkillline:
        	    len = 0;
      ! 	    ptr = buf + l;
        	    break;
        	case z_acceptline:
        	    for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
      ! 		if (!strcmp(buf + l, zlecmds[t0].name))
        		    break;
        	    if (t0 != ZLECMDCOUNT) {
        		lastnamed = t0;
        		statusline = NULL;
        		return t0;
        	    }
        	    /* fall through */
        	default:
        	    if (cmd == z_listchoices || cmd == z_deletecharorlist ||
        		cmd == z_acceptline || c == ' ' || c == '\t') {
        		LinkList cmdll;
        		int ambig = 100;
      --- 612,642 ----
        	case z_vikillline:
        	case z_backwardkillline:
        	    len = 0;
      ! 	    ptr = buf;
        	    break;
        	case z_acceptline:
      + 	case z_vicmdmode:
      + 	unambiguous:
        	    for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
      ! 		if (!strcmp(buf, zlecmds[t0].name))
        		    break;
        	    if (t0 != ZLECMDCOUNT) {
        		lastnamed = t0;
        		statusline = NULL;
      + 		bindtab = obindtab;
        		return t0;
        	    }
        	    /* fall through */
        	default:
      + 	    if(cmd == z_selfinsertunmeta) {
      + 		c &= 0x7f;
      + 		if(c == '\r')
      + 		    c = '\n';
      + 		cmd = z_selfinsert;
      + 	    }
        	    if (cmd == z_listchoices || cmd == z_deletecharorlist ||
      + 		cmd == z_expandorcomplete || cmd == z_expandorcompleteprefix ||
      + 		cmd == z_completeword || cmd == z_vicmdmode ||
        		cmd == z_acceptline || c == ' ' || c == '\t') {
        		LinkList cmdll;
        		int ambig = 100;
      ***************
      *** 615,621 ****
        		heapalloc();
        		cmdll = newlinklist();
        		for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
      ! 		    if (strpfx(buf + l, zlecmds[t0].name)) {
        			int xx;
        
        			addlinknode(cmdll, zlecmds[t0].name);
      --- 644,650 ----
        		heapalloc();
        		cmdll = newlinklist();
        		for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
      ! 		    if (strpfx(buf, zlecmds[t0].name)) {
        			int xx;
        
        			addlinknode(cmdll, zlecmds[t0].name);
      ***************
      *** 627,641 ****
        		permalloc();
        		if (empty(cmdll))
        		    feep();
      ! 		else if (cmd == z_listchoices ||
      ! 			 cmd == z_deletecharorlist)
        		    listlist(cmdll);
        		else if (!nextnode(firstnode(cmdll))) {
      ! 		    strcpy(ptr = buf + l, peekfirst(cmdll));
        		    ptr += (len = strlen(ptr));
        		} else {
      ! 		    strcpy(buf + l, peekfirst(cmdll));
      ! 		    ptr = buf + l + ambig;
        		    ptr[0] = '_';
        		    ptr[1] = '\0';
        		    if (isset(AUTOLIST) &&
      --- 656,671 ----
        		permalloc();
        		if (empty(cmdll))
        		    feep();
      ! 		else if (cmd == z_listchoices || cmd == z_deletecharorlist)
        		    listlist(cmdll);
        		else if (!nextnode(firstnode(cmdll))) {
      ! 		    strcpy(ptr = buf, peekfirst(cmdll));
        		    ptr += (len = strlen(ptr));
      + 		    if(cmd == z_acceptline || cmd == z_vicmdmode)
      + 			goto unambiguous;
        		} else {
      ! 		    strcpy(buf, peekfirst(cmdll));
      ! 		    ptr = buf + ambig;
        		    ptr[0] = '_';
        		    ptr[1] = '\0';
        		    if (isset(AUTOLIST) &&
      ***************
      *** 647,653 ****
        		    len = ambig;
        		}
        	    } else {
      ! 		if (len == NAMLEN - l - 1 || icntrl(c) || cmd != z_selfinsert)
        		    feep();
        		else
        		    *ptr++ = c, len++;
      --- 677,683 ----
        		    len = ambig;
        		}
        	    } else {
      ! 		if (len == NAMLEN || icntrl(c) || cmd != z_selfinsert)
        		    feep();
        		else
        		    *ptr++ = c, len++;
      *** 1.2	1995/07/21 22:10:34
      --- Src/zle_hist.c	1995/07/23 02:20:38
      ***************
      *** 589,597 ****
        doisearch(int dir)
        {
            char *s, *oldl;
      !     char ibuf[256], *sbuf = ibuf + 14;
      !     int sbptr = 0, cmd, ohl = histline, ocs = cs;
            int nomatch, chequiv = 0;
        
            strcpy(ibuf, (dir == -1) ? "bck-i-search: " : "fwd-i-search: ");
            statusline = ibuf;
      --- 589,598 ----
        doisearch(int dir)
        {
            char *s, *oldl;
      !     char *ibuf = halloc(80), *sbuf = ibuf + 14;
      !     int sbptr = 0, cmd, ohl = histline, ocs = cs, sibuf = 80;
            int nomatch, chequiv = 0;
      +     int odir = dir, *obindtab = bindtab;
        
            strcpy(ibuf, (dir == -1) ? "bck-i-search: " : "fwd-i-search: ");
            statusline = ibuf;
      ***************
      *** 602,607 ****
      --- 603,609 ----
            }
            bindtab = mainbindtab;
            for (;;) {
      + 	sbuf[sbptr] = '\0';
        	nomatch = 0;
        	if (sbptr > 1 || (sbptr == 1 && sbuf[0] != '^')) {
        	    int ohistline = histline;
      ***************
      *** 627,632 ****
      --- 629,637 ----
        	    }
        	    chequiv = 0;
        	}
      + 	sbuf[sbptr] = '_';
      + 	sbuf[sbptr + 1] = 0;
      +     ref:
        	refresh();
        	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
        	    setline(oldl);
      ***************
      *** 635,647 ****
        	    break;
        	}
        	switch (cmd) {
        	case z_vicmdmode:
        	    bindtab = (bindtab == mainbindtab) ? altbindtab : mainbindtab;
      ! 	    continue;
        	case z_vibackwarddeletechar:
        	case z_backwarddeletechar:
        	    if (sbptr)
      ! 		sbuf[--sbptr] = '\0';
        	    else
        		feep();
        	    histline = ohl;
      --- 640,658 ----
        	    break;
        	}
        	switch (cmd) {
      + 	case z_clearscreen:
      + 	    clearscreen();
      + 	    goto ref;
      + 	case z_redisplay:
      + 	    redisplay();
      + 	    goto ref;
        	case z_vicmdmode:
        	    bindtab = (bindtab == mainbindtab) ? altbindtab : mainbindtab;
      ! 	    goto ref;
        	case z_vibackwarddeletechar:
        	case z_backwarddeletechar:
        	    if (sbptr)
      ! 		sbptr--;
        	    else
        		feep();
        	    histline = ohl;
      ***************
      *** 658,704 ****
        	case z_acceptline:
        	    acceptline();
        	    goto brk;
      - 	case z_virevrepeatsearch:
        	case z_historyincrementalsearchbackward:
      ! 	    ohl = (histline += (dir = -1));
      ! 	    chequiv = 1;
      ! 	    memcpy(ibuf, "bck", 3);
      ! 	    refresh();
      ! 	    continue;
      ! 	case z_virepeatsearch:
        	case z_historyincrementalsearchforward:
      ! 	    ohl = (histline += (dir = 1));
        	    chequiv = 1;
      ! 	    memcpy(ibuf, "fwd", 3);
        	    refresh();
        	    continue;
        	case z_sendstring:
        	    sendstring();
      ! 	    continue;
        	case z_quotedinsert:
        	    if ((c = getkey(0)) == EOF)
        		goto brk;
        	    else
        		cmd = z_selfinsert;
        	default:
      ! 	    if (cmd == z_magicspace)
        		c = ' ';
      ! 	    else if (cmd != z_selfinsert && cmd != z_selfinsertunmeta) {
        		if (ungetok)
        		    ungetkey(c);
        		else
        		    feep();
        		goto brk;
        	    }
      ! 	    if (!nomatch && sbptr != 39) {
        		sbuf[sbptr++] = c;
      ! 		sbuf[sbptr] = '\0';
      ! 	    }
        	}
            }
          brk:
            free(oldl);
            statusline = NULL;
        }
        
        /**/
      --- 669,729 ----
        	case z_acceptline:
        	    acceptline();
        	    goto brk;
        	case z_historyincrementalsearchbackward:
      ! 	    dir = -1;
      ! 	    goto rpt;
        	case z_historyincrementalsearchforward:
      ! 	    dir = 1;
      ! 	    goto rpt;
      ! 	case z_virevrepeatsearch:
      ! 	    dir = -odir;
      ! 	    goto rpt;
      ! 	case z_virepeatsearch:
      ! 	    dir = odir;
      ! 	rpt:
      ! 	    ohl = (histline += dir);
        	    chequiv = 1;
      ! 	    memcpy(ibuf, (dir == 1) ? "fwd" : "bck", 3);
        	    refresh();
        	    continue;
        	case z_sendstring:
        	    sendstring();
      ! 	    goto ref;
        	case z_quotedinsert:
        	    if ((c = getkey(0)) == EOF)
        		goto brk;
        	    else
        		cmd = z_selfinsert;
        	default:
      ! 	    if(cmd == z_selfinsertunmeta) {
      ! 		c &= 0x7f;
      ! 		if(c == '\r')
      ! 		    c = '\n';
      ! 	    } else if (cmd == z_magicspace)
        		c = ' ';
      ! 	    else if (cmd != z_selfinsert) {
        		if (ungetok)
        		    ungetkey(c);
        		else
        		    feep();
        		goto brk;
        	    }
      ! 	    if (c) {
      ! 		if(sbptr == sibuf - 16) {
      ! 		    sbuf = halloc(sibuf *= 2);
      ! 		    strcpy(sbuf, ibuf);
      ! 		    statusline = ibuf = sbuf;
      ! 		    sbuf = ibuf + 14;
      ! 		}
        		sbuf[sbptr++] = c;
      ! 	    } else if(!nomatch)
      ! 		feep();
        	}
            }
          brk:
            free(oldl);
            statusline = NULL;
      +     bindtab = obindtab;
        }
        
        /**/
      ***************
      *** 784,791 ****
        int
        getvisrchstr(void)
        {
      !     static char sbuf[80];
      !     int sptr = 1, cmd, ret = 0;
            int *obindtab = bindtab;
        
            if (visrchstr) {
      --- 809,816 ----
        int
        getvisrchstr(void)
        {
      !     char *sbuf = halloc(80);
      !     int sptr = 1, cmd, ret = 0, ssbuf = 80;
            int *obindtab = bindtab;
        
            if (visrchstr) {
      ***************
      *** 844,852 ****
        		feep();
        		break;
        	    }
      ! 	  case z_selfinsert:
        	  case z_selfinsertunmeta:
      ! 	    if(sptr != 78) {
        		sbuf[sptr++] = c;
        		break;
        	    }
      --- 869,887 ----
        		feep();
        		break;
        	    }
      ! 	    goto ins;
        	  case z_selfinsertunmeta:
      ! 	    c &= 0x7f;
      ! 	    if(c == '\r')
      ! 		c = '\n';
      ! 	  case z_selfinsert:
      ! 	  ins:
      ! 	    if(c) {
      ! 		if(sptr == ssbuf - 2) {
      ! 		    char *newbuf = halloc(ssbuf *= 2);
      ! 		    strcpy(newbuf, sbuf);
      ! 		    statusline = sbuf = newbuf;
      ! 		}
        		sbuf[sptr++] = c;
        		break;
        	    }
      *** 1.2	1995/07/21 22:10:34
      --- Doc/zshzle.1	1995/07/23 02:20:48
      ***************
      *** 185,200 ****
        beginning of the line. A restricted set of editing functions is available in
        the mini-buffer. An interrupt signal, as defined by the stty setting,  will
        stop the search and go back to the original line. An undefined key will have
      ! the same effect. The supported functions are: backward-delete-char,
      ! quoted-insert, accept-and-hold, accept-and-infer-next-history, accept-line and
      ! accept-line-and-down-history; magic-space just inserts a space. Any string
        that is bound to an out-string (via bindkey -s) will behave as if out-string
        were typed directly.
        Typing the binding of \fBhistory-incremental-search-backward\fP will get the
        next occurrence of the contents of the mini-buffer. Typing the binding of
      ! \fBhistory-incremental-search-forward\fP inverts the sense of the search. The
      ! direction of the search is indicated in the mini-buffer. Any multi-character
      ! string 
        that is not bound to one of the above functions will beep and interrupt the
        search, leaving the last found line in the buffer. Any single character that
        is not bound to one of the above functions, or self-insert or
      --- 185,207 ----
        beginning of the line. A restricted set of editing functions is available in
        the mini-buffer. An interrupt signal, as defined by the stty setting,  will
        stop the search and go back to the original line. An undefined key will have
      ! the same effect. The supported functions are:
      ! backward-delete-char, vi-backward-delete-char,
      ! clear-screen, redisplay,
      ! quoted-insert,
      ! accept-and-hold, accept-and-infer-next-history, accept-line and
      ! accept-line-and-down-history; magic-space just inserts a space.
      ! vi-cmd-mode toggles between the main and alternate key bindings;
      ! the main key bindings (insert mode) will be selected initially.
      ! Any string
        that is bound to an out-string (via bindkey -s) will behave as if out-string
        were typed directly.
        Typing the binding of \fBhistory-incremental-search-backward\fP will get the
        next occurrence of the contents of the mini-buffer. Typing the binding of
      ! \fBhistory-incremental-search-forward\fP inverts the sense of the search.
      ! \fBvi-repeat-search\fP and \fBvi-rev-repeat-search\fP are similarly supported.
      ! The direction of the search is indicated in the mini-buffer.
      ! Any multi-character string 
        that is not bound to one of the above functions will beep and interrupt the
        search, leaving the last found line in the buffer. Any single character that
        is not bound to one of the above functions, or self-insert or
      ***************
      *** 592,604 ****
        Read the name of an editor command and
        execute it. A restricted set of editing functions is available in the
        mini-buffer. An interrupt signal, as defined by the stty setting, will
      ! abort the function. The allowed functions are: backward-delete-char,
      ! vi-backward-delete-char, kill-region (kills the last word),
      ! backward-kill-word, vi-backward-kill-word, kill-whole-line,
      ! vi-kill-line, backward-kill-line, list-choices, delete-char-or-list
      ! and accept-line. The space and tab characters, if not bound to one of
        these functions, will complete the name and then list the
      ! possibilities if the autolist option is set.
        .TP
        \fBexecute-last-named-cmd\fP (ESC-z) (unbound) (unbound)
        Redo the last function executed with \fBexecute-named-cmd\fP.
      --- 599,622 ----
        Read the name of an editor command and
        execute it. A restricted set of editing functions is available in the
        mini-buffer. An interrupt signal, as defined by the stty setting, will
      ! abort the function. The allowed functions are:
      ! backward-delete-char, vi-backward-delete-char,
      ! clear-screen, redisplay,
      ! quoted-insert,
      ! kill-region (kills the last word),
      ! backward-kill-word, vi-backward-kill-word,
      ! kill-whole-line, vi-kill-line, backward-kill-line,
      ! list-choices, delete-char-or-list,
      ! complete-word, expand-or-complete, expand-or-complete-prefix,
      ! accept-line and vi-cmd-mode (treated the same as accept-line).
      ! The space and tab characters, if not bound to one of
        these functions, will complete the name and then list the
      ! possibilities if the \fBAUTO_LIST\fP option is set.
      ! Any string
      ! that is bound to an out-string (via bindkey -s) will behave as if out-string
      ! were typed directly. Any other character that is not bound to self-insert or
      ! self-insert-unmeta will beep and be ignored. If the function is called from vi
      ! command mode, the bindings of the current insert mode will be used.
        .TP
        \fBexecute-last-named-cmd\fP (ESC-z) (unbound) (unbound)
        Redo the last function executed with \fBexecute-named-cmd\fP.

-----BEGIN PGP SIGNATURE-----
Version: 2.6.i

iQBVAgUBMBG2aGWJ8JfKi+e9AQFqAgH+M0woz85GHKi1XxChwLfUS7Hb+NE21O55
Ew0QiNb663rpNDeJkLJADx6bQMOowb330v69pg3uYyo/osYSJmAUEA==
=K8GV
-----END PGP SIGNATURE-----

