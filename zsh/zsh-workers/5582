From zsh-workers-return-5582-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 01 14:47:12 1999
Return-Path: <zsh-workers-return-5582-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 29455 invoked from network); 1 Mar 1999 14:47:11 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 1 Mar 1999 14:47:11 -0000
Received: (qmail 5948 invoked by alias); 1 Mar 1999 14:46:39 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5582
Received: (qmail 5941 invoked from network); 1 Mar 1999 14:46:38 -0000
Date: Mon, 1 Mar 1999 15:45:53 +0100 (MET)
Message-Id: <199903011445.PAA15418@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Mon, 1 Mar 1999 17:26:14 +0300
Subject: RE: PATCH: Re: pws-10 RE: zsh-3.1.5-pws-9: _path_files  and symbolic links


Andrej Borsenkow wrote:

> > The question is what one can find under `/u/'. If there is anything
> > matching `l/l/T' the behavior might be correct (since it can't expand
> > `u' to `usr' then).
> 
> Nope. It is the problem of exact match. ``/u'' is matched _exactly_ and
> hence ``/usr'' is never even tried.

Ah, tricky. The patch below makes path components be left unchanged
only if the rest of the string would produce a match below that
directory.

Bye
 Sven

diff -u oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Mon Mar  1 14:32:16 1999
+++ Completion/Core/_path_files	Mon Mar  1 15:45:51 1999
@@ -170,23 +170,26 @@
   fi
 fi
 
-# First we skip over all pathname components in `str' which really exist in
-# the file-system, so that `/usr/lib/l<TAB>' doesn't offer you `lib' and
-# `lib5'. Pathname components skipped this way are taken from `str' and added
-# to `donepath'.
-
-while [[ "$str" = */* ]] do
-  [[ -e "$realpath$donepath${str%%/*}" ]] || break
-  donepath="$donepath${str%%/*}/"
-  str="${str#*/}"
-done
-
+# Save the original string.
 orig="${str:s/*//}"
 
 # Now build the glob pattern by calling `_match_pattern'.
 patstr="$str"
 matchflags=""
 _match_pattern _path_files patstr matchflags
+
+# First we skip over all pathname components in `str' which really exist in
+# the file-system, so that `/usr/lib/l<TAB>' doesn't offer you `lib' and
+# `lib5'. Pathname components skipped this way are taken from `orig' and added
+# to `donepath'.
+
+while [[ "$orig" = */* ]] do
+  tmp1=($realpath$donepath${orig%%/*}/${~patstr#*/})
+  [[ $#tmp1 -gt 0 && -e "$realpath$donepath${orig%%/*}" ]] || break
+  donepath="$donepath${orig%%/*}/"
+  orig="${orig#*/}"
+  patstr="${patstr#*/}"
+done
 
 # We almost expect the pattern to have changed `..' into `*.*.', `/.' into
 # `/*.', and probably to contain two or more consecutive `*'s. Since these

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

