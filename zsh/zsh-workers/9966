From zsh-workers-return-9966-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 02 10:03:44 2000
Return-Path: <zsh-workers-return-9966-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 15623 invoked from network); 2 Mar 2000 10:03:42 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 2 Mar 2000 10:03:42 -0000
Received: (qmail 17237 invoked by alias); 2 Mar 2000 10:03:34 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9966
Received: (qmail 17226 invoked from network); 2 Mar 2000 10:03:34 -0000
Date: Thu, 2 Mar 2000 11:03:28 +0100 (MET)
Message-Id: <200003021003.LAA12189@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Sven Wischnowsky's message of Thu, 2 Mar 2000 10:09:25 +0100
	(MET)
Subject: Re: PATCH: wordcode files


I wrote:

> Bart Schaefer wrote:
> 
> > This all sounds fine, although I lean towards requiring that the .zwc
> > extension appear in the $fpath listing.  What happens, for example, if
> > I have both a ~/zshfun/ and ~/zshfun.zwc and I list ~/zshfun in $fpath?
> 
> You get the functions in ~/zshfun because you named that. But we can
> change that to be more consistent (I mean: requiring the extension).

This'll do?

Bye
 Sven

P.S.: I just noted that the CVS does not contain the (rather
      important) patches from 9953 and 9958.

diff -ru ../z.old/Doc/Zsh/builtins.yo Doc/Zsh/builtins.yo
--- ../z.old/Doc/Zsh/builtins.yo	Wed Mar  1 17:02:18 2000
+++ Doc/Zsh/builtins.yo	Thu Mar  2 10:58:01 2000
@@ -1304,9 +1304,10 @@
 for a description of how autoloaded functions are searched).
 
 If there is at least one var(function) argument, the wordcode for all
-these functions will be put in the created wordcode var(file). Such
-files containing the code for multiple functions are intended to be
-used as elements of the tt(FPATH)/tt(fpath) special array.
+these functions will be put in the created wordcode var(file) (if that 
+name does not end in tt(.zwc), this extension is automatically
+appended). Such files containing the code for multiple functions are
+intended to be used as elements of the tt(FPATH)/tt(fpath) special array.
 
 If the tt(-U) option is given, aliases in the var(function)s will not
 be expanded. If the tt(-r) option is given, the function(s) in the
diff -ru ../z.old/Doc/Zsh/func.yo Doc/Zsh/func.yo
--- ../z.old/Doc/Zsh/func.yo	Wed Mar  1 17:02:20 2000
+++ Doc/Zsh/func.yo	Thu Mar  2 11:01:17 2000
@@ -52,7 +52,9 @@
 autoload myfunc1 myfunc2 ...)
 
 The elements of the tt(fpath) array may also name wordcode files
-directly. This is mostly useful for wordcode files containing multiple 
+directly. The names of these files must have the tt(.zwc) extension
+but in tt(fpath) the names may be given with or without it. This is
+mostly useful for wordcode files containing multiple 
 functions, in which case the file is treated like a directory
 containing files for functions and will be searched for the definition 
 of the function.
diff -ru ../z.old/Src/parse.c Src/parse.c
--- ../z.old/Src/parse.c	Wed Mar  1 17:02:00 2000
+++ Src/parse.c	Thu Mar  2 10:56:02 2000
@@ -2361,9 +2361,12 @@
     LinkNode node;
     struct fdhead head;
     wordcode pre[FD_PRELEN];
-    char *file, **ofiles = files, **oofiles = files, *name, *tail;
+    char *file, **ofiles = files, **oofiles = files, *tail;
     Eprog prog;
 
+    if (!strsfx(FD_EXT, dump))
+	dump = dyncat(dump, FD_EXT);
+
     if ((dfd = open(dump, O_WRONLY|O_CREAT, 0600)) < 0) {
 	zerrnam(nam, "can't write dump file: %s", dump, 0);
 	return 1;
@@ -2436,9 +2439,10 @@
 	    head.strs = prog->strs - ((char *) prog->prog);
 	    head.hlen = (sizeof(struct fdhead) / sizeof(wordcode)) +
 		(strlen(*ofiles) + sizeof(wordcode)) / sizeof(wordcode);
-	    for (name = tail = *ofiles; *name; name++)
-		if (*name == '/')
-		    tail = name + 1;
+	    if ((tail = strrchr(*ofiles, '/')))
+		tail++;
+	    else
+		tail= *ofiles;
 	    head.tail = tail - *ofiles;
 	    if (other)
 		fdswap((Wordcode) &head, sizeof(head) / sizeof(wordcode));
@@ -2539,20 +2543,23 @@
 Eprog
 try_dump_file(char *dump, char *name, char *func)
 {
+    char *file;
     int isrec = 0;
     Wordcode d;
     FDHead h;
     FuncDump f;
 
+    file = (strsfx(FD_EXT, dump) ? dump : dyncat(dump, FD_EXT));
+
  rec:
 
     d = NULL;
     for (f = dumps; f; f = f->next)
-	if (!strcmp(dump, f->name)) {
+	if (!strcmp(file, f->name)) {
 	    d = f->map;
 	    break;
 	}
-    if (!f && (isrec || !(d = load_dump_header(dump)))) {
+    if (!f && (isrec || !(d = load_dump_header(file)))) {
 	if (!isrec) {
 	    struct stat stc, stn;
 	    char *p = (char *) zhalloc(strlen(dump) + strlen(name) +
@@ -2561,10 +2568,10 @@
 	    sprintf(p, "%s/%s%s", dump, name, FD_EXT);
 
 	    /* Ignore the dump file if it is older than the normal one. */
-	    if (stat(p, &stc) || stat(func, &stn) || stn.st_mtime > stc.st_mtime)
+	    if (stat(p, &stc) || (!stat(func, &stn) && stn.st_mtime > stc.st_mtime))
 		return NULL;
 
-	    if (!(d = load_dump_header(dump = p)))
+	    if (!(d = load_dump_header(file = p)))
 		return NULL;
 
 	} else
@@ -2594,7 +2601,7 @@
 
 	    return prog;
 	} else if (fdflags(d) & FDF_MAP) {
-	    load_dump_file(dump, (fdflags(d) & FDF_OTHER), fdother(d));
+	    load_dump_file(file, (fdflags(d) & FDF_OTHER), fdother(d));
 	    isrec = 1;
 	    goto rec;
 	} else {
@@ -2602,7 +2609,7 @@
 	    Patprog *pp;
 	    int np, fd, po = h->npats * sizeof(Patprog);
 
-	    if ((fd = open(dump, O_RDONLY)) < 0 ||
+	    if ((fd = open(file, O_RDONLY)) < 0 ||
 		lseek(fd, ((h->start * sizeof(wordcode)) +
 			   ((fdflags(d) & FDF_OTHER) ? fdother(d) : 0)), 0) < 0) {
 		if (fd >= 0)

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

