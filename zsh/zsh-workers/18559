From zsh-workers-return-18559-mason-zsh=primenet.com.au@sunsite.dk Wed May 21 10:11:37 2003
Return-Path: <zsh-workers-return-18559-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 19975 invoked from network); 21 May 2003 10:11:36 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 21 May 2003 10:11:36 -0000
Received: (qmail 14584 invoked by alias); 21 May 2003 10:11:27 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 18559
Received: (qmail 14573 invoked from network); 21 May 2003 10:11:27 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 21 May 2003 10:11:27 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [62.189.183.235] by sunsite.dk (MessageWall 1.0.8) with SMTP; 21 May 2003 10:11:27 -0000
Received: from exchange01.csr.com (unverified) by 
 (Content Technologies SMTPRS 4.2.1) with ESMTP id <T6256dc9a76c0a88d01628@> for <zsh-workers@sunsite.dk>;
 Wed, 21 May 2003 11:21:33 +0100
Received: from csr.com (tinky-winky.csr.com [192.168.144.127]) by exchange01.csr.com with SMTP (Microsoft Exchange Internet Mail Service Version 5.5.2650.21)
	id LKHGJ3C4; Wed, 21 May 2003 11:12:02 +0100
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: zle -M and other option arguments
Date: Wed, 21 May 2003 11:11:24 +0100
Message-ID: <27450.1053511884@csr.com>
From: Peter Stephenson <pws@csr.com>

I tried this last night:
  zle -M my-keymap -R a-z self-insert
and it doesn't work.  This is actually documented: -M takes the first
non-option argument, not an argument of its own.  I imagine this is due
to the historically somewhat poor handling of arguments to options.

4.1.1 is the last chance to fix this for a while, I think it would be
better the other way.

Looking for `non-option' in the documentation turns up the same problem
with the -d option to ztcp and zsocket.  These are new, so there is no
problem changing these.

Any comments?


Index: README
===================================================================
RCS file: /cvsroot/zsh/zsh/README,v
retrieving revision 1.12
diff -u -r1.12 README
--- README	8 May 2003 10:30:46 -0000	1.12
+++ README	21 May 2003 10:06:09 -0000
@@ -48,6 +48,14 @@
   % print ${foo/\//-} "${foo/\//+}"
   word-bird word+bird
 
+In 4.0, the -M option to bindkey used the first non-option argument to
+specify the keymap, whereas it now uses an argument to the option.  Hence:
+  bindkey -M -R keymap a-z self-insert
+needs to be rewritten as
+  bindkey -M keymap -R a-z self-insert
+The following form works in both versions:
+  bindkey -R -M keymap a-z self-insert
+
 Documentation
 -------------
 
Index: Src/zsh.h
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/zsh.h,v
retrieving revision 1.47
diff -u -r1.47 zsh.h
--- Src/zsh.h	14 May 2003 15:09:15 -0000	1.47
+++ Src/zsh.h	21 May 2003 10:06:09 -0000
@@ -955,10 +955,11 @@
 /* Option was set as +X */
 #define OPT_PLUS(ops,c)		((ops)->ind[c] & 2)
 /*
- * Option was set any old how, maybe including an argument 
- * (cheap test when we don't care).
+ * Option was set any old how, maybe including an argument
+ * (cheap test when we don't care).  Some bits of code
+ * expect this to be 1 or 0.
  */
-#define OPT_ISSET(ops,c)	((ops)->ind[c])
+#define OPT_ISSET(ops,c)	((ops)->ind[c] != 0)
 /* Option has an argument */
 #define OPT_HASARG(ops,c)	((ops)->ind[c] > 3)
 /* The argument for the option; not safe if it doesn't have one */
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.33
diff -u -r1.33 zle_main.c
--- Src/Zle/zle_main.c	19 May 2003 10:30:47 -0000	1.33
+++ Src/Zle/zle_main.c	21 May 2003 10:06:09 -0000
@@ -1336,7 +1336,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("bindkey", 0, bin_bindkey, 0, -1, 0, "evaMldDANmrsLRp", NULL),
+    BUILTIN("bindkey", 0, bin_bindkey, 0, -1, 0, "evaM:ldDANmrsLRp", NULL),
     BUILTIN("vared",   0, bin_vared,   1,  7, 0, NULL,             NULL),
     BUILTIN("zle",     0, bin_zle,     0, -1, 0, "aAcCDFgGIKlLmMNRU", NULL),
 };
Index: Src/Zle/zle_keymap.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_keymap.c,v
retrieving revision 1.10
diff -u -r1.10 zle_keymap.c
--- Src/Zle/zle_keymap.c	14 May 2003 15:09:15 -0000	1.10
+++ Src/Zle/zle_keymap.c	21 May 2003 10:06:10 -0000
@@ -656,11 +656,7 @@
 	else if(OPT_ISSET(ops,'a'))
 	    kmname = "vicmd";
 	else if(OPT_ISSET(ops,'M')) {
-	    kmname = *argv++;
-	    if(!kmname) {
-		zwarnnam(name, "-M option requires a keymap argument", NULL, 0);
-		return 1;
-	    }
+	    kmname = OPT_ARG(ops,'M');
 	} else
 	    kmname = "main";
 	km = openkeymap(kmname);
Index: Src/Modules/tcp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/tcp.c,v
retrieving revision 1.35
diff -u -r1.35 tcp.c
--- Src/Modules/tcp.c	23 Apr 2003 18:48:39 -0000	1.35
+++ Src/Modules/tcp.c	21 May 2003 10:06:10 -0000
@@ -341,7 +341,7 @@
 {
     int herrno, err=1, destport, force=0, verbose=0, test=0, targetfd=0;
     SOCKLEN_T  len;
-    char **addrp, *desthost, *localname, *remotename, **dargs;
+    char **addrp, *desthost, *localname, *remotename;
     struct hostent *zthost = NULL, *ztpeer = NULL;
     struct servent *srv;
     Tcp_session sess = NULL;
@@ -356,26 +356,24 @@
         test = 1;
 
     if (OPT_ISSET(ops,'d')) {
-	targetfd = atoi(args[0]);
-	dargs = args + 1;
+	targetfd = atoi(OPT_ARG(ops,'d'));
 	if (!targetfd) {
-	    zwarnnam(nam, "%s is an invalid argument to -d", args[0], 0);
+	    zwarnnam(nam, "%s is an invalid argument to -d",
+		     OPT_ARG(ops,'d'), 0);
 	    return 1;
 	}
     }
-    else
-	dargs = args;
 
 
     if (OPT_ISSET(ops,'c')) {
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    tcp_cleanup();
 	}
 	else {
-	    targetfd = atoi(dargs[0]);
+	    targetfd = atoi(args[0]);
 	    sess = zts_byfd(targetfd);
 	    if(!targetfd) {
-		zwarnnam(nam, "%s is an invalid argument to -c", dargs[0], 0);
+		zwarnnam(nam, "%s is an invalid argument to -c", args[0], 0);
 		return 1;
 	    }
 
@@ -391,7 +389,7 @@
 	    }
 	    else
 	    {
-		zwarnnam(nam, "fd %s not found in tcp table", dargs[0], 0);
+		zwarnnam(nam, "fd %s not found in tcp table", args[0], 0);
 		return 1;
 	    }
 	}
@@ -399,16 +397,16 @@
     else if (OPT_ISSET(ops,'l')) {
 	int lport = 0;
 
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    zwarnnam(nam, "-l requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	srv = getservbyname(dargs[0], "tcp");
+	srv = getservbyname(args[0], "tcp");
 	if (srv)
 	    lport = srv->s_port;
 	else
-	    lport = htons(atoi(dargs[0]));
+	    lport = htons(atoi(args[0]));
 	if (!lport) { zwarnnam(nam, "bad service name or port number", NULL, 0);
 	return 1;
 	}
@@ -469,12 +467,12 @@
     {
 	int lfd, rfd;
 
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    zwarnnam(nam, "-a requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	lfd = atoi(dargs[0]);
+	lfd = atoi(args[0]);
 
 	if (!lfd) {
 	    zwarnnam(nam, "invalid numerical argument", NULL, 0);
@@ -483,7 +481,7 @@
 
 	sess = zts_byfd(lfd);
 	if (!sess) {
-	    zwarnnam(nam, "fd %s is not registered as a tcp connection", dargs[0], 0);
+	    zwarnnam(nam, "fd %s is not registered as a tcp connection", args[0], 0);
 	    return 1;
 	}
 
@@ -556,7 +554,7 @@
     }
     else
     {
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    LinkNode node;
 	    for(node = firstnode(ztcp_sessions); node; incnode(node))
 	    {
@@ -601,19 +599,19 @@
 	    }
 	    return 0;
 	}
-	else if (!dargs[1]) {
+	else if (!args[1]) {
 	    destport = htons(23);
 	}
 	else {
 
-	    srv = getservbyname(dargs[1],"tcp");
+	    srv = getservbyname(args[1],"tcp");
 	    if (srv)
 		destport = srv->s_port;
 	    else
-		destport = htons(atoi(dargs[1]));
+		destport = htons(atoi(args[1]));
 	}
 	
-	desthost = ztrdup(dargs[0]);
+	desthost = ztrdup(args[0]);
 	
 	zthost = zsh_getipnodebyname(desthost, AF_INET, 0, &herrno);
 	if (!zthost || errflag) {
@@ -675,7 +673,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("ztcp", 0, bin_ztcp, 0, 3, 0, "acdflLtv", NULL),
+    BUILTIN("ztcp", 0, bin_ztcp, 0, 3, 0, "acd:flLtv", NULL),
 };
 
 /* The load/unload routines required by the zsh library interface */
Index: Src/Modules/socket.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/socket.c,v
retrieving revision 1.3
diff -u -r1.3 socket.c
--- Src/Modules/socket.c	27 Aug 2002 21:10:34 -0000	1.3
+++ Src/Modules/socket.c	21 May 2003 10:06:10 -0000
@@ -62,7 +62,6 @@
 {
     int err=1, verbose=0, test=0, targetfd=0;
     SOCKLEN_T len;
-    char **dargs;
     struct sockaddr_un soun;
     int sfd;
 
@@ -73,26 +72,23 @@
 	test = 1;
 
     if (OPT_ISSET(ops,'d')) {
-	targetfd = atoi(args[0]);
-	dargs = args + 1;
+	targetfd = atoi(OPT_ARG(ops,'d'));
 	if (!targetfd) {
-	    zwarnnam(nam, "%s is an invalid argument to -d", args[0], 0);
+	    zwarnnam(nam, "%s is an invalid argument to -d",
+		     OPT_ARG(ops, 'd'), 0);
 	    return 1;
 	}
     }
-    else
-	dargs = args;
-
 
     if (OPT_ISSET(ops,'l')) {
 	char *localfn;
 
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    zwarnnam(nam, "-l requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	localfn = dargs[0];
+	localfn = args[0];
 
 	sfd = socket(PF_UNIX, SOCK_STREAM, 0);
 
@@ -139,12 +135,12 @@
     {
 	int lfd, rfd;
 
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    zwarnnam(nam, "-a requires an argument", NULL, 0);
 	    return 1;
 	}
 
-	lfd = atoi(dargs[0]);
+	lfd = atoi(args[0]);
 
 	if (!lfd) {
 	    zwarnnam(nam, "invalid numerical argument", NULL, 0);
@@ -212,7 +208,7 @@
     }
     else
     {
-	if (!dargs[0]) {
+	if (!args[0]) {
 	    zwarnnam(nam, "zsocket requires an argument", NULL, 0);
 	    return 1;
 	}
@@ -225,7 +221,7 @@
 	}
 
 	soun.sun_family = AF_UNIX;
-	strncpy(soun.sun_path, dargs[0], UNIX_PATH_MAX);
+	strncpy(soun.sun_path, args[0], UNIX_PATH_MAX);
 	
 	if ((err = connect(sfd, (struct sockaddr *)&soun, sizeof(struct sockaddr_un)))) {
 	    zwarnnam(nam, "connection failed: %e", NULL, errno);
@@ -251,7 +247,7 @@
 }
 
 static struct builtin bintab[] = {
-    BUILTIN("zsocket", 0, bin_zsocket, 0, 3, 0, "adltv", NULL),
+    BUILTIN("zsocket", 0, bin_zsocket, 0, 3, 0, "ad:ltv", NULL),
 };
 
 /* The load/unload routines required by the zsh library interface */
Index: Doc/Zsh/zle.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/zle.yo,v
retrieving revision 1.29
diff -u -r1.29 zle.yo
--- Doc/Zsh/zle.yo	25 Apr 2003 11:19:09 -0000	1.29
+++ Doc/Zsh/zle.yo	21 May 2003 10:06:10 -0000
@@ -134,9 +134,8 @@
 item(tt(-a))(
 Selects keymap `tt(vicmd)'.
 )
-item(tt(-M))(
-The first non-option argument is used as a keymap name,
-and does not otherwise count as an argument.
+item(tt(-M) var(keymap))(
+The var(keymap) specifies a keymap name.
 )
 enditem()
 
Index: Doc/Zsh/mod_tcp.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_tcp.yo,v
retrieving revision 1.4
diff -u -r1.4 mod_tcp.yo
--- Doc/Zsh/mod_tcp.yo	25 Apr 2003 11:19:09 -0000	1.4
+++ Doc/Zsh/mod_tcp.yo	21 May 2003 10:06:10 -0000
@@ -7,7 +7,7 @@
 findex(ztcp)
 cindex(TCP)
 cindex(sockets, TCP)
-item(tt(ztcp) [ tt(-acdflLtv) ] [ var(args) ])(
+item(tt(ztcp) [ tt(-acflLtv) ] [ tt(-d) var(fd) ] [ var(args) ])(
 tt(ztcp) is implemented as a builtin to allow full use of shell
 command line editing, file I/O, and job control mechanisms.
 
@@ -75,9 +75,8 @@
 tt(REPLY) will be set to the file descriptor associated
 with that connection.
 
-If tt(-d) is specified, the first non-option argument
-will be taken as the target file descriptor for the
-connection.
+If tt(-d) is specified, its argument will be taken as the target file
+descriptor for the connection.
 
 In order to elicit more verbose output, use tt(-v).
 )
@@ -94,9 +93,8 @@
 will be set to the file descriptor associated
 with that listener.
 
-If tt(-d) is specified, the first non-option argument
-will be taken as the target file descriptor for
-the connection.
+If tt(-d) is specified, its argument will be taken as the target file
+descriptor for the connection.
 
 In order to elicit more verbose output, use tt(-v).
 )
@@ -108,7 +106,7 @@
 be set to the file descriptor associated with
 the inbound connection.
 
-If tt(-d) is specified, the first non-option argument
+If tt(-d) is specified, its argument
 will be taken as the target file descriptor for the
 connection.
 
Index: Doc/Zsh/mod_socket.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_socket.yo,v
retrieving revision 1.3
diff -u -r1.3 mod_socket.yo
--- Doc/Zsh/mod_socket.yo	28 Aug 2002 16:13:01 -0000	1.3
+++ Doc/Zsh/mod_socket.yo	21 May 2003 10:06:10 -0000
@@ -7,7 +7,7 @@
 findex(zsocket)
 cindex(sockets)
 cindex(sockets, Unix domain)
-item(tt(zsocket) [ tt(-adltv) ] [ var(args) ])(
+item(tt(zsocket) [ tt(-altv) ] [ tt(-d) var(fd) ] [ var(args) ])(
 tt(zsocket) is implemented as a builtin to allow full use of shell
 command line editing, file I/O, and job control mechanisms.
 
@@ -21,7 +21,7 @@
 associated with that connection.  Currently, only stream connections
 are supported.
 
-If tt(-d) is specified, the first non-option argument
+If tt(-d) is specified, the its argument
 will be taken as the target file descriptor for the
 connection.
 
@@ -38,7 +38,7 @@
 The shell parameter tt(REPLY) will be set to the file descriptor
 associated with that listener.
 
-If tt(-d) is specified, the first non-option argument
+If tt(-d) is specified, its argument
 will be taken as the target file descriptor for
 the connection.
 
@@ -51,7 +51,7 @@
 be set to the file descriptor associated with
 the inbound connection.
 
-If tt(-d) is specified, the first non-option argument
+If tt(-d) is specified, its argument
 will be taken as the target file descriptor for the
 connection.
 

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR Ltd., Science Park, Milton Road,
Cambridge, CB4 0WH, UK                          Tel: +44 (0)1223 692070


**********************************************************************
The information transmitted is intended only for the person or
entity to which it is addressed and may contain confidential 
and/or privileged material. 
Any review, retransmission, dissemination or other use of, or
taking of any action in reliance upon, this information by 
persons or entities other than the intended recipient is 
prohibited.  
If you received this in error, please contact the sender and 
delete the material from any computer.
**********************************************************************

