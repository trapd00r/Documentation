From zsh-workers-return-15635-mason-zsh=primenet.com.au@sunsite.dk Wed Aug 15 23:13:22 2001
Return-Path: <zsh-workers-return-15635-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11058 invoked from network); 15 Aug 2001 23:13:21 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 15 Aug 2001 23:13:21 -0000
Received: (qmail 22817 invoked by alias); 15 Aug 2001 23:13:14 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15635
Received: (qmail 22806 invoked from network); 15 Aug 2001 23:13:13 -0000
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: Re: Correction oddity 
In-reply-to: "Peter Stephenson"'s message of "Thu, 16 Aug 2001 00:50:08 BST."
             <20010815235013.940CD14284@pwstephenson.fsnet.co.uk> 
Date: Thu, 16 Aug 2001 01:16:44 +0100
From: Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Message-Id: <20010816001649.1729214284@pwstephenson.fsnet.co.uk>

Peter Stephenson wrote:
> the _urls function (we're at line 74,

Forget that, we've finished _urls.  We're executing this in _arguments:

      compadd -M "$matcher" -D equal - "${(@)equal%%:*}"

The redefined compadd:

  compadd() {
    [[ ${argv[(I)-[a-zA-Z]#U[a-zA-Z]#]} -eq 0 &&
       "${#:-$PREFIX$SUFFIX}" -le _comp_correct ]] && return

    ### This distinction doesn't seem to be needed anymore
    # if [[ "$PREFIX" = \~*/* ]]; then
    #   PREFIX="${PREFIX%%/*}/(#a${_comp_correct})${PREFIX#*/}"
    # else
      PREFIX="(#a${_comp_correct})$PREFIX"
    # fi

    (( $_correct_group )) && _correct_expl[_correct_group]=${argv[(R)-*[JV]]}

    builtin compadd "$_correct_expl[@]" "$@"
  }

finds _correct_group is 3; I presume this is the index of the -J or -V
argument in the compadd command,

  compadd -M m:{a-zA-Z}={A-Za-z} -M corrections \
-X Completing corrections -M r:|[_-]=* r:|=* -D equal -

and indeed it is that `-M' which should be -J or -V.  Unfortunately it
becomes -M because there's no -J or -V in the argument list, and in that
case ${argv[(R)-*[JV]]} returns the first argument --- dunno if that's a
bug, it doesn't seem so hot, but it's presumably not the root bug.
Getting that test to check if the reverse match turned up something
sensible might be a start, but I'm way out of my depth.

-- 
Peter Stephenson <pws@pwstephenson.fsnet.co.uk>
Work: pws@csr.com
Web: http://www.pwstephenson.fsnet.co.uk

