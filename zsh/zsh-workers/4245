From zsh-workers-request@math.gatech.edu Wed Jul 22 15:03:34 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16703 invoked from network); 22 Jul 1998 15:03:29 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 22 Jul 1998 15:03:29 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id KAA01268;
	Wed, 22 Jul 1998 10:52:56 -0400 (EDT)
Resent-Date: Wed, 22 Jul 1998 10:52:56 -0400 (EDT)
Message-Id: <9807221448.AA14383@ibmth.df.unipi.it>
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: PATCH: lete2ctl
Date: Wed, 22 Jul 1998 16:48:12 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>
Resent-Message-ID: <"QspRU1.0.jJ.7pVjr"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4245
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

Here's a much needed patch to lete2ctl, which, you will have
forgotten, converts tcsh complete statements to compctl statements.

If you are a user of perl 5.004, the main new feature is that it now
works.  I take it from this that no-one has been using it recently.
It is still supposed to run under perl 4.

Otherwise, the main new features are that directories are handled
using the new capabilities of compctl, so that `n/*/d/' turns into
`-/' and `n%*%p:$HOME/Mail%' turns into `-W $HOME/Mail -f'.
Also, machine-dependent limits are handled properly.

I have also turned on warnings and fixed the problems that showed up.
The more trifling changes are simply to persuade Emacs to match quotes
and brackets properly.

*** Misc/lete2ctl.old	Wed Jul 22 15:29:36 1998
--- Misc/lete2ctl	Wed Jul 22 16:36:40 1998
***************
*** 1,4 ****
! #!/usr/local/bin/perl -- -*-perl-*-
  #
  #   ``Wee have also Shelles, thee Lyke of whych you knowe not, wherein
  #     thee User may with thee merest Presse of thee Tabbe-Keye expande
--- 1,4 ----
! #!/usr/local/bin/perl -w
  #
  #   ``Wee have also Shelles, thee Lyke of whych you knowe not, wherein
  #     thee User may with thee merest Presse of thee Tabbe-Keye expande
***************
*** 9,15 ****
  # Runs as a filter.  Should ignore anything which isn't a "complete".
  # It expects each "complete" statement to be the first thing on a line.
  # All the examples in the tcsh manual give sensible results.
! # Author:  Peter Stephenson <pws@s-a.amtp.liv.ac.uk>
  #
  # Option:
  # -x (exact): only applies in the case of command disambiguation (is
--- 9,15 ----
  # Runs as a filter.  Should ignore anything which isn't a "complete".
  # It expects each "complete" statement to be the first thing on a line.
  # All the examples in the tcsh manual give sensible results.
! # Author:  Peter Stephenson <pws@ibmth.df.unipi.it>
  #
  # Option:
  # -x (exact): only applies in the case of command disambiguation (is
***************
*** 41,48 ****
  #     statement for zsh.
  
  # Handle options
! ($ARGV[0] eq '-x') && shift && ($opt_x = 1);
! ($ARGV[0] =~ /^-+$/) && shift;
  
  # Function names used (via magic autoincrement) when cmdline words are needed
  $funcnam = 'compfn001';
--- 41,50 ----
  #     statement for zsh.
  
  # Handle options
! if (@ARGV) {
!     ($ARGV[0] eq '-x') && shift && ($opt_x = 1);
!     ($ARGV[0] =~ /^-+$/) && shift;
! }
  
  # Function names used (via magic autoincrement) when cmdline words are needed
  $funcnam = 'compfn001';
***************
*** 62,77 ****
  		$word .= '"' . $word2;
  	    }
  	} elsif (/\S/) {
! 	    ($word, $_) = /^([^\s\\\'\"#;]*)(.*)$/;
  	    # Backslash: literal next character
  	    /^\\(.)/ && (($word .= substr($_,1,1)),
  			 ($_ = substr($_,2)));
  	    # Rest of line quoted or end of command
! 	    /^[#;]/ && ($_ = '');
  	} else {
  	    return undef;
  	}
! 	length($word) && ($ret = $ret . $word);
      }
      $ret;
  }
--- 64,79 ----
  		$word .= '"' . $word2;
  	    }
  	} elsif (/\S/) {
! 	    ($word, $_) = /^([^\s\\\'\"\#;]*)(.*)$/;
  	    # Backslash: literal next character
  	    /^\\(.)/ && (($word .= substr($_,1,1)),
  			 ($_ = substr($_,2)));
  	    # Rest of line quoted or end of command
! 	    /^[\#;]/ && ($_ = '');
  	} else {
  	    return undef;
  	}
! 	length($word) && ($ret = defined($ret) ? $ret . $word : $word);
      }
      $ret;
  }
***************
*** 115,132 ****
      } elsif ($c eq 'S') {
  	$ret = '-k signals';
      } elsif ($c eq 'd') {
! 	$qual = '/';
      } elsif ($c eq 'e') {
  	$ret = '-E';
      } elsif ($c eq 'f' && !$glob) {
  	$ret = '-f';
      } elsif ($c eq 'l') {
! 	$ret = qq
! -k  '(cputime filesize datasize stacksize coredumpsize resident descriptors)'
!     ;
      } elsif ($c eq 'p') {
! 	# Use globbing, but make sure there's a star at the end
! 	($glob =~ /\*$/) || ($glob .= '*');
      } elsif ($c eq 's') {
  	$ret = '-p';
      } elsif ($c eq 't') {
--- 117,135 ----
      } elsif ($c eq 'S') {
  	$ret = '-k signals';
      } elsif ($c eq 'd') {
! 	if (defined($glob)) {
! 	    $qual = '-/';
! 	} else {
! 	    $ret = '-/';
! 	}
      } elsif ($c eq 'e') {
  	$ret = '-E';
      } elsif ($c eq 'f' && !$glob) {
  	$ret = '-f';
      } elsif ($c eq 'l') {
! 	$ret = q!-k "(`limit | awk '{print $1}'`)"!;
      } elsif ($c eq 'p') {
! 	$ret = "-W $glob -f", undef($glob) if defined($glob);
      } elsif ($c eq 's') {
  	$ret = '-p';
      } elsif ($c eq 't') {
***************
*** 135,141 ****
  	$glob =~ s/'/'\\''/g;
  	$ret = "-X '$glob'";
  	undef($glob);
!     } elsif ($c eq '$') {     # '{
  	$ret = "-k " . substr($_,1);
      } elsif ($c eq '(') {
  	s/'/'\\''/g;
--- 138,144 ----
  	$glob =~ s/'/'\\''/g;
  	$ret = "-X '$glob'";
  	undef($glob);
!     } elsif ($c eq '$') {     # '){
  	$ret = "-k " . substr($_,1);
      } elsif ($c eq '(') {
  	s/'/'\\''/g;
***************
*** 161,168 ****
      # foo{bar,ba,blak,sheap} -> foo(bar|ba|blak|sheap).
      # This saves a lot of mess, since in zsh brace expansion occurs
      # before globbing.  I'm sorry, but I don't trust $` and $'.
!     while ((($b,$m,$e) = ($glob =~ /^(.*)\{(.*)\}(.*)$/))
! 	   && ($m =~ /,/)) {
  	@m = split(/,/, $m);
  	for ($i = 0; $i < @m; $i++) {
  	    while ($m[$i] =~ /\\$/) {
--- 164,171 ----
      # foo{bar,ba,blak,sheap} -> foo(bar|ba|blak|sheap).
      # This saves a lot of mess, since in zsh brace expansion occurs
      # before globbing.  I'm sorry, but I don't trust $` and $'.
!     while (defined($glob) && (($b,$m,$e) = ($glob =~ /^(.*)\{(.*)\}(.*)$/))
! 	   && $m =~ /,/) {
  	@m = split(/,/, $m);
  	for ($i = 0; $i < @m; $i++) {
  	    while ($m[$i] =~ /\\$/) {
***************
*** 188,195 ****
  
  while (<>) {
      if (/^\s*complete\s/) {
! 	$wc = 0;
! 	undef(@stuff); undef($default);
  	$_ = $';
  	while (/\\$/) {
  	    # Remove backslashed newlines: in principle these should become
--- 191,198 ----
  
  while (<>) {
      if (/^\s*complete\s/) {
! 	undef(@stuff); 
! 	$default = '';
  	$_ = $';
  	while (/\\$/) {
  	    # Remove backslashed newlines: in principle these should become
***************
*** 211,224 ****
  	    $sep =~ s/(\W)/\\$1/g;
  	    @split = split(/$sep/,$word);
  	    for ($i = 0; $i < 3; $i++) {
! 		while ($split[i] =~ /\\$/) {
! 		    substr($split[i],-1,1) = "";
! 		    splice(@split,$i,2,"$split[i]\\$sep$split[i+1]");
  		}
  	    }
! 	    ($pat,$arg,$type,$suffix,$crap) = @split;
! 	    ($suffix =~ /^\s*$/) && undef($suffix);
! 	    if (($word =~ /^n${sep}\*${sep}/) &&
  		 (!defined($defmatch))) {
  		 # The "complete" catch-all:  treat this as compctl\'s
  		 # default (requiring no pattern matching).
--- 214,227 ----
  	    $sep =~ s/(\W)/\\$1/g;
  	    @split = split(/$sep/,$word);
  	    for ($i = 0; $i < 3; $i++) {
! 		while ($split[$i] =~ /\\$/) {
! 		    substr($split[$i],-1,1) = "";
! 		    splice(@split,$i,2,"$split[$i]\\$sep$split[$i+1]");
  		}
  	    }
! 	    ($pat,$arg,$type,$suffix) = @split;
! 	    defined($suffix) && ($suffix =~ /^\s*$/) && undef($suffix);
! 	    if (($word =~ /^n$sep\*$sep/) &&
  		 (!defined($defmatch))) {
  		 # The "complete" catch-all:  treat this as compctl\'s
  		 # default (requiring no pattern matching).
***************
*** 236,243 ****
  			} else {
  			    ($defmatch =~ /\*$/) && chop($defmatch);
  			    if ($opt_x) {
! 				$c = ($defmatch =~ /[*?]/) ? 'C' : c;
! 				$pat = "${c}[0,${defmatch}]";
  			    } else {
  				$pat = ($defmatch =~ /[*?]/) ?
  				    "C[0,${defmatch}]" : "S[${defmatch}]";
--- 239,246 ----
  			} else {
  			    ($defmatch =~ /\*$/) && chop($defmatch);
  			    if ($opt_x) {
! 				$c = ($defmatch =~ /[*?]/) ? 'C' : 'c';
! 				$pat = $c . "[0,${defmatch}]";
  			    } else {
  				$pat = ($defmatch =~ /[*?]/) ?
  				    "C[0,${defmatch}]" : "S[${defmatch}]";
***************
*** 259,265 ****
  		    } else {
  		        # Not command word completion, but still command
  			# word with pattern
! 			($defmatch = '*') || ($pat = "W[0,$defmatch] $pat");
  			push(@defaultword,defined($suffix) ?
  			     "'$pat' $type -S '$suffix'" : "'$pat' $type");
  		    }
--- 262,268 ----
  		    } else {
  		        # Not command word completion, but still command
  			# word with pattern
! 			($defmatch eq '*') || ($pat = "W[0,$defmatch] $pat");
  			push(@defaultword,defined($suffix) ?
  			     "'$pat' $type -S '$suffix'" : "'$pat' $type");
  		    }

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Gruppo Teorico, Dipartimento di Fisica
Piazza Torricelli 2, 56100 Pisa, Italy

