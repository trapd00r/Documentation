From zsh-workers-return-18175-mason-zsh=primenet.com.au@sunsite.dk Mon Feb 03 13:32:07 2003
Return-Path: <zsh-workers-return-18175-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5302 invoked from network); 3 Feb 2003 13:32:05 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 3 Feb 2003 13:32:05 -0000
Received: (qmail 3768 invoked by alias); 3 Feb 2003 11:45:17 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 18175
Received: (qmail 3761 invoked from network); 3 Feb 2003 11:45:17 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 3 Feb 2003 11:45:17 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [62.189.183.235] by sunsite.dk (MessageWall 1.0.8) with SMTP; 3 Feb 2003 11:45:17 -0000
Received: from exchange01.csr.com (unverified) by 
 (Content Technologies SMTPRS 4.2.1) with ESMTP id <T602feb09b7c0a88d015c4@> for <zsh-workers@sunsite.dk>;
 Mon, 3 Feb 2003 11:46:33 +0000
Received: from csr.com (tinky-winky.csr.com [192.168.144.127]) by exchange01.csr.com with SMTP (Microsoft Exchange Internet Mail Service Version 5.5.2650.21)
	id DQ47KS6A; Mon, 3 Feb 2003 11:38:14 -0000
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: Perforce completion
Date: Mon, 03 Feb 2003 11:40:17 +0000
Message-ID: <16446.1044272417@csr.com>
From: Peter Stephenson <pws@csr.com>

Here's a completion file for Perforce, a CVS replacement we've been
evaluating.  (You can download it for free for up to two clients from
www.perforce.com.)  It looks like it's not going to get much more work
done on it for the time being, so I might as well add it as is.

This is probably fairly specialised, but it's only disk space.

Index: Completion/Unix/Command/_p4
===================================================================
RCS file: Completion/Unix/Command/_p4
diff -N Completion/Unix/Command/_p4
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ Completion/Unix/Command/_p4	3 Feb 2003 11:37:32 -0000
@@ -0,0 +1,1560 @@
+#compdef p4 -value-,P4CLIENT,-default- -value-,P4PORT,-default-
+
+# Increasingly loosely based on _cvs version 1.17.
+
+# Styles, tags and contexts
+# =========================
+#
+# If the `verbose' style is set (it is assumed by default), verbose
+# descriptions are provided for many completed quantities derived
+# dynamically such as subcommand names, labels, changelists -- in fact,
+# just about anything for which Perforce itself produces a verbose,
+# one-line description.  It may be turned off in the context of each
+# subcommand e.g.
+#   zstyle ':completion:*:p4-labelsync:*' verbose false
+# or for a particular tag, e.g. changelists,
+#   zstyle ':completeion:*:changelists' verbose false
+# or just for top-level completion (i.e. up to and including completion
+# of the subcommand):
+#   zstyle ':completion:*:p4:*' verbose false
+# or for p4 as a whole,
+#   zstyle  ':completion:*:p4(-*|):*' verbose false
+# This is actually handled by the `_describe' function underneath the
+# Perforce completion system; it's mentioned here as verbosity adds
+# significantly to a lot of the Perforce completions.
+#
+# Note that completing changelists (which are just numbers) is not very
+# useful if `verbose' is turned off.  There is no speed advantages for
+# turning it off, either.
+#
+# The style `max' can be set to a number which limits how many
+# possibilities can be shown when selecting changelists or jobs.  This is
+# handled within Perforce, so the completion code may limit the number even
+# further.  If not set explicitly, the value is taken to be 20 to avoid a
+# huge database being output.  Set it to a larger number if necessary.
+#
+# The style `all-files' is used to tell the completion system to
+# complete any file in a given context.  This is for use in places
+# where it would, for example, only complete files opened for editing.
+# See the next section for more.
+#
+# The style `depot-files' tells the system to complete files by asking
+# Perforce for a list where it would otherwise complete files locally by
+# the standard mechanism --- basically any time you don't use // notation
+# and there is no restriction e.g. to opened files only.  There is likely
+# to be a significant speed penalty for this; it is turned off by default
+# in all contexts.  The advantage is that it cuts out files not maintained
+# by Perforce.  (Again, note this is a style, not a tag.)  Contexts
+# where this might be particularly useful include p4-diff or p4-diff2.
+#
+# The tags depot-files and depot-dirs also exist; they are used whenever
+# the system is completing files or directories by asking Perforce
+# to list them, rather than by using normal file completion.
+#
+# The tag subdirs is used to complete the special `...' which tells
+# Perforce to search all subdirectories.  Hence you can turn this
+# feature off by suitably manipulating your tags.
+#
+# Completion of files and their revisions
+# =======================================
+#
+# File completion handles @ and # suffixes.  If the filename is completed,
+# typing @ or # removes the space which was automatically added.
+#
+# A # is automatically quoted when handled in this way; if the file is
+# typed by hand or the completion didn't finish (e.g. you typed a character
+# in the middle of menu completion), you probably need to type `\#' by
+# hand.  The problem is that the completion system uses extended globbing
+# and hence a pattern of the form `filename#' always matches `filename'
+# (since e# matches any number of e's including one).  Hence this can look
+# like an expansion which expands to `filename'.
+#
+# After @, you can complete changelists (note the use of the style `max'
+# above), labels or clients (but not dates), while after `#' you can
+# complete numeric revisions or the special revision names head, none,
+# have.  These are available whether or not you completed the filename; if
+# the file doesn't exist, numeric revisions won't work, but the rest will
+# (though what Perforce will do with the resulting command is another matter).
+#
+# In addition, when completing after `file@', only changes specific to `file'
+# will be shown (exactly the list of changes Perforce shows from the
+# command `p4 changes file').  If this doesn't work, chances are that
+# `file' does not exist.  Having a multi-directory match (literal `...')
+# in `file' should work fine, since `p4 changes' recognises all normal
+# Perforce file syntax.
+#
+# Some perforce commands allow you to specify a range of revisions or
+# changes as `file@1,@2' or `file#1,#2'.  Currently, the second part of the
+# revision range can always be completed (whether the command accepts them
+# or not), but the comma after the first part of the range is only added
+# automatically if the documentation suggests the command accepts ranges at
+# that point.  This is an auto-removable suffix, so it will disappear if
+# you hit space or return.  Typing a `#' at this point will insert a
+# backslash, as before.
+#
+# File completion for some functions is restricted by the Perforce
+# status of the file; for example, `p4 opened' only completes opened
+# files (surprised?)  However, you can set the style (N.B. not tag)
+# all-files; so, for example, you can turn off the limit in this case by
+#   zstyle ':completion:*:p4-opened:*' all-files true
+# Normally the file-patterns style would be used to control matching,
+# but as the file types are not selected by globbing it doesn't work here
+# However, if you set the all-files style, all filename completion is done
+# by the standard mechanism; in this case, the file-patterns style works
+# as usual.  The ignored-patterns is available in any case, even without
+# all-files.
+#
+# With `p4 diff', the shell will spot if you have used an option that
+# allows you to diff unopened files (such as -f) and in that case offer
+# all files; otherwise, it just offers opened files.
+#
+# Completion of changes
+# =====================
+#
+# There is various extra magic available any time change numbers
+# are completed, regardless of how this was reached, i.e.
+# `p4 fixes -c ...' and `p4 diff filename.c@...' are treated the same way.
+# Note, however, these only work if you are at the point where a change
+# number would be completed.
+#
+# Firstly, as mentioned above there is a maximum for the number of
+# changes which will be shown, given by the style max, or defaulting to 20.
+# Only the most recent changes will be shown.  This is to avoid a speed
+# penalty or clumsy output.  If a positive numeric argument is given
+# when changes are being completed, the maximum is set (unconditionally)
+# to that number instead.
+#
+# It is also possible to give a negative numeric prefix to a listing widget
+# (i.e. typically whatever is bound to ^D).  If there is a numeric value at
+# the point where a change number is expected, the full description for
+# that change is shown in the format of a completion listing.
+# [TODO: this could be made configurable with a style.]
+#
+# It may be necessary to abandon the current completion attempt before
+# typing this to force the completion system to display the new text.
+# Replacing delete-char-or-list with the following user defined widget
+# (create with `zle -N ...') will force this for any negative prefix argument.
+#    (( ${NUMERIC:-0} < 0 )) && (( CURSOR = CURSOR ))
+#    zle delete-char-or-list
+#
+# Completion of jobs
+# =================
+#
+# Completing jobs uses the same logic for the numeric prefix as completing
+# changes: a positive prefix changes the maximum number of jobs which
+# will be shown, and a negative prefix when listing shows the full
+# text for the job whose name is currently inserted on the command line.
+# In this case, the entire text of the word being completed is assumed
+# to constitute the job name (which is almost certainly correct).
+#
+# Calls to p4
+# ===========
+#
+# Much of the information from Perforce is provided by calls to p4
+# commands.  This is done via the _call_program interface, as described
+# in the zshcompletesys manual page.  Hence a suitable context with the
+# `command' style allows the user to take control of this call.
+# The tags used are the name of the p4 command, or in the case of
+# calls to help subcommands, `help-<subcommand>'.  Note that if the
+# value of the style begins with `-', the arguments to the perforce
+# command are appended to the remaining words of the style before calling
+# the command.
+#
+# TODO
+# ====
+#
+# No mechanism is provided for completely ignoring certain files not
+# handled by Perforce as with .cvsignore.  This could be done ad hoc.
+# However, the ignored-patterns style and the parameter $fignore are
+# of course applied as usual, so setting ignored-patterns for the
+# context `:completion:*:p4[-:]*' should work.
+
+_p4() {
+    # rely on localoptions
+    setopt nonomatch
+    local p4cmd==p4
+    integer i
+
+    if [[ $service = -value-* ]]; then
+	# Completing parameter value.
+	# Some of these --- in particular P4PORT --- don't need
+	# the perforce server.
+	case $compstate[parameter] in
+	    (P4PORT) _p4_host_port
+		     ;;
+	    (P4CLIENT) _p4_clients
+		       ;;
+	esac
+	# We do not handle values anywhere else.
+	return
+    fi
+
+    if [[ $p4cmd = '=p4' ]]; then
+	_message "p4 excutable not found: completion not available"
+	return
+    fi
+
+    if (( ! ${#_p4_cmd_list} )); then
+	(( ${+_p4_cmd_list} )) || typeset -ga _p4_cmd_list
+	local hline
+	# Output looks like <tab>command-name<space>description in words...
+	# Ignore blank lines and the heading line beginning `Perforce...'
+	# Just gets run once, then cached, so don't bother optimising
+	# this to a grossly unreadable parameter substitution.
+	_call_program help-commands p4 help commands | while read -A hline; do
+	    (( ${#hline} < 2 )) && continue
+	    [[ $hline[1] = (#i)perforce ]] && continue
+	    _p4_cmd_list+=("${hline[1]}:${hline[2,-1]}")
+	done
+    fi
+
+    # We need to try and check if we are before or after the
+    # subcommand, since some of the options with arguments, in particular -c,
+    # work differently.  It didn't work if I just added '*::...' to the
+    # end of the arguments list, anyway.
+    for (( i = 2; i < CURRENT; i++ )); do
+	if [[ $words[i] = -[cCdHLpPux] ]]; then
+	    # word with following argument
+	    (( i++ ))
+	elif [[ $words[i] != -* ]]; then
+	    break
+	fi
+    done
+
+    if (( i >= CURRENT )); then
+	_arguments -s : \
+	    '-c+[client]:client:_p4_clients' \
+	    '-C+[charset]:charset:_p4_charset' \
+	    '-d+[current directory]:directory:_path_files -g "*(/)"' \
+	    '-H+[hostname]:host:_hosts' \
+	    '-G[python output]' \
+	    '-L+[message language]:language: ' \
+	    '-p+[server port]:port:_ports' \
+	    '-P+[password on server]:password: ' \
+	    '-s[output script tags]' \
+	    '-u+[user]:user name:_users' \
+	    '-x+[filename or -]:file:_p4_file_or_Minus' \
+	    '1:perforce command:_p4_command'
+    else
+	(( i-- ))
+	(( CURRENT -= i ))
+	shift $i words
+	_p4_command_arg
+    fi
+}
+
+
+#
+# Command and argument dispatchers
+#
+
+(( $+functions[_p4_command] )) ||
+_p4_command() {
+    _describe -t p4-commands 'Perforce command' _p4_cmd_list
+}
+
+
+(( $+functions[_p4_command_arg] )) ||
+_p4_command_arg() {
+    local curcontext="$curcontext" cmd=${words[1]}
+    if (( $+functions[_p4_cmd_$cmd] )); then
+	 curcontext="${curcontext%:*:*}:p4-${cmd}:"
+	 _p4_cmd_$cmd
+    else
+	 _message "unhandled perforce command: $cmd"
+    fi
+}
+
+
+#
+# Helper functions
+#
+
+(( $+functions[_p4_branches] )) ||
+_p4_branches() {
+    local bline match mbegin mend
+    local -a bl
+    bl=(${${${(f)"$(_call_program branches p4 branches 2>/dev/null)"}##Branch }/ /:})
+    [[ $#bl -eq 1 && $bl[1] = '' ]] && bl=()
+    (( $#bl )) && _describe -t branches 'Perforce branch' bl
+}
+
+
+(( $+functions[_p4_changelist] )) ||
+_p4_changelist() {
+    local cline match mbegin mend max ctype num comma file
+    local -a cl cstatus
+
+    zstyle -s ":completion:${curcontext}:" max max
+    if [[ ${NUMERIC:-0} -lt 0 && -z $compstate[insert] ]]; then
+	 # Not inserting (i.e. just listing) and given a negative
+	 # prefix argument.  Instead of listing possible completions,
+	 # show the full description for the change number on the line at
+	 # the moment.
+	 [[ $PREFIX = (|*[^[:digit:]])(#b)(<->) ]] && num+=$match[1]
+	 [[ $SUFFIX = (#b)(<->)* ]] && num+=$match[1]
+	 if [[ -n $num ]]; then
+	     _message -r "$(_call_program describe p4 describe $num)"
+	     return 0
+	 fi
+    elif [[ ${NUMERIC:-0} -gt 0 ]]; then
+	 max=$NUMERIC
+    fi
+
+    # Hack: assume the arguments we want are at the end.
+    while [[ $argv[-1] = -t? ]]; do
+	 case $argv[-1] in
+	     # Change embedded in filename; extract that and remove
+	     # the corresponding prefix.  Remove possible `#'s, too,
+	     # in case we are looking at a range.
+	     (-tf) file=${${(Q)PREFIX}%%[\#@]*}
+		   compset -P '*@'
+		   ;;
+	     # Changes already submitted
+	     (-ts) cstatus=(-s submitted)
+		   ctype="submitted "
+		   ;;
+	     # Changes still pending
+	     (-tp)
+		   cstatus=(-s pending)
+		   ctype="pending "
+		   ;;
+	     # Range allowed: append comma and supply rules for
+	     # removing and handling subsequent `#'.
+	     (-tR) comma=(-S, -R _p4_file_suffix)
+	 esac
+	 argv=($argv[1,-2])
+    done
+    # Limit to the 20 most recent changes by default to avoid huge
+    # output.
+    cl=(
+${${${${(f)"$(_call_program changes p4 changes -m ${max:-20} $cstatus \$file)"}##Change\ }//\ on\ /:}/\ by\ /\ }
+"default:changelist not yet numbered")
+    [[ $#cl -eq 1 && $cl[1] = '' ]] && cl=()
+    _describe -t changelists "${ctype}changelist" cl $comma
+}
+
+
+(( $+functions[_p4_charset] )) ||
+_p4_charset() {
+    local expl
+    _wanted charset expl 'character set' \
+	 compadd eucjp iso8859-1 shiftjis utf8 winansi
+}
+
+
+(( $+functions[_p4_clients] )) ||
+_p4_clients() {
+    local cline match mbegin mend 
+    local -a slash cl
+
+    # Are we completing a client view in a filespec?
+    compset -P '//' && slash=(-S/ -q)
+
+    cl=(${${${(f)"$(_call_program clients p4 clients)"}##Client\ }/\ /:})
+    [[ $#cl -eq 1 && $cl[1] = '' ]] && cl=()
+    _describe -t clients 'Perforce client' cl $slash
+}
+
+
+(( $+functions[_p4_counters] )) ||
+_p4_counters() {
+    local cline match mbegin mend
+    local -a cl
+
+    cl=(${${${(f)"$(_call_program counters p4 counters)"}/\ /:}/\=/current value})
+    [[ $#cl -eq 1 && $cl[1] = '' ]] && cl=()
+    _describe -t counters 'Perforce counter' cl
+}
+
+
+(( $+functions[_p4_counter_value] )) ||
+_p4_counter_value() {
+    if [[ -n $words[CURRENT-1] ]]; then
+	 local value="$(_call_program counter p4 counter $words[CURRENT-1] 2>/dev/null)"
+	 if [[ -n $value ]]; then
+	     # No space.  This allows stuff like incarg and decarg.
+	     compstate[insert]=1
+	     _wanted value expl 'counter value' compadd $value
+	 fi
+    fi
+}
+
+
+(( $+functions[_p4_depots] )) ||
+_p4_depots() {
+    local dline match mbegin mend max
+    local -a dl
+
+    dl=(${${${(f)"$(_call_program depots p4 depots)"}##Depot\ }/\ /:})
+    [[ $#dl -eq 1 && $dl[1] = '' ]] && dl=()
+    _describe -t depots 'depot name' dl
+}
+
+
+(( $+functions[_p4_file_or_minus] )) ||
+_p4_file_or_minus() {
+    _alternative 'minus:minus sign:(-)' 'files:file name:_files'
+}
+
+
+(( $+functions[_p4_file_suffx] )) ||
+_p4_file_suffix() {
+    # Used with compadd -R to handle @ or # after a file name.
+    # Differs from compadd -r '...' in that it quotes `#' if typed.
+    [[ $1 = 1 ]] || return
+
+    if [[ $LBUFFER[-1] = [\ ,] ]]; then
+	 if [[ $KEYS = '#' ]]; then
+	     if [[ $LBUFFER[-1] = , ]]; then
+		 # Range: no suffix removal but add a backslash
+		 LBUFFER+=\\
+	     else
+		 # Suffix removal with an added backslash
+		 LBUFFER="$LBUFFER[1,-2]\\"
+	     fi
+	 elif [[ $KEYS = (*[^[:print:]]*|[[:blank:]\;\&\|]) || \
+		 ( $KEYS = @ && $LBUFFER[-1] = ' ' ) ]] ; then
+	     # Normal suffix removal
+	     LBUFFER="$LBUFFER[1,-2]"
+	 fi
+    fi
+}
+
+
+#
+# Helper functions for the helper function _p4_files.  These files
+# are low-level enough that they don't handle tags; this is done
+# by the _alternative handler in _p4_files.
+#
+
+(( $+functions[_p4_integrated_files] )) ||
+_p4_integrated_files() {
+    local pfx=${(Q)PREFIX} type
+    local -a files
+
+    compset -P '*/'
+    files=(${${${(f)"$(_call_program integrated p4 integrated \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)"}%\#*}##*/})
+    [[ $#files -eq 1 && $files[1] = '' ]] && files=()
+    compadd "$@" -a files
+}
+
+
+(( $+functions[_p4_opened_files] )) ||
+_p4_opened_files() {
+    local pfx=${(Q)PREFIX} type
+    local -a files
+
+    compset -P '*/'
+    files=(${${${(f)"$(_call_program opened p4 opened \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)"}%\#*}##*/})
+    [[ $#files -eq 1 && $files[1] = '' ]] && files=()
+    compadd "$@" -a files
+}
+
+
+(( $+functions[_p4_resolved_files] )) ||
+_p4_resolved_files() {
+    local pfx=${(Q)PREFIX} type
+    local -a files
+
+    compset -P '*/'
+    files=(${${${(f)"$(_call_program resolved p4 resolved \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)"}%\#*}##*/})
+    [[ $#files -eq 1 && $files[1] = '' ]] && files=()
+    compadd "$@" -a files
+}
+
+(( $+functions[_p4_subdir_search] )) ||
+_p4_subdir_search() {
+    # This has no other function than to offer to add the `...' used
+    # by Perforce to indicate a recursive search of directories.
+    # Bit pathetic, really.
+    compset -P '*/'
+    compadd "$@" '...'
+}
+
+(( $+functions[_p4_depot_dirs] )) ||
+_p4_depot_dirs() {
+    # Normal completion of directories in depots
+    local pfx=${(Q)PREFIX} expl
+    local -a files
+
+    compset -P '*/'
+    files=(${"${(f)$(_call_program dirs p4 dirs \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)}"##*/})
+    [[ $#files -eq 1 && $files[1] = '' ]] && files=()
+    compadd "$@" -S / -q -a files
+}
+
+(( $+functions[_p4_depot_files] )) ||
+_p4_depot_files() {
+    # Normal completion of files in depots
+    local pfx=${(Q)PREFIX} expl
+    local -a files
+
+    compset -P '*/'
+    files=(${${${(f)"$(_call_program files p4 files \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)"}%\#*}##*/})
+    [[ $#files -eq 1 && $files[1] = '' ]] && files=()
+    compadd "$@" -R _p4_file_suffix -a files
+}
+
+(( $+functions[_p4_client_dirs] )) ||
+_p4_client_dirs() {
+    # This is a slightly odd addition which isn't often necessary.
+    # When completing directories in a client specification, Perforce
+    # doesn't tell you about intermediate directories which are in
+    # the client, but not in the depot.  (Well... sometimes.  I've
+    # had some odd results with this.  I suspect there may be a bug
+    # but I don't really know enough to be sure.)
+    #
+    # For example, if my view contains
+    #   //depot/branches/rev1.2/...   //pws_client/branches/rev1.2/...
+    # then `p4 dirs "//pws_client/*"' won't mention the `branches'
+    # directory because the view actually starts lower down.  So
+    # we add it by hand when necessary.
+    #
+    # We don't want to waste time on this, since it's not the usual
+    # case, so we cache the results where necessary.  This means
+    # recording all the clients that we can later ask about if necessary.
+    # To flush the cache, `unset _p4_client_list _p4_client_dirs'.
+    if (( ! ${+_p4_client_list} )); then
+	# Retrieve the list of clients.
+	typeset -gA _p4_client_list
+	local -a tmplist
+	local tmpelt
+	tmplist=(${${${(f)"$(_call_program clients p4 clients)"}##Client\ }%%\ *})
+	[[ $#tmplist -eq 1 && $tmplist[1] = '' ]] && tmplist=()
+	for tmpelt in $tmplist; do
+	    _p4_client_list[$tmpelt]=1
+	done
+    fi
+
+    # See if the first path element is a client.  Very often it
+    # will actually be a depot, so we test this as quickly as possible.
+    local client=${${PREFIX##//}%%/*}
+    [[ -z ${_p4_client_list[$client]} ]] && return 1
+
+    local oldifs=$IFS IFS= type dir line dirs
+
+    (( ${+_p4_client_dirs} )) || typeset -gA _p4_client_dirs
+
+    if (( ${+_p4_client_dirs[$client]} )); then
+	# Already cached, although may be empty.
+	dirs=${_p4_client_dirs[$client]}
+    else
+	# We need to look at the View stanza of the client record
+	# to see what directories exist in the client view.
+	_call_program client "p4 client -o $client" 2>/dev/null | while read line; do
+	    case $line in
+		([[:blank:]]##) type=
+			        ;;
+		((#b)([[:alpha:]]##):*) type=${match[1]}
+				        ;;
+		(*) if [[ $type = View ]]; then
+	                dir=${${line##[[:blank:]]##//*[[:blank:]]//$client}%%/...(/*|)}
+			if [[ $#dir -gt 1 ]]; then
+			    dirs+="${dirs:+ }${(q)dir##/}"
+			fi
+		    fi
+		    ;;
+	    esac
+	done
+    fi
+
+    (( ${#dirs} )) || return 1
+
+    # Turn our string of space-separated backquoted elements into an array.
+    dirs=(${(z)dirs})
+    # Get the current prefix also as an array of elements
+    compset -P '//[^/]##/'
+    pfx=(${(s./.)${(Q)PREFIX}})
+
+    local -a ndirs
+    local match mbegin mend
+    # Check matching path segments
+    while (( ${#pfx} > 1 )); do
+	ndirs=()
+	for dir in $dirs; do
+	    if [[ $dir = $pfx/(#b)(*) ]]; then
+		ndirs+=($match[1])
+	    fi
+	done
+	(( ${#ndirs} )) || return 1
+	dirs=($ndirs)
+	shift pfx
+	compset -P '[^/]'
+    done
+    compadd -S / -q "$@" -- ${dirs%%/*}
+}
+
+(( $+functions[_p4_files] )) ||
+_p4_files() {
+    local pfx fline expl opt match mbegin mend range type
+    local -a files types
+
+    local dodirs unmaintained
+
+    while (( $# )); do
+	if [[ $1 = -t(#b)(?) ]]; then
+	    case $match[1] in
+		(d) dodirs=-/
+		    ;;
+		(u) unmaintained=1
+		    ;;
+		(i) types+=(integrated)
+		    ;;
+		(o) types+=(opened)
+		    ;;
+		(r) types+=(resolved)
+		    ;;
+		(R) range="-tR"
+		    ;;
+	    esac
+	fi
+	shift
+    done
+
+    # Remove the quotes present in the word on the command line,
+    # since we will treat this as a literal string from now on.
+    # We might get into problems with characters recognised as
+    # special by p4 files and p4 dirs, but worry about that later.
+    pfx=${(Q)PREFIX}
+    if [[ -prefix *@ ]]; then
+	# Check for existing range syntax
+	[[ $PREFIX = *[@\#]*,* ]] && range=
+	# After @ you can specify changelists, clients, labels or dates.
+	# Don't try to complete dates.
+	_alternative \
+	    "changelist:changelist:_p4_changelist $range -tf" \
+	    client:client:_p4_clients \
+	    label:label:_p4_labels
+    elif [[ -prefix *\# ]]; then
+	# Check for existing range syntax
+	[[ $PREFIX = *[@\#]*,* ]] && range=
+	# Remove longest possible tail match to get name --- this
+	# automatically handles filenames in ranges e.g. `foo#1,#3'.
+	# (Note the compset removes the maximum possible head match,
+	# so we only complete the second part of the range in that case.)
+	_p4_revisions $range
+    elif [[ $PREFIX = //* ]]; then
+	# This specifies files already handled by Perforce, so there's
+	# no point trying to look for unmaintained files.  Assume
+	# the user knows what they're doing.
+	local -a altfiles
+
+	if [[ $PREFIX = //[^/]# ]]; then
+	    # Complete //clientname spec.  Don't complete non-directories...
+	    # I don't actually know if they are valid here.
+	    altfiles+=("clients:Perforce client:_p4_clients")
+	else
+	    local donefiles=1
+	    if [[ -z $dodirs ]]; then
+		if [[ ${#types} -gt 0 ]] &&
+		    ! zstyle -t ":completion:${curcontext}:" all-files; then
+		    for type in $types; do
+			altfiles+=("$type-files:$type file:_p4_${type}_files")
+		    done
+		else
+		    altfiles+=("depot-files:file in depot:_p4_depot_files")
+		fi
+	    fi
+	    # Intermediate directories in a client view.
+	    # See function for notes.
+	    altfiles+=("client-dirs:client directory:_p4_client_dirs")
+	fi
+	altfiles+=("depot-dirs:directory in depot:_p4_depot_dirs"
+	    "subdirs:subdirectory search:_p4_subdir_search")
+	_alternative $altfiles
+    elif [[ -n $unmaintained && -z $dodirs ]]; then
+	# a la _cvs_nonentried_files: directories are never maintained,
+	# so skip 'em.  Unmaintained files can't be integrated, opened
+	# or resolved, so treat as exclusive (just as well, since
+	# this bit's messy).
+	local MATCH MBEGIN MEND
+	local -a omitpats
+
+	match=()
+	: ${PREFIX:#(#b)(*/)(*)}
+	pfx="$match[1]"
+	pfx=${(e)~pfx}
+	omitpats=(
+	    ${${${${(f)"$(_call_program files p4 files \"\$pfx\*\$\{\(Q\)SUFFIX\}\" 2>/dev/null)"}%\#*}##*/}//(#m)[][*?()<|^~#\\]/\\$MATCH}
+	)
+
+	[[ $#omitpats -eq 1 && $omitpats[1] = '' ]] && omitpats=()
+	if (( ${#omitpats} )); then
+	    _path_files -g "*~(*/|)(${(j:|:)~omitpats})(D.)"
+	else
+	    _path_files
+	fi
+	# Don't handle suffixes for non-entried files
+    elif (( ${#types} )) && ! zstyle -t ":completion:${curcontext}:" all-files
+    then
+	local -a altfiles
+
+	for type in $types; do
+	    altfiles+=("$type-files:$type file:_p4_${type}_files")
+	done
+
+	altfiles+=("depot-dirs:directory in depot:_p4_depot_dirs"
+	    "subdirs:subdirectory search:_p4_subdir_search")
+	_alternative $altfiles
+    elif zstyle -t ":completion:${curcontext}:" depot-files; then
+	local -a altfiles
+	if [[ -z $dodirs ]]; then
+	    altfiles+=("depot-files:file in depot:_p4_depot_files")
+	fi
+	altfiles+=("depot-dirs:directory in depot:_p4_depot_dirs"
+	    "subdirs:subdirectory search:_p4_subdir_search")
+	_alternative $altfiles
+    else
+	# Look locally.
+	_alternative \
+	    "files:file:_path_files -R _p4_file_suffix $dodirs" \
+	    "subdirs:subdirectory search:_p4_subdir_search"
+    fi
+}
+
+
+#
+# Remaining helpers for other types of Perforce metadata.
+#
+
+(( $+functions[_p4_filetypes] )) ||
+_p4_filetypes() {
+    local -a values
+    if compset -P '*+*'; then
+	# That second `*' is deliberate --- only complete the last
+	# letter since we can have a whole string of them.
+	values=(
+	    "m:always set modtime on client"
+	    "w:always writeable on client"
+	    "x:set exec bit on client"
+	    "k:full RCS keyword expansion"
+	    "k:RCS expansion only for Id, Header"
+	    "l:exclusive open, disallow multiple opens"
+	    "C:server stores compress file per revision"
+	    "D:server stores deltas in RCS format"
+	    "F:server stores full file per revision"
+	    "S:server stores only head revision")
+	_describe -t file-modifiers 'Perforce file modifier' values
+    else
+	values=(
+	    "text:text, translate newlines"
+	    "binary:raw bytes"
+	    "symlink:symbolic link"
+	    "apple:Mac resource + data"
+	    "unicode:text, translate newlines, store as UTF-8")
+	_describe -t file-types 'Perforce file type' values -S+ -q
+    fi
+}
+
+
+(( $+functions[_p4_groups] )) ||
+_p4_groups() {
+    _describe -t groups 'Perforce group' $(_call_program groups p4 groups)
+}
+
+
+(( $+functions[_p4_host_port] )) ||
+_p4_host_port() {
+    if compset -P '*:'; then
+	_ports
+    else
+	# is this -q-able?
+	_hosts -S :
+    fi
+}
+
+(( $+functions[_p4_jobs] )) ||
+_p4_jobs() {
+    local jline match mbegin mend max
+    local -a jl
+
+    zstyle -s ":completion:${curcontext}:" max max
+    if [[ ${NUMERIC:-0} -lt 0 && -z $compstate[insert] ]]; then
+	# Not inserting (i.e. just listing) and given a negative
+	# prefix argument.  Instead of listing possible completions,
+	# show the full description for the job which is on the line at
+	# the moment.
+	_message -r "$(_call_program jobs p4 jobs -e \"Job=\$PREFIX\$SUFFIX\" -l 2>/dev/null)"
+	return 0
+    elif [[ ${NUMERIC:-0} -gt 0 ]]; then
+	max=$NUMERIC
+    fi
+
+    _call_program jobs p4 jobs -m ${max:-20} | while read jline; do
+	if [[ $jline = (#b)([^[:blank:]]##)' '[^[:blank:]]##' '(*) ]]; then
+	    jl+=("${match[1]}:${match[2]}")
+	fi
+    done
+    _describe -t jobs 'Perforce job' jl
+}
+
+(( $+functions[_p4_jobview] )) ||
+_p4_jobview() {
+    # Jobviews (see `p4 help jobview') are ways of interrogating the
+    # jobs/fixes database.  It's basically either a set of strings,
+    # or a set of key=value pairs, or some combination, separated
+    # by various logical operators.  The `=' could be a comparison,
+    # but we don't currently bother with that here; it's a bit cumbersome
+    # to commit.
+    local line type oldifs=$IFS IFS= key value
+    local match mbegin mend
+    # This is simply to split out two space-delimited words a backreferences.
+    local m2words
+    m2words='(#b)[[:blank:]]##([[:alnum:]]##)[[:blank:]]##([^[:blank:]]##)'
+
+    local -a valuespec
+    local -A p4fields p4values
+
+    # All the characters which can separate multiple match attempts.
+    # Ignore up to the last one.  We don't try to complete these.
+    compset -P '*[[:blank:]\^\&\|\(\)]'
+
+    # According to the manual, `p4 jobspec' requires admin priveleges.
+    # If this is true even of `p4 jobspec -o', we are a bit screwed.
+    _call_program jobspec p4 jobspec -o 2>/dev/null | while read line; do
+	case $line in
+	    ([[:blank:]]##) type=
+			    ;;
+	    ((#b)([[:alpha:]]##):*) type=${match[1]}
+				    ;;
+	    (*) case $type in
+	        # This stanza tells us all the allowed fields.
+	        (Fields) if [[ $line = [[:blank:]]##<->${~m2words}* ]]
+	                 then
+			     p4fields[${(L)match[1]}]=${match[2]}
+			 fi
+			 ;;
+	        # This stanza gives allowed values for the `select' types.
+		(Values) if [[ $line = ${~m2words}* ]]; then
+			     p4values[${(L)match[1]}]=${match[2]}
+			 fi
+			 ;;
+	        esac
+	        ;;
+	esac
+    done
+
+    IFS=$oldifs
+
+    if (( ! ${#p4fields} )); then
+	# We didn't get anything; add the defaults.
+	p4fields=(
+	    date	date
+	    description text
+	    job		word
+	    status	select
+	    user	word
+	)
+	p4values=(
+	    status	open/suspended/closed
+	)
+    fi
+
+    for key in ${(k)p4fields}; do
+	if [[ -n ${p4values[$key]} ]]; then
+	    valuespec+=("${key}:${p4fields[$key]}:(${p4values[$key]//\\// })")
+	elif [[ $key = job ]]; then
+	    # Nothing special for jobs; add our own completion.
+	    valuespec+=("${key}:Perforce job:_p4_jobs")
+	elif [[ $key = user ]]; then
+	    # Nothing provided for user; add our own completion.
+	    valuespec+=("${key}:user:_users")
+	else
+	    valuespec+=("${key}:${p4fields[$key]}: ")
+	fi
+    done
+
+    _values 'Job specification parameter' $valuespec
+}
+
+(( $+functions[_p4_labels] )) ||
+_p4_labels() {
+    local lline match mbegin mend
+    local -a ll
+    _call_program labels p4 labels | while read lline; do
+	if [[ $lline = (#b)'Label '([^[:blank:]]##)' '(*) ]]; then
+	    ll+=("${match[1]}:${match[2]}")
+	fi
+    done
+    _describe -t labels 'Perforce label' ll
+}
+
+
+(( $+functions[_p4_revisions] )) ||
+_p4_revisions() {
+    # Doesn't handle standard completion options; requires space
+    # in front if used as action in _arguments.
+
+    local rline match mbegin mend comma expl pfx
+    local -a rl
+
+    if [[ $1 = -tR ]]; then
+	# handle ranges
+	comma=(-S, -R _p4_file_suffix)
+	shift
+    fi
+
+    # Beware of @foo,#bar; stupid but probably valid.
+    pfx=${${(Q)PREFIX}%%[\#@]*}
+    compset -P '*\#'
+
+    # Numerical revision numbers, possibly with text.
+    if [[ -z $PREFIX || $PREFIX = <-> ]]; then
+	# always allowed (same as none)
+	rl+=(0)
+	_call_program filelog p4 filelog $1 2>/dev/null | while read rline; do
+	    if [[ $rline = (#b)'... #'(<->)*\'(*)\' ]]; then
+		rl+=("${match[1]}:${match[2]}")
+	    fi
+	done
+    fi
+    # Non-numerical (special) revision names.
+    if [[ -z $PREFIX || $PREFIX != <-> ]]; then
+	rl+=('head:head revision' 'none:empty revision'
+		'have:current synced revision')
+    fi
+    _describe -t revisions 'revision' rl $comma
+}
+
+
+(( $+functions[_p4_status] )) ||
+_p4_status() {
+    # Perforce statuses are usually limited to a set of values
+    # given by the jobspec.
+    local jline match mbegin mend
+    local -a statuses
+
+    _call_program jobspec p4 jobspec -o | while read jline; do
+	if [[ $jline = (#b)Status[[:blank:]]##(*/*) ]]; then
+	    statuses=(${(s./.)match[1]})
+	    break
+	fi
+    done
+    if (( !${#statuses} )); then
+	# Couldn't find anything from the jobspec; add defaults.
+	statuses=(closed open suspended)
+    fi
+    _describe -t status 'job status' statuses
+    return 1
+}
+
+
+(( $+functions[_p4_variables] )) ||
+_p4_variables() {
+    local line match mbegin mend expl
+    local -a vars
+
+    _call_program help-environment p4 help environment | while IFS= read line; do
+	if [[ $line = $'\t'(#b)([A-Z][A-Z0-9_]##)* ]]; then
+	   vars+=($match[1])
+	fi
+    done
+
+    _wanted variable expl 'environment variable' compadd -S= -q $vars
+}
+
+#
+# Completions for p4 commands
+#
+
+(( $+functions[_p4_cmd_add] )) ||
+_p4_cmd_add() {
+    _arguments -s : \
+	'-c+[select by changelist]:changelist:_p4_changelist -tp' \
+	'-t+[set file type]:file type:_p4_filetypes' \
+	'*:file:_p4_files -tu'
+}
+
+
+(( $+functions[_p4_cmd_admin] )) ||
+_p4_cmd_admin() {
+    if (( CURRENT == 2 )); then
+	local -a adcmds
+	adcmds=(
+	    "checkpoint:checkpoint, save copy of journal file"
+	    "journal:save and truncate journal file"
+	    "stop:stop the server")
+        _describe -t commands 'Perforce admin command' adcmds
+    elif [[ $words[2] == (checkpoint|journal) ]]; then
+	shift words
+	(( CURRENT-- ))
+	_arguments -s : \
+	    '-z[gzip journal file]' \
+	    '1::journal file prefix: '
+    fi
+}
+
+
+(( $+functions[_p4_cmd_annotate] )) ||
+_p4_cmd_annotate() {
+    # If you don't have this, it's new in release 2002.2.
+    _arguments -s : \
+	'-a[all, show both added and deleted lines]' \
+	'-q[quiet, suppress one-line file header]' \
+	'*::file:_p4_files -tR'
+}
+
+(( $+functions[_p4_cmd_branch] )) ||
+_p4_cmd_branch() {
+    _arguments -s : \
+	'(-o)-f[force operation by superuser]' \
+	'(-o -i)-d[delete branch]' \
+	'(-d -i -f)-o[write specification to standard output]' \
+	'(-d -o)-i[read specificationf from standard input]' \
+	'(-i)*::branch name:_p4_branches'
+}
+
+
+(( $+functions[_p4_cmd_branches] )) ||
+_p4_cmd_branches() {
+    # No arguments.
+    _arguments -s :
+}
+
+
+(( $+functions[_p4_cmd_change] )) ||
+_p4_cmd_change() {
+    _arguments -s : \
+	'(-o)-f[allow force by superuser]' \
+	'-s[joblist includes the fix status]' \
+	'(-o -i)-d[describe newly created pending change]' \
+	'(-d -i -f)-o[output specification to standard output]' \
+	'(-d -o)-i[read specification from standard input]' \
+	'(-i)1::changelist:_p4_changelist -tp'
+}
+
+
+(( $+functions[_p4_cmd_changes] )) ||
+_p4_cmd_changes() {
+    _arguments -s : \
+      '-i[include integrated changes]' \
+      '-l[long output]' \
+      '-c[select by client]:client:_p4_clients' \
+      '-m[most recent N changes]:max changes: ' \
+      '-s[select by status]:status:(pending submitted)' \
+      '-u[select by user]:user:_users' \
+      '*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_client] )) ||
+_p4_cmd_client() {
+    _arguments -s : \
+	'-f[force modification by superuser]' \
+	'-t[use template]:template client:_p4_clients' \
+	'(-o -i -t)-d[delete client]' \
+	'(-d -i -f)-o[print to standard output]' \
+	'(-d -o -t)-i[read from standard input]' \
+	'1::file:_p4_clients'
+}
+
+
+(( $+functions[_p4_cmd_clients] )) ||
+_p4_cmd_clients() {
+    # No arguments.
+    _arguments -s :
+}
+
+
+(( $+functions[_p4_cmd_counter] )) ||
+_p4_cmd_counter() {
+    _arguments -s : \
+	'-d[delete counter]' \
+	'-f[force setting of internal counter]' \
+	'1:counter:_p4_counters' \
+	'(-d)2::numeric value:_p4_counter_value'
+}
+
+
+(( $+functions[_p4_cmd_counters] )) ||
+_p4_cmd_counters() {
+    # No arguments
+    _arguments -s :
+}
+
+
+(( $+functions[_p4_cmd_delete] )) ||
+_p4_cmd_delete() {
+    _arguments -s : \
+	'-c[select changelist for deletion]:changelist:_p4_changelist -tp' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_depot] )) ||
+_p4_cmd_depot() {
+    _arguments -s : \
+	'-d[delete depot]' \
+	'-o[print to stdout]' \
+	'-i[read name from stdin]' \
+	'(-i)*::depot name:_p4_depots'
+}
+
+
+(( $+functions[_p4_cmd_depots] )) ||
+_p4_cmd_depots() {
+    # No arguments
+    _arguments -s :
+}
+
+
+(( $+functions[_p4_cmd_describe] )) ||
+_p4_cmd_describe() {
+    _arguments -s : \
+	'-d-[select diff option]:diff option:((b\:ignore\ blanks c\:context n\:RCS s\:summary u\:unified w\:ignore\ all\ whitespace))' \
+	'-s[short form]' \
+	'*::changelist:_p4_changelist'
+}
+
+
+(( $+functions[_p4_cmd_diff] )) ||
+_p4_cmd_diff() {
+    local limit
+    [[ ${words[(I)-(f|sd|se)]} -eq 0 ]] && limit=" -to"
+    _arguments -s : \
+	'-d-[select diff option]:diff option:((b\:ignore\ blanks c\:context n\:RCS s\:summary u\:unified w\:ignore\ all\ whitespace))' \
+	'-f[diff every file]' \
+	'(-sd -se -sr)-sa[opened files, different or missing]' \
+	'(-sa -se -sr)-sd[unopened files, missing]' \
+	'(-sa -sd -sr)-se[unopened files, different]' \
+	'(-sa -sd -se)-sr[opened files, same as depot]' \
+	'-t[include non-text files]' \
+	"*::file:_p4_files$limit"
+}
+
+
+(( $+functions[_p4_cmd_diff2] )) ||
+_p4_cmd_diff2() {
+    _arguments -s : \
+	'-b[specify branch view]:branch name:_p4_branches' \
+	'-d-[select diff option]:diff option:((b\:ignore\ blanks c\:context n\:RCS s\:summary u\:unified w\:ignore\ all\ whitespace))' \
+	'-q[only list different files]' \
+	'-t[include non-text files]' \
+	'-u[use patch-friendly output]' \
+	'1::first file:_p4_files' \
+	'2::second file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_dirs] )) ||
+_p4_cmd_dirs() {
+    _arguments -s : \
+	'-C[only dirs on current client]' \
+	'-D[include dirs with deleted files]' \
+	'-H[only dirs on the `have'\'' list]' \
+	'*::directory:_p4_files -td'
+}
+
+
+(( $+functions[_p4_cmd_edit] )) ||
+_p4_cmd_edit() {
+    _arguments -s : \
+	'-c[set changelist for edit]:changelist:_p4_changelist -tp' \
+	'-t[set filetype]:filetype:_p4_filetypes' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_filelog] )) ||
+_p4_cmd_filelog() {
+    _arguments -s : \
+	'-i[follow branches]' \
+	'-l[long output, full changelist text]' \
+	'-m[set maximum number of revisions to show]:max revisions: ' \
+	'-t[include time with date]' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_files] )) ||
+_p4_cmd_files() {
+    _arguments -s : \
+	'-a[display all revisions in given range]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_fix] )) ||
+_p4_cmd_fix() {
+    _arguments -s : \
+	'-d[delete the fix]' \
+	'-s[set job status]:status:_p4_status' \
+	'1::-c required:(-c)' \
+	'2::changelist:_p4_changelist' \
+	'3::job:_p4_jobs'
+}
+
+
+(( $+functions[_p4_cmd_fixes] )) ||
+_p4_cmd_fixes() {
+    _arguments -s : \
+	'-i[include integrated changelists]' \
+	'-j[select by job]:job:_p4_jobs' \
+	'-c[select by changelist]:changelist:_p4_changelist' \
+	'*::fixed file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_flush] )) ||
+_p4_cmd_flush() {
+    _arguments -s : \
+	'-f[force resynchronisation]' \
+	'-n[show operations but don'\''t perform them]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_fstat] )) ||
+_p4_cmd_fstat() {
+    _arguments -s : \
+	'-c+[select by changelist]:changelist:_p4_changelist -ts' \
+	'-C[select mapped files]' \
+	'-H[select synced files]' \
+	'-W[select opened files]' \
+	'-l[include fileSize, possibly slow]' \
+	'-P[output clientFile in full Perforce syntax]' \
+	'-s[shorten, no client-related data]' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_group] )) ||
+_p4_cmd_group() {
+    _arguments -s : \
+	'-d[delete group]' \
+	'-o[output to stdout]' \
+	'-i[read from stdin]' \
+	'1::perforce group:_p4_groups'
+}
+
+
+(( $+functions[_p4_cmd_groups] )) ||
+_p4_cmd_groups() {
+    _arguments -s : \
+	'1::user name:_users'
+}
+
+
+(( $+functions[_p4_cmd_have] )) ||
+_p4_cmd_have() {
+    _p4_files
+}
+
+
+(( $+functions[_p4_cmd_help] )) ||
+_p4_cmd_help() {
+    local hline
+    if (( ! ${#_p4_help_list} )); then
+	(( ${+_p4_help_list} )) || typeset -ga _p4_help_list
+	# All commands have help.
+	_p4_help_list=($_p4_cmd_list)
+	_call_program help p4 help | while read -A hline; do
+	    if [[ $hline[1] = p4 && $hline[2] = help ]]; then
+		_p4_help_list+=("$hline[3]:${hline[4,-1]}")
+	    fi
+	done
+    fi
+    _describe -t help-options 'Perforce help option' _p4_help_list
+}
+
+
+(( $+functions[_p4_cmd_info] )) ||
+_p4_cmd_info() {
+    # No arguments
+    _arguments -s :
+}
+
+
+(( $+functions[_p4_cmd_integrate] )) ||
+_p4_cmd_integrate() {
+    local range
+    # If -s is present, the first normal argument can't have revRange.
+    [[ ${words[(I)-s]} -eq 0 ]] && range=" -tR"
+    _arguments -s : \
+	'-b[select branch]:branch:_p4_branches' \
+	'-c[select changelist for integration]:changelist:_p4_changelist -tp' \
+	'-f[force reintegration]' \
+	'-d[reintegrated deleted files]' \
+	'-h[integrate to revision had on client]' \
+	'-i[integrate if no common file base]' \
+	'-n[no action, dummy run]' \
+	'-r[reverse direction of integration with branch]' \
+	'-s[select source]:source file:_p4_files -tR' \
+	'-t[propagate type changes]' \
+	'-v[leave newly branched files uncopied till sync]' \
+	"1:file:_p4_files$range" \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_integrated] )) ||
+_p4_cmd_integrated() {
+    _p4_files -ti
+}
+
+
+(( $+functions[_p4_cmd_job] )) ||
+_p4_cmd_job() {
+    _arguments -s : \
+	'(-d -o -i)-f[force setting of readonly fields]' \
+	'(-f -o -i)-d[delete job]' \
+	'(-f -d -i)-o[print to stdout]' \
+	'(-d -o)-i[read from stdin]' \
+	'(-i)1::job:_p4_jobs'
+}
+
+
+(( $+functions[_p4_cmd_jobs] )) ||
+_p4_cmd_jobs() {
+    _arguments -s : \
+	'-e[select by jobview]:jobview:_p4_jobview' \
+	'-i[included integrated changes]' \
+	'-l[long output, full job descriptions]' \
+	'-r[reverse order of job names]' \
+	'-m[limit to most recent N jobs]:most recent jobs: ' \
+	'(-e -i -l -m)-R[]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_jobspec] )) ||
+_p4_cmd_jobspec() {
+    _arguments -s : \
+	'-i[read form from stdin]' \
+	'-o[write form from to stdout]'
+}
+
+
+(( $+functions[_p4_cmd_label] )) ||
+_p4_cmd_label() {
+    _arguments -s : \
+	'-f[force operation]' \
+	'-t+[copy template]:template: ' \
+	'(-o -i -t)-d[delete label]' \
+	'(-d -f -i)-o[write to standard output]' \
+	'(-o -d -t)-i[read from standard input]' \
+	'*::label:_p4_labels'
+}
+
+
+(( $+functions[_p4_cmd_labels] )) ||
+_p4_cmd_labels() {
+    _arguments -s : \
+	'1::file or revisions which must contain label:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_labelsync] )) ||
+_p4_cmd_labelsync() {
+    _arguments -s : \
+	'-a[add files to label]' \
+	'-d[delete files from label]' \
+	'-n[no effect, dummy run]' \
+	'-l[specify lable]:label:_p4_labels' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_lock] )) ||
+_p4_cmd_lock() {
+    _arguments -s : \
+	'-c[select by changelist]:changelist:_p4_changelist -tp' \
+	'*::file:_p4_files -to'
+}
+
+
+(( $+functions[_p4_cmd_logger] )) ||
+_p4_cmd_logger() {
+    _arguments -s : \
+	'-c[limit by counter no]:number: ' \
+	'-t[use counter instead of logger]:counter:_p4_counters'
+}
+
+
+(( $+functions[_p4_cmd_obliterate] )) ||
+_p4_cmd_obliterate() {
+    _message "obliterate is dangerous: you're on your own here."
+}
+
+
+(( $+functions[_p4_cmd_opened] )) ||
+_p4_cmd_opened() {
+    _arguments -s : \
+	'-a[list for all clients]' \
+	'-c+[select by changelist]:changelist:_p4_changelist -tp' \
+	'*::file:_p4_files -to'
+}
+
+
+(( $+functions[_p4_cmd_passwd] )) ||
+_p4_cmd_passwd() {
+    _arguments -s : : \
+	'-O[explicit old password]:old password: ' \
+	'-P[explicit new password]:new password: ' \
+	'1::user name:_users'
+}
+
+
+(( $+functions[_p4_cmd_print] )) ||
+_p4_cmd_print() {
+    _arguments -s : \
+	'-a[display all revisions in a range]' \
+	'-o[Select output file]:output file:_files' \
+	'-q[Suppress header]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_protect] )) ||
+_p4_cmd_protect() {
+    _arguments -s : \
+	'-o[write spec to stdout]' \
+	'-i[read spec from stdin]'
+}
+
+
+(( $+functions[_p4_cmd_reopen] )) ||
+_p4_cmd_reopen() {
+    _arguments -s : \
+	'-c+[select changelist to reopen on]:changelist:_p4_changelist -tp' \
+	'-t+[set file type]:file type:_p4_filetypes' \
+	'*::file:_p4_files -to'
+}
+
+
+(( $+functions[_p4_cmd_resolve] )) ||
+_p4_cmd_resolve() {
+    _arguments -s : \
+	'-a-[select automatic merge type]:automation type:((f\:force\ acceptance m\:skip\ conflicts s\:safe t\:use\ theirs y\:use\ yours))' \
+	'-d-[select diff option]:diff option:((b\:ignore\ blanks w\:ignore\ all\ whitespace))' \
+	'-f[force re-resolution]' \
+	'-n[no action, just list]' \
+	'-t[force textual merge on binary files]' \
+	'-v[verbose, mark all changes]' \
+	'*::file:_p4_files -to'
+}
+
+
+(( $+functions[_p4_cmd_resolved] )) ||
+_p4_cmd_resolved() {
+    _p4_files -tr
+}
+
+
+(( $+functions[_p4_cmd_revert] )) ||
+_p4_cmd_revert() {
+    _arguments -s : \
+	'-a[revert unaltered files]' \
+	'-c[limit reversions to changelist]:changelist:_p4_changelist -tp' \
+	'-n[no action, show effect only]' \
+	'*::file:_p4_files -to'
+}
+
+
+(( $+functions[_p4_cmd_review] )) ||
+_p4_cmd_review() {
+    _arguments -s : \
+	'-c[select changelist for counter]:changelist:_p4_changelist -ts' \
+	'-t[limit change number by counter]:counter:_p4_counters'
+}
+
+
+(( $+functions[_p4_cmd_reviews] )) ||
+_p4_cmd_reviews() {
+    _arguments -s : \
+	'-c[show users by changelist]:changelist:_p4_changelist -ts' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_set] )) ||
+_p4_cmd_set() {
+    # Only works under Windoze but maybe we are on Cygwin.
+    _arguments -s : \
+	'-s[set for whole system]' \
+	'-S[set for specified service]:service: ' \
+	"*::environment variable:_p4_variables"
+}
+
+
+(( $+functions[_p4_cmd_submit] )) ||
+_p4_cmd_submit() {
+    _arguments -s : \
+	'-r[files open for add or edit remain open]' \
+	'-s[include fix status in list]' \
+	'(-s -i)-c[submit specific change]:changelist:_p4_changelist -tp' \
+	'(-c)-i[read changelist spec from stdin]' \
+	'*::file:_p4_files -to -tr' \
+}
+
+
+(( $+functions[_p4_cmd_sync] )) ||
+_p4_cmd_sync() {
+    _arguments -s : \
+	'-f[force resynchronisation]' \
+	'-n[show operations but don'\''t perform them]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_triggers] )) ||
+_p4_cmd_triggers() {
+    _arguments -s : \
+	'-o[output form to stdout]' \
+	'-i[read from from stdin]'
+}
+
+
+(( $+functions[_p4_cmd_typemap] )) ||
+_p4_cmd_typemap() {
+    _arguments -s : \
+	'-o[output table to stdout]' \
+	'-i[read table from stdin]'
+}
+
+
+(( $+functions[_p4_cmd_unlock] )) ||
+_p4_cmd_unlock() {
+    _arguments -s : \
+	'-c[non-default changelist to unlock]:changelist:_p4_changelist -tp' \
+	'-f[allow superuser to unlock any file]' \
+	'*::file:_p4_files'
+}
+
+
+(( $+functions[_p4_cmd_user] )) ||
+_p4_cmd_user() {
+    _arguments -s : \
+	'(-o)-f[force edit by superuser]' \
+	'(-o -i)-d[delete user]' \
+	'(-o -d)-i[read form from stdin]' \
+	'(-f -i -d)-o[write form to stdout]' \
+	'(-i)1::username:_users'
+}
+
+
+(( $+functions[_p4_cmd_users] )) ||
+_p4_cmd_users() {
+    _arguments -s : \
+	'*::username:_users'
+}
+
+
+(( $+functions[_p4_cmd_verify] )) ||
+_p4_cmd_verify() {
+    _arguments -s : \
+	'-q[operate quietly]' \
+	'-u[compute and save digest if missing]' \
+	'-v[compute and save all digets]' \
+	'*::file:_p4_files -tR'
+}
+
+
+(( $+functions[_p4_cmd_where] )) ||
+_p4_cmd_where() {
+    _p4_files
+}
+
+
+_p4 "$@"

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR Ltd., Science Park, Milton Road,
Cambridge, CB4 0WH, UK                          Tel: +44 (0)1223 692070


**********************************************************************
The information transmitted is intended only for the person or
entity to which it is addressed and may contain confidential 
and/or privileged material. 
Any review, retransmission, dissemination or other use of, or
taking of any action in reliance upon, this information by 
persons or entities other than the intended recipient is 
prohibited.  
If you received this in error, please contact the sender and 
delete the material from any computer.
**********************************************************************

