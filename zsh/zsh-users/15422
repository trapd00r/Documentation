From zsh-users-return-15422-mason-zsh=primenet.com.au@zsh.org Wed Sep 22 06:39:47 2010
Return-Path: <zsh-users-return-15422-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 18853 invoked by alias); 22 Sep 2010 06:39:47 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15422
Received: (qmail 7869 invoked from network); 22 Sep 2010 06:39:44 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FROM,T_TO_NO_BRKTS_FREEMAIL autolearn=ham
	version=3.3.1
Received-SPF: pass (ns1.primenet.com.au: SPF record at _spf.google.com designates 209.85.215.171 as permitted sender)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:received:mime-version:received:in-reply-to
         :references:from:date:message-id:subject:to:content-type
         :content-transfer-encoding;
        bh=k+w0DoiCIu88pCHlrcFpoJznO8SbbaHhcYbTr81ckoc=;
        b=gKDgyIrnQjmFctNQN2GUaccp9aQjg2S/rrcG2Jy1ny3aYc8hclDC4GNHhANSsYRo1a
         UeKX6E5H7uA6OJ/SHbYmX6vIakFPY7xmmwDNd+uA8AwqsMQZosAHVYT3iJ8ouAyL5cxG
         hjyVOwoCxv0hkrsR5Qx7AYtnwfCE1O6N1smm4=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=mime-version:in-reply-to:references:from:date:message-id:subject:to
         :content-type:content-transfer-encoding;
        b=WFt46phhTnDHk/GcpjJJwRYaDci7BnekE/FOyeLUYpnmPlpzvZHnJDskM0pFY0tX9k
         sr2PmklQLqf/3R/8fseI92JT6l8shxQu469tvzZlebWVEL20/BgmIHTY/rIvdGx+J8vu
         0D9ZFcmTGIKXgASKbx0XC/s+iBz4mRwDGhk1Y=
MIME-Version: 1.0
In-Reply-To: <4C98D2D0.9030901@gmail.com>
References: <AANLkTinyDC-OoGBzuisMKUg+OqeeqG=HKZrNDuJZL+sD@mail.gmail.com>
 <100916072654.ZM29712@torch.brasslantern.com> <4C950347.9060109@gmail.com>
 <100918124147.ZM31152@torch.brasslantern.com> <AANLkTimY1T1n9Nq7ePkNdSbJ9zhPobwzwM5SfNYb8qfB@mail.gmail.com>
 <100920075521.ZM30584@torch.brasslantern.com> <AANLkTikpY9u90sfKn4Ew0jc4CTq=PQB3=VdJoGs2Bccf@mail.gmail.com>
 <4C98D2D0.9030901@gmail.com>
From: Anonymous bin ich <ichbinanon@gmail.com>
Date: Wed, 22 Sep 2010 12:09:18 +0530
Message-ID: <AANLkTini8tsLOLG1R8qT6YboLJsSr+G2xyY08ogCVzn+@mail.gmail.com>
Subject: Re: Waiting for a process without using pid
To: zsh-users@zsh.org
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

On Tue, Sep 21, 2010 at 9:14 PM, Anonymous bin Ich <ichbinanon@gmail.com> w=
rote:
> On 09/20/2010 10:20 PM, PJ Weisberg wrote:
>>
>> On Mon, Sep 20, 2010 at 7:55 AM, Bart Schaefer
>> <schaefer@brasslantern.com> =C2=A0wrote:
>>
>>> Perhaps I was trying to make my solution too general; i.e., I didn't
>>> want to care how many children were started or whether their PIDs had
>>> been remembered. =C2=A0But if you always have exactly two children, why=
 not
>>> this?
>>>
>>> =C2=A0 =C2=A0coproc read -E
>>> =C2=A0 =C2=A0trap "print -p" CHLD
>>>
>>> =C2=A0 =C2=A0./child.sh&
>>> =C2=A0 =C2=A0pid1=3D$!
>>> =C2=A0 =C2=A0./child.sh&
>>> =C2=A0 =C2=A0pid2=3D$!
>>>
>>> =C2=A0 =C2=A0read -p
>>> =C2=A0 =C2=A0kill $pid1>&/dev/null
>>> =C2=A0 =C2=A0kill $pid2>&/dev/null
>>
>> You *can* rewrite that to not care how many children there are.
>>
>> for thing in $stuff; do
>> =C2=A0 =C2=A0 ./child.sh $thing
>> =C2=A0 =C2=A0 set -A pids $pids $!
>> done
>>
>> for child in $pids; do
>> =C2=A0 =C2=A0 kill $child>&/dev/null
>> done
>
> Ok, I have modified child.sh as following:
>
> #!/bin/sh
> if [ $# -gt 0 ]; then
> =C2=A0 =C2=A0gotsig=3D0
> =C2=A0 =C2=A0deadchild=3D0
> =C2=A0 =C2=A0trap "exitfunc" INT HUP TERM
> =C2=A0 =C2=A0trap "exitdeadchildfunc" CHLD
> =C2=A0 =C2=A0exitfunc () {
> =C2=A0 =C2=A0 =C2=A0 =C2=A0echo $$: Got sig...
> =C2=A0 =C2=A0 =C2=A0 =C2=A0gotsig=3D1
> =C2=A0 =C2=A0}
> =C2=A0 =C2=A0exitdeadchildfunc () {
> =C2=A0 =C2=A0 =C2=A0 =C2=A0echo $$: SIG is CHLD...
> =C2=A0 =C2=A0 =C2=A0 =C2=A0deadchild=3D1
> =C2=A0 =C2=A0}
> =C2=A0 =C2=A0echo $$: Sleeping for $1 seconds
> =C2=A0 =C2=A0sleep $1 &
> =C2=A0 =C2=A0wait
> =C2=A0 =C2=A0if [ $gotsig -ne 0 ]; then
> =C2=A0 =C2=A0 =C2=A0 =C2=A0if [ $deadchild -ne 0 ]; then
> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0echo $$: sleep in for $1 seconds=
 already stopped (no $!)
> =C2=A0 =C2=A0 =C2=A0 =C2=A0else
> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0echo $$: Stopping sleep for $1 s=
econds in $!
> =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0 =C2=A0kill $!
> =C2=A0 =C2=A0 =C2=A0 =C2=A0fi
> =C2=A0 =C2=A0else
> =C2=A0 =C2=A0 =C2=A0 =C2=A0echo $$: Slept for $1 seconds
> =C2=A0 =C2=A0fi
> else
> =C2=A0 =C2=A0echo No args
> =C2=A0 =C2=A0exit 1;
> fi
>
>
> So, two normal cases are:
>
> % ./parent.sh
> 6680: Launching 2 child processes
> 6682: Sleeping for 1 seconds
> 6683: Sleeping for 5 seconds
> 6682: SIG is CHLD...
> 6682: Slept for 1 seconds
> 6680: Waking coprocess
> Woken
> Finishing 6680
> 6680: got HUP
> 6680: Waking coprocess
> 6683: Got sig...
> 6683: Stopping sleep in 6685 for 5 seconds
> % ./parent.sh
> 6686: Launching 2 child processes
> 6688: Sleeping for 1 seconds
> 6689: Sleeping for 5 seconds
> 6688: SIG is CHLD...
> 6688: Slept for 1 seconds
> 6686: Waking coprocess
> Woken
> Finishing 6686
> 6686: got HUP
> 6686: Waking coprocess
> 6689: Got sig...
> 6689: SIG is CHLD...
> 6689: sleep in 6691 for 5 seconds already stopped
> %
>
> And one abnormal case is:
> % ./parent.sh
> 6620: Launching 2 child processes
> 6622: Sleeping for 1 seconds
> 6623: Sleeping for 5 seconds
> 6622: SIG is CHLD...
> 6622: Slept for 1 seconds
> 6620: Waking coprocess
> 6620: Waking coprocess
> % 6623: SIG is CHLD...
> 6623: Slept for 5 seconds
>
> %
>
> Now what is happening? Also, anyway do debug it (set -x isn't very helpfu=
l
> since all processes write simultaneously)
>

Ok, I don't know what was the problem but I solved it by removing
coproc altogether:
% cat parent.sh
#!/usr/bin/zsh

trap "myexitfunc" CHLD
trap "print $$: got HUP; exit 0" HUP
function myexitfunc () {
    print "$$: Killing self"
    kill -HUP -$$
}

setopt HUP
print "$$: Launching 2 child processes"
./child.sh 1 0&
./child.sh 5 0&
wait

exit 0

%

Actually, if I remove setopt HUP and replace print with echo, it works
with /bin/sh too :)

Regards

