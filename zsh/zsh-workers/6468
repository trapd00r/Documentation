From zsh-workers-return-6468-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Jun 04 15:27:52 1999
Return-Path: <zsh-workers-return-6468-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 4471 invoked from network); 4 Jun 1999 15:27:52 -0000
Received: from ns2.primenet.com.au (HELO primenet.com.au) (@203.24.36.3)
  by ns1.primenet.com.au with SMTP; 4 Jun 1999 15:27:52 -0000
Received: (qmail 13330 invoked from network); 4 Jun 1999 13:41:08 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns2.primenet.com.au with SMTP; 4 Jun 1999 13:41:08 -0000
Received: (qmail 28031 invoked by alias); 4 Jun 1999 13:39:33 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6468
Received: (qmail 28024 invoked from network); 4 Jun 1999 13:39:31 -0000
Date: Fri, 4 Jun 1999 15:39:28 +0200 (MET DST)
Message-Id: <199906041339.PAA03390@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: dies und das


1) A little example for the -first- context, containing only
   comments. Is this ok? (At least the vared-stuff is probably
   not too trivial.)
2) Changed _complete to look if a parameter `compcontext' is set and
   non-empty. If it is, the valu is taken as the name of a context and 
   the function for this is called to generate matches.
   This is intended for things like:
     % foo() { local compcontext=foo; vared foo }
     % compdef _foo foo
   -- makes _foo be called when completing inside that vared.
   This was discussed some time ago, together with compstate[vared]
   and suggested by Bart.
3) Fixes for some typos in comments of completion functions.
4) Mention that even we accept unified diffs (in zsh-development-guide).

And finally a question: the FAQ says that the old mailing list archive 
is at ftp.sterling.com. I can't reach that, can anyone else?

Bye
 Sven

diff -u -r oc/Base/_first Completion/Base/_first
--- oc/Base/_first	Fri Jun  4 15:29:25 1999
+++ Completion/Base/_first	Fri Jun  4 15:14:32 1999
@@ -0,0 +1,63 @@
+#compdef -first-
+
+# This function is called at the very beginning before any other
+# function for a specific context.
+#
+# This just gives some examples of things you might want to do here.
+#
+#
+# If you use the vared builtin and want completion in there to act the 
+# way completion on the right hand side of assignments is done, add
+# (or un-comment) this code:
+#
+#     if [[ -n $compstate[vared] ]]; then
+#       if [[ $compstate[vared] = *\[* ]]; then
+#         # vared on an array-element
+#         compstate[parameter]=${compstate[vared]%%\[*}
+#         compstate[context]=value
+#       else
+#         # vared on a parameter, let's see if it is an array
+#         compstate[parameter]=$compstate[vared]
+#         if [[ ${(tP)compstate[vared]} = *(array|assoc)* ]]; then
+#           compstate[context]=array_value
+#         else
+#           compstate[context]=value
+#         fi
+#       fi
+#       return
+#     fi
+#
+#
+#
+# Other things you can do here is to complete different things if the
+# word on the line matches a certain pattern. This example allows
+# completion of words from the history by adding two commas at the end 
+# and hitting TAB.
+#
+#     if [[ "$PREFIX" = *,, ]]; then
+#       local max i=1
+#     
+#       PREFIX="$PREFIX[1,-2]"
+#       # If a numeric prefix is given, we use it as the number of
+#       # lines (multiplied by ten below) in the history to search.
+#       if [[ NUMERIC -gt 1 ]]; then
+#         max=$NUMERIC
+#         NUMERIC=1
+#       else
+#         # The default is to search the last 100 lines.
+#         max=10
+#       fi
+#       # We first search in the last ten lines, then in the last
+#       # twenty lines, and so on...
+#       while [[ i -le max ]]; do
+#         if compgen -X "%Bhistory ($n):%b" -Q -H $(( i*10 )) ''; then
+#           # We have found at least one matching word, so we switch
+#           # on menu-completion and make sure that no other
+#           # completion function is called by setting _comp_skip.
+#           compstate[insert]=menu
+#           _comp_skip=1
+#           return
+#         fi
+#         (( i++ ))
+#       done
+#     fi
diff -u -r oc/Base/_long_options Completion/Base/_long_options
--- oc/Base/_long_options	Fri Jun  4 14:40:39 1999
+++ Completion/Base/_long_options	Fri Jun  4 15:12:56 1999
@@ -7,11 +7,11 @@
 # a command that does not support this option.
 #
 # For options that get an argument after a `=', the function also tries
-# to automatically find out what should be complete as the argument.
+# to automatically find out what should be completed as the argument.
 # The possible completions for option-arguments can be described with
 # the arguments to this function. This is done by giving pairs of
 # patterns and actions as consecutive arguments. The actions specify
-# what should be done to complete arguemts of those options that match 
+# what should be done to complete arguments of those options that match 
 # the pattern. The action may be a list of words in brackets or in
 # parentheses, separated by spaces. A list in brackets denotes
 # possible values for an optional argument, a list in parentheses
@@ -27,18 +27,18 @@
 # This makes `yes' and `no' be completed as the argument of options
 # whose description ends in a star, file names for options that
 # contain the substring `=FILE' in the description, and paths for
-# options whose description contains `=DIR'. Note the last two
+# options whose description contains `=DIR'. Note that the last two
 # patterns are not needed since this function always completes files
 # for option descriptions containing `=FILE' and paths for option
 # descriptions that contain `=DIR' or `=PATH'. These builtin patterns
 # can be overridden by patterns given as arguments, though.
 # 
-# This function accepts following options:
+# This function accepts the following options:
 #
 # -t   do completion only on words starting with two hyphens
 #
 # -i   list of patterns. Options, matching these patterns, are ignored.
-#      The list may be given as array name or as literal list in braces.
+#      The list may be given as a array name or as a literal list in braces.
 #      E.g. _long_options -i '(--(enable|disable)-FEATURE*)' will ignore
 #      --enable-FEATURE, that is listed in configure help output
 #
diff -u -r oc/Core/_approximate Completion/Core/_approximate
--- oc/Core/_approximate	Fri Jun  4 14:40:43 1999
+++ Completion/Core/_approximate	Fri Jun  4 15:01:21 1999
@@ -1,9 +1,9 @@
 #autoload
 
 # This code will try to correct the string on the line based on the
-# strings generated for the context if `compconfig[correct]' is set.
-# These corrected strings will be shown in a list and one can
-# cycle through them as in a menucompletion or get the corrected prefix.
+# strings generated for the context. These corrected strings will be
+# shown in a list and one can cycle through them as in a menucompletion
+# or get the corrected prefix.
 #
 # Supported configuration keys:
 #
@@ -64,7 +64,7 @@
 local _comp_correct _correct_prompt comax
 local cfgacc cfgorig cfgps cfgins
 
-# Only if all global matchers hav been tried.
+# Only if all global matchers have been tried.
 
 [[ compstate[matcher] -ne compstate[total_matchers] ]] && return 1
 
diff -u -r oc/Core/_complete Completion/Core/_complete
--- oc/Core/_complete	Fri Jun  4 14:40:42 1999
+++ Completion/Core/_complete	Fri Jun  4 14:50:03 1999
@@ -6,6 +6,15 @@
 
 local comp name
 
+# If we have a user-supplied context name, use only that.
+
+if [[ -n "$compcontext" ]]; then
+  comp="$_comps[$compcontext]"
+  [[ -z "$comp" ]] || "$comp"
+
+  return
+fi
+
 # An entry for `-first-' is the replacement for `compctl -T'
 # Completion functions may set `_compskip' to any value to make the 
 # main loops stop calling other completion functions.
@@ -19,6 +28,7 @@
     return
   fi
 fi
+
 
 # For arguments and command names we use the `_normal' function.
 
diff -u -r oc/Core/_correct Completion/Core/_correct
--- oc/Core/_correct	Fri Jun  4 14:40:43 1999
+++ Completion/Core/_correct	Fri Jun  4 15:02:13 1999
@@ -1,8 +1,8 @@
 #autoload
 
-# This is mainly a wrapper around the more general `_approximate.
+# This is mainly a wrapper around the more general `_approximate'.
 # By setting `compstate[pattern_match]' to something unequal to `*' and
-# then calling `_approximate, we get only corrections, not all strings
+# then calling `_approximate', we get only corrections, not all strings
 # with the corrected prefix and something after it.
 #
 # Supported configuration keys are the same as for `_approximate', only
diff -u -r oc/Core/_files Completion/Core/_files
--- oc/Core/_files	Fri Jun  4 14:40:42 1999
+++ Completion/Core/_files	Fri Jun  4 15:03:27 1999
@@ -1,7 +1,7 @@
 #autoload
 
 # Utility function for completing files of a given type or any file.
-# In many cases you will want to call this one instead of _path_files().
+# In many cases you will want to call this one instead of `_path_files'.
 
 local nm=$compstate[nmatches] ret=1
 
@@ -12,9 +12,9 @@
 
   # We didn't get any matches for those types of files described by
   # the `-g' or `-/' option. Now we try it again accepting all files.
-  # First we get those options that we have to use even if then. If
-  # we find out that the `-f' option was given, we already accepted
-  # all files and give up immediatly.
+  # First we get those options that we have to use even then. If we
+  # find out that the `-f' option was given, we already accepted all
+  # files and give up immediatly.
 
   opts=()
   while getopts "P:S:W:F:J:V:X:f/g:" opt; do
diff -u -r oc/Core/_list Completion/Core/_list
--- oc/Core/_list	Fri Jun  4 14:40:43 1999
+++ Completion/Core/_list	Fri Jun  4 15:03:57 1999
@@ -1,8 +1,8 @@
 #autoload
 
 # This completer function makes the other completer functions used
-# insert possible completions only after once the list has been
-# shown.
+# insert possible completions only after the list has been shown at
+# least once.
 #
 # Configuration keys:
 #
diff -u -r oc/Core/_normal Completion/Core/_normal
--- oc/Core/_normal	Fri Jun  4 14:40:42 1999
+++ Completion/Core/_normal	Fri Jun  4 15:05:59 1999
@@ -3,7 +3,7 @@
 local comp command cmd1 cmd2 pat val name i ret=1
 
 # Completing in command position? If not we set up `cmd1' and `cmd2' as
-# two strings we have search in the completion definition arrays (e.g.
+# two strings we have to search in the completion definition arrays (e.g.
 # a path and the last path name component).
 
 command="$words[1]"
diff -u -r oc/Core/_parameters Completion/Core/_parameters
--- oc/Core/_parameters	Fri Jun  4 14:40:43 1999
+++ Completion/Core/_parameters	Fri Jun  4 15:06:44 1999
@@ -1,7 +1,7 @@
 #autoload
 
 # This should be used to complete parameter names if you need some of the
-# extra options of compadd. It first tries to complete only non-local
-# parameters. All arguments are given to compadd.
+# extra options of compadd. It completes only non-local parameters. All
+# arguments are given to compadd.
 
 compadd "$@" - "${(@)${(@)${(@)${(@f)$(typeset)}:#*local *\=*}%%\=*}##* }"
diff -u -r oc/Core/_parameters~ Completion/Core/_parameters~
--- oc/Core/_parameters~	Fri Jun  4 14:40:44 1999
+++ Completion/Core/_parameters~	Tue Jun  1 11:21:21 1999
@@ -4,5 +4,4 @@
 # extra options of compadd. It first tries to complete only non-local
 # parameters. All arguments are given to compadd.
 
-compadd "$@" - "${(@)${(@)${(@)${(@f)$(typeset)}:#*local *\=*}%%\=*}##* }" ||
-    compadd "$@" - "${(@)${(@)${(@f)$(typeset)}%%\=*}##* }"
+compadd "$@" - "${(@)${(@)${(@)${(@f)$(typeset)}:#*local *\=*}%%\=*}##* }"
diff -u -r oc/Core/_sep_parts Completion/Core/_sep_parts
--- oc/Core/_sep_parts	Fri Jun  4 14:40:43 1999
+++ Completion/Core/_sep_parts	Fri Jun  4 15:07:49 1999
@@ -9,7 +9,7 @@
 #
 #  _sep_parts '(foo bar)' @ hosts
 #
-# This will make this function complete the strings `foo' and `bar'
+# This will make this function complete the strings `foo' and `bar'.
 # If the string on the line contains a `@', the substring after it
 # will be completed from the array `hosts'. Of course more arrays
 # may be given, each preceded by another separator string.
diff -u -r oc/Core/compinit Completion/Core/compinit
--- oc/Core/compinit	Fri Jun  4 14:40:42 1999
+++ Completion/Core/compinit	Fri Jun  4 15:08:46 1999
@@ -2,7 +2,7 @@
 # functions and aliases. Everything else is split into different files that
 # will automatically be made autoloaded (see the end of this file).
 # The names of the files that will be considered for autoloading have to
-# start with an underscores (like `_setopt).
+# start with an underscores (like `_setopt').
 # The first line of these files will be read and has to say what should be
 # done with its contents:
 #
diff -u od/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- od/Zsh/compsys.yo	Fri Jun  4 14:40:19 1999
+++ Doc/Zsh/compsys.yo	Fri Jun  4 14:56:38 1999
@@ -331,6 +331,11 @@
 contexts, in most cases named after the context itself
 (e.g. completion for the `tt(-tilde-)' context is done by the function 
 named `tt(_tilde)').
+
+Before trying to find a function for a specific context, tt(_complete) 
+checks if the parameter `tt(compcontext)' is set to a non-empty
+value. If it is, the value is taken as the name of the context to use
+and the function defined for that context will be called.
 )
 item(tt(_approximate))(
 This completer function uses the tt(_complete) completer to generate
--- Util/zsh-development-guide.old	Fri Jun  4 14:56:55 1999
+++ Util/zsh-development-guide	Fri Jun  4 14:58:03 1999
@@ -17,12 +17,13 @@
 
 * Send all patches to the mailing list rather than directly to me.
 
-* Send only context diffs "diff -c oldfile newfile".  They are much
-  easier to read and understand while also allowing the patch program
-  to patch more intelligently.  Please make sure the filenames in
-  the diff header are relative to the top-level directory of the zsh
-  distribution; for example, it should say "Src/init.c" rather than
-  "init.c" or "zsh/Src/init.c".
+* Send only context diffs "diff -c oldfile newfile" or unified diffs
+  "diff -u oldfile newfile".  They are much easier to read and
+  understand while also allowing the patch program to patch more
+  intelligently.  Please make sure the filenames in the diff header
+  are relative to the top-level directory of the zsh distribution; for
+  example, it should say "Src/init.c" rather than "init.c" or
+  "zsh/Src/init.c".
 
 * Please put only one bug fix or feature enhancement in a single patch and
   only one patch per mail message.  This helps me to multiplex the many

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

