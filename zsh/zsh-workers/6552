From zsh-workers-return-6552-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Jun 09 12:40:19 1999
Return-Path: <zsh-workers-return-6552-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5671 invoked from network); 9 Jun 1999 12:40:18 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 9 Jun 1999 12:40:18 -0000
Received: (qmail 8418 invoked by alias); 9 Jun 1999 12:39:52 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 6552
Received: (qmail 8402 invoked from network); 9 Jun 1999 12:39:51 -0000
Message-Id: <9906091211.AA11909@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: pws-21: unsigned 64-bit integer type
Date: Wed, 09 Jun 1999 14:11:12 +0200
From: Peter Stephenson <pws@ibmth.df.unipi.it>

Helmut Jarausch says his problems with memory accesses for 64-bit integers
are now OK, except that defining an unsigned variant of the type is a
problem.  The following puts in a separate test for that, and also
explicitly tries `__int64_t' and `__uint64_t' for suitable types.  It would
probably have been easier to remove the only use of zulong from convbase(),
which can certainly be done.

--- Src/zsh.h.u64	Wed Jun  9 09:28:57 1999
+++ Src/zsh.h	Wed Jun  9 13:32:52 1999
@@ -47,7 +47,11 @@
  */
 #ifdef ZSH_64_BIT_TYPE
 typedef ZSH_64_BIT_TYPE zlong;
+#ifdef ZSH_64_BIT_UTYPE
+typedef ZSH_64_BIT_UTYPE zulong;
+#else
 typedef unsigned ZSH_64_BIT_TYPE zulong;
+#endif
 #else
 typedef long zlong;
 typedef unsigned long zulong;
--- acconfig.h.u64	Sun Jun  6 17:47:51 1999
+++ acconfig.h	Wed Jun  9 13:51:41 1999
@@ -248,8 +248,11 @@
 /* Define to 1 if long is 64 bits */
 #undef LONG_IS_64_BIT
 
-/* Define to a 64 bit type if there is one, but long is shorter */
+/* Define to a 64 bit integer type if there is one, but long is shorter */
 #undef ZSH_64_BIT_TYPE
+
+/* Define to an unsigned variant of ZSH_64_BIT_TYPE if that is defined */
+#undef ZSH_64_BIT_UTYPE
 
 /* Define to 1 if off_t is 64 bit (for large file support) */
 #undef OFF_T_IS_64_BIT
--- aczsh.m4.u64	Mon May 17 17:57:54 1999
+++ aczsh.m4	Wed Jun  9 13:42:56 1999
@@ -74,12 +74,12 @@
 dnl
 dnl zsh_64_BIT_TYPE
 dnl   Check whether the first argument works as a 64-bit type.
-dnl   If there is a non-zero second argument, we just assume it works
+dnl   If there is a non-zero third argument, we just assume it works
 dnl   when we're cross compiling.  This is to allow a type to be
 dnl   specified directly as --enable-lfs="long long".
-dnl   Sets zsh_cv_64_bit_type to the first argument if the test worked,
-dnl   `no' otherwise.  Be careful testing this, as it may produce
-dnl   two words `long long' on an unquoted substitution.
+dnl   Sets the variable given in the second argument to the first argument
+dnl   if the test worked, `no' otherwise.  Be careful testing this, as it
+dnl   may produce two words `long long' on an unquoted substitution.
 dnl   This macro does not produce messages as it may be run several times
 dnl   before finding the right type.
 dnl
@@ -95,11 +95,11 @@
   $1 foo = 0; 
   return sizeof($1) != 8;
 }
-], zsh_cv_64_bit_type="$1", zsh_cv_64_bit_type=no,
-  [if test x$2 != x ; then
-    zsh_cv_64_bit_type="$1"
+], $2="$1", $2=no,
+  [if test x$3 != x ; then
+    $2="$1"
   else
-    zsh_cv_64_bit_type=no
+    $2=no
   fi])
 ])
 
--- configure.in.u64	Wed Jun  9 10:40:03 1999
+++ configure.in	Wed Jun  9 13:48:46 1999
@@ -559,16 +559,31 @@
 elif test "x$enable_lfs" != x; then
   AC_CACHE_CHECK(if compiler has a 64 bit type, zsh_cv_64_bit_type,
   [if test "x$enable_lfs" != xyes; then
-     zsh_64_BIT_TYPE(${enable_lfs})
+     zsh_64_BIT_TYPE(${enable_lfs}, zsh_cv_64_bit_type, force)
    else
-     zsh_64_BIT_TYPE(long long)
+     zsh_64_BIT_TYPE(long long, zsh_cv_64_bit_type)
      if test "$zsh_cv_64_bit_type" = no; then
-       zsh_64_BIT_TYPE(quad_t)
+       zsh_64_BIT_TYPE(quad_t, zsh_cv_64_bit_type)
+     fi
+     if test "$zsh_cv_64_bit_type" = no; then
+       zsh_64_BIT_TYPE(__int64_t, zsh_cv_64_bit_type)
      fi
    fi
 ])
   if test "$zsh_cv_64_bit_type" != no; then
     AC_DEFINE_UNQUOTED(ZSH_64_BIT_TYPE, $zsh_cv_64_bit_type)
+
+    dnl Handle cases where unsigned type cannot be simply
+    dnl `unsigned ZSH_64_BIT_TYPE'.  More tests may be required.
+    AC_CACHE_CHECK(for a corresponding unsigned 64 bit type,
+    zsh_cv_64_bit_utype,
+    [zsh_64_BIT_TYPE(unsigned $zsh_cv_64_bit_type, zsh_cv_64_bit_utype, force)
+     if test "$zsh_cv_64_bit_utype" = no; then
+       zsh_64_BIT_TYPE(__uint64_t, zsh_cv_64_bit_utype)
+     fi])
+    if test "$zsh_cv_64_bit_utype" != no; then
+      AC_DEFINE_UNQUOTED(ZSH_64_BIT_UTYPE, $zsh_cv_64_bit_utype)
+    fi
 
     AC_CACHE_CHECK(if off_t is 64 bit, zsh_cv_off_t_is_64_bit,
     [AC_TRY_RUN([

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

