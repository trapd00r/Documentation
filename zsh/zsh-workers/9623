From zsh-workers-return-9623-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Feb 08 14:37:28 2000
Return-Path: <zsh-workers-return-9623-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 5872 invoked from network); 8 Feb 2000 14:37:27 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 8 Feb 2000 14:37:27 -0000
Received: (qmail 2225 invoked by alias); 8 Feb 2000 14:28:45 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9623
Received: (qmail 2217 invoked from network); 8 Feb 2000 14:28:44 -0000
Date: Tue, 8 Feb 2000 15:28:42 +0100 (MET)
Message-Id: <200002081428.PAA02690@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Tue, 08 Feb 2000 13:59:05 +0000
Subject: Re: Problem with completion after a variable with globcomplete


Oliver Kiddle wrote:

> Sven Wischnowsky wrote:
> > 
> > Oliver Kiddle wrote:
> > 
> > > zsh -f
> > > autoload -U compinit
> > > compinit
> > > setopt globcomplete
> > > f=/home
> > > cd $f/okiddle/<tab>
> > >
> > > Here the tab, inserts a space when I would expect it to list directories
> > > in my home. It seems to be that completion stops working for the second
> > > directory after a variable reference.
> > 
> > The test if we had a pattern went wrong.
> 
> Thanks, this fixes it for the case above but I noticed that the problem
> is still there for arrays. I've also found that the problem also exists
> for tilde expansion - using ${(q)...) quotes a tilde and square
> brackets.
> 
> > -          "$PREFIX$SUFFIX" != "${(q)PREFIX}${(q)SUFFIX}" ]]; then
> > +          "${PREFIX:s/$//}${SUFFIX:s/$//}" != "${(q)PREFIX:s/$//}${(q)SUFFIX:s/$//}"
> 
> I can send a patch which as far as I know fixes the problem by extending
> your logic there to take out tildes and square brackets but I don't
> really understand the context in which that line has been used (and why
> the globcomplete option should affect it) and so I'm not sure that it
> wouldn't break anything else in the process. The condition seems to be
> checking for any characters which might need to be quoted in $PREFIX and
> $SUFFIX. I would have thought that any character could appear as part of
> the command-line.

The line was added in 9454 -- trying to make the interaction with the
_match completer a bit smoother (there is almost no real reason to use 
GLOB_COMPLETE nowadays, the _match completer should be better -- and
configurable).

If GLOB_COMPLETE is set, then `$compstate[pattern_match]' is set to
`*' by the completion code (compatibility).


Ok, the patch below changes the test to not look at the components
already processed.

Bye
 Sven

diff -ru ../z.old/Completion/Core/_path_files Completion/Core/_path_files
--- ../z.old/Completion/Core/_path_files	Tue Feb  8 14:12:36 2000
+++ Completion/Core/_path_files	Tue Feb  8 15:22:19 2000
@@ -445,15 +445,15 @@
     if [[ "$tpre" = */* ]]; then
       PREFIX="${donepath}${linepath}${cpre}${tpre%%/*}"
       SUFFIX="/${tsuf#*/}"
+      tmp2="${cpre}${tpre%%/*}"
     else
       PREFIX="${donepath}${linepath}${cpre}${tpre}"
       SUFFIX="${tsuf}"
+      tmp2="${cpre}${tpre}"
     fi
 
     if (( $#tmp4 )) ||
-       [[ -n "$compstate[pattern_match]" &&
-          "${PREFIX:s/$//}${SUFFIX:s/$//}" != "${(q)PREFIX:s/$//}${(q)SUFFIX:s/$//}" ]]; then
-
+       [[ -n "$compstate[pattern_match]" && "$tmp2" != "${(q)tmp2}" ]]; then
       # It is. For menucompletion we now add the possible completions
       # for this component with the unambigous prefix we have built
       # and the rest of the string from the line as the suffix.

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

