From zsh-workers-return-5362-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Feb 13 13:23:17 1999
Return-Path: <zsh-workers-return-5362-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 17905 invoked from network); 13 Feb 1999 13:23:16 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 13 Feb 1999 13:23:16 -0000
Received: (qmail 14331 invoked by alias); 13 Feb 1999 13:22:40 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5362
Received: (qmail 14324 invoked from network); 13 Feb 1999 13:22:38 -0000
Message-Id: <9902131306.AA34056@ibmth.df.unipi.it>
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: PATCH: 3.1.5-pws-7++: #key-* style completions
Date: Sat, 13 Feb 1999 14:06:53 +0100
From: Peter Stephenson <pws@ibmth.df.unipi.it>

This alters the format of definitions for directly bindable completions via
#key-array or #key-function widgets (for intermittent readers, these
function like the old zle -C widgets I previously introduced) so that the
bindkey string comes last, and there can be zero or more of them.

I've just noticed a slight problem with rebinding all completion-type key
bindings to use the new functions, when combined with #key-* bindings: if
you do (say) ^D, it will always generate the context-dependent list,
replacing the list you just made with the #key-* function, whereas if ^D
was bound as originally, it will use an existing completion list.  However,
that was imperfect because if there was no existing completion list it
would generate the one according to the old-style compctl's.  So the
present arrangement is probably better, but not perfect.  Is there some way
in shell code of making listing functions use an existing completion
list where there is one (maybe as an option)?

--- Misc/Completion/__most_recent_file.bk	Sat Feb 13 13:48:43 1999
+++ Misc/Completion/__most_recent_file	Sat Feb 13 13:49:08 1999
@@ -1,2 +1,2 @@
-#key-array \C-xm expand-or-complete
+#key-array expand-or-complete \C-xm
 __most_recent_file=(-g '*(om[1])')
--- Misc/Completion/init.bk	Sat Feb 13 13:48:48 1999
+++ Misc/Completion/init	Sat Feb 13 13:55:12 1999
@@ -30,17 +30,18 @@
 #   `#pattern-array <pattern>'
 #     like `#pattern-function' but defining an array
 #
-#   `#key-function <key-sequence> <style>
-#     this is used to bind special completions to a <key-sequence>;
-#     the <style> is the name of one of the built-in completion widgets
-#     (complete-word, delete-char-or-list, expand-or-complete,
-#     expand-or-complete-prefix, list-choices, menu-complete,
-#     menu-expand-or-complete, or reverse-menu-complete); this will create
-#     a internal widget and bind the given key-sequence to this widget so
-#     that typing this key-sequence will have the effect of completing
-#     the word on the command line as defined in the file
+#   `#key-function <style> [ <key-sequence> ... ]
+#     this is used to bind special completions to all the given
+#     <key-sequence>(s). The <style> is the name of one of the built-in
+#     completion widgets (complete-word, delete-char-or-list,
+#     expand-or-complete, expand-or-complete-prefix, list-choices,
+#     menu-complete, menu-expand-or-complete, or reverse-menu-complete).
+#     This creates a widget behaving like <style> so that the
+#     completions are chosen as given in the the rest of the file,
+#     rather than by the context.  The widget has the same name as
+#     the autoload file and can be bound using bindkey in the normal way.
 #
-#   `#key-array <key-sequence> <style>
+#   `#key-array <style> [ <key-sequence> ... ]
 #     like `#key-function', but defining an array instead
 #
 #   `#helper'
@@ -108,11 +109,12 @@
 
 
 # This is used to define completion handlers directly bound to keys. The
-# first argument is as for `defcomp', giving the handler. The second argument
-# is a key-sequence usable fo `bindkey'. The third argument is the name of one
-# of the built-in completion widgets. Typing the given key sequence will
-# complete the word the cursor is on according to the completion definition
-# given and will behave as if the built-in completion widget was used.
+# first argument is as for `defcomp', giving the handler. The second
+# argument is the name of one of the built-in completion widgets. Any
+# remaining arguments are used as key sequences to bind the widget.
+# Typing that key sequence will complete the word the cursor is on
+# according to the completion definition given and will behave as if the
+# built-in completion widget was used.
 
 defkeycomp() {
   local name
@@ -126,9 +128,14 @@
   else
     name="$1"
   fi
-  zle -C "$name" "$3" __main_key_complete
-  bindkey "$2" "$name"
   keycomps[$name]="$1"
+  shift
+  zle -C "$name" "$1" __main_key_complete
+  shift
+  while (( $# )); do
+    bindkey "$1" "$name"
+    shift
+  done
 }
 
 # These can be used to easily save and restore the state of the special
@@ -202,25 +209,27 @@
 
 # Now we make the files automatically autoloaded.
 
-local dir file line
+local dir file line func
 
 for dir in $fpath; do
   [[ $dir = . ]] && continue
   for file in $dir/__*~*~(N); do
     read -rA line < $file
-    if [[ $line[1] = '#function' ]]; then
-      defcomp -a ${file:t} "${(@)line[2,-1]}"
-    elif [[ $line[1] = '#array' ]]; then
-      defcomp " $file" "${(@)line[2,-1]}"
-    elif [[ $line[1] = '#pattern-function' ]]; then
-      defpatcomp -a ${file:t} "$line[2]"
-    elif [[ $line[1] = '#pattern-array' ]]; then
-      defcomp " $file" "$line[2]"
-    elif [[ $line[1] = '#key-function' ]]; then
-      defkeycomp -a "${file:t}" "$line[2]" "$line[3]"
-    elif [[ $line[1] = '#key-array' ]]; then
-      defkeycomp " $file" "$line[2]" "$line[3]"
-    elif [[ $line[1] = '#helper' ]]; then
+    func=$line[1]
+    shift line
+    if [[ $func = '#function' ]]; then
+      defcomp -a ${file:t} "${line[@]}"
+    elif [[ $func = '#array' ]]; then
+      defcomp " $file" "${line[@]}"
+    elif [[ $func = '#pattern-function' ]]; then
+      defpatcomp -a ${file:t} "${line[@]}"
+    elif [[ $func = '#pattern-array' ]]; then
+      defcomp " $file" "${line[@]}"
+    elif [[ $func = '#key-function' ]]; then
+      defkeycomp -a "${file:t}" "${line[@]}"
+    elif [[ $func = '#key-array' ]]; then
+      defkeycomp " $file" "${line[@]}"
+    elif [[ $func = '#helper' ]]; then
       autoload ${file:t}
     fi
   done

-- 
Peter Stephenson <pws@ibmth.df.unipi.it>       Tel: +39 050 844536
WWW:  http://www.ifh.de/~pws/
Dipartimento di Fisica, Via Buonarroti 2, 56127 Pisa, Italy

