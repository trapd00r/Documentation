From zsh-workers-return-5875-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Mar 22 13:56:03 1999
Return-Path: <zsh-workers-return-5875-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 3112 invoked from network); 22 Mar 1999 13:55:55 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 22 Mar 1999 13:55:55 -0000
Received: (qmail 12567 invoked by alias); 22 Mar 1999 13:55:24 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5875
Received: (qmail 12560 invoked from network); 22 Mar 1999 13:55:21 -0000
Date: Mon, 22 Mar 1999 14:55:10 +0100 (MET)
Message-Id: <199903221355.OAA08373@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Mon, 22 Mar 1999 16:02:44 +0300
Subject: RE: PATCH: cleanup in zle_tricky.c


Andrej Borsenkow wrote:

> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13%> l /u/i/s/*.hTAB
>   b-e-e-p
> 
> /u/i/s expands to (single) /usr/include/sys - at least, if the last
> component is considered directory:
> 
> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13%> ls -d /usr/include/s*(/)
> /usr/include/sys

I forgot to handle the case when GLOB_COMPLETE is not set...

> Another one that puzzled me:
> 
> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13/Completion%> cp -rp
> {Core,Base,Builtin} ~
> /.zsh.d/Completion
> cp: Cannot access Builtin: No such file or directory
> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13/Completion%> cp -rp
> {Core,Base,Builtin} ~ /.zsh.d/Completion
> 
> I moved cursor before closing bracket (BuiltinCURSOR}) and pressed TAB -
> with the result BEEP (this with GLOB_COMPLETE set). If GLOB_COMPLETE is
> unset, I get (after TAB):
> 
> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13/Completion%> cp -rp Core Base Builtin
> ~/
> .zsh.d/Completion
> 
> Now, the first is correct (I need COMPLETE_IN_WORD for this to work). But
> what is the second?

The effect of expand-or-complete -- but it has always been like that.

> Do I understand it correctly, that now * is always added if GLOB_COMPLETE is
> set (and never added is GLOB_COMPLETE is unset)? Und is globbing ever done
> at all? I mean, normally, Doc/z*i should be globbed before completion even
> starts - now (with GLOB_COMPLETE) this is the same as Doc/z*i*.

That's not a change (at least it should have behaved like this
before). With old style completion and with new style completion and
not setting compstate[pattern_match] to anything not starting with a
`*', glob completion will insert a `*' at the cursor position.
Globbing is only done if expand-or-complete is used and GLOB_COMPLETE
is not set, as always.

And in a different message:

> bor@itsrm2:/tools/src/zsh-3.1.5-pws-13/Completion%> zsh -f
> itsrm2% cp -r {BTAB
> itsrm2% {cp -r {B
> 
> itsrm2% cp -r {BaTAB
> itsrm2% cp -r B{ase/

Yes, I had found this, too, while testing your last mail. Re-insertion 
of braces has always been very hard and I had tested several things,
but then forgot to test the simple cases again, it seems -- forgetting 
to add a special test when the brace is it the beginning.

Thanks!

Bye
 Sven

diff -u os/Zle/zle_tricky.c Src/Zle/zle_tricky.c
--- os/Zle/zle_tricky.c	Mon Mar 22 13:44:47 1999
+++ Src/Zle/zle_tricky.c	Mon Mar 22 14:50:36 1999
@@ -2063,6 +2063,12 @@
 
     ow = w;
 
+    /* If the brace is at the beginning, we have to treat it now. */
+
+    if (!test && !bc && bp) {
+	*bp = 0;
+	bp = NULL;
+    }
     while (ll && lw) {
 	/* First try the matchers. */
 	for (mp = NULL, ms = mstack; !mp && ms; ms = ms->next) {
@@ -2203,7 +2209,7 @@
 		    lw -= alen; iw += alen;
 		    bc -= llen;
 
-		    if (bc <= 0 && bp) {
+		    if (!test && bc <= 0 && bp) {
 			*bp = matchbufadded + bc;
 			bp = NULL;
 		    }
@@ -2295,7 +2301,7 @@
 		    ll -= mp->llen; lw -= mp->wlen;
 		    bc -= mp->llen;
 
-		    if (bc <= 0 && bp) {
+		    if (!test && bc <= 0 && bp) {
 			*bp = matchbufadded + bc;
 			bp = NULL;
 		    }
@@ -2315,7 +2321,7 @@
 	    il++; iw++;
 	    ll--; lw--;
 	    bc--;
-	    if (bc <= 0 && bp) {
+	    if (!test && bc <= 0 && bp) {
 		*bp = matchbufadded + (sfx ? (ow - w) : (w - ow));
 		bp = NULL;
 	    }
@@ -6314,11 +6320,11 @@
 	}
 	if (!pl) {
 	    inststrlen(brbeg, 1, -1);
-	    pl = -1;
+	    pl = -1; hasp = 0;
 	}
 	if (!sl) {
 	    inststrlen(brend, 1, -1);
-	    sl = -1;
+	    sl = -1; hass = 0;
 	}
     }
     /* Walk through the top-level cline list. */
diff -u -r oc/Base/_long_options Completion/Base/_long_options
--- oc/Base/_long_options	Mon Mar 22 13:44:24 1999
+++ Completion/Base/_long_options	Mon Mar 22 14:38:41 1999
@@ -215,7 +215,7 @@
 
   [[ -n "$_comp_correct" ]] && patflags="$patflags(#a$_comp_correct)"
 
-  [[ "$compstate[pattern_match]" != \** ]] && pat="$pat:gs/*//"
+  [[ "${compstate[pattern_match]-*}" != \** ]] && pat="$pat:gs/*//"
 
   # Then we walk through the array names. For each array we test if it 
   # contains the option string. If so, we `invoke' the action stored
diff -u -r oc/Core/_multi_parts Completion/Core/_multi_parts
--- oc/Core/_multi_parts	Mon Mar 22 13:44:26 1999
+++ Completion/Core/_multi_parts	Mon Mar 22 14:37:51 1999
@@ -62,7 +62,7 @@
 
 patstr="${${patstr//$sep/*$sep}//\*##/*}"
 
-[[ "$compstate[pattern_match]" != \** ]] && patstr="$patstr:gs/*//"
+[[ "${compstate[pattern_match]-*}" != \** ]] && patstr="$patstr:gs/*//"
 
 # First we will skip over those parts of the matches for which we have 
 # exact substrings on the line. In `pref' we will build the
diff -u -r oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Mon Mar 22 13:44:26 1999
+++ Completion/Core/_path_files	Mon Mar 22 14:37:26 1999
@@ -204,7 +204,7 @@
 
 patstr="$patstr:gs-/-*/-:gs/*.*./../:gs-/*.-/.-:gs/**/*/:gs-.*/-./-"
 
-[[ "$compstate[pattern_match]" != \** ]] && patstr="$patstr:gs/*//"
+[[ "${compstate[pattern_match]-*}" != \** ]] && patstr="$patstr:gs/*//"
 
 # We take the last pathname component from the pattern and store it in
 # `patlast', replacing `*'s in it with patterns that match any character
diff -u -r oc/Core/_sep_parts Completion/Core/_sep_parts
--- oc/Core/_sep_parts	Mon Mar 22 13:44:26 1999
+++ Completion/Core/_sep_parts	Mon Mar 22 14:38:22 1999
@@ -69,7 +69,7 @@
   _match_pattern _sep_parts test matchflags
   [[ -n "$_comp_correct" ]] && matchflags="$matchflags(#a$_comp_correct)"
 
-  [[ "$compstate[pattern_match]" != \** ]] && test="$test:gs/*//"
+  [[ "${compstate[pattern_match]-*}" != \** ]] && test="$test:gs/*//"
 
   test="${matchflags}${test}"
   testarr=( "${(@M)${(@P)arr}:#${~test}*}" )
@@ -103,7 +103,7 @@
   _match_pattern _sep_parts test matchflags
   [[ -n "$_comp_correct" ]] && matchflags="$matchflags(#a$_comp_correct)"
 
-  [[ "$compstate[pattern_match]" != \** ]] && test="$test:gs/*//"
+  [[ "${compstate[pattern_match]-*}" != \** ]] && test="$test:gs/*//"
 
   test="${matchflags}${test}"
   testarr=( "${(@M)${(@P)arr}:#${~test}*}" )
@@ -136,7 +136,7 @@
   _match_pattern _sep_parts test matchflags
   [[ -n "$_comp_correct" ]] && matchflags="$matchflags(#a$_comp_correct)"
 
-  [[ "$compstate[pattern_match]" != \** ]] && test="$test:gs/*//"
+  [[ "${compstate[pattern_match]-*}" != \** ]] && test="$test:gs/*//"
 
   test="${matchflags}${test}"
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

