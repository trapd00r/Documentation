From zsh-workers-return-10364-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Mar 31 13:01:57 2000
Return-Path: <zsh-workers-return-10364-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 20269 invoked from network); 31 Mar 2000 13:01:55 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 31 Mar 2000 13:01:55 -0000
Received: (qmail 21582 invoked by alias); 31 Mar 2000 13:01:14 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10364
Received: (qmail 21556 invoked from network); 31 Mar 2000 13:01:11 -0000
Date: Fri, 31 Mar 2000 15:00:40 +0200 (MET DST)
Message-Id: <200003311300.PAA01232@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Fri, 31 Mar 2000 12:34:28 +0000
Subject: Re: PATCH: was: Re: endianness of wordcode


Bart Schaefer wrote:

> On Mar 31,  9:06am, Sven Wischnowsky wrote:
> } Subject: Re: PATCH: was: Re: endianness of wordcode
> }
> } Or maybe make `-a' the opposite of `-c'? I.e. `-c' says that currently 
> } defined (not marked for autoloading) functions are to be written and
> } `-a' says functions marked for autoloading are to be written. We could 
> } then say `...to be written without signalling an error', so that `-ca' 
> } allows to mix both
> 
> That would be fine.  (Note, I'm not "everyone" ...)

Since it allows everything that was possible before, just giving more
security...

> } And then we can add a description of the _cvs problem in the manual,
> } so that people know why using this might be a problem.
> 
> That would be good, too.

I hope I made that clear enough in the patch...

Bye
 Sven

diff -ru ../z.old/Doc/Zsh/builtins.yo Doc/Zsh/builtins.yo
--- ../z.old/Doc/Zsh/builtins.yo	Fri Mar 31 14:34:18 2000
+++ Doc/Zsh/builtins.yo	Fri Mar 31 14:57:17 2000
@@ -1304,7 +1304,7 @@
 cindex(.zwc files, creation)
 cindex(compilation)
 xitem(tt(zcompile) [ tt(-U) ] [ tt(-z) | tt(-k) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
-xitem(tt(zcompile) tt(-c) [ tt(-ma) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
+xitem(tt(zcompile) tt(-ca) [ tt(-m) ] [ tt(-R) | tt(-M) ] var(file) [ var(name) ... ])
 item(tt(zcompile -t) var(file) [ var(name) ... ])(
 This builtin command can be used to compile functions or scripts and
 store the compiled form in a file, and to examine files containing
@@ -1312,7 +1312,7 @@
 execution of scripts by avoiding parsing of the text when the files
 are read.
 
-The first form (without the tt(-c) or tt(-t) options) creates a
+The first form (without the tt(-c), tt(-a) or tt(-t) options) creates a
 compiled file.  If only the var(file) argument is provided, the
 output file has the name `var(file)tt(.zwc)' and will be placed in
 the same directory as the var(file).  This will make the compiled
@@ -1334,18 +1334,33 @@
 and are intended to be used as elements of the tt(FPATH)/tt(fpath)
 special array.
 
-The second form, with the tt(-c) option, writes the definitions for
-all the named functions into var(file).  The names must be functions
-currently defined in the shell.  Functions that are only marked for
-autoloading can not be written unless the tt(-a) option is given, too.
-In that case the contents of the definition files for those functions
-will be written to the var(file).  If the tt(-m) option is given, too,
+The second form, with the tt(-c) or tt(-a) option, writes the
+definitions for all the named functions into var(file).  For tt(-c),
+the names must be functions currently defined in the shell, not only
+marked for autoloading.  Functions that are only marked for
+autoloading can be written by using the tt(-a) option. If both tt(-c)
+and tt(-a) are given, a mixture of defined functions and functions
+marked for autoloading may be given. In the case of functions marked
+for autoloading, the contents of the definition files for those
+functions will be written to the var(file).  In any case, the
+functions in files written with the tt(-c) or tt(-a) option will be
+autoloaded as if the tt(KSH_AUTOLOAD) option were unset.
+
+The reason for making loaded and not-yet loaded functions be handled
+by different options is that some definition files for autoloaded
+define multiple functions including the function currently loaded
+itself and, at the end, call this function. In such cases the
+resulting zwc file will be different in the two cases (function is
+already loaded or not). In particular, if it is already loaded, the
+other functions defined in the file are not automatically written into 
+the zwc file and, of course, any other initialization code in the file 
+will be lost.
+
+If the tt(-m) option is combined with tt(-c) or tt(-a),
 the var(name)s are used as patterns and all functions whose names
 match one of these patterns will be written. If no var(name) is given,
 the definitions of all functions currently defined or marked as
-autoloaded will be written.  In any case, the functions in files
-written with the tt(-c) option will be autoloaded as if the
-tt(KSH_AUTOLOAD) option were unset.
+autoloaded will be written.
 
 The third form, with the tt(-t) option, examines an existing
 compiled file.  Without further arguments, the names of the original
diff -ru ../z.old/Src/parse.c Src/parse.c
--- ../z.old/Src/parse.c	Fri Mar 31 14:34:07 2000
+++ Src/parse.c	Fri Mar 31 14:58:22 2000
@@ -2285,11 +2285,11 @@
 
     if ((ops['k'] && ops['z']) || (ops['R'] && ops['M']) ||
 	(ops['c'] && (ops['U'] || ops['k'] || ops['z'])) ||
-	(!ops['c'] && (ops['m'] || ops['a']))) {
+	(!(ops['c'] || ops['a']) && ops['m'])) {
 	zwarnnam(nam, "illegal combination of options", NULL, 0);
 	return 1;
     }
-    if (ops['c'] && isset(KSHAUTOLOAD))
+    if ((ops['c'] || ops['a']) && isset(KSHAUTOLOAD))
 	zwarnnam(nam, "functions will use zsh style autoloading", NULL, 0);
 
     flags = (ops['k'] ? FDHF_KSHLOAD :
@@ -2328,13 +2328,14 @@
     }
     map = (ops['M'] ? 2 : (ops['R'] ? 0 : 1));
 
-    if (!args[1] && !ops['c'])
+    if (!args[1] && !(ops['c'] || ops['a']))
 	return build_dump(nam, dyncat(*args, FD_EXT), args, ops['U'], map, flags);
 
     dump = (strsfx(FD_EXT, *args) ? *args : dyncat(*args, FD_EXT));
 
-    return (ops['c'] ?
-	    build_cur_dump(nam, dump, args + 1, ops['m'], map, ops['a']) :
+    return ((ops['c'] || ops['a']) ?
+	    build_cur_dump(nam, dump, args + 1, ops['m'], map,
+			   (ops['c'] ? 1 : 0) | (ops['a'] ? 2 : 0)) :
 	    build_dump(nam, dump, args + 1, ops['U'], map, flags));
 }
 
@@ -2556,8 +2557,8 @@
 }
 
 static int
-cur_add_func(Shfunc shf, LinkList names, LinkList progs,
-	     int *hlen, int *tlen, int autol)
+cur_add_func(char *nam, Shfunc shf, LinkList names, LinkList progs,
+	     int *hlen, int *tlen, int what)
 {
     Eprog prog;
     WCFunc wcf;
@@ -2565,21 +2566,26 @@
     if (shf->flags & PM_UNDEFINED) {
 	int ona = noaliases;
 
-	if (!autol)
-	    return 2;
-
+	if (!(what & 2)) {
+	    zwarnnam(nam, "function is not loaded: %s", shf->nam, 0);
+	    return 1;
+	}
 	noaliases = (shf->flags & PM_UNALIASED);
 	if (!(prog = getfpfunc(shf->nam, NULL)) || prog == &dummy_eprog) {
 	    noaliases = ona;
-
+	    zwarnnam(nam, "can't load function: %s", shf->nam, 0);
 	    return 1;
 	}
 	if (prog->dump)
 	    prog = dupeprog(prog, 1);
 	noaliases = ona;
-    } else
+    } else {
+	if (!(what & 1)) {
+	    zwarnnam(nam, "function is already loaded: %s", shf->nam, 0);
+	    return 1;
+	}
 	prog = dupeprog(shf->funcdef, 1);
-
+    }
     wcf = (WCFunc) zhalloc(sizeof(*wcf));
     wcf->name = shf->nam;
     wcf->prog = prog;
@@ -2598,9 +2604,9 @@
 /**/
 static int
 build_cur_dump(char *nam, char *dump, char **names, int match, int map,
-	       int autol)
+	       int what)
 {
-    int dfd, hlen, tlen, err;
+    int dfd, hlen, tlen;
     LinkList progs, lnames;
     Shfunc shf = NULL;
 
@@ -2623,10 +2629,8 @@
 
 	for (i = 0; i < shfunctab->hsize; i++)
 	    for (hn = shfunctab->nodes[i]; hn; hn = hn->next)
-		if ((err = cur_add_func((Shfunc) hn, lnames, progs,
-					&hlen, &tlen, autol))) {
-		    zwarnnam(nam, (err == 1 ? "can't load function: %s" :
-				   "function is not loaded: %s"), shf->nam, 0);
+		if (cur_add_func(nam, (Shfunc) hn, lnames, progs,
+				 &hlen, &tlen, what)) {
 		    errflag = 0;
 		    close(dfd);
 		    unlink(dump);
@@ -2650,10 +2654,8 @@
 		for (hn = shfunctab->nodes[i]; hn; hn = hn->next)
 		    if (!listcontains(lnames, hn->nam) &&
 			pattry(pprog, hn->nam) &&
-			(err = cur_add_func((Shfunc) hn, lnames, progs,
-					    &hlen, &tlen, autol))) {
-			zwarnnam(nam, (err == 1 ? "can't load function: %s" :
-				       "function is not loaded: %s"), shf->nam, 0);
+			cur_add_func(nam, (Shfunc) hn, lnames, progs,
+				     &hlen, &tlen, what)) {
 			errflag = 0;
 			close(dfd);
 			unlink(dump);
@@ -2670,9 +2672,7 @@
 		unlink(dump);
 		return 1;
 	    }
-	    if ((err = cur_add_func(shf, lnames, progs, &hlen, &tlen, autol))) {
-		zwarnnam(nam, (err == 1 ? "can't load function: %s" :
-			       "function is not loaded: %s"), shf->nam, 0);
+	    if (cur_add_func(nam, shf, lnames, progs, &hlen, &tlen, what)) {
 		errflag = 0;
 		close(dfd);
 		unlink(dump);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

