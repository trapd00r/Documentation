From zsh-workers-request@euclid.skiles.gatech.edu Mon May 12 04:25:54 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 12695 invoked from network); 12 May 1997 04:25:46 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 12 May 1997 04:25:46 -0000
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id AAA03290; Mon, 12 May 1997 00:09:53 -0400 (EDT)
Resent-Date: Mon, 12 May 1997 00:09:53 -0400 (EDT)
Message-ID: <19970512141320.59565@primenet.com.au>
Date: Mon, 12 May 1997 14:13:20 +1000
From: Geoff Wing <mason@primenet.com.au>
To: Zsh Hackers <zsh-workers@math.gatech.edu>
Subject: zle_refresh.c patch (cut/paste enhancement)
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
X-Mailer: Mutt 0.69e
Resent-Message-ID: <"ic-xo1.0.Lp.GWfTp"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3129
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

This is to fix up some more cut/paste stuff.  It's a patch on
zsh-3.0.3-test5  but should work on 3.1.*
Lines that extend fully to the right margin should now be properly displayed
for cut/paste depending on whether they extend onto the next line or not.

Technical:
previously:
	each line is `line width' + '\0'
now:
	appended  '\n' if continues on next line else '\0'

*** Src/zle_refresh.c.org	Mon May 12 12:52:38 1997
--- Src/zle_refresh.c	Mon May 12 13:54:14 1997
***************
*** 81,96 ****
      if (lwinw != winw || lwinh != winh) {
  	if (nbuf) {
  	    for (ln = 0; ln != lwinh; ln++) {
! 		zfree(nbuf[ln], lwinw + 1);
! 		zfree(obuf[ln], lwinw + 1);
  	    }
  	    free(nbuf);
  	    free(obuf);
  	}
  	nbuf = (char **)zcalloc((winh + 1) * sizeof(char *));
  	obuf = (char **)zcalloc((winh + 1) * sizeof(char *));
! 	nbuf[0] = (char *)zalloc(winw + 1);
! 	obuf[0] = (char *)zalloc(winw + 1);
  
  	lwinw = winw;
  	lwinh = winh;
--- 81,96 ----
      if (lwinw != winw || lwinh != winh) {
  	if (nbuf) {
  	    for (ln = 0; ln != lwinh; ln++) {
! 		zfree(nbuf[ln], lwinw + 2);
! 		zfree(obuf[ln], lwinw + 2);
  	    }
  	    free(nbuf);
  	    free(obuf);
  	}
  	nbuf = (char **)zcalloc((winh + 1) * sizeof(char *));
  	obuf = (char **)zcalloc((winh + 1) * sizeof(char *));
! 	nbuf[0] = (char *)zalloc(winw + 2);
! 	obuf[0] = (char *)zalloc(winw + 2);
  
  	lwinw = winw;
  	lwinh = winh;
***************
*** 139,145 ****
  
  #define nextline					\
  {							\
-     *s = '\0';						\
      if (ln != winh - 1)					\
  	ln++;						\
      else {						\
--- 139,144 ----
***************
*** 157,170 ****
  	    nvln--;					\
      }							\
      if (!nbuf[ln])					\
! 	nbuf[ln] = (char *)zalloc(winw + 1);		\
      s = (unsigned char *)nbuf[ln];			\
      sen = s + winw;					\
  }
  
  #define snextline					\
  {							\
-     *s = '\0';						\
      if (ln != winh - 1)					\
  	ln++;						\
      else						\
--- 156,168 ----
  	    nvln--;					\
      }							\
      if (!nbuf[ln])					\
! 	nbuf[ln] = (char *)zalloc(winw + 2);		\
      s = (unsigned char *)nbuf[ln];			\
      sen = s + winw;					\
  }
  
  #define snextline					\
  {							\
      if (ln != winh - 1)					\
  	ln++;						\
      else						\
***************
*** 180,186 ****
  	    scrollwindow(tosln);			\
  	}						\
      if (!nbuf[ln])					\
! 	nbuf[ln] = (char *)zalloc(winw + 1);		\
      s = (unsigned char *)nbuf[ln];			\
      sen = s + winw;					\
  }
--- 178,184 ----
  	    scrollwindow(tosln);			\
  	}						\
      if (!nbuf[ln])					\
! 	nbuf[ln] = (char *)zalloc(winw + 2);		\
      s = (unsigned char *)nbuf[ln];			\
      sen = s + winw;					\
  }
***************
*** 300,306 ****
  
      /* Deemed necessary by PWS 1995/05/15 due to kill-line problems */
      if (!*nbuf)
! 	*nbuf = (char *)zalloc(winw + 1);
  
      s = (unsigned char *)(nbuf[ln = 0] + pptw);
      t = line;
--- 298,304 ----
  
      /* Deemed necessary by PWS 1995/05/15 due to kill-line problems */
      if (!*nbuf)
! 	*nbuf = (char *)zalloc(winw + 2);
  
      s = (unsigned char *)(nbuf[ln = 0] + pptw);
      t = line;
***************
*** 309,340 ****
  	if (t == scs)			/* if cursor is here, remember it */
  	    nvcs = s - (unsigned char *)(nbuf[nvln = ln]);
  
! 	if (*t == '\n')			/* newline */
  	    nextline
! 	else if (*t == '\t') {		/* tab */
  	    t0 = (char *)s - nbuf[ln];
! 	    if ((t0 | 7) + 1 >= winw)
  		nextline
! 	    else
  		do
  		    *s++ = ' ';
  		while ((++t0) & 7);
  	} else if (icntrl(*t)) {	/* other control character */
  	    *s++ = '^';
! 	    if (s == sen)
  		nextline
  	    *s++ = (*t == 127) ? '?' : (*t | '@');
  	} else				/* normal character */
  	    *s++ = *t;
! 	if (s == sen)
  	    nextline
      }
  
  /* if we're really on the next line, don't fake it; do everything properly */
      if (t == scs && (nvcs = s - (unsigned char *)(nbuf[nvln = ln])) == winw) {
! 	*s = '\0';
  	switch (*s) { 		/* a sad hack to make the break */
! 	case '\0':		/* in nextline work */
  	    nextline
  	}
  	*s = '\0';
--- 307,349 ----
  	if (t == scs)			/* if cursor is here, remember it */
  	    nvcs = s - (unsigned char *)(nbuf[nvln = ln]);
  
! 	if (*t == '\n')	{		/* newline */
! 	    *s++ = '\0';
! 	    *s = '\0';			/* text not wrapped */
  	    nextline
! 	} else if (*t == '\t') {		/* tab */
  	    t0 = (char *)s - nbuf[ln];
! 	    if ((t0 | 7) + 1 >= winw) {
! 		*s++ = '\0';
! 		*s = '\n';		/* text wrapped */
  		nextline
! 	    } else
  		do
  		    *s++ = ' ';
  		while ((++t0) & 7);
  	} else if (icntrl(*t)) {	/* other control character */
  	    *s++ = '^';
! 	    if (s == sen) {
! 		*s++ = '\0';
! 		*s = '\n';		/* text wrapped */
  		nextline
+ 	    }
  	    *s++ = (*t == 127) ? '?' : (*t | '@');
  	} else				/* normal character */
  	    *s++ = *t;
! 	if (s == sen) {
! 	    *s++ = '\0';
! 	    *s = '\n';			/* text wrapped */
  	    nextline
+ 	}
      }
  
  /* if we're really on the next line, don't fake it; do everything properly */
      if (t == scs && (nvcs = s - (unsigned char *)(nbuf[nvln = ln])) == winw) {
! 	*s++ = '\0';
! 	*s = '\n';
  	switch (*s) { 		/* a sad hack to make the break */
! 	case '\n':		/* in nextline work */
  	    nextline
  	}
  	*s = '\0';
***************
*** 359,371 ****
  	for (; t < (unsigned char *)statusline + statusll; t++) {
  	    if (icntrl(*t)) {	/* simplified processing in the status line */
  		*s++ = '^';
! 		if (s == sen)
  		    snextline
  		*s++ = (*t == 127) ? '?' : (*t | '@');
  	    } else
  		*s++ = *t;
! 	    if (s == sen)
  		snextline
  	}
      }
  
--- 368,386 ----
  	for (; t < (unsigned char *)statusline + statusll; t++) {
  	    if (icntrl(*t)) {	/* simplified processing in the status line */
  		*s++ = '^';
! 		if (s == sen) {
! 		    *s++ = '\0';
! 		    *s = '\n';
  		    snextline
+ 		}
  		*s++ = (*t == 127) ? '?' : (*t | '@');
  	    } else
  		*s++ = *t;
! 	    if (s == sen) {
! 		*s++ = '\0';
! 		*s = '\n';
  		snextline
+ 	    }
  	}
      }
  
***************
*** 374,392 ****
  	if (!statusline)
  	    tosln = winh;
  	strncpy(nbuf[tosln - 1] + winw - 7, " <.... ", 7);
! 	nbuf[tosln - 1][winw] = '\0';
      }
  
  /* insert <....> at end of first status line if status is too big */
      if (more_status) {
  	strncpy(nbuf[tosln] + winw - 8, " <....> ", 8);
! 	nbuf[tosln][winw] = '\0';
      }
  
      *s = '\0';
      nlnct = ln + 1;
      for (ln = nlnct; ln < winh; ln++)
! 	zfree(nbuf[ln], winw + 1), nbuf[ln] = NULL;
  
  /* determine whether the right-prompt exists and can fit on the screen */
      if (!more_start)
--- 389,407 ----
  	if (!statusline)
  	    tosln = winh;
  	strncpy(nbuf[tosln - 1] + winw - 7, " <.... ", 7);
! 	nbuf[tosln - 1][winw] = nbuf[tosln - 1][winw + 1] = '\0';
      }
  
  /* insert <....> at end of first status line if status is too big */
      if (more_status) {
  	strncpy(nbuf[tosln] + winw - 8, " <....> ", 8);
! 	nbuf[tosln][winw] = nbuf[tosln][winw + 1] = '\0';
      }
  
      *s = '\0';
      nlnct = ln + 1;
      for (ln = nlnct; ln < winh; ln++)
! 	zfree(nbuf[ln], winw + 2), nbuf[ln] = NULL;
  
  /* determine whether the right-prompt exists and can fit on the screen */
      if (!more_start)
***************
*** 398,404 ****
  	t0 = t0 > 5 ? 5 : t0;
  	strncpy(nbuf[0] + pptw, ">....", t0);
  	memset(nbuf[0] + pptw + t0, ' ', winw - t0 - pptw);
! 	nbuf[0][winw] = '\0';
      }
  
      for (ln = 0; !clearf && (ln < nlnct); ln++) {
--- 413,419 ----
  	t0 = t0 > 5 ? 5 : t0;
  	strncpy(nbuf[0] + pptw, ">....", t0);
  	memset(nbuf[0] + pptw + t0, ' ', winw - t0 - pptw);
! 	nbuf[0][winw] = nbuf[0][winw + 1] = '\0';
      }
  
      for (ln = 0; !clearf && (ln < nlnct); ln++) {
***************
*** 416,422 ****
  		nbuf[ln] && !strncmp(nbuf[ln], obuf[ln + 1], 16)) {
  		moveto(ln, 0);
  		tcout(TCDELLINE);
! 		zfree(obuf[ln], winw + 1);
  		for (t0 = ln; t0 != olnct; t0++)
  		    obuf[t0] = obuf[t0 + 1];
  		obuf[--olnct] = NULL;
--- 431,437 ----
  		nbuf[ln] && !strncmp(nbuf[ln], obuf[ln + 1], 16)) {
  		moveto(ln, 0);
  		tcout(TCDELLINE);
! 		zfree(obuf[ln], winw + 2);
  		for (t0 = ln; t0 != olnct; t0++)
  		    obuf[t0] = obuf[t0 + 1];
  		obuf[--olnct] = NULL;
***************
*** 535,540 ****
--- 550,556 ----
  	char_ins = 0,		/* number of characters inserted/deleted */
  	col_cleareol,		/* clear to end-of-line from this column */
  	i, j,			/* tmp					 */
+ 	ins_last,		/* insert pushed last character off line */
  	nllen, ollen,		/* new and old line buffer lengths	 */
  	rnllen;			/* real new line buffer length		 */
  
***************
*** 559,571 ****
      if (cleareol 		/* request to clear to end of line */
  	|| !nllen 		/* no line buffer given */
  	|| (ln == 0 && (put_rpmpt != oput_rpmpt))) {	/* prompt changed */
! 	p1 = halloc(winw + 1);
  	if (nllen)
  	    strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', winw - nllen);
! 	p1[winw] = '\0';
  	if (ln && nbuf[ln])
! 	    strncpy(nl, p1, winw + 1);	/* next time obuf will be up-to-date */
  	else
  	    nl = p1;		/* don't keep the padding for prompt line */
  	nllen = winw;
--- 575,587 ----
      if (cleareol 		/* request to clear to end of line */
  	|| !nllen 		/* no line buffer given */
  	|| (ln == 0 && (put_rpmpt != oput_rpmpt))) {	/* prompt changed */
! 	p1 = halloc(winw + 2);
  	if (nllen)
  	    strncpy(p1, nl, nllen);
  	memset(p1 + nllen, ' ', winw - nllen);
! 	p1[winw] = p1[winw + 1] = '\0';
  	if (ln && nbuf[ln])
! 	    strncpy(nl, p1, winw + 2);	/* next time obuf will be up-to-date */
  	else
  	    nl = p1;		/* don't keep the padding for prompt line */
  	nllen = winw;
***************
*** 599,616 ****
  /* 2b: first a new trick for automargin niceness - good for cut and paste */
  
      if (hasam && vcs == winw) {
! 	vln++, vcs = 1;
!         if (nbuf[vln]  && *nbuf[vln])
! 	    zputc(*nbuf[vln], shout);
! 	else
! 	    zputc(' ', shout);  /* I don't think this should happen */
! 	if (ln == vln) {	/* better safe than sorry */
! 	    nl++;
! 	    if (*ol)
! 		ol++;
! 	    ccs = 1;
! 	}			/* else  hmmm... I wonder what happened */
      }
  
  /* 2c: if we're on the first line, start checking at the end of the prompt;
     we shouldn't be doing anything within the prompt */
--- 615,638 ----
  /* 2b: first a new trick for automargin niceness - good for cut and paste */
  
      if (hasam && vcs == winw) {
! 	if (nbuf[vln] && nbuf[vln][vcs + 1] == '\n') {
! 	    vln++, vcs = 1;
!             if (nbuf[vln]  && *nbuf[vln])
! 		zputc(*nbuf[vln], shout);
! 	    else
! 		zputc(' ', shout);  /* I don't think this should happen */
! 	    if (ln == vln) {	/* better safe than sorry */
! 		nl++;
! 		if (*ol)
! 		    ol++;
! 		ccs = 1;
! 	    }			/* else  hmmm... I wonder what happened */
! 	} else {
! 	    vln++, vcs = 0;
! 	    zputc('\n', shout);
! 	}
      }
+     ins_last = 0;
  
  /* 2c: if we're on the first line, start checking at the end of the prompt;
     we shouldn't be doing anything within the prompt */
***************
*** 631,642 ****
  	    for (; *nl && (*nl == *ol); nl++, ol++, ccs++) ;
  
  	if (!*nl) {
! 	    if ((char_ins <= 0)	|| (ccs >= winw))    /* written everything */
  		return;
! 	    else		/* we've got junk on the right yet to clear */
! 		if (tccan(TCCLEAREOL) && (char_ins >= tclen[TCCLEAREOL])
! 	    	    && col_cleareol != -2)
! 		    col_cleareol = 0;	/* force a clear to end of line */
  	}
  
  	moveto(ln, ccs);	/* move to where we do all output from */
--- 653,671 ----
  	    for (; *nl && (*nl == *ol); nl++, ol++, ccs++) ;
  
  	if (!*nl) {
! 	    if ((char_ins <= 0) || (ccs > winw))    /* written everything */
  		return;
! 	    if (ccs == winw && hasam && ins_last && vcs != winw) {
! 		nl--;		/* we can assume we can go back here */
! 		moveto(ln, winw - 1);
! 		zputc(*nl, shout);
! 		vcs++;
! 		return;		/* write last character in line */
! 	    }
! 	    if (tccan(TCCLEAREOL) && (char_ins >= tclen[TCCLEAREOL])
! 	    	&& col_cleareol != -2)
! 	    /* we've got junk on the right yet to clear */
! 		col_cleareol = 0;	/* force a clear to end of line */
  	}
  
  	moveto(ln, ccs);	/* move to where we do all output from */
***************
*** 706,713 ****
  			ccs = (vcs += i);
  		    /* if we've pushed off the right, truncate oldline */
  			for (i = 0; *(ol + i) && i < winw - ccs; i++);
! 			if (i == winw - ccs)
  			    *(ol + i) = '\0';
  			i = 0;
  			break;
  		    }
--- 735,744 ----
  			ccs = (vcs += i);
  		    /* if we've pushed off the right, truncate oldline */
  			for (i = 0; *(ol + i) && i < winw - ccs; i++);
! 			if (i == winw - ccs) {
  			    *(ol + i) = '\0';
+ 			    ins_last = 1;
+ 			}
  			i = 0;
  			break;
  		    }

-- 
Geoff Wing [mason@primenet.com.au]   Technical Manager
  Phone    : +61-3-9818 2977         PrimeNet - Internet Consultancy
  Facsimile: +61-3-9819 3788         Web : <URL:http://www.primenet.com.au/>
  Mobile   : 0412 162 441

