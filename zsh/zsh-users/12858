From zsh-users-return-12858-mason-zsh=primenet.com.au@sunsite.dk Sun May 18 20:26:01 2008
Return-Path: <zsh-users-return-12858-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8366 invoked from network); 18 May 2008 20:25:58 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.4 (2008-01-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 18 May 2008 20:25:58 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 57859 invoked from network); 18 May 2008 20:25:46 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 18 May 2008 20:25:46 -0000
Received: (qmail 2589 invoked by alias); 18 May 2008 20:25:36 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 12858
Received: (qmail 2573 invoked from network); 18 May 2008 20:25:35 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 18 May 2008 20:25:35 -0000
Received: from mtaout03-winn.ispmail.ntl.com (mtaout03-winn.ispmail.ntl.com [81.103.221.49])
	by bifrost.dotsrc.org (Postfix) with ESMTP id 47C4A80589A4
	for <zsh-users@sunsite.dk>; Sun, 18 May 2008 22:25:31 +0200 (CEST)
Received: from aamtaout04-winn.ispmail.ntl.com ([81.103.221.35])
          by mtaout03-winn.ispmail.ntl.com with ESMTP
          id <20080518203020.LBKI22559.mtaout03-winn.ispmail.ntl.com@aamtaout04-winn.ispmail.ntl.com>
          for <zsh-users@sunsite.dk>; Sun, 18 May 2008 21:30:20 +0100
Received: from pws-pc ([81.107.40.67]) by aamtaout04-winn.ispmail.ntl.com
          with ESMTP
          id <20080518202537.MGQZ29112.aamtaout04-winn.ispmail.ntl.com@pws-pc>
          for <zsh-users@sunsite.dk>; Sun, 18 May 2008 21:25:37 +0100
Date: Sun, 18 May 2008 21:24:22 +0100
From: Peter Stephenson <p.w.stephenson@ntlworld.com>
To: "Zsh Users" <zsh-users@sunsite.dk>
Subject: Re: Question on filename completion
Message-ID: <20080518212422.6f14cf75@pws-pc>
In-Reply-To: <080518120311.ZM4212@torch.brasslantern.com>
References: <d53cb3110805181023p1e823d8drb196db9e52f79b33@mail.gmail.com>
	<080518120311.ZM4212@torch.brasslantern.com>
X-Mailer: Claws Mail 3.3.1 (GTK+ 2.12.9; x86_64-redhat-linux-gnu)
Mime-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
X-Virus-Scanned: ClamAV 0.91.2/7151/Sun May 18 20:36:29 2008 on bifrost
X-Virus-Status: Clean

On Sun, 18 May 2008 12:03:11 -0700
Bart Schaefer <schaefer@brasslantern.com> wrote:
> On May 18, 10:53pm, Gowtham M wrote:
> }
> } When I hit tab at
> } zsh> ls /some/path/to/something/761/xyz/_  # Tab is hit when cursor is at _
> } 
> } zsh spends a lot of time in stat64()ing all the directories from
> } /some/path/to/something/0 to /some/path/to/something/9999
> } 
> } I do not understand why this is required to complete the filename
> } after /some/path/to/something/761/xyz
> 
> This is _path_files at work.  Try typing
> 
>     zsh> ls /s/p/t/s<TAB>
> 
> and you'll find that it gets competed to
> 
>     zsh> ls /some/path/to/something/
> 
> On any given completion attempt, _path_files doesn't know whether any
> path component might be only part of a directory name which, if it were
> completed, would lead to additional matches among the sub-directories,
> etc.  So it re-scans the whole hierarchy.

Right.  However, I've always been uncomfortable that this is
unconditional.  99.9% of the time I find that if the directory path as
I've given it exists already, it's the path I want, and looking for more
is just slowing things down, sometimes unbearably (as for remote paths
in Cygwin).

Here's the accept-exact-dirs style to remedy that.  There could very
well be glitches with the style set, but it appears to be usable
already, and I will try it out myself since I've been vaguely wanting it
for a long time.  As you can see from the patch it's highly unlikely to
cause problems if not set.

Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.209
diff -u -r1.209 compsys.yo
--- Doc/Zsh/compsys.yo	16 May 2008 11:49:21 -0000	1.209
+++ Doc/Zsh/compsys.yo	18 May 2008 20:13:50 -0000
@@ -1098,6 +1098,20 @@
 `continue', _expand will add the expansion as a match and the completion
 system will also be allowed to continue.
 )
+kindex(accept-exact-dirs, completion style)
+item(tt(accept-exact-dirs))(
+This is used by filename completion.  Unlike tt(accept-exact) it is
+a boolean.  By default, filename completion examines all components
+of a path to see if there are completions of that component, even if
+the component matches an existing directory.  For example, when
+completion after tt(/usr/bin/), the function examines possible
+completions to tt(/usr).
+
+When this style is true, any prefix of a path that matches an existing
+directory is accepted without any attempt to complete it further.
+Hence, in the given example, the path tt(/usr/bin/) is accepted
+immediately and completion tried in that directory.
+)
 kindex(add-space, completion style)
 item(tt(add-space))(
 This style is used by the tt(_expand) completer.  If it is true (the
Index: Completion/Unix/Type/_path_files
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Unix/Type/_path_files,v
retrieving revision 1.27
diff -u -r1.27 _path_files
--- Completion/Unix/Type/_path_files	23 Feb 2008 00:10:24 -0000	1.27
+++ Completion/Unix/Type/_path_files	18 May 2008 20:13:51 -0000
@@ -318,6 +318,29 @@
 
   skipped=
   cpre=
+
+  if zstyle -t ":completion:${curcontext}:paths" accept-exact-dirs &&
+    [[ $pre = (#b)(*)/([^/]#) ]]; then
+    # We've been told that we can accept an exact directory
+    # prefix immediately.  Try this with the longest path prefix
+    # first:  this saves stats in the simple case and may get around
+    # automount behaviour if early components don't yet exist.
+    tmp1=$match[1]
+    tpre=$match[2]
+    while true; do
+      if [[ -d $donepath$tmp1 ]]; then
+	donepath=$donepath$tmp1/
+	pre=$tpre
+	break
+      elif [[ $tmp1 = (#b)(*)/([^/]#) ]]; then
+	tmp1=$match[1]
+	tpre=$match[2]/$tpre
+      else
+	break
+      fi
+    done
+  fi
+
   tpre="$pre"
   tsuf="$suf"
   testpath="$donepath"


-- 
Peter Stephenson <p.w.stephenson@ntlworld.com>
Web page now at http://homepage.ntlworld.com/p.w.stephenson/

