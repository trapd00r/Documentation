From zsh-workers-return-11519-mason-zsh=primenet.com.au@sunsite.auc.dk Tue May 23 00:20:07 2000
Return-Path: <zsh-workers-return-11519-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 8521 invoked from network); 23 May 2000 00:20:05 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 May 2000 00:20:05 -0000
Received: (qmail 19694 invoked by alias); 23 May 2000 00:19:56 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 11519
Received: (qmail 19686 invoked from network); 23 May 2000 00:19:54 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <000522171947.ZM236@candle.brasslantern.com>
Date: Mon, 22 May 2000 17:19:47 -0700
In-Reply-To: <0FUZ00C1W0R3BH@la-la.cambridgesiliconradio.com>
Comments: In reply to Peter Stephenson <pws@cambridgesiliconradio.com>
        "Re: Proxy support for zftp functions" (May 22,  6:04pm)
References: <0FUZ00C1W0R3BH@la-la.cambridgesiliconradio.com>
X-Mailer: Z-Mail Lite (5.0.0 30July97)
To: zsh-workers@sunsite.auc.dk (Zsh hackers list)
Subject: Re: Proxy support for zftp functions
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On May 22,  6:04pm, Peter Stephenson wrote:
> Subject: Re: Proxy support for zftp functions
> 
> [...] a date
> and time parsing and conversion module might be a nice extension --- or, of
> course, a piece of shell code that does it neatly, if that's possible.

Here's at least a start at it.  The formats recognized are those typically
found in email Date: headers or as output of `date`; e.g. it makes no
attempt to figure out whether 3/5/7 is March 5, 1907 or May 3, 2007 etc.,
so it simply ignores dates that don't spell out the name of the month.
It also doesn't parse year-month-day (the day is assumed to be the first
number outside an HH:MM[:SS] form) but maybe there's a clever way to fit
that in unambiguously.

This expects to find one or both of the associative arrays $date and $time,
which it fills in the obvious way.  If you don't pre-declare either of them,
you can only check the return value to see whether the parse succeeded.

---- 8< ---- snip ----8< ----
[[ -z "$*" || $ZSH_VERSION < 3.1.6 ]] && return 1

setopt localoptions extendedglob noshwordsplit noksharrays

local HHMMSS='(<->):(<->):#(<->)#'
local DDmmYY='(<->)[-[:space:]]([[:alpha:]]##)[-[:space:]](<->)'
local DDmm='(<->)[[:space:]]([[:alpha:]]##)'
local ZONE='[[:space:]]#([^:[:space:]]##)'

[[ ${(t)date} == association ]] || typeset -A date ; date=()
[[ ${(t)time} == association ]] || typeset -A time ; time=()

set $=*		# Canonicalize whitespace

if [[ "$*" == (#i)(#b)${~DDmmYY}[[:space:]]${~HHMMSS}[[:space:]]#([ap]m)#${~ZONE} ]]
then
    date=(day "$match[1]" month "$match[2]" year "$match[3]")
    time=(hour "$match[4]" minute "$match[5]" second "$match[6]"
	  ampm "$match[7]" zone "$match[8]")
elif [[ "$*" == (#i)(#b)${~DDmm}[[:space:]]${~HHMMSS}[[:space:]]#([ap]m)# ]]
then
    date=(day "$match[1]" month "$match[2]" year "")
    time=(hour "$match[3]" minute "$match[4]" second "$match[5]"
	  ampm "$match[6]" zone "")
elif [[ "$*" == (#i)(#b)${~HHMMSS}[[:space:]]([ap]m)#${~ZONE}[[:space:]]${~DDmmYY} ]]
then
    time=(hour "$match[1]" minute "$match[2]" second "$match[3]"
	  ampm "$match[4]" zone "$match[5]")
    date=(day "$match[6]" month "$match[7]" year "$match[8]")
elif [[ "$*" == (#i)(#b)${~HHMMSS}[[:space:]]([ap]m)#${~ZONE}[[:space:]]${~DDmm}[[:space:]](<->) ]]
then
    time=(hour "$match[1]" minute "$match[2]" second "$match[3]"
	  ampm "$match[4]" zone "$match[5]")
    date=(day "$match[6]" month "$match[7]" year "$match[8]")
elif [[ "$*" == (#i)(#b)([[:alpha:]]##),[[:space:]]#${~DDmmYY}[[:space:]]${~HHMMSS}[[:space:]]#([ap]m)#${~ZONE} ]]
then
    # Day of the week (Mon, Tue, ...) is $match[1]
    date=(day "$match[2]" month "$match[3]" year "$match[4]")
    time=(hour "$match[5]" minute "$match[6]" second "$match[7]"
	  ampm "$match[8]" zone "$match[9]")
elif [[ "$*" == (#i)(#b)([[:alpha:]]##),[[:space:]]#${~DDmm}[[:space:]](<->)[[:space:]]${~HHMMSS}[[:space:]]#([ap]m)#${~ZONE} ]]
then
    # Day of the week (Mon, Tue, ...) is $match[1]
    date=(day "$match[2]" month "$match[3]" year "$match[4]")
    time=(hour "$match[5]" minute "$match[6]" second "$match[7]"
	  ampm "$match[8]" zone "$match[9]")
elif [[ "$*" == (#i)(#b)([[:alpha:]]##)[[:space:]]([[:alpha:]]##)[[:space:]](<->)[[:space:]]${~HHMMSS}[[:space:]]#([ap]m)#${~ZONE}[[:space:]](<->) ]]
then
    # Day of the week (Mon, Tue, ...) is $match[1]
    date=(day "$match[3]" month "$match[2]" year "$match[9]")
    time=(hour "$match[4]" minute "$match[5]" second "$match[6]"
	  ampm "$match[7]" zone "$match[8]")
elif [[ "$*" == (#i)(#b)([[:alpha:]]##)[[:space:]](<->)[[:space:]]${~HHMMSS}[[:space:]]([ap]m)# ]]
then
    date=(day "$match[2]" month "$match[1]" year "")
    time=(hour "$match[3]" minute "$match[4]" second "$match[5]"
	  ampm "$match[6]" zone "")
elif [[ "$*" == ${~DDmmYY} || "$*" == ${~DDmm}[[:space:]](<->) ]]
then
    date=(day "$match[1]" month "$match[2]" year "$match[3]")
    time=(hour "" minute "" second "" ampm "" zone "")
elif [[ "$*" == ${~HHMMSS}[[:space:]]#([ap]m)# ]]
then
    date=(day "" month "" year "")
    time=(hour "$match[1]" minute "$match[2]" second "$match[3]"
	  ampm "$match[4]" zone "")
fi

(( $#date || $#time ))
---- 8< ---- snip ----8< ----

