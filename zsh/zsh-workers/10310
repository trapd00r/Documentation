From zsh-workers-return-10310-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Mar 29 08:49:55 2000
Return-Path: <zsh-workers-return-10310-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 11143 invoked from network); 29 Mar 2000 08:49:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 29 Mar 2000 08:49:53 -0000
Received: (qmail 18952 invoked by alias); 29 Mar 2000 08:49:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10310
Received: (qmail 18942 invoked from network); 29 Mar 2000 08:49:42 -0000
Date: Wed, 29 Mar 2000 10:49:41 +0200 (MET DST)
Message-Id: <200003290849.KAA22271@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Tue, 28 Mar 2000 18:27:38 +0000
Subject: PATCH: Re: autoload +X[zk]


Bart Schaefer wrote:

> On Mar 28,  1:52pm, Sven Wischnowsky wrote:
> } Subject: Re: autoload +X[zk]
> }
> } > Note also the handling of the positional parameters. For the first
> } > call (i.e.: when the init code from the file is executed) they are not 
> } > set. Only for the appended function call are they set up. This is the
> } > behaviour the ksh I have here shows.
> } 
> } Damn. That doesn't work, because the printing functions just output
> } `foo "$@"' for the not-really-existing call.
> 
> And the    [[ -o kshautoload ]] || foo "$@"   trick doesn't work if we
> were to really emulate that ksh behavior, either, does it?

But the `foo "$@"' here isn't used when using ksh-style autoloading,
i.e. what's in the positional parameters doesn't matter here.

Anyway...

> } Hm. What are we supposed to do here? Handle positional parameters
> } differently?
> 
> For now, I think the answer is:  Handle positional parameters like zsh
> always has done for kshautoload (as you pointed out in 10298) and fix
> the problem of accurately emulating ksh at a later time.

I had hoped you would say that.

Bye
 Sven

diff -ru ../z.old/Src/exec.c Src/exec.c
--- ../z.old/Src/exec.c	Wed Mar 29 10:36:16 2000
+++ Src/exec.c	Wed Mar 29 10:41:27 2000
@@ -3249,8 +3249,6 @@
 
     pushheap();
 
- rec:
-
     oargv0 = NULL;
     obreaks = breaks;;
     if (trapreturn < 0)
@@ -3275,45 +3273,59 @@
     if (flags & PM_TAGGED)
 	opts[XTRACE] = 1;
     opts[PRINTEXITVALUE] = 0;
-    if (!(prog->flags & EF_RUN)) {
-	if (doshargs) {
-	    LinkNode node;
+    if (doshargs) {
+	LinkNode node;
 
-	    node = doshargs->first;
-	    pparams = x = (char **) zcalloc(((sizeof *x) *
+	node = doshargs->first;
+	pparams = x = (char **) zcalloc(((sizeof *x) *
 					 (1 + countlinknodes(doshargs))));
-	    if (isset(FUNCTIONARGZERO)) {
-		oargv0 = argzero;
-		argzero = ztrdup((char *) node->dat);
-	    }
-	    node = node->next;
-	    for (; node; node = node->next, x++)
-		*x = ztrdup((char *) node->dat);
-	} else {
-	    pparams = (char **) zcalloc(sizeof *pparams);
-	    if (isset(FUNCTIONARGZERO)) {
-		oargv0 = argzero;
-		argzero = ztrdup(argzero);
-	    }
+	if (isset(FUNCTIONARGZERO)) {
+	    oargv0 = argzero;
+	    argzero = ztrdup((char *) node->dat);
+	}
+	node = node->next;
+	for (; node; node = node->next, x++)
+	    *x = ztrdup((char *) node->dat);
+    } else {
+	pparams = (char **) zcalloc(sizeof *pparams);
+	if (isset(FUNCTIONARGZERO)) {
+	    oargv0 = argzero;
+	    argzero = ztrdup(argzero);
 	}
     }
     fstack.name = dupstring(name);
     fstack.prev = funcstack;
     funcstack = &fstack;
-    runshfunc(prog, ((prog->flags & EF_RUN) ? NULL : wrappers), fstack.name);
+
+    if (prog->flags & EF_RUN) {
+	Shfunc shf;
+
+	runshfunc(prog, NULL, fstack.name);
+
+	prog->flags &= ~EF_RUN;
+
+	if (!(shf = (Shfunc) shfunctab->getnode(shfunctab,
+						(name = fname)))) {
+	    zerr("%s: function not defined by file", name, 0);
+	    if (!noreturnval)
+		lastval = 1;
+	    popheap();
+	    return;
+	}
+	prog = shf->funcdef;
+    }
+    runshfunc(prog, wrappers, fstack.name);
     funcstack = fstack.prev;
     if (retflag) {
 	retflag = 0;
 	breaks = obreaks;
     }
-    if (!(prog->flags & EF_RUN)) {
-	freearray(pparams);
-	if (oargv0) {
-	    zsfree(argzero);
-	    argzero = oargv0;
-	}
-	pparams = tab;
+    freearray(pparams);
+    if (oargv0) {
+	zsfree(argzero);
+	argzero = oargv0;
     }
+    pparams = tab;
     optcind = oldoptcind;
     zoptind = oldzoptind;
     scriptname = oldscriptname;
@@ -3336,23 +3348,6 @@
 	trapreturn++;
     if (noreturnval)
 	lastval = oldlastval;
-
-    if (prog->flags & EF_RUN) {
-	Shfunc shf;
-
-	prog->flags &= ~EF_RUN;
-
-	if (!(shf = (Shfunc) shfunctab->getnode(shfunctab,
-						(name = fname)))) {
-	    zerr("%s: function not defined by file", name, 0);
-	    if (!noreturnval)
-		lastval = 1;
-	    popheap();
-	    return;
-	}
-	prog = shf->funcdef;
-	goto rec;
-    }
     popheap();
 }
 

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

