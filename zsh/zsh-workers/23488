From zsh-workers-return-23488-mason-zsh=primenet.com.au@sunsite.dk Tue May 29 16:59:23 2007
Return-Path: <zsh-workers-return-23488-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23633 invoked from network); 29 May 2007 16:59:19 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.0 (2007-05-01) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00 autolearn=no
	version=3.2.0
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 29 May 2007 16:59:19 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 31099 invoked from network); 29 May 2007 16:59:13 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 29 May 2007 16:59:13 -0000
Received: (qmail 12722 invoked by alias); 29 May 2007 16:59:10 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 23488
Received: (qmail 12713 invoked from network); 29 May 2007 16:59:09 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 29 May 2007 16:59:09 -0000
Received: (qmail 30526 invoked from network); 29 May 2007 16:59:09 -0000
Received: from cluster-c.mailcontrol.com (168.143.177.190)
  by a.mx.sunsite.dk with SMTP; 29 May 2007 16:59:04 -0000
Received: from cameurexb01.EUROPE.ROOT.PRI ([62.189.241.200])
	by rly19c.srv.mailcontrol.com (MailControl) with ESMTP id l4TGwKNm010182
	for <zsh-workers@sunsite.dk>; Tue, 29 May 2007 17:58:32 +0100
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.1830);
	 Tue, 29 May 2007 17:58:27 +0100
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.8/8.13.4) with ESMTP id l4TGwRdm001176
	for <zsh-workers@sunsite.dk>; Tue, 29 May 2007 17:58:27 +0100
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.8/8.13.8/Submit) with ESMTP id l4TGwRtf001173
	for <zsh-workers@sunsite.dk>; Tue, 29 May 2007 17:58:27 +0100
Message-Id: <200705291658.l4TGwRtf001173@news01.csr.com>
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: PATCH: a few module tidy-ups
Date: Tue, 29 May 2007 17:58:27 +0100
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 29 May 2007 16:58:27.0176 (UTC) FILETIME=[938A1680:01C7A212]
Content-Type: text/plain
MIME-Version: 1.0
X-Scanned-By: MailControl A-07-07-05 (www.mailcontrol.com) on 10.67.0.129

Nothing very interesting here.

Rationalise some return codes, as threatened.
Rename load_module_silence() to load_module() and remove that.
Remove unused first argument from require_module().
Remove unused function run_hook().
Document more functions in module.c.
Note changes in source tree documentation.

Index: README
===================================================================
RCS file: /cvsroot/zsh/zsh/README,v
retrieving revision 1.46
diff -u -r1.46 README
--- README	21 May 2007 11:32:02 -0000	1.46
+++ README	29 May 2007 16:55:01 -0000
@@ -137,6 +137,11 @@
 have never worked and the most consistent change was to restrict the
 set to portable characters only.
 
+Writers of add-on modules should note that the API has changed
+significantly to allow user control of individual features provided by
+modules.  See the documentation for zmodload -F and
+Etc/zsh-development-guide, in that order.
+
 Documentation
 -------------
 
Index: Etc/zsh-development-guide
===================================================================
RCS file: /cvsroot/zsh/zsh/Etc/zsh-development-guide,v
retrieving revision 1.12
diff -u -r1.12 zsh-development-guide
--- Etc/zsh-development-guide	28 May 2007 22:57:40 -0000	1.12
+++ Etc/zsh-development-guide	29 May 2007 16:55:04 -0000
@@ -229,7 +229,8 @@
 is left for abstract features at the end of the array and the names
 must be added by the module.  Note that heap memory should
 be used for this (zhalloc, etc.) as memory for the features array is not
-freed.
+freed; note also the pointers for the abstract features are not
+initialised so setting them is mandatory any time there are any present.
 
 A structure "struct features" should
 be used to contain all standard features as well as the number of
@@ -242,12 +243,14 @@
 NULL, containing a 1 for every feature that is enabled and a zero for other
 feature.  By default features are disabled.  If *enablesp is not NULL, its
 values should be used to decide whether features are to be turned off.  It
-should return status 0 for success, 1 on a failure to alter a feature.
-The function handlefeatures() conveniently handles all standard features
-present in the module's features structure; abstract features must
-be handled by the module.  As with features_, any handling of the
-array by the module itself should take into account that the array
-will not be freed and any allocation should therefore be from heap memory.
+should return status 0 for success, 1 on a failure to alter a feature.  The
+function handlefeatures() conveniently handles all standard features
+present in the module's features structure; abstract features must be
+handled by the module (as with the features array, the area of the enables
+array for abstract features is not even initialised by the main shell).  As
+with features_, any handling of the array by the module itself should take
+into account that the array will not be freed and any allocation should
+therefore be from heap memory.
 
 The functions features_ and enables_ can be called at any point
 after setup_ has been called and before cleanup_ is called.  In
Index: Src/builtin.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/builtin.c,v
retrieving revision 1.178
diff -u -r1.178 builtin.c
--- Src/builtin.c	28 May 2007 22:57:41 -0000	1.178
+++ Src/builtin.c	29 May 2007 16:55:07 -0000
@@ -163,7 +163,7 @@
     builtintab->freenode    = freebuiltinnode;
     builtintab->printnode   = printbuiltinnode;
 
-    addbuiltins("zsh", builtins, sizeof(builtins)/sizeof(*builtins));
+    (void)addbuiltins("zsh", builtins, sizeof(builtins)/sizeof(*builtins));
 }
 
 /* Print a builtin */
Index: Src/init.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/init.c,v
retrieving revision 1.74
diff -u -r1.74 init.c
--- Src/init.c	28 May 2007 22:57:41 -0000	1.74
+++ Src/init.c	29 May 2007 16:55:08 -0000
@@ -701,7 +701,7 @@
 	    close(tmppipe[1]);
     }
 
-    addhookdefs(argzero, zshhooks, sizeof(zshhooks)/sizeof(*zshhooks));
+    (void)addhookdefs(argzero, zshhooks, sizeof(zshhooks)/sizeof(*zshhooks));
 
     init_eprog();
 
@@ -979,7 +979,7 @@
 		 * Always attempt to load the newuser module to perform
 		 * checks for new zsh users.  Don't care if we can't load it.
 		 */
-		if (!load_module_silence("zsh/newuser", NULL, 1)) {
+		if (!load_module("zsh/newuser", NULL, 1)) {
 		    /* Unload it immediately. */
 		    unload_named_module("zsh/newuser", "zsh", 1);
 		}
@@ -1152,7 +1152,7 @@
 
 #include "bltinmods.list"
 
-    (void)load_module("zsh/main", NULL);
+    (void)load_module("zsh/main", NULL, 0);
 }
 
 /**/
@@ -1213,8 +1213,8 @@
 autoload_zleread(char **lp, char **rp, int ha, int con)
 {
     zlereadptr = fallback_zleread;
-    if (load_module("zsh/zle", NULL) != 1)
-	(void)load_module("zsh/compctl", NULL);
+    if (load_module("zsh/zle", NULL, 0) != 1)
+	(void)load_module("zsh/compctl", NULL, 0);
     return zlereadptr(lp, rp, ha, con);
 }
 
@@ -1240,7 +1240,7 @@
 autoload_zlesetkeymap(int mode)
 {
     zlesetkeymapptr = noop_function_int;
-    (void)load_module("zsh/zle", NULL);
+    (void)load_module("zsh/zle", NULL, 0);
     (*zlesetkeymapptr)(mode);
 }
 
Index: Src/module.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/module.c,v
retrieving revision 1.27
diff -u -r1.27 module.c
--- Src/module.c	29 May 2007 14:16:03 -0000	1.27
+++ Src/module.c	29 May 2007 16:55:10 -0000
@@ -221,11 +221,31 @@
     return 0;
 }
 
+/*
+ * Manipulate a set of builtins.  This should be called
+ * via setfeatureenables() (or, usually, via the next level up,
+ * handlefeatures()).
+ *
+ * "nam" is the name of the calling code builtin, probably "zmodload".
+ *
+ * "binl" is the builtin table containing an array of "size" builtins.
+ *
+ * "e" is either NULL, in which case all builtins in the
+ * table are removed, or else an array corresponding to "binl"
+ * with a 1 for builtins that are to be added and a 0 for builtins
+ * that are to be removed.  Any builtin already in the appropriate
+ * state is left alone.
+ *
+ * Returns 1 on any error, 0 for success.  The recommended way
+ * of handling errors is to compare the enables passed down
+ * with the set retrieved after the error to find what failed.
+ */
+
 /**/
-mod_export int
+static int
 setbuiltins(char const *nam, Builtin binl, int size, int *e)
 {
-    int hads = 0, hadf = 0, n;
+    int ret = 0, n;
 
     for(n = 0; n < size; n++) {
 	Builtin b = &binl[n];
@@ -235,24 +255,22 @@
 	    if (addbuiltin(b)) {
 		zwarnnam(nam,
 			 "name clash when adding builtin `%s'", b->node.nam);
-		hadf = 1;
+		ret = 1;
 	    } else {
 		b->node.flags |= BINF_ADDED;
-		hads = 2;
 	    }
 	} else {
 	    if (!(b->node.flags & BINF_ADDED))
 		continue;
 	    if (deletebuiltin(b->node.nam)) {
 		zwarnnam(nam, "builtin `%s' already deleted", b->node.nam);
-		hadf = 1;
+		ret = 1;
 	    } else {
-		hads = 2;
 		b->node.flags &= ~BINF_ADDED;
 	    }
 	}
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
 /*
@@ -261,8 +279,7 @@
  * added; that flag is set if they succeed.
  *
  * If any fail, an error message is printed, using nam as the leading name.
- * Returns 1 if all additions succeed, 2 if some succeed and some fail, and 0
- * if all (and at least 1) fail.
+ * Returns 0 on success, 1 for any failure.
  *
  * This should not be used from a module; instead, use handlefeatures().
  */
@@ -271,7 +288,7 @@
 mod_export int
 addbuiltins(char const *nam, Builtin binl, int size)
 {
-    int hads = 0, hadf = 0, n;
+    int ret = 0, n;
 
     for(n = 0; n < size; n++) {
 	Builtin b = &binl[n];
@@ -279,13 +296,12 @@
 	    continue;
 	if(addbuiltin(b)) {
 	    zwarnnam(nam, "name clash when adding builtin `%s'", b->node.nam);
-	    hadf = 1;
+	    ret = 1;
 	} else {
 	    b->node.flags |= BINF_ADDED;
-	    hads = 2;
 	}
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
 
@@ -444,9 +460,9 @@
     if (p) {
 	if (q)
 	    q->next = p->next;
-	else 
+	else
 	    condtab = p->next;
-		
+
 	if (p->module) {
 	    /* autoloaded, free it */
 	    zsfree(p->name);
@@ -458,11 +474,16 @@
     return -1;
 }
 
+/*
+ * Add or remove sets of conditions.  The interface is
+ * identical to setbuiltins().
+ */
+
 /**/
-mod_export int
+static int
 setconddefs(char const *nam, Conddef c, int size, int *e)
 {
-    int hads = 0, hadf = 0;
+    int ret = 0;
 
     while (size--) {
 	if (e && *e++) {
@@ -473,10 +494,9 @@
 	    if (addconddef(c)) {
 		zwarnnam(nam, "name clash when adding condition `%s'",
 			 c->name);
-		hadf = 1;
+		ret = 1;
 	    } else {
 		c->flags |= CONDF_ADDED;
-		hads = 2;
 	    }
 	} else {
 	    if (!(c->flags & CONDF_ADDED)) {
@@ -485,15 +505,14 @@
 	    }
 	    if (deleteconddef(c)) {
 		zwarnnam(nam, "condition `%s' already deleted", c->name);
-		hadf = 1;
+		ret = 1;
 	    } else {
 		c->flags &= ~CONDF_ADDED;
-		hads = 2;
 	    }
 	}
 	c++;
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
 /* This adds a definition for autoloading a module for a condition. */
@@ -565,17 +584,16 @@
 mod_export int
 addhookdefs(char const *nam, Hookdef h, int size)
 {
-    int hads = 0, hadf = 0;
+    int ret = 0;
 
     while (size--) {
 	if (addhookdef(h)) {
 	    zwarnnam(nam, "name clash when adding hook `%s'", h->name);
-	    hadf = 1;
-	} else
-	    hads = 2;
+	    ret = 1;
+	}
 	h++;
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
 /* Delete hook definitions. */
@@ -599,15 +617,20 @@
     return 0;
 }
 
+/* Remove multiple hook definitions. */
+
 /**/
 mod_export int
 deletehookdefs(UNUSED(char const *nam), Hookdef h, int size)
 {
+    int ret = 0;
+
     while (size--) {
-	deletehookdef(h);
+	if (deletehookdef(h))
+	    ret = 1;
 	h++;
     }
-    return 1;
+    return ret;
 }
 
 /* Add a function to a hook. */
@@ -648,6 +671,8 @@
     return 1;
 }
 
+/* Delete a hook. */
+
 /**/
 mod_export int
 deletehookfunc(char *n, Hookfn f)
@@ -683,22 +708,18 @@
 	return ((Hookfn) getdata(lastnode(h->funcs)))(h, d);
 }
 
-/**/
-int
-runhook(char *n, void *d)
-{
-    Hookdef h = gethookdef(n);
-
-    if (h)
-	return runhookdef(h, d);
-    return 0;
-}
 
 
 /************************************************************************
  * Shell parameters.
  ************************************************************************/
 
+/*
+ * Check that it's possible to add a parameter.  This
+ * requires that either there's no parameter already present,
+ * or it's a global parameter marked for autoloading.
+ */
+
 static int
 checkaddparam(char *nam)
 {
@@ -815,11 +836,16 @@
     return 0;
 }
 
+/*
+ * Add or remove sets of parameters.  The interface is
+ * identical to setbuiltins().
+ */
+
 /**/
-mod_export int
+static int
 setparamdefs(char const *nam, Paramdef d, int size, int *e)
 {
-    int hads = 0, hadf = 0;
+    int ret = 0;
 
     while (size--) {
 	if (e && *e++) {
@@ -829,9 +855,7 @@
 	    }
 	    if (addparamdef(d)) {
 		zwarnnam(nam, "error when adding parameter `%s'", d->name);
-		hadf = 1;
-	    } else {
-		hads = 2;
+		ret = 1;
 	    }
 	} else {
 	    if (!d->pm) {
@@ -840,14 +864,12 @@
 	    }
 	    if (deleteparamdef(d)) {
 		zwarnnam(nam, "parameter `%s' already deleted", d->name);
-		hadf = 1;
-	    } else {
-		hads = 2;
+		ret = 1;
 	    }
 	}
 	d++;
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
 /* This adds a definition for autoloading a module for a parameter. */
@@ -880,6 +902,11 @@
 /**/
 MathFunc mathfuncs;
 
+/*
+ * Remove a single math function form the list (utility function).
+ * This does not delete a module math function, that's deletemathfunc().
+ */
+
 /**/
 void
 removemathfunc(MathFunc previous, MathFunc current)
@@ -894,6 +921,8 @@
     zfree(current, sizeof(*current));
 }
 
+/* Find a math function in the list, handling autoload if necessary. */
+
 /**/
 MathFunc
 getmathfunc(char *name, int autol)
@@ -917,6 +946,8 @@
     return NULL;
 }
 
+/* Add a single math function */
+
 /**/
 static int
 addmathfunc(MathFunc f)
@@ -944,6 +975,8 @@
     return 0;
 }
 
+/* Delete a single math function */
+
 /**/
 mod_export int
 deletemathfunc(MathFunc f)
@@ -971,11 +1004,16 @@
     return -1;
 }
 
+/*
+ * Add or remove sets of math functions.  The interface is
+ * identical to setbuiltins().
+ */
+
 /**/
-mod_export int
+static int
 setmathfuncs(char const *nam, MathFunc f, int size, int *e)
 {
-    int hads = 0, hadf = 0;
+    int ret = 0;
 
     while (size--) {
 	if (e && *e++) {
@@ -986,10 +1024,9 @@
 	    if (addmathfunc(f)) {
 		zwarnnam(nam, "name clash when adding math function `%s'",
 			 f->name);
-		hadf = 1;
+		ret = 1;
 	    } else {
 		f->flags |= MFF_ADDED;
-		hads = 2;
 	    }
 	} else {
 	    if (!(f->flags & MFF_ADDED)) {
@@ -998,17 +1035,18 @@
 	    }
 	    if (deletemathfunc(f)) {
 		zwarnnam(nam, "math function `%s' already deleted", f->name);
-		hadf = 1;
+		ret = 1;
 	    } else {
 		f->flags &= ~MFF_ADDED;
-		hads = 2;
-	    }	    
+	    }
 	}
 	f++;
     }
-    return hadf ? hads : 1;
+    return ret;
 }
 
+/* Add an autoload definition for a math function. */
+
 /**/
 int
 add_automathfunc(char *nam, char *module)
@@ -1147,6 +1185,12 @@
 # define RTLD_GLOBAL 0
 #endif
 
+/*
+ * Attempt to load a module.  This is the lowest level of
+ * zsh function for dynamical modules.  Returns the handle
+ * from the dynamic loader.
+ */
+
 /**/
 static void *
 try_load_module(char const *name)
@@ -1167,6 +1211,11 @@
     return ret;
 }
 
+/*
+ * Load a module, with option to complain or not.
+ * Returns the handle from the dynamic loader.
+ */
+
 /**/
 static void *
 do_load_module(char const *name, int silent)
@@ -1182,6 +1231,10 @@
 /**/
 #else /* !DYNAMIC */
 
+/*
+ * Dummy loader when no dynamic loading available; always fails.
+ */
+
 /**/
 static void *
 do_load_module(char const *name, int silent)
@@ -1249,6 +1302,13 @@
     zfree(m, sizeof(*m));
 }
 
+/*
+ * Return 1 if a module is fully loaded else zero.
+ * A linked module may be marked as unloaded even though
+ * we can't fully unload it; this returns 0 to try to
+ * make that state transparently like an unloaded module.
+ */
+
 /**/
 mod_export int
 module_loaded(const char *name)
@@ -1650,6 +1710,11 @@
 	(m->u.handle && cleanup_module(m));
 }
 
+/*
+ * Test a module name contains only valid characters: those
+ * allowed in a shell identifier plus slash.  Return 1 if so.
+ */
+
 /**/
 static int
 modname_ok(char const *p)
@@ -1663,25 +1728,24 @@
 }
 
 /*
+ * High level function to load a module, encapsulating
+ * all the handling of module functions.
+ *
+ * "*enablesstr" is NULL if the caller is not feature-aware;
+ * then the module should turn on all features.  If it
+ * is not NULL it points to an array of features to be
+ * turned on.  This function is responsible for testing whether
+ * the module supports those features.
+ *
+ * If "silent" is 1, don't issue warnings for errors.
+ *
  * Now returns 0 for success (changed post-4.3.4),
  * 1 for complete failure, 2 if some features couldn't be set.
  */
 
 /**/
 mod_export int
-load_module(char const *name, char **enablesstr)
-{
-    return load_module_silence(name, enablesstr, 0);
-}
-
-/*
- * Returns 0 for success (changed post-4.3.4), 1 for complete
- * failure, 2 if some features couldn't be set.
- */
-
-/**/
-mod_export int
-load_module_silence(char const *name, char **enablesstr, int silent)
+load_module(char const *name, char **enablesstr, int silent)
 {
     Module m;
     void *handle = NULL;
@@ -1754,7 +1818,7 @@
      */
     if (m->deps)
 	for (n = firstnode(m->deps); n; incnode(n))
-	    if (load_module_silence((char *) getdata(n), NULL, silent) == 1) {
+	    if (load_module((char *) getdata(n), NULL, silent) == 1) {
 		m->flags &= ~MOD_BUSY;
 		unqueue_signals();
 		return 1;
@@ -1803,9 +1867,9 @@
     return bootret;
 }
 
-/* This ensures that the module with the name given as the second argument
+/* This ensures that the module with the name given as the first argument
  * is loaded.
- * The last argument is the array of features to set.  If this is NULL
+ * The other argument is the array of features to set.  If this is NULL
  * and the module needs to be loaded, all features are enabled.
  * If this is non-NULL the module features are set accordingly
  * whether or not the module is loaded; it is an error if the
@@ -1815,11 +1879,15 @@
  * The return value is 0 if the module was found or loaded
  * (this changed post-4.3.4, because I got so confused---pws),
  * 1 if loading failed completely, 2 if some features couldn't be set.
+ *
+ * This function behaves like load_module() except that it
+ * handles the case where the module was already loaded, and
+ * sets features accordingly.
  */
 
 /**/
 mod_export int
-require_module(char *nam, const char *module, char **features)
+require_module(const char *module, char **features)
 {
     Module m = NULL;
     LinkNode node;
@@ -1830,7 +1898,7 @@
     node = find_module(module, 1, &module);
     if (!node || !(m = ((Module) getdata(node)))->u.handle ||
 	(m->flags & MOD_UNLOAD))
-	ret = load_module_silence(module, features, 0);
+	ret = load_module(module, features, 0);
     else
 	ret = do_module_features(m, features, 0);
     unqueue_signals();
@@ -1838,6 +1906,11 @@
     return ret;
 }
 
+/*
+ * Indicate that the module named "name" depends on the module
+ * named "from".
+ */
+
 /**/
 void
 add_dep(const char *name, char *from)
@@ -1872,6 +1945,11 @@
 	zaddlinknode(m->deps, ztrdup(from));
 }
 
+/*
+ * Function to be used when scanning the builtins table to
+ * find and print autoloadable builtins.
+ */
+
 /**/
 static void
 autoloadscan(HashNode hn, int printflags)
@@ -1905,6 +1983,10 @@
  * Handling for the zmodload builtin and its various options.
  ************************************************************************/
 
+/*
+ * Main builtin entry point for zmodload.
+ */
+
 /**/
 int
 bin_zmodload(char *nam, char **args, Options ops, UNUSED(int func))
@@ -1982,6 +2064,8 @@
     return ret;
 }
 
+/* zmodload -A */
+
 /**/
 static int
 bin_zmodload_alias(char *nam, char **args, Options ops)
@@ -2093,6 +2177,8 @@
     return 0;
 }
 
+/* zmodload -e (without -F) */
+
 /**/
 static int
 bin_zmodload_exist(UNUSED(char *nam), char **args, Options ops)
@@ -2112,7 +2198,7 @@
 		    m = (Module) getdata(node2);
 		else
 		    continue;
-	    } 
+	    }
 	    if (m->u.handle && !(m->flags & MOD_UNLOAD)) {
 		nicezputs(modname, stdout);
 		putchar('\n');
@@ -2132,6 +2218,8 @@
     }
 }
 
+/* zmodload -d */
+
 /**/
 static int
 bin_zmodload_dep(UNUSED(char *nam), char **args, Options ops)
@@ -2205,6 +2293,8 @@
     }
 }
 
+/* zmodload -ab */
+
 /**/
 static int
 bin_zmodload_auto(char *nam, char **args, Options ops)
@@ -2249,6 +2339,8 @@
     }
 }
 
+/* zmodload -ac */
+
 /**/
 static int
 bin_zmodload_cond(char *nam, char **args, Options ops)
@@ -2313,6 +2405,8 @@
     }
 }
 
+/* zmodload -af */
+
 /**/
 static int
 bin_zmodload_math(char *nam, char **args, Options ops)
@@ -2369,6 +2463,11 @@
     }
 }
 
+/*
+ * Function for scanning the parameter table to find and print
+ * out autoloadable parameters.
+ */
+
 static void
 printautoparams(HashNode hn, int lon)
 {
@@ -2382,6 +2481,8 @@
     }
 }
 
+/* zmodload -ap */
+
 /**/
 static int
 bin_zmodload_param(char *nam, char **args, Options ops)
@@ -2425,6 +2526,8 @@
     }
 }
 
+/* Backend handler for zmodload -u */
+
 /**/
 int
 unload_module(Module m, LinkNode node)
@@ -2513,6 +2616,11 @@
     return 0;
 }
 
+/*
+ * Unload a module by name (modname); nam is the command name.
+ * Optionally don't print some error messages (always print
+ * dependency errors).
+ */
 
 /**/
 int
@@ -2556,6 +2664,7 @@
     return ret;
 }
 
+/* zmodload -u without -d */
 
 /**/
 static int
@@ -2590,7 +2699,7 @@
     } else {
 	/* load modules */
 	for (; *args; args++) {
-	    int tmpret = require_module(nam, *args, NULL);
+	    int tmpret = require_module(*args, NULL);
 	    if (tmpret && ret != 1)
 		ret = tmpret;
 	}
@@ -2599,6 +2708,8 @@
     }
 }
 
+/* zmodload -F */
+
 /**/
 static int
 bin_zmodload_features(char *nam, char **args, Options ops)
@@ -2743,7 +2854,7 @@
 	return 1;
     }
 
-    return require_module(nam, modname, args);
+    return require_module(modname, args);
 }
 
 
@@ -2834,23 +2945,36 @@
 {
     int ret = 0;
 
-    if (f->bn_size && setbuiltins(nam, f->bn_list, f->bn_size, e) != 1)
-	ret = 1;
-    if (e)
-	e += f->bn_size;
-    if (f->cd_size && setconddefs(nam, f->cd_list, f->cd_size, e) != 1)
-	ret = 1;
-    if (e)
-	e += f->cd_size;
-    if (f->pd_size && setparamdefs(nam, f->pd_list, f->pd_size, e) != 1)
-	ret = 1;
-    if (e)
-	e += f->pd_size;
-    if (f->mf_size && setmathfuncs(nam, f->mf_list, f->mf_size, e) != 1)
-	ret = 1;
+    if (f->bn_size) {
+	if (setbuiltins(nam, f->bn_list, f->bn_size, e))
+	    ret = 1;
+	if (e)
+	    e += f->bn_size;
+    }
+    if (f->cd_size) {
+	if (setconddefs(nam, f->cd_list, f->cd_size, e))
+	    ret = 1;
+	if (e)
+	    e += f->cd_size;
+    }
+    if (f->pd_size) {
+	if (setparamdefs(nam, f->pd_list, f->pd_size, e))
+	    ret = 1;
+	if (e)
+	    e += f->pd_size;
+    }
+    if (f->mf_size) {
+	if (setmathfuncs(nam, f->mf_list, f->mf_size, e))
+	    ret = 1;
+    }
     return ret;
 }
 
+/*
+ * Convenient front-end to get or set features which
+ * can be used in a module enables_() function.
+ */
+
 /**/
 mod_export int
 handlefeatures(char *nam, Features f, int **enables)
@@ -2864,6 +2988,12 @@
 /*
  * Ensure module "modname" is providing feature with "prefix"
  * and "feature" (e.g. "b:", "limit").
+ *
+ * This will usually be called from the main shell to handle
+ * loading of an autoloadable feature.
+ *
+ * Returns 0 on success, 1 for error in module, 2 for error
+ * setting the feature.
  */
 
 /**/
@@ -2875,5 +3005,5 @@
 
     features[0] = f;
     features[1] = NULL;
-    return require_module(NULL, modname, features);
+    return require_module(modname, features);
 }
Index: Src/Modules/zftp.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/zftp.c,v
retrieving revision 1.43
diff -u -r1.43 zftp.c
--- Src/Modules/zftp.c	28 May 2007 22:57:41 -0000	1.43
+++ Src/Modules/zftp.c	29 May 2007 16:55:13 -0000
@@ -3174,7 +3174,7 @@
 int
 setup_(UNUSED(Module m))
 {
-    return (require_module("", "zsh/net/tcp", NULL) == 1);
+    return (require_module("zsh/net/tcp", NULL) == 1);
 }
 
 /**/
Index: Src/Zle/complete.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complete.c,v
retrieving revision 1.36
diff -u -r1.36 complete.c
--- Src/Zle/complete.c	29 May 2007 09:53:44 -0000	1.36
+++ Src/Zle/complete.c	29 May 2007 16:55:15 -0000
@@ -1524,7 +1524,7 @@
     addhookfunc("reverse_menu", (Hookfn) reverse_menu);
     addhookfunc("list_matches", (Hookfn) list_matches);
     addhookfunc("invalidate_list", (Hookfn) invalidate_list);
-    addhookdefs(m->nam, comphooks, sizeof(comphooks)/sizeof(*comphooks));
+    (void)addhookdefs(m->nam, comphooks, sizeof(comphooks)/sizeof(*comphooks));
     return addwrapper(m, wrapper);
 }
 
@@ -1539,7 +1539,8 @@
     deletehookfunc("reverse_menu", (Hookfn) reverse_menu);
     deletehookfunc("list_matches", (Hookfn) list_matches);
     deletehookfunc("invalidate_list", (Hookfn) invalidate_list);
-    deletehookdefs(m->nam, comphooks, sizeof(comphooks)/sizeof(*comphooks));
+    (void)deletehookdefs(m->nam, comphooks,
+			 sizeof(comphooks)/sizeof(*comphooks));
     deletewrapper(m, wrapper);
     return setfeatureenables(m->nam, &module_features, NULL);
 }
Index: Src/Zle/zle_main.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_main.c,v
retrieving revision 1.97
diff -u -r1.97 zle_main.c
--- Src/Zle/zle_main.c	28 May 2007 22:57:42 -0000	1.97
+++ Src/Zle/zle_main.c	29 May 2007 16:55:16 -0000
@@ -1844,7 +1844,7 @@
 {
     addhookfunc("before_trap", (Hookfn) zlebeforetrap);
     addhookfunc("after_trap", (Hookfn) zleaftertrap);
-    addhookdefs(m->nam, zlehooks, sizeof(zlehooks)/sizeof(*zlehooks));
+    (void)addhookdefs(m->nam, zlehooks, sizeof(zlehooks)/sizeof(*zlehooks));
     return 0;
 }
 
@@ -1858,7 +1858,7 @@
     }
     deletehookfunc("before_trap", (Hookfn) zlebeforetrap);
     deletehookfunc("after_trap", (Hookfn) zleaftertrap);
-    deletehookdefs(m->nam, zlehooks, sizeof(zlehooks)/sizeof(*zlehooks));
+    (void)deletehookdefs(m->nam, zlehooks, sizeof(zlehooks)/sizeof(*zlehooks));
     return setfeatureenables(m->nam, &module_features, NULL);
 }
 
Index: Src/Zle/zle_thingy.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_thingy.c,v
retrieving revision 1.31
diff -u -r1.31 zle_thingy.c
--- Src/Zle/zle_thingy.c	28 May 2007 22:57:42 -0000	1.31
+++ Src/Zle/zle_thingy.c	29 May 2007 16:55:17 -0000
@@ -590,7 +590,7 @@
     Thingy t;
     Widget w, cw;
 
-    if (require_module(name, "zsh/complete", NULL) == 1) {
+    if (require_module("zsh/complete", NULL) == 1) {
 	zwarnnam(name, "can't load complete module");
 	return 1;
     }
Index: Src/Zle/zle_tricky.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/zle_tricky.c,v
retrieving revision 1.86
diff -u -r1.86 zle_tricky.c
--- Src/Zle/zle_tricky.c	28 May 2007 22:57:42 -0000	1.86
+++ Src/Zle/zle_tricky.c	29 May 2007 16:55:18 -0000
@@ -612,7 +612,7 @@
      * no completion widgets are defined. */
 
     if (!module_loaded("zsh/compctl") && !hascompwidgets)
-	(void)load_module("zsh/compctl", NULL);
+	(void)load_module("zsh/compctl", NULL, 0);
 
     if (runhookdef(BEFORECOMPLETEHOOK, (void *) &lst)) {
 	active = 0;


To access the latest news from CSR copy this link into a web browser:  http://www.csr.com/email_sig.php

To get further information regarding CSR, please visit our Investor Relations page at http://ir.csr.com/csr/about/overview

