Delivered-To: mason-zsh@primenet.com.au
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
Date: Wed, 3 Feb 1999 12:06:13 +0100 (MET)
Message-Id: <199902031106.MAA11648@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Fri, 29 Jan 1999 09:31:43 -0800
Subject: Re: PATCH: Re: Btw.: glob-qualifier
X-Mailing-List: <zsh-workers@sunsite.auc.dk> 5203


Bart Schaefer wrote:

> On Jan 29,  2:37pm, Sven Wischnowsky wrote:
> } Subject: PATCH: Re: Btw.: glob-qualifier
> }
> } > [...] (o(ug=w,o+r)) for "user and group must have exactly the write
> } > bit set, and other must have at least r" and (o(u+x,go-w)) for "user
> } > must have at least the execute bit set, and group and other must not
> } > have write" and so on.
> } 
> } The patch below implements this (with a few extras).
> 
> Nifty!  Now I only have one question ... is there another, better letter
> than `o' that could be adopted (since the mode is no longer `o'ctal),
> thus giving us both o and O for ascending/descending sorts, as in the
> parameter flags?

Maybe we want to wait some more time before we use the patch below to
find out if we get a reply to the message I send (asking if it's ok to 
change this). I just had some free time...

Anyway, I'd really like to clean this up, so the patch

- changes what was the `o' qualifier to `f' (= file-modes?); I haven't 
  found a better character, but it's easy to change; other free
  characters are: behijknqvyzBCFHJKPQVYZ
- changes the `O' qualifier to `o' and introduces a new qualifier `O'
  that behaves like `^o' (sorts in descending order); and yes, `(^oc)' 
  is the same as `(Oc)'; the uses in the zls example function have
  been changed, are there any more uses?


Bye
 Sven

--- os/glob.c	Wed Feb  3 10:56:32 1999
+++ Src/glob.c	Wed Feb  3 11:44:33 1999
@@ -1432,7 +1432,7 @@
 			    }
 			}
 			break;
-		    case 'o':
+		    case 'f':
 			/* Match modes with chmod-spec. */
 			func = qualmodeflags;
 			data = qgetmodespec(&s);
@@ -1501,6 +1501,7 @@
 			data = qgetnum(&s);
 			break;
 
+		    case 'o':
 		    case 'O':
 			{
 			    int t;
@@ -1524,7 +1525,7 @@
 			    }
 			    gf_sorts |= t;
 			    gf_sortlist[gf_nsorts++] = t |
-				((sense & 1) ? GS_DESC : 0);
+				(((sense & 1) ^ (s[-1] == 'O')) ? GS_DESC : 0);
 			    s++;
 			    break;
 			}
--- od/Zsh/expn.yo	Wed Feb  3 11:08:04 1999
+++ Doc/Zsh/expn.yo	Wed Feb  3 11:51:00 1999
@@ -1098,7 +1098,7 @@
 item(tt(t))(
 files with the sticky bit (01000)
 )
-item(tt(o)var(spec))(
+item(tt(f)var(spec))(
 files with access rights matching var(spec). This var(spec) may be a
 octal number optionally preceded by a `tt(=)', a `tt(PLUS())', or a
 `tt(-)'. If none of these characters is given, the behavior is the
@@ -1111,7 +1111,7 @@
 inthe file-modes are not checked, this is only useful in combination
 with `tt(=)'.
 
-If the qualifier `tt(o)' is followed by any other character anything
+If the qualifier `tt(f)' is followed by any other character anything
 up to the next matching character (`tt([)', `tt({)', and `tt(<)' match 
 `tt(])', `tt(})', and `tt(>)' respectively, any other character
 matches itself) is taken as a list of comma-separated
@@ -1132,11 +1132,11 @@
 `tt(s)' for the setuid and setgid bits, and `tt(t)' for the sticky
 bit.
 
-Thus, `tt(*(o70?))' gives the files for which the owner has read,
+Thus, `tt(*(f70?))' gives the files for which the owner has read,
 write, and execute permission, and for which other group members have
 no rights, independent of the permissions for other user. The pattern
-`tt(*(o-100))' gives all files for which the owner does not have
-execute permission, and `tt(*(o:gu+w,o-rx))' gives the files for which 
+`tt(*(f-100))' gives all files for which the owner does not have
+execute permission, and `tt(*(f:gu+w,o-rx))' gives the files for which 
 the owner and the other members of the group have at least write
 permission, and fo which other users don't have read or execute
 permission.
@@ -1215,7 +1215,7 @@
 sets the tt(GLOB_DOTS) option for the current pattern
 pindex(GLOB_DOTS, setting in pattern)
 )
-item(tt(O)var(c))(
+item(tt(o)var(c))(
 specifies how the names of the files should be sorted. If var(c) is
 tt(n) they are sorted by name (the default), if var(c) is tt(L) they
 are sorted depending on the size (length) of the files, tt(l) makes
@@ -1224,16 +1224,20 @@
 inode change respectively. Note that tt(a), tt(m), and tt(c) compare
 the age to the current time, so the first name in the list is the 
 one of the youngest file. Also note that the modifiers tt(^) and tt(-) are 
-used, so `tt(*(^-OL))' gives a list of all files sorted by file size in 
+used, so `tt(*(^-oL))' gives a list of all files sorted by file size in 
 descending order working not on symbolic links but on the files they
 point to.
 )
+item(tt(O)var(c))(
+like `tt(o)', but sorts in descending order; i.e. `tt(*(^oc))' is the
+same as `tt(*(Oc))' and `tt(*(^Oc))' is the same as `tt(*(oc))'
+)
 item(tt([)var(beg)[tt(,)var(end)]tt(]))(
 specifies which of the matched filenames should be included in the
 returned list. The syntax is the same as for array
 subscripts. var(beg) and the optional var(end) may be mathematical
 expressions. As in parameter subscripting they may be negative to make 
-them count from the last match backward. E.g.: `tt(*(^-OL[1,3]))'
+them count from the last match backward. E.g.: `tt(*(-OL[1,3]))'
 gives a list of the names of three biggest files.
 )
 enditem()
--- of/zls	Wed Feb  3 12:02:02 1999
+++ Functions/zls	Wed Feb  3 12:02:32 1999
@@ -32,7 +32,7 @@
 
 if ((! ARGC)) then
     if [[ $opts = *t* ]]; then
-        set *(O$tmod)
+        set *(o$tmod)
     else
         set *
     fi
@@ -44,7 +44,7 @@
     for (( f = 2; f <= $ARGC; f++ )); do
 	n="$n|\$$f"
     done
-    eval "argv=(($n)(O$tmod))"
+    eval "argv=(($n)(o$tmod))"
 fi
 
 for f in $*

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

