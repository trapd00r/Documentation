18:23:55 ▏       mst dhoss: a list only exists, if ever, as a series of SV entries on the perl stack
18:24:13 ▏       mst dhoss: an array is an actual AV with indices and stuff
18:26:25 ▏   Altreus eval: sub foo() { my @arr = qw(a b); @arr }  [ foo(), scalar foo ]
18:26:27 ▏   perlbot Altreus: ["a","b",2]
18:26:34 ▏       mst anyway, &
18:26:41 ▏   Altreus dhoss: the function returns an /array/, so in scalar context you get its length
18:26:57 ▏   Altreus eval: sub foo() { return qw(a b) }  [ foo(), scalar foo ]



=for double-not

A double "not" operator is used for converting scalar to boolean value
  use constant TRUE => !! 1;
  use constant FALSE => !! '';

=cut

=for zero-width

# zero-width, match _before_ 'foo':
split(/(?=foo)/, 'foobarfoobazfooqux');

=cut

=for unimport()

# unimport()
# 11:33:22 ▏      anno >> woldrich: it runs unimport(). what unimport() does is
# up to the module

use Data::Dumper;
no Data::Dumper qw(Dumper);

=cut

=for arithmetic

* siginfies multiplication, but two asterisks in a row are a shorthand for
exponentiation (this derives from FORTRAN). Thus, one might write 2 ** 8 = 256.

=cut

=for Mechanize

$mech->add_handler("request_send", sub { shift->dump; return });
$mech->add_handler("response_done", sub { shift->dump; return });

This will cause all HTTP requests and responses to be output, so you can see exactly whats happening.

=cut

=for research

my $str = "Hello"; pos($str) = 0; [ scalar $str =~ m/\G[\s\n]*/gc ]

=cut

# vim: ft=perl tw=0 nowrap:
