From zsh-workers-return-5947-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Mar 25 17:08:40 1999
Return-Path: <zsh-workers-return-5947-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16827 invoked from network); 25 Mar 1999 17:08:38 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 25 Mar 1999 17:08:38 -0000
Received: (qmail 16626 invoked by alias); 25 Mar 1999 17:08:14 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 5947
Received: (qmail 16617 invoked from network); 25 Mar 1999 17:08:10 -0000
Date: Thu, 25 Mar 1999 18:08:00 +0100 (MET)
Message-Id: <199903251708.SAA25022@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Andrej Borsenkow"'s message of Thu, 25 Mar 1999 19:37:23 +0300
Subject: RE: Still something strange with ambiguous prefix


Andrej Borsenkow wrote:

> itsrm2% bindkey '^I' complete-word
> itsrm2% fpath=($PWD/*(/))
> itsrm2% . Core/compinit
> itsrm2% compconf completer=_complete:_match match_original=yes
> itsrm2% l /t/s/z/D/z*iTAB
> itsrm2% l /tools/src/zsh-3.1.5-pws-13/Doc/zsh.info
> zsh.info         zsh.info-5       zshbuiltins.1    zshoptions.1
> zsh.info-1       zsh.info-6       zshbuiltins.yo   zshoptions.yo
> zsh.info-10      zsh.info-7       zshcompwid.1     ztexi.yo
> zsh.info-2       zsh.info-8       zshcompwid.yo
> zsh.info-3       zsh.info-9       zshmisc.1
> zsh.info-4       zsh.texi         zshmisc.yo

I tested it with a local directory (not `/...'), sorry. There a
different branch was called and it worked. Try the one below. Ok?

> > > 3.
> > >
> > > bor@itsrm2:~%> l /t/s/gl/co*TAB
> > > bor@itsrm2:~%> l /tools/src/glib-1.1.15/co* <= cursor here
> > > glib-1.1.15/  glib-1.2.0/
> > >
> > > So, menu completion is started for prefix, but cursor is placed
> > at the end
> > > of word.
> >
> > Grrrr, I asked if you wanted the cursor placed in the middle of the
> > word with menu-completion in message 5651 and you answered `Me not' in
> > message 5657.
> >
> 
> a) (with the same zsh as in 2)
> 
> itsrm2% l /u/l/lTAB
> itsrm2% l /u/l/l
>             ^ cursor here (after `/u')
> u1/   usr/
> 
> May I kindly ask, what is the difference between this ang glib example?

Menucompletion. In menucompletion the cursor was always moved to the
end, but not for normal completion.

> > Anyway, I don't know how I should change this easily for now. The
> > problem is that the path suffix is just an ignored suffix for the
> > completion code and normally one really wants to have the cursor at
> > the end of the whole word with menu-completion.
> 
> That makes sense, if we complete the whole word. But what happens here -
> that we actually complete just a single part of it. When I said "yes" to
> your question - I implied, that a user will be presented with the complete
> list (in the above example, this would mean *all* files that match gl*/co*).
> Simply, because it was what compctl always did, and I was accustomed to it.
> All of you said, it is "the bad thing". Now, after actually using it, I
> agree.

In normal usage the cursor can be where you want and TAB should give
some reasonable result. With menucompletion (where anything that is
inserted is the full string) putting the cursor at the end may save
you some nasty moving-the-curosr-to-the-end-of-it which would have to
be done by hand.

Bye
 Sven

diff -u -r oc/Base/_long_options Completion/Base/_long_options
--- oc/Base/_long_options	Thu Mar 25 15:31:24 1999
+++ Completion/Base/_long_options	Thu Mar 25 18:01:10 1999
@@ -215,8 +215,6 @@
 
   [[ -n "$_comp_correct" ]] && patflags="$patflags(#a$_comp_correct)"
 
-  [[ "${compstate[pattern_match]-*}" != \** ]] && pat="$pat:gs/*//"
-
   # Then we walk through the array names. For each array we test if it 
   # contains the option string. If so, we `invoke' the action stored
   # with the name. If the action is a list of words, we just add them, 
diff -u -r oc/Core/_multi_parts Completion/Core/_multi_parts
--- oc/Core/_multi_parts	Thu Mar 25 15:31:27 1999
+++ Completion/Core/_multi_parts	Thu Mar 25 18:00:09 1999
@@ -45,7 +45,11 @@
 # the original string in `orig'.
 
 if [[ $#compstate[pattern_match] -ne 0 ]]; then
-  patstr="${PREFIX}*${SUFFIX}*"
+  if [[ "${compstate[pattern_match]-*}" = \** ]]; then
+    str="${PREFIX}*${SUFFIX}*"
+  else
+    str="${PREFIX}${SUFFIX}"
+  fi
 else
   patstr="${PREFIX:q}*${SUFFIX:q}*"
 fi
@@ -61,8 +65,6 @@
 [[ -n "$_comp_correct" ]] && matchflags="$matchflags(#a$_comp_correct)"
 
 patstr="${${patstr//$sep/*$sep}//\*##/*}"
-
-[[ "${compstate[pattern_match]-*}" != \** ]] && patstr="$patstr:gs/*//"
 
 # First we will skip over those parts of the matches for which we have 
 # exact substrings on the line. In `pref' we will build the
diff -u -r oc/Core/_path_files Completion/Core/_path_files
--- oc/Core/_path_files	Thu Mar 25 15:31:27 1999
+++ Completion/Core/_path_files	Thu Mar 25 18:00:19 1999
@@ -113,7 +113,11 @@
 # the prefix and the suffix. Then we see if we will do menucompletion.
 
 if [[ $#compstate[pattern_match] -ne 0 ]]; then
-  str="${PREFIX}*${SUFFIX}"
+  if [[ "${compstate[pattern_match]-*}" = \** ]]; then
+    str="${PREFIX}*${SUFFIX}"
+  else
+    str="${PREFIX}${SUFFIX}"
+  fi
 else
   str="${PREFIX:q}*${SUFFIX:q}"
   [[ "$str" = \\\~* ]] && str="$str[2,-1]"
@@ -212,8 +216,6 @@
 # add the pattern for matching any characters before a slash.
 
 patstr="$patstr:gs-/-*/-:gs/*.*./../:gs/**/*/:gs-.*/-./-"
-
-[[ "${compstate[pattern_match]-*}" != \** ]] && patstr="$patstr:gs/*//"
 
 # We take the last pathname component from the pattern and store it in
 # `patlast', replacing `*'s in it with patterns that match any character
diff -u -r oc/Core/_sep_parts Completion/Core/_sep_parts
--- oc/Core/_sep_parts	Thu Mar 25 15:31:27 1999
+++ Completion/Core/_sep_parts	Thu Mar 25 18:00:38 1999
@@ -69,8 +69,6 @@
   _match_pattern _sep_parts test matchflags
   [[ -n "$_comp_correct" ]] && matchflags="$matchflags(#a$_comp_correct)"
 
-  [[ "${compstate[pattern_match]-*}" != \** ]] && test="$test:gs/*//"
-
   test="${matchflags}${test}"
   testarr=( "${(@M)${(@P)arr}:#${~test}*}" )
   testarr=( "${(@)testarr:#}" )

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

