From zsh-users-return-13030-mason-zsh=primenet.com.au@sunsite.dk Mon Jul 14 17:43:02 2008
Return-Path: <zsh-users-return-13030-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25452 invoked from network); 14 Jul 2008 17:43:00 -0000
X-Spam-Checker-Version: SpamAssassin 3.2.5 (2008-06-10) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=AWL,BAYES_00 autolearn=ham
	version=3.2.5
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 14 Jul 2008 17:43:00 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 80616 invoked from network); 14 Jul 2008 17:42:47 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 14 Jul 2008 17:42:47 -0000
Received: (qmail 12623 invoked by alias); 14 Jul 2008 17:42:37 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 13030
Received: (qmail 12610 invoked from network); 14 Jul 2008 17:42:36 -0000
Received: from bifrost.dotsrc.org (130.225.254.106)
  by sunsite.dk with SMTP; 14 Jul 2008 17:42:36 -0000
Received: from cluster-g.mailcontrol.com (cluster-g.mailcontrol.com [208.87.233.190])
	by bifrost.dotsrc.org (Postfix) with ESMTPS id B26AD80525AB
	for <zsh-users@sunsite.dk>; Mon, 14 Jul 2008 19:42:31 +0200 (CEST)
Received: from cameurexb01.EUROPE.ROOT.PRI ([193.128.72.68])
	by rly24g.srv.mailcontrol.com (MailControl) with ESMTP id m6EHgMjK000470
	for <zsh-users@sunsite.dk>; Mon, 14 Jul 2008 18:42:23 +0100
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.3959);
	 Mon, 14 Jul 2008 18:42:20 +0100
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.14.2/8.13.4) with ESMTP id m6EHgKl5001190
	for <zsh-users@sunsite.dk>; Mon, 14 Jul 2008 18:42:20 +0100
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.14.2/8.14.2/Submit) with ESMTP id m6EHgK9r001187
	for <zsh-users@sunsite.dk>; Mon, 14 Jul 2008 18:42:20 +0100
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-users@sunsite.dk (Zsh users list)
Subject: history-beginning-local function
X-Mailer: MH-E 8.0.3; nmh 1.3; GNU Emacs 22.1.1
Date: Mon, 14 Jul 2008 18:42:20 +0100
Message-ID: <1186.1216057340@csr.com>
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 14 Jul 2008 17:42:20.0308 (UTC) FILETIME=[F7332540:01C8E5D8]
X-Scanned-By: MailControl A-08-50-03 (www.mailcontrol.com) on 10.71.0.134
X-Virus-Scanned: ClamAV 0.92.1/7709/Mon Jul 14 18:16:52 2008 on bifrost
X-Virus-Status: Clean

This function allows you to have a local history file so that, for
example, you can pick "make" commands appropriate to a local directory
without rendering the history unusable for other operations.  It uses
the "fc -p" command that Wayne added.

The main problem is that you have to create and update the local history
file yourself since commands aren't saved to it.  This is tricky since
it happens in the main shell after zle returns.  We'd need a hook
function of some sort to be able to do the effect of fc -p around the
point the history is saved, unless there's a smarter way of doing it.

There are probably more subtle problems.


# history-beginning-local
#
#   Mostly a drop-in replacement for history-beginning-search-backward
#   or -forward, depending on the name.
#
#   Allows a local history file to be searched for certain commands to execute.
#   The main restriction is that at the moment commands are not saved
#   to the local history file, which needs to be primed by hand
#   (for example, by selecting lines from the global history file).
#
#   The style local-history-file should be set to a file that
#   will contain the local history, in the same format as $HISTFILE,
#   while local-history-commands should be set to a list of commands
#   (or patterns matching commands) that should use the local history
#   file.  Both must be set.
#
#   If the style local-history-only is not set the global history
#   will be searched if there is no match in the local history.
#   The global history is tried again from the most recent entry;
#   no ordering is implied between the two histories.
#
#   If the style local-history-verbose is set a notice is printed
#   below the command line if the local history was searched.
#
#   Styles use the context ":zle:" followed by the widget name followed
#   by a colon.  It is recommended that a wildcard be used at the end
#   to protect against future enhancements.
#
#   For example,
#    zstyle ':zle:*' local-history-file .zsh-local-history
#    zstyle ':zle:*' local-history-commands make gcc gdb

emulate -L zsh
setopt extendedglob

local w lhf
local -a lhc
integer lhv lho restore

zstyle -s ":zle:$WIDGET:" local-history-file lhf || return 1
zstyle -a ":zle:$WIDGET:" local-history-commands lhc || return 1
zstyle -t ":zle:$WIDGET:" local-history-verbose && lhv=1
zstyle -t ":zle:$WIDGET:" local-history-only && lho=1

# try / always block for restoring history
{
  if [[ -f $lhf ]]; then
    integer oldcursor=CURSOR iline
    local new
    local -a words found

    words=(${(z)BUFFER})
    if [[ ${(Q)words[1]} = (${(j.|.)~lhc}) ]]; then
      (( restore = 1 ))
      fc -p $lhf

      # Search history for pattern.
      # As $history is an associative array we can get all matches.
      found=(${(kon)history[(R)${LBUFFER}*]})

      if [[ $WIDGET = *forw* ]]; then
	# Searching forward.  Look back through matches until we
	# get back to the current history number.
	for iline in $found; do
	  (( $iline <= HISTNO )) && break
	  # Skip duplicates.
	  [[ $history[$iline] = $BUFFER ]] || new=$found[$i]
	done
      else
	# Searching backward.  Look forward through matches until we
	# reach the current history number.
	for iline in $found; do
	  (( $iline >= HISTNO )) && break
	  # Skip duplicates.
	  [[ $history[$iline] = $BUFFER ]] || new=$iline
	done
      fi
      if [[ -n $new ]]; then
	# Match found.  Move to line.
	HISTNO=$new
	(( CURSOR = oldcursor ))
	(( lhv )) && zle -M "Matched in local history"
	return 0
      elif (( lho )); then
	(( lhv )) && zle -M "No match in local history"
	return 1
      else
	(( lhv )) && zle -M "No match in local history; falling through"
      fi
    fi
  fi
} always {
  (( restore )) && fc -P
}

if [[ $WIDGET = *forw* ]]; then
  zle history-beginning-search-forward
else
  zle history-beginning-search-backward
fi

if [[ $WIDGET = *-end* ]]; then
  zle end-of-line
fi

# end


-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070

