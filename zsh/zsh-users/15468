From zsh-users-return-15468-mason-zsh=primenet.com.au@zsh.org Fri Oct 22 04:05:56 2010
Return-Path: <zsh-users-return-15468-mason-zsh=primenet.com.au@zsh.org>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 1693 invoked by alias); 22 Oct 2010 04:05:56 -0000
Mailing-List: contact zsh-users-help@zsh.org; run by ezmlm
Precedence: bulk
X-No-Archive: yes
List-Id: Zsh Users List <zsh-users.zsh.org>
List-Post: <mailto:zsh-users@zsh.org>
List-Help: <mailto:zsh-users-help@zsh.org>
Delivered-To: mailing list zsh-users@zsh.org
X-Seq: 15468
Received: (qmail 28369 invoked from network); 22 Oct 2010 04:05:44 -0000
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_NONE
	autolearn=ham version=3.3.1
Received-SPF: none (ns1.primenet.com.au: domain at closedmail.com does not designate permitted sender hosts)
From: Bart Schaefer <schaefer@brasslantern.com>
Message-id: <101021210513.ZM30802@torch.brasslantern.com>
Date: Thu, 21 Oct 2010 21:05:13 -0700
In-reply-to: <AANLkTikBOSBNfBHXDFdfiCkijVt5G5+-1UVFz_VqY3wZ@mail.gmail.com>
Comments: In reply to Nikolai Weibull <now@bitwi.se>
 "Neat hash -d trick" (Oct 22, 12:34am)
References: <AANLkTikBOSBNfBHXDFdfiCkijVt5G5+-1UVFz_VqY3wZ@mail.gmail.com>
X-Mailer: OpenZMail Classic (0.9.2 24April2005)
To: Zsh Users <zsh-users@zsh.org>
Subject: Re: Neat hash -d trick
MIME-version: 1.0
Content-type: text/plain; charset=us-ascii

[Aside to -workers:  This reminds me about Mikael Magnusson's thread
for his proposed HASH_LOOKUP option, which sort of died out without
resolution after a discussion of findcmd() behaving oddly.]

On Oct 22, 12:34am, Nikolai Weibull wrote:
}
} for ((i = 1; i < 9; i++)); do

You probably mean <= 9 there?  Or just

  for i in {1..9}

}   hash -d .$i=${(j:/:)${(l:2::.:)${(s::)${(l:i::.:)}}}}

    hash -d .$i=${${(l:i*3::../:)}%/}

} done
} 
} cd ~.4/dir

A generic word of caution about using "hash -d": if you for any reason
change the value of $PATH or $path after this, all your custom hash
entries are lost when the table is rebuilt for the new searchpath.

A similar trick:

    dotdot() {
      if (( NUMERIC > 0 ))
      then LBUFFER+=..; repeat $((NUMERIC-1)) LBUFFER+=/..
      else LBUFFER+=.
      fi
    }
    zle -N dotdot
    bindkey . dotdot

Now you can type ESC 4 . to insert ../../../.. (or ESC 9 ESC 9 . to
insert 99 levels, if for some insane reason you need that many).

} What would be even sweeter is if someone would come up with a way to
} do this with only one call to hash -d without writing out all the
} expansions

Because the counter has to be referenced twice in the expansion, I
don't think there's any way of avoiding the "for" loop that's worth
the effort to figure out.  However,

    for i in {1..9}; h+=(.$i=${${(l:i*3::../:)}%/}); hash -d $h

Or to avoid leaving $i and $h with a value at the end,

    hash -d $( for i in {1..9}; print .$i=${${(l:i*3::../:)}%/} )

