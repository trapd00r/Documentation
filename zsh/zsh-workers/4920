From zsh-workers-request@math.gatech.edu Fri Jan 15 16:48:21 1999
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23079 invoked from network); 15 Jan 1999 16:48:20 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 15 Jan 1999 16:48:20 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id LAA07364;
	Fri, 15 Jan 1999 11:45:23 -0500 (EST)
Resent-Date: Fri, 15 Jan 1999 11:45:23 -0500 (EST)
From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <990115084316.ZM26658@candle.brasslantern.com>
Date: Fri, 15 Jan 1999 08:43:15 -0800
In-Reply-To: <9901151544.AA14645@ibmth.df.unipi.it>
Comments: In reply to Peter Stephenson <pws@ibmth.df.unipi.it>
        "PATCH: zsh-3.1.5-pws-4 + typeset fix: memory leak" (Jan 15,  4:44pm)
References: <9901151544.AA14645@ibmth.df.unipi.it>
X-Mailer: Z-Mail (4.0b.820 20aug96)
To: Peter Stephenson <pws@ibmth.df.unipi.it>, zsh-workers@math.gatech.edu
Subject: Re: PATCH: zsh-3.1.5-pws-4 + typeset fix: memory leak
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Resent-Message-ID: <"wzssj1.0._o1.Z2tds"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4920
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Jan 15,  4:44pm, Peter Stephenson wrote:
} Subject: PATCH: zsh-3.1.5-pws-4 + typeset fix: memory leak
}
} the problem with your approach is that `print -P' can take more than
} one argument, and all need freeing: the easiest thing to do is use
} heap memory (which gets freed automatically when the builtin exits),
} and free the permanent memory straight away.

Another place where 3.0.5 appears to have been patched but 3.1.5 has not.
The 3.0.5 code reads:

	/* -P option -- interpret as a prompt sequence */
	if(ops['P']) {
	    char *arg = putprompt(metafy(args[n], len[n], META_NOALLOC),
				  &len[n], NULL, 0);
	    args[n] = (char *)alloc(len[n] + 1);
	    memcpy(args[n], arg, len[n]);
	    args[n][len[n]] = 0;
	    free(arg);
	}

I'm sure the memcpy() is done to avoid recomputing len[n]+1 in dupstring().

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

