From zsh-workers-return-8720-mason-zsh=primenet.com.au@sunsite.auc.dk Mon Nov 22 10:39:30 1999
Return-Path: <zsh-workers-return-8720-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 21563 invoked from network); 22 Nov 1999 10:39:25 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 22 Nov 1999 10:39:25 -0000
Received: (qmail 6311 invoked by alias); 22 Nov 1999 10:39:15 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8720
Received: (qmail 6302 invoked from network); 22 Nov 1999 10:39:12 -0000
Date: Mon, 22 Nov 1999 11:39:10 +0100 (MET)
Message-Id: <199911221039.LAA05279@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: stylify completion parameters


Most of this patch turns parameters used by the completion system into 
styles (not `fignore', not yet).

The styles are named like `users', `users-hosts' , etc. Default values 
are still generated but not stored as styles (they are cached in
parameters). These are (in some cases) used together with pseudo-tags
such as `accounts', `my-accounts', and `other-accounts'. I.e. you can
set:

  compstyle '*:my-accounts' users-hosts user1:host1 user2:host2 ...

This also required some changes to `_combination', of course. I've
changed it to take the first argument as a tag name and the second one 
as the style name. That is supposed to be of the form `foo-bar' to
make `_foo' and `_bar' be tried to supply defaults.

One problem with this is that I haven't even tried to make `compinit'
automatically convert the old parameters to calls to `compstyle'. They 
may not be set yet, and things like that...


Some other small changes:

- Completers now always append their name to the current context.
  Previously they did it only if no context was set up yet.
- I've changed the name of the style `description' to `verbose'. I
  hope you all agree that this makes more sense when thinking about,
  e.g. jobs or processes.
- Then I changed the `accept' style to the hopefully better named
  `max-errors' and made it require full strings instead of the `n' or
  `!' (they are now `numeric' and `not-numeric').
- The `menu' style is boolean for `_oldlist' and for `_expand' it uses 
  strings (not sub-strings) and `show-all' instead of `showall'.
- The `insert' style is renamed to `insert-unambiguous' and is
  boolean.


Ok. Apart from that `fignore' thing, this is everything I want to do
to the styles stuff.

Bye
 Sven

diff -u -r ../zo/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../zo/Doc/Zsh/compsys.yo	Fri Nov 19 15:12:06 1999
+++ Doc/Zsh/compsys.yo	Sat Nov 20 23:25:48 1999
@@ -464,7 +464,7 @@
 and the value of the style for the first matching pattern is used.
 
 For example, many completion functions can generate matches in a
-simple and a verbose form and use the tt(description) style to decide
+simple and a verbose form and use the tt(verbose) style to decide
 which form should be used. To make all such functions always use the
 verbose form one can simply call
 
@@ -472,7 +472,7 @@
 
 in one of the startup files like tt(.zshrc) (after the call to the
 tt(compinit) function). This definition simply means that the
-tt(description) style has tt(yes) as its value in every context.
+tt(verbose) style has tt(yes) as its value in every context.
 
 The completion function for the tt(kill) builtin command uses this
 style to decide if jobs and processes are listed only as job numbers
@@ -523,6 +523,9 @@
 that should be replaced by one of the more generic ones.)
 
 startitem()
+item(tt(accounts))(
+used to look up the tt(users-hosts) style
+)
 item(tt(all-files))(
 for the names of all files
 )
@@ -638,6 +641,9 @@
 item(tt(modules))(
 for modules (e.g. tt(zsh) modules)
 )
+item(tt(my-accounts))(
+used to look up the tt(users-hosts) style
+)
 item(tt(named-directories))(
 for named directories (you wouldn't have guessed that, would you?)
 )
@@ -650,6 +656,9 @@
 item(tt(options))(
 for command options
 )
+item(tt(other-accounts))(
+used to look up the tt(users-hosts) style
+)
 item(tt(packages))(
 for packages (e.g. tt(rpm) packages)
 )
@@ -738,31 +747,6 @@
 them.)
 
 startitem()
-item(tt(accept))(
-This is used by the tt(_approximate) completer function to determine
-the maximum number of errors to accept. The completer will try to
-generate completions by first allowing one error, then two errors, and
-so on, until either a match was found or the maximum number of errors
-given by this style has been reached.
-
-If the value for this style contains a lower- or upper-case `tt(n)', the 
-completer function will take any numeric argument as the
-maximum number of errors allowed. For example, with
-
-example(compstyle ':approximate' accept 2n)
-
-two errors will be allowed if no numeric argument is given. However,
-with a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
-errors are accepted.  Hence with a value of `tt(0n)', no correcting
-completion will be attempted unless a numeric argument is given.
-
-If the value contains `tt(n)' or `tt(N)' and an exclamation mark
-(`tt(!)'), tt(_approximate) will em(not) try to generate corrected
-completions when given a numeric argument, so in this case the number given
-should be greater than zero.  For example, `tt(2n!)' specifies that
-correcting completion with two errors will usually be performed, but if a
-numeric argument is given, correcting completion will not be performed.
-)
 item(tt(arguments))(
 The value of this style is given to the tt(ps) command by functions
 that call it when generating process identifiers as matches.
@@ -820,7 +804,7 @@
 after the first ambiguous pathname component even when menucompletion
 is used.
 )
-item(tt(description))(
+item(tt(verbose))(
 This is used in several contexts to decide if only a simple or a
 verbose list of matches should be generated. For example some commands 
 show descriptions for option names if this style is true.
@@ -864,14 +848,36 @@
 different types will be put in different groups, so that they are
 listed separately and not mixed when using menu completion.
 )
-item(tt(insert))(
-This is used by the tt(_match) completer function. If it is set to a
-string starting with tt(unambig), the tt(_completer) will start menu
+item(tt(groups))(
+A style holding the names of the groups that should be completed. If
+this is not set by the user, the group names from the YP database or
+the file `tt(/etc/group)' will be used.
+)
+item(tt(hosts))(
+A style holding the names of hosts that should be completed. If this
+is not set by the user the hostnames in `tt(/etc/hosts)' will be used.
+)
+item(tt(hosts-ports))(
+This style is used by commands that need or accept hostnames and
+ports. The strings in the value should be of the form
+`var(host)tt(:)var(port)'. These hostnames and ports are completed
+depending on the information already on the line, so that if, for
+example, the hostname is already typed, only those ports will be
+completed for which pairs with the hostname from the line exist.
+)
+item(tt(hosts-ports-users))(
+Like tt(hosts-ports) but used for commands like tt(telnet) and
+containing strings of the form `var(host)tt(:)var(port)tt(:)var(user)' .
+)
+item(tt(insert-unambiguous))(
+This is used by the tt(_match) completer function. If it is set to
+`true', the tt(_completer) will start menu
 completion only if no unambiguous string could be generated that is at
 least as long as the original string from the line.
 )
 item(tt(last-prompt))(
-This is used by the main completion function tt(_main_complete). If it 
+This is used by the main completion function tt(_main_complete) with
+no particular context name. If it 
 is `true', the cursor will always be moved back to the last prompt if
 that is still visible, independent of the setting of the
 tt(ALWAYS_LAST_PROMPT) option.
@@ -927,20 +933,45 @@
 directory name used by a user placing web pages within their home
 area.
 )
+item(tt(max-errors))(
+This is used by the tt(_approximate) completer function to determine
+the maximum number of errors to accept. The completer will try to
+generate completions by first allowing one error, then two errors, and
+so on, until either a match was found or the maximum number of errors
+given by this style has been reached.
+
+If the value for this style contains the string `tt(numeric)', the 
+completer function will take any numeric argument as the
+maximum number of errors allowed. For example, with
+
+example(compstyle ':approximate' accept 2 numeric)
+
+two errors will be allowed if no numeric argument is given. However,
+with a numeric argument of six (as in `tt(ESC-6 TAB)'), up to six
+errors are accepted.  Hence with a value of `tt(0 numeric)', no correcting
+completion will be attempted unless a numeric argument is given.
+
+If the value contains the string `tt(not-numeric)', tt(_approximate)
+will em(not) try to generate corrected
+completions when given a numeric argument, so in this case the number given
+should be greater than zero.  For example, `tt(2 not-numeric)' specifies that
+correcting completion with two errors will usually be performed, but if a
+numeric argument is given, correcting completion will not be performed.
+)
 item(tt(menu))(
 This is used by the tt(_expand) completer. If it is unset or set to
-the empty string, the words resulting from expansion (if any) will
+an empty value, the words resulting from expansion (if any) will
 simply be inserted in the command line, replacing the original
-string. However, if this style is set to a non-empty string, the user
+string. However, if this style is set to a non-empty value, the user
 can cycle through the expansion as in menucompletion. Unless the value
-contains the substring `tt(only)', the user will still be offered all
+contains the string `tt(only)', the user will still be offered all
 expansions at once as one of the strings to insert in the command
 line; normally, this possibility is offered first, but if the value
-contains the substring `tt(last)', it is offered last. Also, if the
-value contains the substring `tt(sort)', the expansions will be sorted
+contains the string `tt(last)', it is offered last. Also, if the
+value contains the string `tt(sort)', the expansions will be sorted
 alphabetically, normally they are kept in the order the expansion
-produced them in. And finally, if the value contains the substring
-`tt(showall)', the string of all words will be shown in the list of
+produced them in. And finally, if the value contains the string
+`tt(show-all)', the string of all words will be shown in the list of
 expansions.
 
 The tt(_oldlist) completer uses this, too. Here it controls how menu
@@ -948,7 +979,7 @@
 user types a standard completion key type such as tt(TAB). The default
 behaviour of tt(_oldlist) is that menu completion always continues
 with the existing list of completions.  If this style is set to
-tt(never), however, a new completion is started if the old list was
+`false', however, a new completion is started if the old list was
 generated by a different completion command (the behaviour without the 
 tt(_oldlist) completer).
 
@@ -962,7 +993,7 @@
 In the tt(_approximate) completer this style is used to specify
 whether the original string on which correcting completion was
 attempted is to be included in the list of possible corrections. If it
-is set to any non-empty string, the original string will be offered
+is set to any non-empty value, the original string will be offered
 when cycling through the completions. Normally it will appear as the
 first string, so that the command line does not change immediately;
 consecutive completion attempts will cycle through the corrected
@@ -1005,6 +1036,11 @@
 tt(colors) tag. Here, the value should be the pathname of a file
 containing color names in the format of an X11 tt(rgb.txt) file.
 )
+item(tt(ports))(
+A style holding the service names of ports to complete. If this is
+not set by the user, the service names from `tt(/etc/services)' will
+be used.
+)
 item(tt(prefix-hidden))(
 This is used when matches with a common prefix are added (e.g. option
 names). If it is `true', this prefix will not be shown in the list of
@@ -1083,6 +1119,26 @@
 substitution will be performed only if given an explicit numeric
 argument other than `tt(1)', as by typing `tt(ESC 2 TAB)'.
 )
+item(tt(users))(
+This may be set to a list of names that should be completed whenever 
+a username is needed. If it is not set or the string on the line
+doesn't match any of the strings in this list, all usernames will be
+completed.
+)
+item(tt(users-hosts))(
+The values of this style should be of the form
+`var(user)tt(:)var(host)'. It is used for commands that need pairs of
+user- and hostnames. For such commands, only the pairs from this style 
+are used and if, for example, the hostname is already typed, then only 
+the hostnames for which there is a pair with that username is defined.
+
+If set for the tt(my-accounts) tag, this is used for commands such as
+tt(rlogin) and tt(ssh). I.e. the style should contain the names of the 
+user's own accounts. With the tt(other-accounts) this is used for
+commands such as tt(talk) and tt(finger) and should contain other
+people's accounts. Finally, this may also used by some commands with
+the tt(accounts) tag.
+)
 item(tt(word))(
 To find out if listing should be performed on its own, the tt(_list)
 completer normally compares the contents of the line with the contents
@@ -1093,72 +1149,6 @@
 )
 enditem()
 
-subsect(Parameters)
-
-These parameters may be set by the user to change the behavior of the
-completion system:
-
-startitem()
-item(tt(users))(
-This may be set to an array of names that should be completed whenever 
-a username is needed. If it is not set or the string on the line
-doesn't match any of the strings in this array, all usernames will be
-completed.
-)
-item(tt(groups))(
-An array holding the names of the groups that should be completed. If
-this is not set by the user, it will automatically be set to a list
-of group names taken from the YP database or the file `tt(/etc/group)'.
-)
-item(tt(hosts))(
-An array holding the names of hosts that should be completed. If this
-is not set by the user it will automatically be set to a list of the
-hostnames in `tt(/etc/hosts)'.
-)
-item(tt(ports))(
-An array holding the service names of ports to complete. If this is
-not set by the user, it will be set to a list of the service names
-from `tt(/etc/services)'.
-)
-item(tt(my_accounts))(
-This array is used for completion of usernames and hostnames for many
-commands, including the tt(ssh) and tt(rlogin) family. It should
-contain elements of the form `var(host)tt(:)var(user)', corresponding
-to the user's own accounts. These pairs will be used to complete names
-of hosts and usernames depending on the information already on the
-line, so that if, for example, the username is already typed, only
-those hostnames will be completed for which pairs with the username
-from the line exist.
-)
-item(tt(other_accounts))(
-Like tt(my_accounts), except that it should contain the usernames and
-hostnames of other people's accounts, for use with commands such as
-tt(talk), tt(ytalk) and tt(finger).
-)
-item(var(command)tt(_accounts))(
-Any of the commands which use the above tt(my_accounts) and
-tt(other_accounts) arrays can have this behaviour overridden by
-specifying a username/hostname array unique to that command.
-For example, if you wanted tt(rcp) to complete usernames and hostnames
-from a different set of accounts, you could set the array
-tt(rcp_accounts) with username/hostname pairs in the same format as
-tt(my_accounts).
-)
-item(tt(telnet_hosts_ports_users))(
-This array is used by the completion function for tt(telnet). It
-should contain elements of the form
-`var(host)tt(:)var(port)tt(:)var(user)'. These triples will be used to 
-complete names of hosts, ports, and usernames depending on the
-information already on the line, so that if, for example, the hostname 
-is already typed, only those ports and usernames will be completed for 
-which triples with the hostname from the line exist.
-)
-item(tt(socket_hosts_ports))(
-Like tt(telnet_hosts_ports_users), but used for the tt(socket) command 
-and containing pairs of hostnames and ports.
-)
-enditem()
-
 texinode(Control Functions)(Bindable Commands)(Completion System Configuration)(Completion System)
 sect(Control Functions)
 cindex(completion system, choosing completers)
@@ -1309,7 +1299,7 @@
 menucompletion allowing you to cycle through these strings.
 
 The exact behavior of this completer can be changed by using the
-styles tt(accept), tt(original), tt(prompt), and tt(insert), see
+styles tt(max-errors), tt(original), tt(prompt), and tt(insert), see
 ifzman(the section `Completion System Configuration' above)\
 ifnzman(noderef(Completion System Configuration)).
 
@@ -1328,8 +1318,8 @@
 For example, with:
 
 example(compstyle '*' completer _complete _correct _approximate
-compstyle ':correct' accept '2n!'
-compstyle ':approximate' accept '3n')
+compstyle ':correct' accept 2 not-numeric'
+compstyle ':approximate' accept 3 numeric)
 
 correction will accept up to two errors. If a numeric argument is
 given, correction will not be performed, but correcting completion
@@ -2265,29 +2255,41 @@
 enditem()
 )
 item(tt(_combination))(
-This function uses a array to represent combinations of completing texts.
-The first argument is a name of the array optionally appended completing
-field names separated by colon.  If it contains no colon, it is assumed
-that the name is formed as `var(prefix)_var(fieldname)_..._var(fieldname)'
-which `var(prefix)' and `var(fieldname)'s does not contain a underscore.
-A each element of the array should be colon-separated completing texts
-which correspond to the field names.  The option `tt(-s) var(sepchar)'
-can be given before the array name to change the delimiter in the array
-element from colon.
-
-Since second argument, zero or more arguments formed as
-`var(fieldname)tt(=)var(pattern)' can be given.  It restricts completion
-candidates from the array by maching a text that corresponds to
-`var(fieldname)' against to `var(pattern)'.  If `tt(:)var(num)' is
-specified between `var(fieldname)' and `tt(=)', `var(num)'th field in
-named as `var(fieldname)' is used instead of the first.
-
-After above arguments, completing field name should be given.  It may have
-suffix `tt(:)var(num)' to use a arbitrary field instead of the first as
-above.
+This function is used to complete combinations of values such as pairs 
+of hostnames and usernames. The possible values will be taken from the 
+style whose name is given as the second argument. The first argument
+is the tag to use to do the lookup.
+
+The style name should consist of multiple parts separated with
+hyphens which are then used as fieldnames. Known values for such
+fields can be given after the second argument in arguments of the form 
+`var(fiels)tt(=)var(pattern)'. The first argument without a equal sign 
+is taken as the name of the field for which completions should be
+generated.
 
-If there are no array element to match all of specified pattern and the
-function `tt(_)var(fieldname)' exists, the function is called.
+The matches generated will be taken from the value of the style. These 
+values should contain the possible values for the combinations where
+the values for the different fields are separated by colons or the
+character given after the tt(-s) option to tt(_combination).
+
+Only the values for the requested fields for which the patterns given
+in the `var(field)tt(=)var(pattern)' match the respective fields in
+the strings from the style value are generated as possible matches.
+
+If no style with the given name is defined for the given tag but a
+function named with the name of the requestd field preceded by an
+underscore is defined, that function will be called to generate the
+matches. This is also done if none of the strings in the value of the
+style match all the patterns given as arguments.
+
+If the same name is used for more than one field, in both the
+`var(field)tt(=)var(pattern)' and the argument that gives the field
+name to complete for, the number of the field (starting with one) may
+be given after the fieldname (separated from it by a colon).
+
+All arguments after the requested fieldname are given to the
+tt(compadd) used (when generating matches from the style value) and to 
+the functions for the fields if they are called.
 )
 enditem()
 
diff -u -r ../zo/Functions/Zle/incremental-complete-word Functions/Zle/incremental-complete-word
--- ../zo/Functions/Zle/incremental-complete-word	Fri Nov 19 15:12:21 1999
+++ Functions/Zle/incremental-complete-word	Sat Nov 20 20:31:44 1999
@@ -18,9 +18,7 @@
 
   local key lbuf="$LBUFFER" rbuf="$RBUFFER" pmpt word
   local lastl lastr wid twid num alt post toolong
-  local curcontext="$curcontext" stop brk
-
-  [[ -z "$curcontext" ]] && curcontext=':incremental'
+  local curcontext="${curcontext}:incremental" stop brk
 
   _style -s '' prompt pmpt || pmpt='incremental (%c): %u%s  %l}'
   _style -s '' stop stop
diff -u -r ../zo/Functions/Zle/predict-on Functions/Zle/predict-on
--- ../zo/Functions/Zle/predict-on	Fri Nov 19 15:12:21 1999
+++ Functions/Zle/predict-on	Sat Nov 20 20:31:31 1999
@@ -53,9 +53,7 @@
 	  unsetopt automenu recexact
 	  integer curs=$CURSOR pos nchar=${#LBUFFER//[^${KEYS[-1]}]}
 	  local -a +h comppostfuncs
-	  local crs curcontext="$curcontext"
-
-	  [[ -z "$curcontext" ] && curcontext=':predict'
+	  local crs curcontext="${curcontext}:predict"
 
 	  comppostfuncs=( predict-limit-list )
 	  zle complete-word
diff -u -r oldcompletion/Base/_combination Completion/Base/_combination
--- oldcompletion/Base/_combination	Mon Nov 22 10:50:18 1999
+++ Completion/Base/_combination	Mon Nov 22 11:09:50 1999
@@ -1,24 +1,26 @@
 #autoload
 
 # Usage:
-#   _combination [-s S] V[:K1:...] Ki1[:Ni1]=Pi1 Ki2[:Ni2]=Pi2 ... Kim[:Nim]=Pim Kj[:Nj] EXPL...
+#   _combination [-s S] TAG STYLE \
+#     Ki1[:Ni1]=Pi1 Ki2[:Ni2]=Pi2 ... Kim[:Nim]=Pim Kj[:Nj] EXPL...
 #
-#  It is assumed that V is formed as PRE_K1_..._Kn if `:K1:...' is not specified.
+#  STYLE should be of the form K1-K2-...-Kn.
 #
 # Example: telnet
 #
-#  Assume an user sets the variable `telnet_hosts_ports_users' as:
+#  Assume an user sets the style `hosts-ports-users' as for the my-accounts
+#  tag:
 #
-#    telnet_hosts_ports_users=(
+#    compstyle '*:telnet*:my-accounts' hosts-ports-users \
 #      host0:: host1::user1 host2::user2
 #      mail-server:{smtp,pop3}:
 #      news-server:nntp:
 #      proxy-server:8000:
-#    )
+# 
 #
-#  `_telnet completes' hosts as:
+#  `_telnet' completes hosts as:
 #
-#    _combination telnet_hosts_ports_users \
+#    _combination my-accounts hosts-ports-users \
 #      ${options[-l]:+users=${options[-l]:q}} \
 #      hosts "$expl[@]"
 #
@@ -28,7 +30,7 @@
 # 
 #  `_telnet' completes ports as:
 #
-#    _combination telnet_hosts_ports_users \
+#    _combination my-accounts hosts-ports-users \
 #      ${options[-l]:+users=${options[-l]:q}} \
 #      hosts="${line[2]:q}" \
 #      ports "$expl[@]"
@@ -39,7 +41,7 @@
 #
 #  `_telnet' completes users for an argument of option `-l' as:
 #
-#    _combination telnet_hosts_ports_users \
+#    _combination my-accounts hosts-ports-users \
 #      ${line[2]:+hosts="${line[2]:q}"} \
 #      ${line[3]:+ports="${line[3]:q}"} \
 #      users "$expl[@]"
@@ -48,7 +50,7 @@
 #  the port argument if they are exist. And if it is failed, `_users' is
 #  called.
 
-local sep var keys pats key num tmp
+local sep tag style keys pats key num tmp
 
 if [[ "$1" = -s ]]; then
   sep="$2"
@@ -57,16 +59,11 @@
   sep=:
 fi
 
-var=$1
-shift
+tag="$1"
+style="$2"
+shift 2
 
-if [[ $var = *:* ]]; then
-  keys=( ${(s/:/)var} )
-  shift keys
-  var="${var%%:*}"
-else
-  keys=( "${(@s:_:)${var#*_}}" )
-fi
+keys=( ${(s/-/)style} )
 pats=( "${(@)keys/*/*}" )
 
 while [[ "$1" = *=* ]]; do
@@ -81,8 +78,8 @@
 num="${${1##*:}:-1}"
 shift
 
-if (( ${(P)+${var}} )); then
-  eval "tmp=( \"\${(@M)${var}:#\${(j($sep))~pats}}\" )"
+if _style -a "$tag" "$style" tmp; then
+  eval "tmp=( \"\${(@M)tmp:#\${(j($sep))~pats}}\" )"
   if (( keys[(in:num:)$key] != 1 )); then
     eval "tmp=( \${tmp#\${(j(${sep}))~\${(@)\${(@)keys[2,(rn:num:)\$key]}/*/*}}$sep} )"
   fi
@@ -92,4 +89,3 @@
 else
   (( $+functions[_$key] )) && "_$key" "$@"
 fi
-
diff -u -r oldcompletion/Base/_describe Completion/Base/_describe
--- oldcompletion/Base/_describe	Mon Nov 22 10:50:18 1999
+++ Completion/Base/_describe	Mon Nov 22 11:09:50 1999
@@ -16,7 +16,7 @@
 
 _tags "$_type" || return 1
 
-_style "$_type" description && _showd=yes
+_style "$_type" verbose && _showd=yes
 
 _description _expl "$1"
 shift
diff -u -r oldcompletion/Base/_jobs Completion/Base/_jobs
--- oldcompletion/Base/_jobs	Mon Nov 22 10:50:19 1999
+++ Completion/Base/_jobs	Mon Nov 22 11:09:50 1999
@@ -6,7 +6,7 @@
 
 _style jobs prefix-needed && [[ "$PREFIX" != %* ]] && return 1
 _style jobs prefix-hidden && pfx=''
-_style jobs description   && desc=yes
+_style jobs verbose       && desc=yes
 
 if [[ "$1" = -r ]]; then
   jids=( "${(@k)jobstates[(R)running*]}" )
diff -u -r oldcompletion/Base/_subscript Completion/Base/_subscript
--- oldcompletion/Base/_subscript	Mon Nov 22 10:50:19 1999
+++ Completion/Base/_subscript	Mon Nov 22 11:09:50 1999
@@ -21,7 +21,7 @@
   while _tags; do
     if _requested indexes -V expl 'array index'; then
       ind=( {1..${#${(P)${compstate[parameter]}}}} )
-      if _style indexes description; then
+      if _style indexes verbose; then
         list=()
         for i in "$ind[@]"; do
           [[ "$i" = ${PREFIX}*${SUFFIX} ]] &&
diff -u -r oldcompletion/Base/_tilde Completion/Base/_tilde
--- oldcompletion/Base/_tilde	Mon Nov 22 10:50:19 1999
+++ Completion/Base/_tilde	Mon Nov 22 11:09:50 1999
@@ -24,7 +24,7 @@
   if _requested directory-stack -V expl 'directory stack' &&
      { ! _style directory-stack prefix-needed ||
        [[ "$PREFIX" = [-+]* ]] }; then
-    if _style directory-stack description; then
+    if _style directory-stack verbose; then
       integer i
 
       lines=("${PWD}" "${dirstack[@]}")
diff -u -r oldcompletion/Builtins/_pids Completion/Builtins/_pids
--- oldcompletion/Builtins/_pids	Mon Nov 22 10:50:21 1999
+++ Completion/Builtins/_pids	Mon Nov 22 11:09:51 1999
@@ -16,7 +16,7 @@
 _style -a ps arguments args
 (( $#listargs )) || listargs=( "$args[@]" )
 
-if _style processes description; then
+if _style processes verbose; then
   list=("${(@Mr:COLUMNS-1:)${(f@)$(ps $listargs 2>/dev/null)}[2,-1]:#[ 	]#${PREFIX}[0-9]#${SUFFIX}[ 	]*${~match}}")
   desc=(-ld list)
 else
diff -u -r oldcompletion/Builtins/_popd Completion/Builtins/_popd
--- oldcompletion/Builtins/_popd	Mon Nov 22 10:50:21 1999
+++ Completion/Builtins/_popd	Mon Nov 22 11:09:51 1999
@@ -13,7 +13,7 @@
 
 ! _style directory-stack prefix-needed || [[ $PREFIX = [-+]* ]] || return 1
 
-if _style directory-stack description; then
+if _style directory-stack verbose; then
   # get the list of directories with their canonical number
   # and turn the lines into an array, removing the current directory
   lines=("${PWD}" "${dirstack[@]}")
diff -u -r oldcompletion/Builtins/_sched Completion/Builtins/_sched
--- oldcompletion/Builtins/_sched	Mon Nov 22 10:50:21 1999
+++ Completion/Builtins/_sched	Mon Nov 22 11:09:51 1999
@@ -7,7 +7,7 @@
     _wanted -C - jobs expl 'scheduled jobs' || return 1
 
     lines=(${(f)"$(sched)"})
-    if _style jobs description; then
+    if _style jobs verbose; then
       disp=( -ld lines )
     else
       disp=()
diff -u -r oldcompletion/Core/_approximate Completion/Core/_approximate
--- oldcompletion/Core/_approximate	Mon Nov 22 10:50:24 1999
+++ Completion/Core/_approximate	Mon Nov 22 11:09:51 1999
@@ -7,7 +7,7 @@
 
 local _comp_correct _correct_prompt comax
 local cfgacc cfgorig cfgps cfgins
-local curcontext="$curcontext" oldcontext
+local curcontext="${curcontext}" oldcontext
 
 # Only if all global matchers have been tried.
 
@@ -17,23 +17,21 @@
 
 [[ "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1
 
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':approximate'
+[[ "$curcontext" != *:correct ]] && curcontext="${curcontext}:approximate"
 
 oldcontext="$curcontext"
 
-_style -s '' accept cfgacc
+_style -s '' max-errors cfgacc
 _style -s '' original cfgorig
 _style -s '' prompt cfgps
 _style -s '' insert cfgins
 
 # Get the number of errors to accept.
 
-if [[ "$cfgacc" = *[nN]* && ${NUMERIC:-1} -ne 1 ]]; then
+if [[ "$cfgacc" = *numeric* && ${NUMERIC:-1} -ne 1 ]]; then
   # Stop if we also have a `!'.
 
-  [[ "$cfgacc" = *\!* ]] && return 1
+  [[ "$cfgacc" = *not-numeric* ]] && return 1
 
   # Prefer the numeric argument if that has a sensible value.
 
diff -u -r oldcompletion/Core/_complete Completion/Core/_complete
--- oldcompletion/Core/_complete	Mon Nov 22 10:50:24 1999
+++ Completion/Core/_complete	Mon Nov 22 11:09:51 1999
@@ -4,11 +4,7 @@
 # a normal completion function, but as one possible value for the
 # completer style.
 
-local comp name curcontext="$curcontext" oldcontext
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':complete'
+local comp name curcontext="${curcontext}:complete" oldcontext
 
 oldcontext="$curcontext"
 
diff -u -r oldcompletion/Core/_correct Completion/Core/_correct
--- oldcompletion/Core/_correct	Mon Nov 22 10:50:24 1999
+++ Completion/Core/_correct	Mon Nov 22 11:09:52 1999
@@ -8,11 +8,7 @@
 # Supported configuration keys are the same as for `_approximate', only
 # starting with `correct'.
 
-local ret=1 opm="$compstate[pattern_match]" curcontext="$curcontext"
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':correct'
+local ret=1 opm="$compstate[pattern_match]" curcontext="${curcontext}:correct"
 
 compstate[pattern_match]='-'
 
diff -u -r oldcompletion/Core/_expand Completion/Core/_expand
--- oldcompletion/Core/_expand	Mon Nov 22 10:50:24 1999
+++ Completion/Core/_expand	Mon Nov 22 11:09:52 1999
@@ -8,11 +8,7 @@
 # word from the line.
 
 local exp word="$PREFIX$SUFFIX" group=-V expl expl2 disp orig menu prompt
-local curcontext="$curcontext" expr descr
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':expand'
+local curcontext="${curcontext}:expand" expr descr
 
 # First, see if we should insert all *completions*.
 
@@ -68,7 +64,7 @@
   expl=(-n)
 fi
 
-if [[ -n "$menu" && "$menu" != *only* && "$menu" = *showall* ]]; then
+if [[ -n "$menu" && "$menu" != *only* && "$menu" = *show-all* ]]; then
   if [[ -n "$descr" ]]; then
     expl2=(-ld disp -X "${descr//\\%d/all words}")
   else
diff -u -r oldcompletion/Core/_list Completion/Core/_list
--- oldcompletion/Core/_list	Mon Nov 22 10:50:24 1999
+++ Completion/Core/_list	Mon Nov 22 11:09:52 1999
@@ -4,11 +4,7 @@
 # insert possible completions only after the list has been shown at
 # least once.
 
-local pre suf curcontext="$curcontext" expr
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':list'
+local pre suf curcontext="${curcontext}:list" expr
 
 # Get the strings to compare.
 
diff -u -r oldcompletion/Core/_main_complete Completion/Core/_main_complete
--- oldcompletion/Core/_main_complete	Mon Nov 22 10:50:25 1999
+++ Completion/Core/_main_complete	Mon Nov 22 11:09:52 1999
@@ -91,7 +91,7 @@
   compadd -UX "${format//\\%d/$str}" -n ''
 fi
 
-_style '' last-prompt always && compstate[last_prompt]=yes
+_style '' last-prompt && compstate[last_prompt]=yes
 
 _lastcomp=( "${(@kv)compstate}" )
 _lastcomp[completer]="$comp"
diff -u -r oldcompletion/Core/_match Completion/Core/_match
--- oldcompletion/Core/_match	Mon Nov 22 10:50:25 1999
+++ Completion/Core/_match	Mon Nov 22 11:09:52 1999
@@ -9,8 +9,8 @@
 # expand-or-complete function because otherwise the pattern will
 # be expanded using globbing.
 
-local tmp opm="$compstate[pattern_match]" ret=0 curcontext="$curcontext"
-local orig ins
+local tmp opm="$compstate[pattern_match]" ret=0 orig ins
+local curcontext="${curcontext}:match"
 
 # Do nothing if we don't have a pattern or there are still global
 # match specifications to try.
@@ -19,12 +19,8 @@
 [[ "$tmp:q" = "$tmp" ||
    compstate[matcher] -ne compstate[total_matchers] ]] && return 1
 
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':match'
-
 _style -s '' original orig
-_style -s '' insert ins
+_style -b '' insert-unambiguous ins
 
 # Try completion without inserting a `*'?
 
@@ -36,7 +32,7 @@
   compstate[matcher]="$compstate[total_matchers]"
 
   if (( ret )); then
-    [[ "$ins" = unambig* &&
+    [[ "$ins" = yes &&
        $#compstate[unambiguous] -ge ${#:-${PREFIX}${SUFFIX}} ]] && 
         compstate[pattern_insert]=unambiguous
     return 0
@@ -53,7 +49,7 @@
 compstate[pattern_match]="$opm"
 compstate[matcher]="$compstate[total_matchers]"
 
-[[ ret -eq 1 && "$ins" = unambig* &&
+[[ ret -eq 1 && "$ins" = yes &&
    $#compstate[unambiguous] -ge ${#:-${PREFIX}${SUFFIX}} ]] && 
     compstate[pattern_insert]=unambiguous
 
diff -u -r oldcompletion/Core/_menu Completion/Core/_menu
--- oldcompletion/Core/_menu	Mon Nov 22 10:50:25 1999
+++ Completion/Core/_menu	Mon Nov 22 11:09:53 1999
@@ -1,10 +1,6 @@
 #autoload
 
-local curcontext="$curcontext"
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':menu'
+local curcontext="${curcontext}:menu"
 
 # This completer is an example showing how menucompletion can be
 # implemented with the new completion system.
diff -u -r oldcompletion/Core/_oldlist Completion/Core/_oldlist
--- oldcompletion/Core/_oldlist	Mon Nov 22 10:50:26 1999
+++ Completion/Core/_oldlist	Mon Nov 22 11:09:53 1999
@@ -1,13 +1,8 @@
 #autoload
 
-local curcontext="$curcontext" list menu
-
-# Probably set initial context.
-
-[[ -z "$curcontext" ]] && curcontext=':oldlist'
+local curcontext="${curcontext}:oldlist" list
 
 _style -s '' list list
-_style -s '' menu menu
 
 # If this is a listing widget and there is already an old list,
 # and either the style :oldlist:list is `always', or it is not `never'
@@ -33,16 +28,12 @@
 fi
 
 # If this is a completion widget, and we have a completion inserted already,
-# and the style :oldlist:menu is not never, then we cycle through the
+# and the style :oldlist:menu is `true', then we cycle through the
 # existing list (even if it was generated by another widget).
 
-if [[ $menu = verbose &&
-      $LASTWIDGET = _verbose_list && $WIDGET != _verbose_list &&
-      -z $compstate[old_insert] &&
-      -n $compstate[old_list] ]]; then
+if [[ -z $compstate[old_insert] && -n $compstate[old_list] ]]; then
   compstate[old_list]=keep
-elif [[ $WIDGET = *complete(|-prefix|-word) &&
-        $menu != (never|verbose) ]]; then
+elif [[ $WIDGET = *complete(|-prefix|-word) ]] && _style '' menu; then
   if [[ -n $compstate[old_insert] ]]; then
     compstate[old_list]=keep
     if [[ $WIDGET = *reverse* ]]; then
diff -u -r oldcompletion/Core/compinit Completion/Core/compinit
--- oldcompletion/Core/compinit	Mon Nov 22 10:50:26 1999
+++ Completion/Core/compinit	Mon Nov 22 11:09:53 1999
@@ -349,10 +349,10 @@
       tmp="'*:urls' local ${${(qqs.:.)val}}"
       ;;
     describe_options)
-      tmp="'*:options' description ${(qq)val}"
+      tmp="'*:options' verbose 'yes'"
       ;;
     describe_values)
-      tmp="'*:values' description ${(qq)val}"
+      tmp="'*:values' verbose 'yes'"
       ;;
     autodescribe_options)
       tmp="'*:options' auto-description ${(qq)val}"
@@ -412,7 +412,7 @@
       tmp="'*' completer ${${(qqs.:.)val}}"
       ;;
     last_prompt)
-      tmp="'*' last-prompt ${(qq)val}"
+      tmp="'*' last-prompt 'yes'"
       ;;
     esac
     [[ -n "$tmp" ]] && style="${style}${cmt}compstyle ${tmp}
@@ -426,11 +426,7 @@
 
 # Very simple interface for setting styles:
 #
-#   compstyle context -styles... context -styles ...
-#
-# Where context is of the form :ctxt-pats:...:tag-pat.
-#
-# This will be improved if needed. Promised.
+#   compstyle pattern style values...
 
 compstyle() {
   local long
@@ -490,7 +486,7 @@
 
 # Default styles. This should be executed conditionally somehow.
 
-compstyle '*'        description   'yes'
+compstyle '*'        verbose       'yes'
 compstyle '*'        prefix-needed 'yes'
 compstyle '*'        prefix-hidden 'no'
 compstyle ':correct' accept        '2n'
diff -u -r oldcompletion/User/_groups Completion/User/_groups
--- oldcompletion/User/_groups	Mon Nov 22 10:50:30 1999
+++ Completion/User/_groups	Mon Nov 22 11:09:53 1999
@@ -1,15 +1,18 @@
 #compdef newgrp
 
-local expl
+local expl groups
 
 _wanted groups expl group || return 1
 
-if (( ! $+groups )); then
-  if (( ${+commands[ypcat]} )); then
-    : ${(A)groups:=${${(s: :)$(ypcat group.byname)}%%:*}} # If you use YP
-  else
-    : ${(A)groups:=${${(s: :)$(</etc/group)}%%:*}}
-  fi
+if ! _style -a groups groups groups; then
+  (( $+_cache_groups )) ||
+      if (( ${+commands[ypcat]} )); then
+        : ${(A)_cache_groups:=${${(s: :)$(ypcat group.byname)}%%:*}} # If you use YP
+      else
+        : ${(A)_cache_groups:=${${(s: :)$(</etc/group)}%%:*}}
+      fi
+
+  groups=( "$_cache_groups[@]" )
 fi
 
-compadd "$@" "$expl[@]" - $groups
+compadd "$@" "$expl[@]" - "$groups[@]"
diff -u -r oldcompletion/User/_hosts Completion/User/_hosts
--- oldcompletion/User/_hosts	Mon Nov 22 10:50:30 1999
+++ Completion/User/_hosts	Mon Nov 22 11:09:54 1999
@@ -1,8 +1,13 @@
 #compdef ftp ncftp ping rwho rup xping traceroute host
 
-local expl
+local expl hosts
 
-: ${(A)hosts:=${(s: :)${(ps:\t:)${${(f)"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}}
+if ! _style -a hosts hosts hosts; then
+  (( $+_cache_hosts )) ||
+      : ${(A)_cache_hosts:=${(s: :)${(ps:\t:)${${(f)"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}}
+
+  hosts=( "$_cache_hosts[@]" )
+fi
 
 _wanted hosts expl host &&
     compadd -M 'm:{a-zA-Z}={A-Za-z} r:|.=* r:|=*' "$@" "$expl[@]" - "$hosts[@]"
diff -u -r oldcompletion/User/_my_accounts Completion/User/_my_accounts
--- oldcompletion/User/_my_accounts	Mon Nov 22 10:50:31 1999
+++ Completion/User/_my_accounts	Mon Nov 22 11:09:54 1999
@@ -1,13 +1,3 @@
 #autoload
 
-local accounts_users_hosts
-
-local varname="$words[1]_accounts"
-
-if [[ ${(P)+varname} -eq 1 ]]; then
-  accounts_users_hosts=( ${(P)varname} )
-else
-  accounts_users_hosts=( $my_accounts )
-fi
-
-_user_at_host "$@"
+_user_at_host -t my-accounts "$@"
diff -u -r oldcompletion/User/_other_accounts Completion/User/_other_accounts
--- oldcompletion/User/_other_accounts	Mon Nov 22 10:50:31 1999
+++ Completion/User/_other_accounts	Mon Nov 22 11:09:54 1999
@@ -1,13 +1,3 @@
 #compdef talk ntalk ytalk finger
 
-local accounts_users_hosts
-
-local varname="$words[1]_accounts"
-
-if [[ ${(P)+varname} -eq 1 ]]; then
-  accounts_users_hosts=( ${(P)varname} )
-else
-  accounts_users_hosts=( $other_accounts )
-fi
-
-_user_at_host "$@"
+_user_at_host -t other-accounts "$@"
diff -u -r oldcompletion/User/_ports Completion/User/_ports
--- oldcompletion/User/_ports	Mon Nov 22 10:50:32 1999
+++ Completion/User/_ports	Mon Nov 22 11:09:54 1999
@@ -1,7 +1,12 @@
 #autoload
 
-local expl
+local expl ports
 
-: ${(A)ports:=${${(M)${${(f)"$(</etc/services)"}:#\#*}#*/tcp}%%[ 	]*}}
+if ! _style ports ports ports; then
+  (( $+_cache_ports )) ||
+      : ${(A)ports:=${${(M)${${(f)"$(</etc/services)"}:#\#*}#*/tcp}%%[ 	]*}}
+
+  ports=( "$_cache_ports[@]" )
+fi
 
 _wanted ports expl port && compadd "$@" "$expl[@]" - "$ports[@]"
diff -u -r oldcompletion/User/_rlogin Completion/User/_rlogin
--- oldcompletion/User/_rlogin	Mon Nov 22 10:50:32 1999
+++ Completion/User/_rlogin	Mon Nov 22 11:21:43 1999
@@ -1,16 +1,6 @@
 #compdef rlogin rsh remsh rcp
 
 _rlogin () {
-  local accounts_users_hosts
-
-  local varname="$words[1]_accounts"
-
-  if (( ${(P)+varname} )); then
-    accounts_users_hosts=( ${(P)varname} )
-  else
-    accounts_users_hosts=( $my_accounts )
-  fi
-
   case "$words[1]" in
   rlogin)
     _arguments -s \
@@ -64,21 +54,21 @@
 }
 
 _rlogin_users () {
-  _tags users && _combination accounts_users_hosts users "$@"
+  _tags users && _combination my-accounts users-hosts users "$@"
 }
 
 _rlogin_hosts () {
   _tags hosts &&
       if [[ "$IPREFIX" == *@ ]]; then
-        _combination accounts_users_hosts "users=${IPREFIX/@}" hosts "$@"
+        _combination my-accounts users-hosts "users=${IPREFIX/@}" hosts "$@"
       else
-        _combination accounts_users_hosts \
+        _combination my-accounts users-hosts \
             ${opt_args[-l]:+"users=${opt_args[-l]:q}"} hosts "$@"
       fi
 }
 
 _rlogin_all_hosts () {
-  _tags hosts && _combination accounts_users_hosts hosts "$@"
+  _tags hosts && _combination my-accounts users-hosts hosts "$@"
 }
 
 _rlogin "$@"
diff -u -r oldcompletion/User/_socket Completion/User/_socket
--- oldcompletion/User/_socket	Mon Nov 22 10:50:32 1999
+++ Completion/User/_socket	Mon Nov 22 11:18:02 1999
@@ -1,9 +1,9 @@
 #compdef socket
 
-# Parameter used:
+# Style used:
 #
-#  socket_hosts_ports
-#    The array that contains paris `host:port'.
+#  hosts-ports
+#    The style that contains pairs `host:port'.
 
 local curcontext="$curcontext" state line expl
 typeset -A opt_args
@@ -41,14 +41,14 @@
     _wanted ports expl 'port to listen' && _ports "$expl[@]"
   else
     _wanted hosts expl 'host' &&
-        _combination socket_hosts_ports hosts "$expl[@]"
+        _combination '' hosts-ports hosts "$expl[@]"
   fi
   ;;
 
 arg2)
   if (( ! $+opt_args[-s] )); then
     _wanted ports expl 'port to connect' &&
-        _combination socket_hosts_ports hosts="${line[2]:q}" ports "$expl[@]"
+        _combination '' hosts-ports hosts="${line[2]:q}" ports "$expl[@]"
   fi
   ;;
 esac
diff -u -r oldcompletion/User/_ssh Completion/User/_ssh
--- oldcompletion/User/_ssh	Mon Nov 22 10:50:32 1999
+++ Completion/User/_ssh	Mon Nov 22 11:17:02 1999
@@ -4,16 +4,6 @@
   local curcontext="$curcontext" state lstate line ret=1 expl args tmp
   typeset -A opt_args
 
-  local accounts_users_hosts
-
-  local varname="$words[1]_accounts"
-
-  if (( ${(P)+varname} )); then
-    accounts_users_hosts=( ${(P)varname} )
-  else
-    accounts_users_hosts=( $my_accounts )
-  fi
-
   args=()
 
   # ssh-opt is a pseudo-command used to complete ssh options for `scp -o'.
@@ -227,14 +217,14 @@
 }
 
 _ssh_users () {
-  _combination accounts_users_hosts users "$@"
+  _combination my-accounts users-hosts users "$@"
 }
 
 _ssh_hosts () {
   if [[ "$IPREFIX" == *@ ]]; then
-    _combination accounts_users_hosts "users=${IPREFIX/@}" hosts "$@"
+    _combination my-accounts users-hosts "users=${IPREFIX/@}" hosts "$@"
   else
-    _combination accounts_users_hosts \
+    _combination my-accounts users-hosts \
       ${opt_args[-l]:+"users=${opt_args[-l]:q}"} hosts "$@"
   fi
 }
diff -u -r oldcompletion/User/_telnet Completion/User/_telnet
--- oldcompletion/User/_telnet	Mon Nov 22 10:50:33 1999
+++ Completion/User/_telnet	Mon Nov 22 11:17:43 1999
@@ -64,14 +64,14 @@
 case "$state" in
 hosts)
   _wanted hosts expl host &&
-      _combination telnet_hosts_ports_users \
+      _combination '' hosts-ports-users \
           ${opt_args[-l]:+users=${opt_args[-l]:q}} \
           hosts "$expl[@]"
   ;;
 
 ports)
   _wanted ports expl port &&
-      _combination telnet_hosts_ports_users \
+      _combination '' hosts-ports-users \
           ${opt_args[-l]:+users=${opt_args[-l]:q}} \
           hosts="${line[2]:q}" \
           ports "$expl[@]"
@@ -79,7 +79,7 @@
 
 users)
   _wanted users expl user &&
-      _combination telnet_hosts_ports_users \
+      _combination '' hosts-ports-users \
       ${line[2]:+hosts="${line[2]:q}"} \
       ${line[3]:+ports="${line[3]:q}"} \
       users "$expl[@]"
diff -u -r oldcompletion/User/_user_at_host Completion/User/_user_at_host
--- oldcompletion/User/_user_at_host	Mon Nov 22 10:50:33 1999
+++ Completion/User/_user_at_host	Mon Nov 22 11:18:27 1999
@@ -1,13 +1,30 @@
 #autoload
 
+# Complete user/host combinations. Normally this looks for the style
+# `users-hosts' for the tag `accounts'. A different tag may be given
+# with `-t tag'.
+# A `-' or `--' as the first argument is ignored.
+
+local tag=accounts
+
+if [[ "$1" = -t?* ]]; then
+  tag="${1[3,-1]}"
+  shift
+elif [[ "$1" = -t ]]; then
+  tag="$2"
+  shift 2
+fi
+
+[[ "$1" = -(|-) ]] && shift
+
 if [[ -prefix 1 *@ ]]; then
-  local user=${PREFIX/@}
+  local user=${PREFIX%%@*}
 
   compset -P 1 '*@'
 
   _wanted -C user-at hosts expl "host for $user" &&
-      _combination accounts_users_hosts users="$user" hosts "$expl[@]" "$@"
+      _combination "${tag}" users-hosts users="$user" hosts "$expl[@]" "$@"
 else
   _wanted users expl "user" &&
-      _combination accounts_users_hosts users -S@ -q "$expl[@]" "$@"
+      _combination "${tag}" users-hosts users -S@ -q "$expl[@]" "$@"
 fi
diff -u -r oldcompletion/User/_users Completion/User/_users
--- oldcompletion/User/_users	Mon Nov 22 10:50:33 1999
+++ Completion/User/_users	Mon Nov 22 11:09:56 1999
@@ -3,11 +3,11 @@
 # If a parameter `users' exists and it is an array, we first try to
 # complete only to its elements.
 
-local expl
+local expl users
 
 _wanted users expl user || return 1
 
-[[ "${(t)users}" = *array* ]] &&
+_style -a users users users &&
     compadd "$expl[@]" "$@" - "$users[@]" && return 0
 
 compadd "$@" "$expl[@]" - "${(@k)userdirs}"

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

