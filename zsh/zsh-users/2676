From zsh-users-return-2676-mason-zsh=primenet.com.au@sunsite.auc.dk Tue Oct 12 16:01:55 1999
Return-Path: <zsh-users-return-2676-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 9776 invoked from network); 12 Oct 1999 16:01:54 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Oct 1999 16:01:54 -0000
Received: (qmail 23315 invoked by alias); 12 Oct 1999 15:59:46 -0000
Mailing-List: contact zsh-users-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.auc.dk
X-Seq: 2676
Received: (qmail 23301 invoked from network); 12 Oct 1999 15:59:40 -0000
From: "Bart Schaefer" <schaefer@candle.brasslantern.com>
Message-Id: <991012155901.ZM9091@candle.brasslantern.com>
Date: Tue, 12 Oct 1999 15:59:01 +0000
In-Reply-To: <Pine.LNX.4.10.9910120601180.1839-100000@divine.city.tvnet.hu>
Comments: In reply to Szabolcs Szakacsits <szaka@sienet.hu>
        "Running N jobs from M all the time" (Oct 12,  6:38am)
References: <Pine.LNX.4.10.9910120601180.1839-100000@divine.city.tvnet.hu>
X-Mailer: Z-Mail (5.0.0 30July97)
To: Szabolcs Szakacsits <szaka@sienet.hu>, zsh-users@sunsite.auc.dk
Subject: Re: Running N jobs from M all the time
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

On Oct 12,  6:38am, Szabolcs Szakacsits wrote:
} Subject: Running N jobs from M all the time
}
} My question would be there is an easy way for $SUBJECT?

If I'm understanding you correctly, you want to do something like

repeat 1000 do
    if (( number_of_jobs >= number_of_processors )); then
	wait $any_job
    fi
    command &
done

And the complaint is that "wait" can only wait for one specific job or
for all of them, not for "the next one that exits."

} I know this can be done with ps, grep, wait, etc but a bit painful and
} not elegant/modern I'd like to use a cleaner way.

You've just discovered another use for the coprocess.  The rest of this
is just standard parallel programming stuff.

function run_parallel {
    # Runs N copies of command at once until M copies have run.

    emulate -L zsh
    if (( $# < 3 )); then
	print "usage: run_parallel N M command [args ...]" >&2
	return 1
    fi

    integer N=$1 M=$2
    shift 2

    if ((M <= N)); then
	repeat $M do $==* & done
	wait
    else
	# Set up a loop to read and write one byte at a time.  This
	# semaphores between the parallel children and the parent zsh.  
	# It's important to pass exactly one byte here and not rely on
	# reading complete lines, lest a race condition develop.

	# Unfortunately, a race still can occur, it's just less likely.
	# Maybe SMP systems are better about multiple writers on one FD?

	coproc while ((--M > 0)) && read -u0k; do print -n .; done

	# Start the first N children

	repeat $N do
	    ((--M))
	    { $==* ; print -np . } &
	done

	# Wait for the semaphore from each child and start another as
	# soon as we get it, up to M children.

	while ((--M > 0)) && read -pk; do
	    { $==* ; print -np . } &
	done

	# Wait for the last N semaphores.

	repeat $N do read -pk; done
    fi

    return $?
}

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

