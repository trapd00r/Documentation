### vim:ft=zsh:foldmethod=marker

### zrcautoload(): a wrapper for autoload
function zrcautoload() {
    setopt local_options
    setopt extended_glob
    local fdir ffile
    local -i ffound
    ffile=${1}
    (( found = 0 ))
    for fdir in ${fpath} ; do
        [[ -e ${fdir}/${ffile} ]] && (( ffound = 1 )) && break
    done
    if (( ffound == 0 )) ; then
        zprintf 2 "  zrcautoload: cannot find %s\n" ${ffile}
        return 1
    fi
    zprintf 3 "  zrcautoload: loading %s\n" ${ffile}
    if zis_316 "atleast" ; then
        autoload -U ${ffile} || return 1
    else
        autoload ${ffile}    || return 1
    fi
    return 0
}

### zrcbindkey(): wrapper for bindkey and $key[]
# Let's document this a little, since it's become non-trivial:
#
# zrcbindkey [-W|-M <m-arg>|-s] keysym action
#
# The M and s options are passed to the bindkey builtin. See its documentation
# for details. The -W option is handled by the wrapper. When used, zrcbindkey
# checks whether the widget in question is available before trying to bind the
# key(-combination). If the widget could not be found, the wrapper returns 2.
#
# The keysym arg can be a combination of one or two entries from the $key hash.
# To list these, use zrclistkeys().
#
# Examples: Ctrl-x-f, Ctrl-x-Ctrl-f, Alt-Enter, PageUp
function zrcbindkey() {

    zis_317 "atleast" || return 3

    setopt localoptions extendedglob noksharrays #xtrace
    local -i check
    local keysym sym2 wid
    local -a keysyms opts wopt

    zparseopts -E 'M:=opts' 's=opts'
    zparseopts -E -D 'W=wopt'
    (( ${#wopt} )) && (( check = 1 ))

    keysyms=()
    keysym=${argv[-2]}
    [[ ${keysym} == (#b)(Ctrl-?|Alt-)-(*) ]] && \
        keysyms=(${match})

    wid=${argv[-1]}

    if (( check > 0 )) ; then
        [[ -z ${widgets[$wid]} ]] && return 2
    fi

    if [[ -n ${keysyms[1]} ]] || [[ -n ${key[$keysym]} ]] ; then
        if (( ${#keysyms} > 0 )) then
            [[ -n ${key[${keysyms[2]}]} ]] && \
                sym2=${key[${keysyms[2]}]} || \
                sym2=${keysyms[2]}

            builtin bindkey ${opts} ${key[${keysyms[1]}]}${sym2} ${wid}
            return $?
        fi
        builtin bindkey ${opts} ${key[$keysym]} ${wid}
        return $?
    fi

    if (( check > 0 )) ; then
        builtin bindkey "${@}"
        return $?
    fi

    return 1
}

### zrcmodload(): wrapper for zmodload (tests ${module_path})
function zrcmodload() {
    zis_317 "atleast" || return 4
    #setopt localoptions xtrace
    local opts mod matches good

    opts=() ; (( good = 0 ))
    while [[ $1 == -* ]] ; do
        opts=( ${opts} $1 )
        shift
    done
    mod=${1}
    shift

    if [[ ${modules[$mod]} == 'loaded' ]] ; then
        zprintf 3 "   zrcmodload: already loaded: %s - Skipping.\n" ${mod}
        return 0
    fi

    if [[ ${mod} == zsh/* ]] || [[ ${mod} == 'compctl' ]] ; then
        (( good = 1 ))
    fi

    if (( good == 0 )) ; then
        zprintf 0 'Failed to handle call: zrcmodload %s %s %s\n' "${opts}" "${mod}" "${(j: :)@}"
        return 3
    fi

    matches=( ${^module_path}/${mod}.(so|dll)(N) )
    (( ${#matches} == 0 )) && return 2

    zprintf 3 "   zrcmodload: loading %s\n" ${mod}
    zmodload "${opts[@]}" ${mod} "$@"
    return $?
}
