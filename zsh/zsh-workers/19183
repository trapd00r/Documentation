From zsh-workers-return-19183-mason-zsh=primenet.com.au@sunsite.dk Mon Oct 13 12:00:40 2003
Return-Path: <zsh-workers-return-19183-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7570 invoked from network); 13 Oct 2003 12:00:39 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 13 Oct 2003 12:00:39 -0000
Received: (qmail 13390 invoked by alias); 13 Oct 2003 12:00:27 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 19183
Received: (qmail 13327 invoked from network); 13 Oct 2003 12:00:26 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 13 Oct 2003 12:00:26 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [62.189.183.235] by sunsite.dk (MessageWall 1.0.8) with SMTP; 13 Oct 2003 12:0:26 -0000
Received: from EXCHANGE02.csr.com (unverified) by MAILSWEEPER01.cambridgesiliconradio.com
 (Content Technologies SMTPRS 4.3.10) with ESMTP id <T6541efce34c0a88d01530@MAILSWEEPER01.cambridgesiliconradio.com> for <zsh-workers@sunsite.dk>;
 Mon, 13 Oct 2003 12:58:51 +0100
Received: from csr.com ([192.168.144.127]) by EXCHANGE02.csr.com with Microsoft SMTPSVC(5.0.2195.5329);
	 Mon, 13 Oct 2003 13:00:49 +0100
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: Re: delete-word does not delete the entire word... 
In-reply-to: "Peter Stephenson"'s message of "Mon, 13 Oct 2003 11:04:08 BST."
             <3762.1066039448@csr.com> 
Date: Mon, 13 Oct 2003 13:00:13 +0100
Message-ID: <27413.1066046413@csr.com>
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 13 Oct 2003 12:00:49.0625 (UTC) FILETIME=[A4AF0C90:01C39181]

Despite the underwhelming response, here is delete-whole-word-match.  It
will now do the right thing if you define it as a `kill' widget (in
principle, the other -match widgets could have a similar treatment, only
in reverse).

Index: Doc/Zsh/contrib.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/contrib.yo,v
retrieving revision 1.29
diff -u -r1.29 contrib.yo
--- Doc/Zsh/contrib.yo	16 Sep 2003 00:43:42 -0000	1.29
+++ Doc/Zsh/contrib.yo	13 Oct 2003 11:56:08 -0000
@@ -484,6 +484,21 @@
 the var(X) of tt(foo)var(X)tt(bar), where var(X) can be any character, then
 the resulting expression is tt(bar)var(X)tt(foo).
 
+Here are some examples of use of the styles, actually taken from the
+simplified interface in tt(select-word-style):
+
+example(zstyle ':zle:*' word-style standard
+zstyle ':zle:*' word-chars '')
+
+Implements bash-style word handling for all widgets, i.e. only
+alphanumerics are word characters; equivalent to setting
+the parameter tt(WORDCHARS) empty for the given context.
+
+example(style ':zle:*kill*' word-style space)
+
+Uses space-delimited words for widgets with the word `kill' in the name.
+Neither of the styles tt(word-chars) nor tt(word-class) is used in this case.
+
 The word matching and all the handling of tt(zstyle) settings is actually
 implemented by the function tt(match-words-by-style).  This can be used to
 create new user-defined widgets.  The calling function should set the local
@@ -498,6 +513,22 @@
 non-word characters following that word (7) the remainder of the line.  Any
 of the elements may be an empty string; the calling function should test
 for this to decide whether it can perform its function.
+)
+tindex(delete-whole-word-match)
+item(tt(delete-whole-word-match))(
+This is another function which works like the tt(-match) functions
+described immediately above, i.e. using styles to decide the word
+boundaries.  However, it is not a replacement for any existing function.
+
+The basic behaviour is to delete the word around the cursor.  There is no
+numeric prefix handling; only the single word around the cursor is
+considered.  If the widget contains the string tt(kill), the removed text
+will be placed in the cutbuffer for future yanking.  This can be obtained
+by defining tt(kill-whole-word-match) as follows:
+
+example(zle -N kill-whole-word-match delete-whole-word-match)
+
+and then binding the widget tt(kill-whole-word-match).
 )
 tindex(copy-earlier-word)
 item(tt(copy-earlier-word))(
Index: Functions/Zle/delete-whole-word-match
===================================================================
RCS file: Functions/Zle/delete-whole-word-match
diff -N Functions/Zle/delete-whole-word-match
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ Functions/Zle/delete-whole-word-match	13 Oct 2003 11:56:08 -0000
@@ -0,0 +1,56 @@
+# Delete the entire word around the cursor.  Does not handle
+# a prefix argument; either the cursor is in the word or it isn't.
+# The word may be just before the cursor, e.g.
+#   print this is a line
+#             ^ here
+# and then the word before (i.e. `this') will be deleted.
+#
+# If the widget has the name `kill' in, the text deleted will be
+# saved for future yanking in the normal way.
+
+emulate -L zsh
+setopt extendedglob
+
+local curcontext=:zle:delete-whole-word
+local -a matched_words
+# Start and end of range of characters to remove.
+integer pos1 pos2
+
+autoload -U match-words-by-style
+match-words-by-style
+
+if [[ -n "${matched_words[3]}" ]]; then
+    # There's whitespace before the cursor, so the word we are deleting
+    # starts at the cursor position.
+    pos1=$CURSOR
+else
+    # No whitespace before us, so delete any wordcharacters there.
+    pos1="${#matched_words[1]}"
+fi
+
+if [[ -n "${matched_words[4]}" ]]; then
+    # There's whitespace at the cursor position, so only delete
+    # up to the cursor position.
+    pos2=$CURSOR
+else
+    # No whitespace at the cursor position, so delete the
+    # current character and any following wordcharacters.
+    (( pos2 = CURSOR + ${#matched_words[5]} + 1 ))
+fi
+
+# Move the cursor then delete the block in one go for the
+# purpose of undoing (and yanking, if appropriate).
+(( CURSOR = pos1 ))
+
+# If the widget name includes the word `kill', the removed
+# text goes into the cutbuffer in the standard way.
+if [[ $WIDGET = *kill* ]]; then
+  local word="${BUFFER[pos1+1,pos2-1]}"
+  if [[ $LASTWIDGET = *kill* ]]; then
+    CUTBUFFER="$CUTBUFFER$word"
+  else
+    killring=("$CUTBUFFER" "${(@)killring[1,-2]}")
+    CUTBUFFER=$word
+  fi
+fi
+BUFFER="${BUFFER[1,pos1]}${BUFFER[pos2,-1]}"

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR Ltd., Science Park, Milton Road,
Cambridge, CB4 0WH, UK                          Tel: +44 (0)1223 692070


**********************************************************************
The information transmitted is intended only for the person or
entity to which it is addressed and may contain confidential 
and/or privileged material. 
Any review, retransmission, dissemination or other use of, or
taking of any action in reliance upon, this information by 
persons or entities other than the intended recipient is 
prohibited.  
If you received this in error, please contact the sender and 
delete the material from any computer.
**********************************************************************

