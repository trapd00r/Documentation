From zsh-workers-request@euclid.skiles.gatech.edu Mon Aug 04 14:37:02 1997
Return-Path: <zsh-workers-request@euclid.skiles.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 19248 invoked from network); 4 Aug 1997 14:36:59 -0000
Received: from euclid.skiles.gatech.edu (list@130.207.146.50)
  by coral.primenet.com.au with SMTP; 4 Aug 1997 14:36:59 -0000
Received: (from list@localhost)
	by euclid.skiles.gatech.edu (8.8.5/8.8.5) id KAA02882;
	Mon, 4 Aug 1997 10:28:14 -0400 (EDT)
Resent-Date: Mon, 4 Aug 1997 10:28:14 -0400 (EDT)
Date: Mon, 4 Aug 1997 18:28:41 +0400 (MSD)
From: Andrej Borsenkow <borsenkow.msk@sni.de>
X-Sender: bor@itsrm1
Reply-To: borsenkow.msk@sni.de
To: Zoltan Hidvegi <hzoli@frontiernet.net>
cc: Zsh hacking and development <zsh-workers@math.gatech.edu>
Subject: Re: RC_EXPAND_PARAM final patch
In-Reply-To: <199708020727.DAA03172@hzoli.home>
Message-ID: <Pine.SV4.3.95.970804175029.1545D-100000@itsrm1>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Resent-Message-ID: <"iq_cj.0.wi.zRUvp"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3414
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

On Sat, 2 Aug 1997, Zoltan Hidvegi wrote:

> 
> This is consistent, predictable, and the implementation is simple.
> 

Totally agreed. If I get it right, the patch does following:
  make substitutions (converting $^a into {a[1],a[2],...}
  word-split the result (it can result in lists in {...} being extended
    if SH_WORD_SPLIT is set)
  make brace expansion in each word (with implicit word splitting)

Correct? Could anybody with better English ;) add description of how ZSH
relly works to zshexpn(1)? 

> There is still one point where the behaviour might be surprising: that's
> when the (e) substitution flag is used:
> 
> % echo ${x}1${(e)^a}2${x}
> x y1a2x y y1b2x y
> 
> With the (e) flag, the behaviour is the same as it was with
> zsh-2.6-beta16 and earlier.  This is related to this behaviour:
> 
> % integer i=0
> % foo=('$[i++]' '$[i++]')
> % echo a${(e)^foo}b${(e)foo} 
> a0b1 2 a3b4 5
> 
> Here a${(e)^foo}b${(e)foo} is substituted to two identical
> a$[i++]b${(e)foo} arguments, and substitution for these arguments is
> started from the beginning.

It is the most surprising thing I ever seen in ZSH!!! _NO_ word in manuals
ever suggested such interpretation. I was always shure that 
${(e)a} just gets recursivly expanded, which is what I call consistent and
predictable ;-) Consider

a=('$[i++]' '$[i++]')
i=0
echo ${(e)^a}${(e)a}
01 2 34 5
i=0
echo ${(e)a}${(e)^a}
0 12 13

I hardly can call it `consistent'. If every expression were evaluated
first, we would get '02 12 3' and '0 12 13' which _is_ predictable - every
${...} is evaluated and combined using well-known rules.

Honestly speaking, how would you describe current behaviour in plain
words?

                              This is exatly the zsh-2.6-beta16 behaviour.
> This can be (or maybe, should be) changed, but that would require much
> more complicated changes. 

I understand, why it was implemented this way, but what's wrong with just
calling stringsubst for the result of ${(e)...} expansion?

                             Since most people probably do not even know
> about the (e) flag, this would not affect too many scripts.  

But if anybody would like to use it, he needs clear picture what to expect
(I still have to find out most things by trial-and-error :(

-------------------------------------------------------------------------
Andrej Borsenkow 		Fax:   +7 (095) 252 01 05
SNI ITS Moscow			Tel:   +7 (095) 252 13 88

NERV:  borsenkow.msk		E-Mail: borsenkow.msk@sni.de
-------------------------------------------------------------------------



