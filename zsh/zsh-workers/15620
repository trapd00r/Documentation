From zsh-workers-return-15620-mason-zsh=primenet.com.au@sunsite.dk Tue Aug 14 09:25:11 2001
Return-Path: <zsh-workers-return-15620-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27991 invoked from network); 14 Aug 2001 09:25:10 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 14 Aug 2001 09:25:10 -0000
Received: (qmail 21416 invoked by alias); 14 Aug 2001 09:25:01 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 15620
Received: (qmail 21397 invoked from network); 14 Aug 2001 09:25:00 -0000
From: martin.ebourne@arcordia.com
Subject: PATCH: Re: Delaying menu completion
To: Bart Schaefer <schaefer@brasslantern.com>
Cc: zsh-workers@sunsite.dk
Date: Tue, 14 Aug 2001 10:21:55 +0100
Message-ID: <OF282F56AE.F70B2E05-ON80256AA8.002E05E6@uk.jpmorgan.com>
X-MIMETrack: Serialize by Router on LON-ARCMTA-01/ARCORDIA(Release 5.0.3 (Intl)|21 March
 2000) at 08/14/2001 10:21:58 AM
MIME-Version: 1.0
Content-type: text/plain; charset=us-ascii





> On Aug 13,  6:53pm, martin.ebourne@arcordia.com wrote:
> } Problem 1
>    zstyle ':completion::match:*' insert-unambiguous pattern
>    zstyle ':completion::approximate*:*' insert-unambiguous yes
>

I had previously tried all sorts of things including (I thought) the above,
but I mostly concentrated on _approximate (since normally you at least
expect match to happen - if set to match-original only, at least).

It turns out that the match line above is exactly what I want, so that's
good. However for approximate there's...

> The caveat I mentioned is that _approximate has this strange test in it:
>     [[ "${#compstate[unambiguous]}" -ge "${#:-$PREFIX$SUFFIX}" ]]
> That means that the unambiguous prefix must be longer than the word on
> the command line.  I.e., there's no way to prevent it dropping into
> menu completion unless all the matches have a common prefix longer than
> what's on the line right now.  I don't remember what that was supposed
> to accomplish, but it seems a rather unlikely situation.  Sven?

I had previously discovered this and tried removing that condition but it
still didn't work properly. However, armed with the now working match above
I've managed to get it to do what I want. With the patch below, I can set
insert-unambiguous to 'always' and then it never enters menu completion,
which is exactly what I'm after.

Someone will need to check the patch because I don't fully understand
what's going on - its a combination of cut & paste and trial & error coding
in there. ;)

Whether 'always' is the best choice I also leave to someone else. Perhaps
'only' may make more sense.

> } Problem 2
> Unfortunately $compstate[old_list] is not available until after you
> enter one of the completion widgets, so you're going to need a helper
> function of some kind, that will be used as the non-menu completion
> widget, and that sets a global variable that can be tested in place
> of $compstate when you invoke _menu_or_down.

Ah, yes, that's what I needed. Given this I tried:

   _is_completing() {
     [[ $compstate[old_list] == shown ]]
   }

   _menu_or_down() {
     if zle is-completing
     then
       zle menu-complete
     else
       zle .history-beginning-search-forward
     fi
   }

   zle -C is-completing complete-word _is_completing
   zle -N menu-or-down _menu_or_down

   bindkey "^[[B" menu-or-down
But 'zle is-completing' wasn't giving the return code (although the info
pages say it will). Given that you already mention the global variable I
guess you may be aware of a caveat for this with completion widgets.
Anyhow, this modification does what I want:

   _is_completing() {
     [[ $compstate[old_list] == shown ]] && _completing=1
   }

   _menu_or_down() {
     integer _completing=0
     zle is-completing
     if (( _completing ))
     then
       zle menu-complete
     else
       zle .history-beginning-search-forward
     fi
   }

Thanks for the help Bart... Things are working just right now and I like it
already.

Cheers,

Martin.


--- Completion/Base/Completer/_approximate.orig    Thu Jun 28 17:06:51 2001
+++ Completion/Base/Completer/_approximate    Tue Aug 14 10:02:17 2001
@@ -10,7 +10,7 @@

 [[ _matcher_num -gt 1 || "${#:-$PREFIX$SUFFIX}" -le 1 ]] && return 1

-local _comp_correct _correct_expl comax cfgacc match
+local _comp_correct _correct_expl comax cfgacc match ins
 local oldcontext="${curcontext}" opm="$compstate[pattern_match]"

 if [[ "$1" = -a* ]]; then
@@ -74,9 +74,17 @@
                "e:$_comp_correct" "o:$PREFIX$SUFFIX"

   if _complete; then
-    if zstyle -t ":completion:${curcontext}:" insert-unambiguous &&
-       [[ "${#compstate[unambiguous]}" -ge "${#:-$PREFIX$SUFFIX}" ]]; then
+    zstyle -s ":completion:${curcontext}:" insert-unambiguous ins
+
+    if [[ "$ins" = (true|yes|on|1|always) &&
+          "${#compstate[unambiguous]}" -ge "${#:-$PREFIX$SUFFIX}" ]]; then
       compstate[pattern_insert]=unambiguous
+    elif [[ "$ins" == always ]]; then
+      [[ "$_old_match_string" = "$PREFIX$SUFFIX$HISTNO" &&
+      "$compstate[insert]" = automenu-unambiguous ]] &&
+       compstate[insert]=automenu
+      [[ "$compstate[insert]" != *menu ]] &&
+       compstate[pattern_insert]= compstate[insert]=
     elif _requested original &&
          { [[ compstate[nmatches] -gt 1 ]] ||
            zstyle -t ":completion:${curcontext}:" original }; then





