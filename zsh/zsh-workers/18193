From zsh-workers-return-18193-mason-zsh=primenet.com.au@sunsite.dk Wed Feb 05 02:08:18 2003
Return-Path: <zsh-workers-return-18193-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 25492 invoked from network); 5 Feb 2003 02:08:17 -0000
Received: from sunsite.dk (130.225.247.90)
  by ns1.primenet.com.au with SMTP; 5 Feb 2003 02:08:17 -0000
Received: (qmail 16121 invoked by alias); 5 Feb 2003 02:08:08 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 18193
Received: (qmail 16114 invoked from network); 5 Feb 2003 02:08:07 -0000
Received: from localhost (HELO sunsite.dk) (127.0.0.1)
  by localhost with SMTP; 5 Feb 2003 02:08:07 -0000
X-MessageWall-Score: 0 (sunsite.dk)
Received: from [63.107.91.101] by sunsite.dk (MessageWall 1.0.8) with SMTP; 5 Feb 2003 2:8:6 -0000
Received: from itasoftware.com (phl.internal.itasoftware.com [192.168.1.115])
	by mta.internal.itasoftware.com (8.12.6/8.12.6) with ESMTP id h15287xY004137;
	Tue, 4 Feb 2003 21:08:07 -0500
Received: (from greg@localhost)
	by itasoftware.com (8.9.3/8.8.7) id VAA26026;
	Tue, 4 Feb 2003 21:08:07 -0500
Message-ID: <15936.29191.196889.6099@phl.itasoftware.com>
Date: Tue, 4 Feb 2003 21:08:07 -0500 (EST)
From: gak@klanderman.net (Greg Klanderman)
To: zsh-workers@sunsite.dk (Zsh list)
Subject: PATCH: Re: compctl "-y" argument busted in 4.0.6
In-Reply-To: <1030204100553.ZM16338@candle.brasslantern.com>
References: <15935.4988.372615.650168@phl.itasoftware.com>
	<1030204100553.ZM16338@candle.brasslantern.com>
Reply-To: gak@klanderman.net
X-Mailer: VM 6.62 under 21.1 (patch 9) "Canyonlands" XEmacs Lucid
Mime-Version: 1.0 (generated by tm-edit 7.108)
Content-Type: text/plain; charset=US-ASCII



>>>>> Bart Schaefer <schaefer@brasslantern.com> writes:

> On Feb 3,  8:12pm, Greg Klanderman wrote:
> }
> } % setopt autolist noautomenu nolistbeep listambiguous listtypes
> } % compctl -k "(foo bar baz)" -y "(FOO BAR BAZ)" foobar       
> } % foobar <TAB>
> } 
> } displays no completions at all!

> This is fixed in 4.1.0-dev-6.  I don't know exactly what fixed it; there
> are no obvious patches meant for it, but it must have been something in
> one of zsh-workers/17195 or 16483.

Thanks Bart,

I have attached a patch for 4.0.6 in case anyone is interested.  Once
I tracked the problem to the calclist() function in
Src/Zle/compresult.c, it was pretty hopeless trying to figure out what
was going on so this patch is simply the version of that same function
from 4.1.0-dev7 massaged back to work under the 4.0.6 codebase.  I've
been using it a few hours here without problem.

My patch from zsh-workers/18191 could also be applied on top of this
if anyone so desires.

thanks,
Greg


--- Zle/compresult.c.orig	Tue Feb  4 17:45:27 2003
+++ Zle/compresult.c	Tue Feb  4 17:45:47 2003
@@ -1443,44 +1443,46 @@
 		}
 		m->flags &= ~CMF_HIDE;
 
-		if (m->disp) {
-		    if (m->flags & CMF_DISPLINE) {
-			nlines += 1 + printfmt(m->disp, 0, 0, 0);
-			g->flags |= CGF_HASDL;
-		    } else {
-			l = niceztrlen(m->disp);
-			ndisp++;
-			if (l > glong)
-			    glong = l;
-			if (l < gshort)
-			    gshort = l;
-			totl += l;
-			mlens[m->gnum] = l;
-		    }
-		    nlist++;
-		    if (!(m->flags & CMF_PACKED))
-			g->flags &= ~CGF_PACKED;
-		    if (!(m->flags & CMF_ROWS))
-			g->flags &= ~CGF_ROWS;
-		} else if (showall || !(m->flags & (CMF_NOLIST | CMF_MULT))) {
+                if (showall || !(m->flags & (CMF_NOLIST | CMF_MULT))) {
 		    if ((m->flags & (CMF_NOLIST | CMF_MULT)) &&
 			(!m->str || !*m->str)) {
 			m->flags |= CMF_HIDE;
 			continue;
 		    }
-		    l = niceztrlen(m->str);
-		    ndisp++;
-		    if (l > glong)
-			glong = l;
-		    if (l < gshort)
-			gshort = l;
-		    totl += l;
-		    mlens[m->gnum] = l;
-		    nlist++;
-		    if (!(m->flags & CMF_PACKED))
-			g->flags &= ~CGF_PACKED;
-		    if (!(m->flags & CMF_ROWS))
-			g->flags &= ~CGF_ROWS;
+                    if (m->disp) {
+                        if (m->flags & CMF_DISPLINE) {
+                            nlines += 1 + printfmt(m->disp, 0, 0, 0);
+                            g->flags |= CGF_HASDL;
+                        } else {
+                            l = niceztrlen(m->disp);
+                            ndisp++;
+                            if (l > glong)
+                                glong = l;
+                            if (l < gshort)
+                                gshort = l;
+                            totl += l;
+                            mlens[m->gnum] = l;
+                        }
+                        nlist++;
+                        if (!(m->flags & CMF_PACKED))
+                            g->flags &= ~CGF_PACKED;
+                        if (!(m->flags & CMF_ROWS))
+                            g->flags &= ~CGF_ROWS;
+                    } else {
+                        l = niceztrlen(m->str);
+                        ndisp++;
+                        if (l > glong)
+                            glong = l;
+                        if (l < gshort)
+                            gshort = l;
+                        totl += l;
+                        mlens[m->gnum] = l;
+                        nlist++;
+                        if (!(m->flags & CMF_PACKED))
+                            g->flags &= ~CGF_PACKED;
+                        if (!(m->flags & CMF_ROWS))
+                            g->flags &= ~CGF_ROWS;
+                    }
 		} else
 		    hidden = 1;
 	    }
@@ -1508,7 +1510,7 @@
     }
     if (!onlyexpl) {
 	char **pp;
-	int *ws, tlines, tline, tcols, maxlen, nth, width, glines;
+	int *ws, tlines, tcols, width, glines;
 
 	for (g = amatches; g; g = g->next) {
 	    glines = 0;
@@ -1572,201 +1574,149 @@
 			ylens[i] = ztrlen(*pp) + add;
 
 		    if (g->flags & CGF_ROWS) {
-			int count, tcol, first, maxlines = 0, llines;
-			int beg = columns / g->shortest, end = g->cols;
+                        int nth, tcol, len;
 
-			while (1) {
-			    tcols = (beg + end) >> 1;
-
-			    for (nth = first = maxlen = width = maxlines =
-				     llines = tcol = 0,
-				     count = g->dcount;
-				 count > 0; count--) {
-				if (ylens[nth] > maxlen)
-				    maxlen = ylens[nth];
-				nth += tcols;
-				tlines++;
-				if (nth >= g->dcount) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcol++] = maxlen;
-				    maxlen = 0;
-				    nth = ++first;
-				    if (llines > maxlines)
-					maxlines = llines;
-				    llines = 0;
-				}
-			    }
-			    if (nth < yl) {
-				ws[tcol++] = maxlen;
-				width += maxlen;
-			    }
-			    if (!count && width <= columns &&
-				(tcols <= 0 || beg == end))
-				break;
-
-			    if (beg == end) {
-				beg--;
-				end--;
-			    } else if (width < columns) {
-				if ((end = tcols) == beg - 1)
-				    end++;
-			    } else {
-				if ((beg = tcols) - 1 == end)
-				    end++;
-			    }
-			}
-			if (tcols > g->cols)
-			    tlines = maxlines;
+                        for (tcols = columns / (g->shortest + add);
+                             tcols > g->cols;
+                             tcols--) {
+
+                            memset(ws, 0, tcols * sizeof(int));
+
+                            for (width = nth = tcol = 0, tlines = 1;
+                                 width < columns && nth < g->dcount;
+                                 nth++, tcol++) {
+
+                                m = *p;
+
+                                if (tcol == tcols) {
+                                    tcol = 0;
+                                    tlines++;
+                                }
+                                len = ylens[nth];
+
+                                if (len > ws[tcol]) {
+                                    width += len - ws[tcol];
+                                    ws[tcol] = len;
+                                }
+                            }
+                            if (width < columns)
+                                break;
+                        }
 		    } else {
-			int beg = ((g->totl + columns) / columns);
-			int end = g->lins;
+                        int nth, tcol, tline, len;
 
-			while (1) {
-			    tlines = (beg + end) >> 1;
-
-			    for (pp = g->ylist, nth = tline = width =
-				     maxlen = tcols = 0;
-				 *pp; pp++) {
-				if (ylens[nth] > maxlen)
-				    maxlen = ylens[nth];
-				if (++tline == tlines) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcols++] = maxlen;
-				    maxlen = tline = 0;
-				}
-				nth++;
-			    }
-			    if (tline) {
-				ws[tcols++] = maxlen;
-				width += maxlen;
-			    }
-			    if (nth == yl && width <= columns &&
-				(beg == end || tlines >= g->lins))
-				break;
-
-			    if (beg == end) {
-				beg++;
-				end++;
-			    } else if (width < columns) {
-				if ((end = tlines) == beg + 1)
-				    end--;
-			    } else {
-				if ((beg = tlines) + 1 == end)
-				    end--;
-			    }
-			}
-			if (tlines > g->lins)
-			    tlines = g->lins;
+                        for (tcols = columns / (g->shortest + add);
+                             tcols > g->cols;
+                             tcols--) {
+
+                            if ((tlines = (g->dcount + tcols - 1) / tcols) <= 0)
+                                tlines = 1;
+
+                            memset(ws, 0, tcols * sizeof(int));
+
+                            for (width = nth = tcol = tline = 0;
+                                 width < columns && nth < g->dcount;
+                                 nth++, tline++) {
+
+                                m = *p;
+
+                                if (tline == tlines) {
+                                    tcol++;
+                                    tline = 0;
+                                }
+                                if (tcol == tcols) {
+                                    tcol = 0;
+                                    tlines++;
+                                }
+                                len = ylens[nth];
+
+                                if (len > ws[tcol]) {
+                                    width += len - ws[tcol];
+                                    ws[tcol] = len;
+                                }
+                            }
+                            if (width < columns)
+                                break;
+                        }
 		    }
 		}
 	    } else if (g->width) {
 		if (g->flags & CGF_ROWS) {
-		    int addlen, count, tcol, maxlines = 0, llines, i;
-		    int beg = columns / g->shortest, end = g->cols;
-		    Cmatch *first;
-
-		    while (1) {
-			tcols = (beg + end) >> 1;
-
-			p = first = skipnolist(g->matches, showall);
-			for (maxlen = width = maxlines = llines = tcol = 0,
-				 count = g->dcount;
-			     count > 0; count--) {
-			    m = *p;
-			    addlen = mlens[m->gnum] + add;
-			    if (addlen > maxlen)
-				maxlen = addlen;
-			    for (i = tcols; i && *p; i--)
-				p = skipnolist(p + 1, showall);
-
-			    llines++;
-			    if (!*p) {
-				if (llines > maxlines)
-				    maxlines = llines;
-				llines = 0;
-
-				if ((width += maxlen) >= columns)
-				    break;
-				ws[tcol++] = maxlen;
-				maxlen = 0;
+                    int nth, tcol, len;
 
-				p = first = skipnolist(first + 1, showall);
-			    }
-			}
-			if (tlines) {
-			    ws[tcol++] = maxlen;
-			    width += maxlen;
-			}
-			if (!count && width <= columns &&
-			    (tcols <= 0 || beg == end))
-			    break;
-
-			if (beg == end) {
-			    beg--;
-			    end--;
-			} else if (width < columns) {
-			    if ((end = tcols) == beg - 1)
-				end++;
-			} else {
-			    if ((beg = tcols) - 1 == end)
-				end++;
-			}
-		    }
-		    if (tcols > g->cols)
-			tlines = maxlines;
+                    for (tcols = columns / (g->shortest + add);
+                         tcols > g->cols;
+                         tcols--) {
+
+                        memset(ws, 0, tcols * sizeof(int));
+
+                        for (width = nth = tcol = 0, tlines = 1,
+                             p = skipnolist(g->matches, showall);
+                             *p && width < columns && nth < g->dcount;
+                             nth++, p = skipnolist(p + 1, showall), tcol++) {
+
+                            m = *p;
+
+                            if (tcol == tcols) {
+                                tcol = 0;
+                                tlines++;
+                            }
+                            len = (mlens[m->gnum] +
+                                   (tcol == tcols - 1 ? 0 : add));
+
+                            if (len > ws[tcol]) {
+                                width += len - ws[tcol];
+                                ws[tcol] = len;
+                            }
+                        }
+                        if (width < columns)
+                            break;
+                    }
 		} else {
-		    int addlen;
-		    int smask = ((showall ? 0 : (CMF_NOLIST | CMF_MULT)) |
-				 CMF_HIDE);
-		    int beg = ((g->totl + columns) / columns);
-		    int end = g->lins;
-
-		    while (1) {
-			tlines = (beg + end) >> 1;
-
-			for (p = g->matches, nth = tline = width =
-				 maxlen = tcols = 0;
-			     (m = *p); p++) {
-			    if (!(m->flags &
-				  (m->disp ? (CMF_DISPLINE | CMF_HIDE) :
-				   smask))) {
-				addlen = mlens[m->gnum] + add;
-				if (addlen > maxlen)
-				    maxlen = addlen;
-				if (++tline == tlines) {
-				    if ((width += maxlen) >= columns)
-					break;
-				    ws[tcols++] = maxlen;
-				    maxlen = tline = 0;
-				}
-				nth++;
-			    }
-			}
-			if (tline) {
-			    ws[tcols++] = maxlen;
-			    width += maxlen;
-			}
-			if (nth == g->dcount && width <= columns &&
-			    (beg == end || tlines >= g->lins))
-			    break;
-
-			if (beg == end) {
-			    beg++;
-			    end++;
-			} else if (width < columns) {
-			    if ((end = tlines) == beg + 1)
-				end--;
-			} else {
-			    if ((beg = tlines) + 1 == end)
-				end--;
-			}
-		    }
-		    if (tlines > g->lins)
-			tlines = g->lins;
+                    int nth, tcol, tline, len;
+
+                    for (tcols = columns / (g->shortest + add);
+                         tcols > g->cols;
+                         tcols--) {
+
+                        if ((tlines = (g->dcount + tcols - 1) / tcols) <= 0)
+                            tlines = 1;
+
+                        memset(ws, 0, tcols * sizeof(int));
+
+                        for (width = nth = tcol = tline = 0,
+                             p = skipnolist(g->matches, showall);
+                             *p && width < columns && nth < g->dcount;
+                             nth++, p = skipnolist(p + 1, showall), tline++) {
+
+                            m = *p;
+
+                            if (tline == tlines) {
+                                tcol++;
+                                tline = 0;
+                            }
+                            if (tcol == tcols) {
+                                tcol = 0;
+                                tlines++;
+                            }
+                            len = (mlens[m->gnum] +
+                                   (tcol == tcols - 1 ? 0 : add));
+
+                            if (len > ws[tcol]) {
+                                width += len - ws[tcol];
+                                ws[tcol] = len;
+                            }
+                        }
+                        if (width < columns) {
+                            if (++tcol < tcols)
+                                tcols = tcol;
+                            break;
+                        }
+                    }
 		}
 	    }
+            if (tcols <= g->cols)
+                tlines = g->lins;
 	    if (tlines == g->lins) {
 		zfree(ws, columns * sizeof(int));
 		g->widths = NULL;

