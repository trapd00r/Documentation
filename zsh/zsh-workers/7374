From zsh-workers-return-7374-mason-zsh=primenet.com.au@sunsite.auc.dk Thu Aug 05 12:19:15 1999
Return-Path: <zsh-workers-return-7374-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 23184 invoked from network); 5 Aug 1999 12:19:14 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 5 Aug 1999 12:19:14 -0000
Received: (qmail 24157 invoked by alias); 5 Aug 1999 12:19:01 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 7374
Received: (qmail 24150 invoked from network); 5 Aug 1999 12:19:01 -0000
Date: Thu, 5 Aug 1999 14:19:00 +0200 (MET DST)
Message-Id: <199908051219.OAA16988@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Wed, 4 Aug 1999 17:00:44 +0000
Subject: PATCH: parameter and quoting (was: Re: Completion problems.)


Bart Schaefer wrote:

> On Aug 4, 11:37am, Sven Wischnowsky wrote:
> } Subject: Re: Completion problems.
> }
> } Tanaka Akira wrote:
> } 
> } > In following examples, unquoted forms are not known until runtime.
> } > 
> } > % if some-complex-command; then var=xxx; else var=yyy; fi; tst $var/<TAB>
> } > % tst $(some-complex-command)/<TAB>
> } 
> } I see two ways to go: 1) completely change the completion code to
> } report strings in unquoted form or 2) add a parameter expansion
> } modifier which does something like the opposite of `:q'.
> 
> I think (2) would be quite useful in other contexts anyway.  Perhaps (Q)?
> (And we could add (q) which means the same as :q, just for completeness.)

The patch below tries to do that in the simplest way I could think of.
This is the solution that makes errors be ignored, because I have to
ask first: we could easily add another flag that turns on error-
checking. OR should error-reporting be the normal case and we should
have a flag to turn it off? For modifiers we could have a new modifier 
that can be combined with `Q' a la `g' and `f', e.g. `$a:EQ' or
something like that. And with respect to the flag: this could be made
to work for things like `${...%...}', too. Btw. something like `${foo%(}'
currently gives me a non-zero return status but no error message --
even though there seems to be some extra code for it -- I haven't
investigated any firther yet, but this seems wrong, doesn't it?

Ok. Which way should we go?

Bye
 Sven

diff -u os/subst.c Src/subst.c
--- os/subst.c	Mon Aug  2 11:44:47 1999
+++ Src/subst.c	Thu Aug  5 14:00:43 1999
@@ -721,6 +721,7 @@
     int flnum = 0;
     int sortit = 0, casind = 0;
     int casmod = 0;
+    int quotemod = 0;
     char *sep = NULL, *spsep = NULL;
     char *premul = NULL, *postmul = NULL, *preone = NULL, *postone = NULL;
     char *replstr = NULL;	/* replacement string for /orig/repl */
@@ -822,6 +823,14 @@
 		case 'i':
 		    casind = 1;
 		    break;
+
+		case 'q':
+		    quotemod = 1;
+		    break;
+		case 'Q':
+		    quotemod = -1;
+		    break;
+
 		case 'e':
 		    eval = 1;
 		    break;
@@ -1546,6 +1555,46 @@
 		makecapitals(&val);
 	}
     }
+    if (quotemod) {
+	if (isarr) {
+	    char **ap;
+
+	    if (!copied)
+		aval = arrdup(aval), copied = 1;
+	    ap = aval;
+
+	    if (quotemod > 0)
+		for (; *ap; ap++)
+		    *ap = bslashquote(*ap, NULL, 0);
+	    else {
+		int one = noerrs, oef = errflag;
+
+		noerrs = 1;
+		for (; *ap; ap++) {
+		    parse_subst_string(*ap);
+		    remnulargs(*ap);
+		    untokenize(*ap);
+		}
+		noerrs = one;
+		errflag = oef;
+	    }
+	} else {
+	    if (!copied)
+		val = dupstring(val), copied = 1;
+	    if (quotemod > 0)
+		val = bslashquote(val, NULL, 0);
+	    else {
+		int one = noerrs, oef = errflag;
+
+		noerrs = 1;
+		parse_subst_string(val);
+		noerrs = one;
+		errflag = oef;
+		remnulargs(val);
+		untokenize(val);
+	    }
+	}
+    }
     if (isarr) {
 	char *x;
 	char *y;
@@ -1747,6 +1796,7 @@
 	    case 'l':
 	    case 'u':
 	    case 'q':
+	    case 'Q':
 		c = **ptr;
 		break;
 
@@ -1868,6 +1918,18 @@
 		    case 'q':
 			copy = bslashquote(copy, NULL, 0);
 			break;
+		    case 'Q':
+			{
+			    int one = noerrs, oef = errflag;
+
+			    noerrs = 1;
+			    parse_subst_string(copy);
+			    noerrs = one;
+			    errflag = oef;
+			    remnulargs(copy);
+			    untokenize(copy);
+			}
+			break;
 		    }
 		    tc = *tt;
 		    *tt = '\0';
@@ -1921,6 +1983,18 @@
 		    break;
 		case 'q':
 		    *str = bslashquote(*str, NULL, 0);
+		    break;
+		case 'Q':
+		    {
+			int one = noerrs, oef = errflag;
+
+			noerrs = 1;
+			parse_subst_string(*str);
+			noerrs = one;
+			errflag = oef;
+			remnulargs(*str);
+			untokenize(*str);
+		    }
 		    break;
 		}
 	    }
diff -u od/Zsh/expn.yo Doc/Zsh/expn.yo
--- od/Zsh/expn.yo	Mon Aug  2 11:45:23 1999
+++ Doc/Zsh/expn.yo	Thu Aug  5 14:12:26 1999
@@ -166,6 +166,9 @@
 case it is only useful if the resulting text is to be re-evaluated
 such as by tt(eval).
 )
+item(tt(Q))(
+Remove one level of quotes from the substituted words.
+)
 item(tt(x))(
 Like tt(q), but break into words at each blank.
 )
@@ -577,6 +580,12 @@
 Capitalize the resulting words.  `Words' in this case refers to sequences
 of alphanumeric characters separated by non-alphanumerics, em(not) to words
 that result from field splitting.
+)
+item(tt(q))(
+Quote the resulting words with backslashes.
+)
+item(tt(Q))(
+Remove one level of quotes from the resulting words.
 )
 item(tt(c))(
 With tt(${#)var(name)tt(}), count the total number of characters in an array,

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

