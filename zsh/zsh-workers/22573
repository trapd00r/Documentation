From zsh-workers-return-22573-mason-zsh=primenet.com.au@sunsite.dk Tue Aug 01 17:30:55 2006
Return-Path: <zsh-workers-return-22573-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 6838 invoked from network); 1 Aug 2006 17:30:51 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.4 (2006-07-25) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.3 required=5.0 tests=AWL,BAYES_00,
	FORGED_RCVD_HELO,SUBJ_HAS_UNIQ_ID autolearn=ham version=3.1.4
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 1 Aug 2006 17:30:51 -0000
Received-SPF: none (ns1.primenet.com.au: domain at sunsite.dk does not designate permitted sender hosts)
Received: (qmail 60186 invoked from network); 1 Aug 2006 17:30:42 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 1 Aug 2006 17:30:42 -0000
Received: (qmail 23863 invoked by alias); 1 Aug 2006 17:30:40 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 22573
Received: (qmail 23854 invoked from network); 1 Aug 2006 17:30:40 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 1 Aug 2006 17:30:40 -0000
Received: (qmail 59925 invoked from network); 1 Aug 2006 17:30:40 -0000
Received: from cluster-c.mailcontrol.com (168.143.177.190)
  by a.mx.sunsite.dk with SMTP; 1 Aug 2006 17:30:37 -0000
Received: from cameurexb01.EUROPE.ROOT.PRI ([62.189.241.200])
	by rly20c.srv.mailcontrol.com (MailControl) with ESMTP id k71HUXLw026230
	for <zsh-workers@sunsite.dk>; Tue, 1 Aug 2006 18:30:34 +0100
Received: from news01.csr.com ([10.103.143.38]) by cameurexb01.EUROPE.ROOT.PRI with Microsoft SMTPSVC(6.0.3790.1830);
	 Tue, 1 Aug 2006 18:30:33 +0100
Received: from news01.csr.com (localhost.localdomain [127.0.0.1])
	by news01.csr.com (8.13.4/8.13.4) with ESMTP id k71HUWGL031573
	for <zsh-workers@sunsite.dk>; Tue, 1 Aug 2006 18:30:32 +0100
Received: from csr.com (pws@localhost)
	by news01.csr.com (8.13.4/8.13.4/Submit) with ESMTP id k71HUWJT031570
	for <zsh-workers@sunsite.dk>; Tue, 1 Aug 2006 18:30:32 +0100
Message-Id: <200608011730.k71HUWJT031570@news01.csr.com>
X-Authentication-Warning: news01.csr.com: pws owned process doing -bs
To: zsh-workers@sunsite.dk (Zsh hackers list)
Subject: Re: Menu-driven version of history-beginning-search-backward 
In-reply-to: <200607281008.k6SA8VJQ019635@news01.csr.com> 
References: <200607261638.k6QGcE7E010498@news01.csr.com> <dc507f4a0607270901r5a4c19f2n20a895b8a831ab3@mail.gmail.com> <060727212432.ZM4920@torch.brasslantern.com> <200607280910.k6S9AmW2018630@news01.csr.com> <200607281008.k6SA8VJQ019635@news01.csr.com>
Comments: In-reply-to Peter Stephenson <pws@csr.com>
   message dated "Fri, 28 Jul 2006 11:08:31 +0100."
Date: Tue, 01 Aug 2006 18:30:31 +0100
From: Peter Stephenson <pws@csr.com>
X-OriginalArrivalTime: 01 Aug 2006 17:30:33.0214 (UTC) FILETIME=[313569E0:01C6B590]
Content-Type: text/plain
MIME-Version: 1.0
X-Scanned-By: MailControl A-07-00-10 (www.mailcontrol.com) on 10.67.0.130

Still tweaking.

Read the keys for the menu separately, so that it will abort on the
first non-digit instead of trying to read all digits first and finding
the first one isn't a digit.

Use HISTNO to get to the history line, consistent with other history
functions; this allows things like accept-line-and-down-history to work
properly.  The obvious way to do this was to reverse match on the
history again to get the line number (if it had been possible to extract
a key and a value into separate arrays I'd have done that; everything I
thought of involved looping over the elements).  This time I had to get
the quoting of the key exactly right; having done it I put a note in the
manual.  I wish we didn't need all these explanatory notes for
subscripts.

Index: Doc/Zsh/params.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/params.yo,v
retrieving revision 1.29
diff -u -r1.29 params.yo
--- Doc/Zsh/params.yo	12 May 2006 14:58:44 -0000	1.29
+++ Doc/Zsh/params.yo	1 Aug 2006 17:23:25 -0000
@@ -211,6 +211,18 @@
 example([[ ${array[(i)pattern]} -le ${#array} ]])
 
 If tt(KSH_ARRAYS) is in effect, the tt(-le) should be replaced by tt(-lt).
+
+Note that in subscripts with both `tt(r)' and `tt(R)' pattern characters
+are active even if they were substituted for a parameter (regardless
+of the setting of tt(GLOB_SUBST) which controls this feature in normal
+pattern matching).  It is therefore necessary to quote pattern characters
+for an exact string match.  Given a string in tt($key), and assuming
+the tt(EXTENDED_GLOB) option is set, the following is sufficient to
+match an element of an array tt($array) containing exactly the value of
+tt($key):
+
+example(key2=${key//(#m)[\][+LPAR()+RPAR()\\*?#<>]/\\$MATCH}
+print ${array[(R)$key2]})
 )
 item(tt(R))(
 Like `tt(r)', but gives the last match.  For associative arrays, gives
Index: Functions/Zle/history-beginning-search-menu
===================================================================
RCS file: /cvsroot/zsh/zsh/Functions/Zle/history-beginning-search-menu,v
retrieving revision 1.2
diff -u -r1.2 history-beginning-search-menu
--- Functions/Zle/history-beginning-search-menu	28 Jul 2006 10:21:07 -0000	1.2
+++ Functions/Zle/history-beginning-search-menu	1 Aug 2006 17:23:25 -0000
@@ -45,7 +45,7 @@
   # since they are otherwise active in the reverse subscript.
   # We need to avoid quoting other characters since they aren't
   # and just stay quoted, rather annoyingly.
-  search=${search//(#m)[*?#<>]/\\$MATCH/}
+  search=${search//(#m)[\][()\\*?#<>]/\\$MATCH/}
   search=${search// /*}
 fi
 
@@ -69,8 +69,19 @@
 display=(${matches/(#m)*/${(l.$width..0.):-$((++i))} $MATCH})
 zle -R "Enter digit${${width##1}:+s}:" $display
 
-local chars
-read -k$width chars
+integer i
+local char chars
+
+# Abort on first non-digit entry instead of requiring all
+# characters to be typed (as "read -k$width chars" would do).
+for (( i = 0; i < $width; i++ )); do
+  read -k char
+  if [[ $char != [[:digit:]] ]]; then
+    zle -R '' $display
+    return 1
+  fi
+  chars+=$char
+done
 
 # Hmmm... this isn't great.  The only way of clearing the display
 # appears to be to overwrite it completely.  I think that's because
@@ -78,25 +89,37 @@
 # properly.
 display=(${display//?/ })
 
-if [[ $chars != [[:digit:]]## || $chars -eq 0 || $chars -gt $n ]]; then
+if [[ $chars -eq 0 || $chars -gt $n ]]; then
   zle -R '' $display
   return 1
 fi
 
-if [[ $WIDGET = *-end* ]]; then
-  LBUFFER=${matches[$chars]} RBUFFER=
-else
-  integer newcursor
+integer newcursor
+if [[ $WIDGET != *-end* ]]; then
   if (( ${+NUMERIC} )); then
     # Advance cursor so that it's still after the string typed
     local -a match mbegin mend
     if [[ $matches[$chars] = (#b)(*${LBUFFER})* ]]; then
-      newcursor=${#match[1]}
+       newcursor=${#match[1]}
     fi
+  else
+    # Maintain cursor
+    newcursor=$CURSOR
   fi
+fi
 
-  BUFFER=${matches[$chars]}
-  (( newcursor )) && CURSOR=$newcursor
+# Find the history lines that contain the matched string and
+# go to the last one.  This allows accept-line-and-down-history etc.
+# to work.
+local -a lines
+local matchq=${matches[$chars]//(#m)[\][()\\*?#<>]/\\$MATCH}
+lines=(${(kon)history[(R)$matchq]})
+HISTNO=$lines[-1]
+
+if (( newcursor )); then
+  CURSOR=$newcursor
+elif [[ $WIDGET = *-end* ]]; then
+  CURSOR=${#BUFFER}
 fi
 
 zle -R '' $display

-- 
Peter Stephenson <pws@csr.com>                  Software Engineer
CSR PLC, Churchill House, Cambridge Business Park, Cowley Road
Cambridge, CB4 0WZ, UK                          Tel: +44 (0)1223 692070


To access the latest news from CSR copy this link into a web browser:  http://www.csr.com/email_sig.php

