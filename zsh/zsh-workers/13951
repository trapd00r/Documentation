From zsh-workers-return-13951-mason-zsh=primenet.com.au@sunsite.dk Thu Apr 12 00:30:15 2001
Return-Path: <zsh-workers-return-13951-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 24713 invoked from network); 12 Apr 2001 00:30:14 -0000
Received: from sunsite.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 12 Apr 2001 00:30:14 -0000
Received: (qmail 165 invoked by alias); 12 Apr 2001 00:30:13 -0000
Mailing-List: contact zsh-workers-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.dk
X-Seq: 13951
Received: (qmail 154 invoked from network); 12 Apr 2001 00:30:12 -0000
Date: Wed, 11 Apr 2001 20:30:05 -0400
From: Clint Adams <schizo@debian.org>
To: zsh-workers@sunsite.dk
Subject: PATCH: ${(k)terminfo}
Message-ID: <20010411203005.A13303@dman.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.2.5i

This rather messily gets ${(k)terminfo} and ${(kv)terminfo} to work.
Should I do the same for termcap?

Index: Src/Modules/terminfo.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Modules/terminfo.c,v
retrieving revision 1.9
diff -u -r1.9 terminfo.c
--- Src/Modules/terminfo.c	2001/04/09 20:18:40	1.9
+++ Src/Modules/terminfo.c	2001/04/12 00:26:48
@@ -198,6 +198,110 @@
 static void
 scanterminfo(HashTable ht, ScanFunc func, int flags)
 {
+    Param pm = NULL;
+    int num;
+    char **capname, *tistr;
+
+    static char *bools[] = {
+	"bw", "am", "bce", "ccc", "xhp", "xhpa", "cpix", "crxm", "xt", "xenl",
+	"eo", "gn", "hc", "chts", "km", "daisy", "hs", "hls", "in", "lpix",
+	"da", "db", "mir", "msgr", "nxon", "xsb", "npc", "ndscr", "nrrmc",
+	"os", "mc5i", "xvpa", "sam", "eslok", "hz", "ul", "xon", NULL};
+    
+    static char *numerics[] = {
+	"cols", "it", "lh", "lw", "lines", "lm", "xmc", "ma", "colors",
+	"pairs", "wnum", "ncv", "nlab", "pb", "vt", "wsl", "bitwin",
+	"bitype", "bufsz", "btns", "spinh", "spinv", "maddr", "mjump",
+	"mcs", "mls", "npins", "orc", "orhi", "orl", "orvi", "cps", "widcs",
+	NULL};
+
+    static char *strings[] = {
+	"acsc", "cbt", "bel", "cr", "cpi", "lpi", "chr", "cvr", "csr", "rmp",
+	"tbc", "mgc", "clear", "el1", "el", "ed", "hpa", "cmdch", "cwin",
+	"cup", "cud1", "home", "civis", "cub1", "mrcup", "cnorm", "cuf1",
+	"ll", "cuu1", "cvvis", "defc", "dch1", "dl1", "dial", "dsl", "dclk",
+	"hd", "enacs", "smacs", "smam", "blink", "bold", "smcup", "smdc",
+	"dim", "swidm", "sdrfq", "smir", "sitm", "slm", "smicm", "snlq",
+	"snrmq", "prot", "rev", "invis", "sshm", "smso", "ssubm", "ssupm",
+	"smul", "sum", "smxon", "ech", "rmacs", "rmam", "sgr0", "rmcup",
+	"rmdc", "rwidm", "rmir", "ritm", "rlm", "rmicm", "rshm", "rmso",
+	"rsubm", "rsupm", "rmul", "rum", "rmxon", "pause", "hook", "flash",
+	"ff", "fsl", "wingo", "hup", "is1", "is2", "is3", "if", "iprog",
+	"initc", "initp", "ich1", "il1", "ip", "ka1", "ka3", "kb2", "kbs",
+	"kbeg", "kcbt", "kc1", "kc3", "kcan", "ktbc", "kclr", "kclo", "kcmd",
+	"kcpy", "kcrt", "kctab", "kdch1", "kdl1", "kcud1", "krmir", "kend",
+	"kent", "kel", "ked", "kext", "kf0", "kf1", "kf10", "kf11", "kf12",
+	"kf13", "kf14", "kf15", "kf16", "kf17", "kf18", "kf19", "kf2",
+	"kf20", "kf21", "kf22", "kf23", "kf24", "kf25", "kf26", "kf27",
+	"kf28", "kf29", "kf3", "kf30", "kf31", "kf32", "kf33", "kf34",
+	"kf35", "kf36", "kf37", "kf38", "kf39", "kf4", "kf40", "kf41",
+	"kf42", "kf43", "kf44", "kf45", "kf46", "kf47", "kf48", "kf49",
+	"kf5", "kf50", "kf51", "kf52", "kf53", "kf54", "kf55", "kf56",
+	"kf57", "kf58", "kf59", "kf6", "kf60", "kf61", "kf62", "kf63",
+	"kf7", "kf8", "kf9", "kfnd", "khlp", "khome", "kich1", "kil1",
+	"kcub1", "kll", "kmrk", "kmsg", "kmov", "knxt", "knp", "kopn",
+	"kopt", "kpp", "kprv", "kprt", "krdo", "kref", "krfr", "krpl",
+	"krst", "kres", "kcuf1", "ksav", "kBEG", "kCAN", "kCMD", "kCPY",
+	"kCRT", "kDC", "kDL", "kslt", "kEND", "kEOL", "kEXT", "kind",
+	"kFND", "kHLP", "kHOM", "kIC", "kLFT", "kMSG", "kMOV", "kNXT",
+	"kOPT", "kPRV", "kPRT", "kri", "kRDO", "kRPL", "kRIT", "kRES",
+	"kSAV", "kSPD", "khts", "kUND", "kspd", "kund", "kcuu1", "rmkx",
+	"smkx", "lf0", "lf1", "lf10", "lf2", "lf3", "lf4", "lf5", "lf6",
+	"lf7", "lf8", "lf9", "fln", "rmln", "smln", "rmm", "smm", "mhpa",
+	"mcud1", "mcub1", "mcuf1", "mvpa", "mcuu1", "nel", "porder", "oc",
+	"op", "pad", "dch", "dl", "cud", "mcud", "ich", "indn", "il", "cub",
+	"mcub", "cuf", "mcuf", "rin", "cuu", "mcuu", "pfkey", "pfloc",
+	"pfx", "pln", "mc0", "mc5p", "mc4", "mc5", "pulse", "qdial",
+	"rmclk", "rep", "rfi", "rs1", "rs2", "rs3", "rf", "rc", "vpa",
+	"sc", "ind", "ri", "scs", "sgr", "setb", "smgb", "smgbp", "sclk",
+	"scp", "setf", "smgl", "smglp", "smgr", "smgrp", "hts", "smgt",
+	"smgtp", "wind", "sbim", "scsd", "rbim", "rcsd", "subcs",
+	"supcs", "ht", "docr", "tsl", "tone", "uc", "hu", "u0", "u1",
+	"u2", "u3", "u4", "u5", "u6", "u7", "u8", "u9", "wait", "xoffc",
+	"xonc", "zerom", "scesa", "bicr", "binel", "birep", "csnm",
+	"csin", "colornm", "defbi", "devt", "dispc", "endbi", "smpch",
+	"smsc", "rmpch", "rmsc", "getm", "kmous", "minfo", "pctrm",
+	"pfxl", "reqmp", "scesc", "s0ds", "s1ds", "s2ds", "s3ds",
+	"setab", "setaf", "setcolor", "smglr", "slines", "smgtb",
+	"ehhlm", "elhlm", "elohlm", "erhlm", "ethlm", "evhlm", "sgr1",
+	"slength", NULL};
+
+    pm = (Param) zhalloc(sizeof(struct param));
+    pm->sets.cfn = NULL;
+    pm->gets.cfn = strgetfn;
+    pm->unsetfn = NULL;
+    pm->ct = 0;
+    pm->env = NULL;
+    pm->ename = NULL;
+    pm->old = NULL;
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    for (capname = bools; *capname; capname++) {
+	if ((num = tigetflag(*capname)) != -1) {
+	    pm->u.str = num ? dupstring("yes") : dupstring("no");
+	    pm->nam = dupstring(*capname);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_INTEGER;
+    for (capname = numerics; *capname; capname++) {
+	if (((num = tigetnum(*capname)) != -1) && (num != -2)) {
+	    pm->u.val = num;
+	    pm->nam = dupstring(*capname);
+	    func((HashNode) pm, flags);
+	}
+    }
+    
+    pm->flags = PM_READONLY | PM_SCALAR;
+    for (capname = strings; *capname; capname++) {
+	if ((tistr = (char *)tigetstr(*capname)) != NULL &&
+	    tistr != (char *)-1) {
+	    pm->u.str = dupstring(tistr);
+	    pm->nam = dupstring(*capname);
+	    func((HashNode) pm, flags);
+	}
+    }
 }
 
 /**/

