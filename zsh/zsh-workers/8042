From zsh-workers-return-8042-mason-zsh=primenet.com.au@sunsite.auc.dk Sat Sep 25 02:53:48 1999
Return-Path: <zsh-workers-return-8042-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2391 invoked from network); 25 Sep 1999 02:53:46 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 25 Sep 1999 02:53:46 -0000
Received: (qmail 4452 invoked by alias); 25 Sep 1999 02:53:36 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 8042
Received: (qmail 4445 invoked from network); 25 Sep 1999 02:53:35 -0000
To: zsh-workers@sunsite.auc.dk
Subject: Re: Chatty little precompiler for _arguments
References: <199909231028.MAA24049@beta.informatik.hu-berlin.de>
 <rsqpuz9wwcl.fsf@crane.jaist.ac.jp>
 <990923151211.ZM26950@candle.brasslantern.com>
MIME-Version: 1.0 (generated by AKEMI 1.13.2 - =?ISO-2022-JP?B?Ig==?=
 =?ISO-2022-JP?B?GyRCQTA0Y0s8GyhCIg==?=)
Content-Type: text/plain; charset=US-ASCII
From: Tanaka Akira <akr@jaist.ac.jp>
Date: 25 Sep 1999 11:53:33 +0900
In-Reply-To: "Bart Schaefer"'s message of "Thu, 23 Sep 1999 15:12:11 +0000"
Message-ID: <rsqvh8z7lci.fsf@crane.jaist.ac.jp>
Lines: 213
User-Agent: Chao-gnus/6.12.5 AKEMI/1.13.2 (=?ISO-2022-JP?B?GyRCQTAbKEI=?=
 =?ISO-2022-JP?B?GyRCNGNLPBsoQg==?=) FLAM-DOODLE/1.12.6
 (=?ISO-2022-JP?B?GyRCM3cbKEI=?= 10R4.0/5.0) Emacs/20.4
 (sparc-sun-solaris2.6) MULE/4.0 (HANANOEN)

In article <990923151211.ZM26950@candle.brasslantern.com>,
  "Bart Schaefer" <schaefer@candle.brasslantern.com> writes:

> Further, with extendedglob, the output of ${(qqqq)...} can't be "eval"d
> without quoting it yet again, because ^ is a metacharacter.  So maybe
> we should use a different letter -- perhaps ${(v)...} like cat? -- for
> Sven's (qqqq).

The patch follows implement (qqqq) intended by me.  Sven's (qqqq) is
changed to (V) because (v) is already used for associative array
values.

Index: Doc/Zsh/expn.yo
===================================================================
RCS file: /projects/zsh/zsh/Doc/Zsh/expn.yo,v
retrieving revision 1.1.1.37
diff -u -F^( -r1.1.1.37 expn.yo
--- Doc/Zsh/expn.yo	1999/09/23 13:21:09	1.1.1.37
+++ Doc/Zsh/expn.yo	1999/09/25 02:44:35
@@ -581,12 +581,14 @@ (see below) is applied using the rules f
 of alphanumeric characters separated by non-alphanumerics, em(not) to words
 that result from field splitting.
 )
+item(tt(V))(
+Make any special characters in the resulting words visible.
+)
 item(tt(q))(
 Quote the resulting words with backslashes. If this flag is given
 twice, the resulting words are quoted in single quotes and if it is
 given three times, the words are quoted in double quotes. If it is
-given four times, no real quoting is done, but any special characters
-in the resulting words will be in a human-readable form.
+given four times, the words are quoted in single quotes preceded a tt($).
 )
 item(tt(Q))(
 Remove one level of quotes from the resulting words.
Index: Src/subst.c
===================================================================
RCS file: /projects/zsh/zsh/Src/subst.c,v
retrieving revision 1.1.1.42
diff -u -F^( -r1.1.1.42 subst.c
--- Src/subst.c	1999/09/23 13:21:36	1.1.1.42
+++ Src/subst.c	1999/09/25 02:44:36
@@ -723,6 +723,7 @@
     int sortit = 0, casind = 0;
     int casmod = 0;
     int quotemod = 0, quotetype = 0, quoteerr = 0;
+    int visiblemod = 0;
     char *sep = NULL, *spsep = NULL;
     char *premul = NULL, *postmul = NULL, *preone = NULL, *postone = NULL;
     char *replstr = NULL;	/* replacement string for /orig/repl */
@@ -826,6 +827,10 @@
 		    casind = 1;
 		    break;
 
+		case 'V':
+		    visiblemod++;
+		    break;
+
 		case 'q':
 		    quotemod++, quotetype++;
 		    break;
@@ -1628,20 +1633,20 @@
 	    ap = aval;
 
 	    if (quotemod > 0) {
-		if (quotetype == 3)
-		    for (; *ap; ap++)
-			*ap = nicedupstring(*ap);
-		else if (quotetype) {
+		if (quotetype) {
 		    int sl;
 		    char *tmp;
 
 		    for (; *ap; ap++) {
+			int pre = quotetype != 3 ? 1 : 2;
 			tmp = bslashquote(*ap, NULL, quotetype);
 			sl = strlen(tmp);
-			*ap = (char *) zhalloc(sl + 3);
-			strcpy((*ap) + 1, tmp);
-			ap[0][0] = ap[0][sl + 1] = (quotetype == 1 ? '\'' : '"');
-			ap[0][sl + 2] = '\0';
+			*ap = (char *) zhalloc(pre + sl + 2);
+			strcpy((*ap) + pre, tmp);
+			ap[0][pre - 1] = ap[0][pre + sl] = (quotetype != 2 ? '\'' : '"');
+			ap[0][pre + sl + 1] = '\0';
+			if (quotetype == 3)
+			  ap[0][0] = '$';
 		    }
 		} else
 		    for (; *ap; ap++)
@@ -1668,18 +1673,19 @@
 	    if (!copied)
 		val = dupstring(val), copied = 1;
 	    if (quotemod > 0) {
-		if (quotetype == 3)
-		    val = nicedupstring(val);
-		else if (quotetype) {
+		if (quotetype) {
+		    int pre = quotetype != 3 ? 1 : 2;
 		    int sl;
 		    char *tmp;
 
 		    tmp = bslashquote(val, NULL, quotetype);
 		    sl = strlen(tmp);
-		    val = (char *) zhalloc(sl + 3);
-		    strcpy(val + 1, tmp);
-		    val[0] = val[sl + 1] = (quotetype == 1 ? '\'' : '"');
-		    val[sl + 2] = '\0';
+		    val = (char *) zhalloc(pre + sl + 2);
+		    strcpy(val + pre, tmp);
+		    val[pre - 1] = val[pre + sl] = (quotetype != 2 ? '\'' : '"');
+		    val[pre + sl + 1] = '\0';
+		    if (quotetype == 3)
+		      val[0] = '$';
 		} else
 		    val = bslashquote(val, NULL, 0);
 	    } else {
@@ -1698,6 +1704,19 @@
 		remnulargs(val);
 		untokenize(val);
 	    }
+	}
+    }
+    if (visiblemod) {
+	if (isarr) {
+	    char **ap;
+	    if (!copied)
+		aval = arrdup(aval), copied = 1;
+	    for (ap = aval; *ap; ap++)
+		*ap = nicedupstring(*ap);
+	} else {
+	    if (!copied)
+		val = dupstring(val), copied = 1;
+	    val = nicedupstring(val);
 	}
     }
     if (isarr) {
Index: Src/utils.c
===================================================================
RCS file: /projects/zsh/zsh/Src/utils.c,v
retrieving revision 1.1.1.32
diff -u -F^( -r1.1.1.32 utils.c
--- Src/utils.c	1999/09/24 12:54:44	1.1.1.32
+++ Src/utils.c	1999/09/25 02:44:36
@@ -2984,7 +2984,64 @@
     for (; *u; u++) {
 	if (e && *e == u)
 	    *e = v, sf = 1;
-	if (ispecial(*u) &&
+	if (instring == 3) {
+	  int c = *u;
+	  if (c == Meta) {
+	    c = *++u ^ 32;
+	  }
+	  c &= 0xff;
+	  if(isprint(c)) {
+	    switch (c) {
+	    case '\\':
+	    case '\'':
+	      *v++ = '\\';
+	      *v++ = c;
+	      break;
+
+	    default:
+	      if(imeta(c)) {
+		*v++ = Meta;
+		*v++ = c ^ 32;
+	      }
+	      else {
+		if (isset(BANGHIST) && c == bangchar) {
+		  *v++ = '\\';
+		}
+		*v++ = c;
+	      }
+	      break;
+	    }
+	  }
+	  else {
+	    switch (c) {
+	    case '\0':
+	      *v++ = '\\';
+	      *v++ = '0';
+	      if ('0' <= u[1] && u[1] <= '7') {
+		*v++ = '0';
+		*v++ = '0';
+	      }
+	      break;
+
+	    case '\007': *v++ = '\\'; *v++ = 'a'; break;
+	    case '\b': *v++ = '\\'; *v++ = 'b'; break;
+	    case '\f': *v++ = '\\'; *v++ = 'f'; break;
+	    case '\n': *v++ = '\\'; *v++ = 'n'; break;
+	    case '\r': *v++ = '\\'; *v++ = 'r'; break;
+	    case '\t': *v++ = '\\'; *v++ = 't'; break;
+	    case '\v': *v++ = '\\'; *v++ = 'v'; break;
+
+	    default:
+	      *v++ = '\\';
+	      *v++ = '0' + ((c >> 6) & 7);
+	      *v++ = '0' + ((c >> 3) & 7);
+	      *v++ = '0' + (c & 7);
+	      break;
+	    }
+	  }
+	  continue;
+	}
+	else if (ispecial(*u) &&
 	    (!instring ||
 	     (isset(BANGHIST) && *u == (char)bangchar) ||
 	     (instring == 2 &&
-- 
Tanaka Akira

