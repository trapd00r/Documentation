From zsh-workers-request@math.gatech.edu Thu Oct 09 09:04:56 1997
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason@primenet.com.au
Received: (qmail 193 invoked from network); 9 Oct 1997 09:04:53 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 9 Oct 1997 09:04:53 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.8.5/8.8.5) id EAA20521;
	Thu, 9 Oct 1997 04:02:03 -0400 (EDT)
Resent-Date: Thu, 9 Oct 1997 04:02:03 -0400 (EDT)
Date: Thu, 9 Oct 1997 10:02:40 +0200 (MET DST)
Message-Id: <199710090802.KAA22296@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
Subject: Compctl
Resent-Message-ID: <"GniZj1.0.a05.xz8Fq"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/3565
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Hi

My last patch (the one implementing partial word completion and all
that) had some problems, the patch below fixes them.

1. There was a problem with the inserted string if COMPLETEFOLDCASE
   was set and the possible matches contained upper- and lowercase
   letters, somtimes the uppercase letters were inserted, breaking the
   completion of the rest of the word.
2. On system where char is signed array subscripts sometimes were
   negative (this is what makes the patch *look* big).

Bye
 Sven

*** Zle/zle_tricky.c	Thu Oct  9 09:12:35 1997
--- ../../z/Src/Zle/zle_tricky.c	Thu Oct  9 09:16:40 1997
***************
*** 210,216 ****
  
  /* This macro is used to test if we should complete partial paths.    */
  
! #define comp_paths()  (!!cseps[(unsigned int) '/'])
  
  /* A flag saying whether we are completing a partial path and a variable   *
   * holding the length of the partial path. again is non-zero if completion *
--- 214,220 ----
  
  /* This macro is used to test if we should complete partial paths.    */
  
! #define comp_paths()  (!!cseps[(int) ((unsigned char) '/')])
  
  /* A flag saying whether we are completing a partial path and a variable   *
   * holding the length of the partial path. again is non-zero if completion *
***************
*** 1423,1429 ****
  	/* If we reached the end of the tested string and the prefix *
  	 * string is not finished, or we are not at a separator in   *
  	 * the prefix, the prefix doesn't match.         	     */
! 	if (!*b || !cseps[(unsigned int) *a])
  	    return -1;
  	/* Find the next matching character.                         */
  	while (*b && !cccmp(*a, *b))
--- 1427,1433 ----
  	/* If we reached the end of the tested string and the prefix *
  	 * string is not finished, or we are not at a separator in   *
  	 * the prefix, the prefix doesn't match.         	     */
! 	if (!*b || !cseps[(int) ((unsigned char) *a)])
  	    return -1;
  	/* Find the next matching character.                         */
  	while (*b && !cccmp(*a, *b))
***************
*** 1449,1455 ****
      while (c >= a && d >= b) {
  	p = c;
  	/* Search the next separator in the suffix.			*/
! 	while (p >= a && !cseps[(unsigned int) *p])
  	    p--;
  	if (p >= a) {
  	    /* We are not in the last part, so compare the beginnings of *
--- 1453,1459 ----
      while (c >= a && d >= b) {
  	p = c;
  	/* Search the next separator in the suffix.			*/
! 	while (p >= a && !cseps[(int) ((unsigned char) *p)])
  	    p--;
  	if (p >= a) {
  	    /* We are not in the last part, so compare the beginnings of *
***************
*** 1537,1543 ****
  	    return m - o;
  	}
  	/* Otherwise search the next separator in the first string...	*/
! 	while (*a && !cseps[(unsigned int) *a])
  	    a++;
  	/* And the matching character in the second string.		*/
  	while (*b && !cccmp(*a, *b))
--- 1541,1547 ----
  	    return m - o;
  	}
  	/* Otherwise search the next separator in the first string...	*/
! 	while (*a && !cseps[(int) ((unsigned char) *a)])
  	    a++;
  	/* And the matching character in the second string.		*/
  	while (*b && !cccmp(*a, *b))
***************
*** 1574,1580 ****
  addmatch(char *s, char *t)
  {
      int test = 0, sl = strlen(s), pl = rpl, cc = 0, *bp, *ep, *sp;
!     char *e = NULL, *tt, *te, *fc, **fm, *ap = NULL, *pc;
      Comp cp = patcomp;
      HashNode hn;
      Param pm;
--- 1578,1584 ----
  addmatch(char *s, char *t)
  {
      int test = 0, sl = strlen(s), pl = rpl, cc = 0, *bp, *ep, *sp;
!     char *e = NULL, *tt, *te, *fc, **fm, *ap = lpre, *pc;
      Comp cp = patcomp;
      HashNode hn;
      Param pm;
***************
*** 2005,2011 ****
  		s++;
  		c = *((unsigned char *) s);
  	    }
! 	    ceqkeys[(unsigned int) k] = m;
  	    while ((c = *((unsigned char *) s)) && c != ':') {
  		s++;
  		if (c == '\\' && *s) { c = *((unsigned char *) s); s++; }
--- 2009,2015 ----
  		s++;
  		c = *((unsigned char *) s);
  	    }
! 	    ceqkeys[(int) k] = m;
  	    while ((c = *((unsigned char *) s)) && c != ':') {
  		s++;
  		if (c == '\\' && *s) { c = *((unsigned char *) s); s++; }
***************
*** 3709,3722 ****
  	    cs += pcs;
  	    inv = 1;
  	}
! 	else {
  	    if (ab)
! 		inststrlen(firstm + apl, 1, ab - apl);
  	    if (ab + ae > shortl)
  		if ((ae -= ab + ae - shortl) < 0)
  		    ae = 0;
  	    if (ae && !atend)
! 		inststrlen(firstm + strlen(firstm) - asl - ae, 0, ae - asl);
  	    if ((ab || (ae && !atend)) && !iscp)
  		inv = 1;
  	}
--- 3707,3726 ----
  	    cs += pcs;
  	    inv = 1;
  	}
! 	else if (ab != apl || ae != asl) {
! 	    char *s = firstm;
! 
! 	    if (isset(COMPLETEFOLDCASE)) {
! 		s = dupstring(s);
! 		downcase(&s);
! 	    }
  	    if (ab)
! 		inststrlen(s + apl, 1, ab - apl);
  	    if (ab + ae > shortl)
  		if ((ae -= ab + ae - shortl) < 0)
  		    ae = 0;
  	    if (ae && !atend)
! 		inststrlen(s + strlen(s) - asl - ae, 0, ae - asl);
  	    if ((ab || (ae && !atend)) && !iscp)
  		inv = 1;
  	}
***************
*** 3961,3967 ****
  
      return a == b ||
  	(isset(COMPLETEFOLDCASE) && a == tolower(b)) ||
! 	((m = ceqkeys[(unsigned int) a]) && (cequiv[(unsigned int) b] & m));
  }
  
  /* Like the previous one, but matching is done in both directions.	*/
--- 3965,3972 ----
  
      return a == b ||
  	(isset(COMPLETEFOLDCASE) && a == tolower(b)) ||
! 	((m = ceqkeys[(int) ((unsigned char) a)]) &&
! 	 (cequiv[(int) ((unsigned char) b)] & m));
  }
  
  /* Like the previous one, but matching is done in both directions.	*/

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

