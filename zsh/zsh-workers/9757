From zsh-workers-return-9757-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Feb 16 10:11:54 2000
Return-Path: <zsh-workers-return-9757-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 2844 invoked from network); 16 Feb 2000 10:11:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 16 Feb 2000 10:11:53 -0000
Received: (qmail 23163 invoked by alias); 16 Feb 2000 10:11:25 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9757
Received: (qmail 23138 invoked from network); 16 Feb 2000 10:11:23 -0000
Date: Wed, 16 Feb 2000 11:11:18 +0100 (MET)
Message-Id: <200002161011.LAA16009@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Oliver Kiddle's message of Tue, 15 Feb 2000 19:53:50 +0000
Subject: Re: help with _match, globcomplete etc. (with a PATCH)


Oliver Kiddle wrote:

> X-Seq: 9752
> 
> Sven Wischnowsky wrote:
> 
> > I couldn't reproduce your `[' problem, unless that was a typo and you
> > meant a quoted `{'. In this case it's the same as for the quoted
> > globbing characters.
> 
> It wasn't a typo. It only occurs when the referenced associative array is set. I can reproduce it as follows:
> zsh -f
> bindkey -me
> unsetopt glob
> typeset -A code
> code[ai]=foo
> echo $code[ai]/{a,<tab>

Hm, this stilll gives me only the `echo foo/\{a,' I was talking about.

> and, in a separate message: 
> > You can bind expand-word to ^X$. Expansion of parameter substitutions
> > is a problem, because the completion (shell) code doesn't get the
> > whole string. We only get the stuff after the $, so we can't really
> > change such things.
> 
> I don't quite understand what you mean here. _expand seems to get the whole thing including the '$'. The main limiting factor on my configuration is that I can't do parameter expansion, command substitution and arithmetic expansion independantly. Maybe the e parameter expansion flag could allow options to select them. Also, I can't see a way of doing globbing, while preserving variable references.

The completion code only gets it if it can find out that we are
*after* the parameter expression. I.e. it gets the `$...' in cases
like `${foo}<TAB>' and `$foo/<TAB>', but not with `$foo<TAB>'.

> In general, I don't like the substitution in _expand but the trouble with not having it enabled is that glob expansion will not work on lines with parameters. My solution is the following patch to _expand which adds the style subst-globs-only which if used with substitute and glob, only does expansion if globbing was able to do something meaningful. If you (Sven) are happy with this addition, I'll do a doc patch aswell.

Err, substitution is done in lines 30/31, so your new style only says
that it should offer expansion only if attempting globbing did change
the word resulting from substitution (given that I don't really
understand the style name but maybe I'm the only one). I think it's
fine to have that configurable.

> and elsewhere:
> > > Another thing which I would like to configure with expansion is when
> > > there is only one match, I'd prefer if the space suffix was not added -
> > > this is one of the things that makes the variable expansion annoying.
> > > Ideally, the suffix would be as if normal completion was used so
> > > directories would get a '/'.
> > When speaking about variables: see above. When speaking about other
> > expansions: _match does that and _expand could be made to do it
> > (adding a loop that appends slashes to directory names).
> 
> It is only really when the globbing results in only one match that I am concerned about the suffix because my cursor is at the end of that match and I'm likely to go on adding more to it and doing more completion. I'll add a patch for this. Should I make it depend on a zstyle thing? Will it be needed for both of the compadds in _expand?

Well, I'd say since the completion code normally adds slashes for
directories we probably don't need a style for it as long as we add it 
with `-qS/', i.e. auto-removable.

> Out of interest, why does the check in _expand need to check against "$word"(|\(N\)) as opposed to just "$word": under what circumstances can the (N) find its way into $exp?

I added this in 6945: `echo [:(N)' gives `[:(N)' (completion for
character-classes).


Bart Schaefer wrote:

> On Feb 15,  7:53pm, Oliver Kiddle wrote:
> } Subject: Re: help with _match, globcomplete etc. (with a PATCH)
> }
> } zsh -f
> } bindkey -me
> } unsetopt glob
> } typeset -A code
> } code[ai]=foo
> } echo $code[ai]/{a,<tab>
> 
> All I get from that is a beep, before Sven's 9749, and
> 
> zagzig% echo foo/\{a, 
>                       ^note trailing space added
> with 9749 applied.
> 
> Of course that seems wrong, too.  I didn't want the brace to be quoted.

As I said: I guess, this was intentional. If you have `a="foo bar"' or 
the words from globbing contain special characters, you want them to
be quoted. There may be a possibility to fix this by changing the
tokenization stuff in doexpansion().

> ...
> 
> } Also, I can't see a way of doing globbing, while preserving variable
> } references.
> 
> This strikes me as nigh impossible in the general case.  What would you
> expect to see if you invoked the "glob but preserve variables" expansion
> in a case like:
> 
> 	zsh% arr=('[sS]' Src/M ../)
> 	zsh% print -l ${~^arr}*
> 
> ??  Or do I completely misunderstand what you're asking?

;-) I was wondering, too.

> (I note that on that example expand-word produces a list of files but
> the _expand completer (with substitute and glob styles set to 1) only
> beeps, with or without 9752 applied.  Is that the right behavior?)

No. Seems like the (e) flag makes the thing be quoted as in double
quotes. I.e. with a='${~^arr}*', ${(e)a} gives `[sS] Src/M ../*', but
a='${(@)~^arr}' gives what we would have expected. The patch below
changes the calls to parsestr() to calls to parse_subst_string() to
get that. Hm, should we call that only conditionally, e.g. if the
${(e)...} is not inquotes and has no (@) or something?

(And of course, to get only all expansion, making it behave like
expand-word, one also needs to set the tag-order style for the expand
completer to `all-expansions'.)

Bye
 Sven

diff -ru ../z.old/Src/subst.c Src/subst.c
--- ../z.old/Src/subst.c	Tue Feb 15 13:21:36 2000
+++ Src/subst.c	Wed Feb 16 10:56:58 2000
@@ -1766,7 +1766,7 @@
 		if (prenum || postnum)
 		    x = dopadding(x, prenum, postnum, preone, postone,
 				  premul, postmul);
-		if (eval && parsestr(x))
+		if (eval && parse_subst_string(x))
 		    return NULL;
 		xlen = strlen(x);
 		for (tn = firstnode(tl);
@@ -1801,7 +1801,7 @@
 	    if (prenum || postnum)
 		x = dopadding(x, prenum, postnum, preone, postone,
 			      premul, postmul);
-	    if (eval && parsestr(x))
+	    if (eval && parse_subst_string(x))
 		return NULL;
 	    xlen = strlen(x);
 	    strcatsub(&y, ostr, aptr, x, xlen, NULL, globsubst);
@@ -1816,7 +1816,7 @@
 		if (prenum || postnum)
 		    x = dopadding(x, prenum, postnum, preone, postone,
 				  premul, postmul);
-		if (eval && parsestr(x))
+		if (eval && parse_subst_string(x))
 		    return NULL;
 		if (qt && !*x && isarr != 2)
 		    y = dupstring(nulstring);
@@ -1832,7 +1832,7 @@
 	    if (prenum || postnum)
 		x = dopadding(x, prenum, postnum, preone, postone,
 			      premul, postmul);
-	    if (eval && parsestr(x))
+	    if (eval && parse_subst_string(x))
 		return NULL;
 	    xlen = strlen(x);
 	    *str = strcatsub(&y, aptr, aptr, x, xlen, fstr, globsubst);
@@ -1851,7 +1851,7 @@
 	if (prenum || postnum)
 	    x = dopadding(x, prenum, postnum, preone, postone,
 			  premul, postmul);
-	if (eval && parsestr(x))
+	if (eval && parse_subst_string(x))
 	    return NULL;
 	xlen = strlen(x);
 	*str = strcatsub(&y, ostr, aptr, x, xlen, fstr, globsubst);

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

