From zsh-workers-request@math.gatech.edu Fri Aug 07 07:14:22 1998
Return-Path: <zsh-workers-request@math.gatech.edu>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27193 invoked from network); 7 Aug 1998 07:14:19 -0000
Received: from math.gatech.edu (list@130.207.146.50)
  by ns1.primenet.com.au with SMTP; 7 Aug 1998 07:14:19 -0000
Received: (from list@localhost)
	by math.gatech.edu (8.9.1/8.9.1) id CAA01388;
	Fri, 7 Aug 1998 02:47:36 -0400 (EDT)
Resent-Date: Fri, 7 Aug 1998 02:47:36 -0400 (EDT)
Date: Fri, 7 Aug 1998 08:49:40 +0200 (MET DST)
Message-Id: <199808070649.IAA19346@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@math.gatech.edu
In-reply-to: Peter Stephenson's message of Thu, 06 Aug 1998 15:14:21 +0200
Subject: Re: ideas: free-search-complete, noexpand (with PATCH)
Resent-Message-ID: <"VcG-W2.0.aL.8Cgor"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/4282
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu


Peter Stephenson wrote:

> 
> ...
> Sven Wischnowsky wrote:
> > The thing below is my patch relative to a 3.1.4 with the patches I
> > found plus Peters. I hope it works for those who have applied this
> > patch.
> 
> Down to 870 lines in zle_tricky.c :-(.  I've got another problem, because
> I'm using Zoli's patch for dynamically loading on AIX, which renames
> refresh to zrefresh, but that only accounts for an extra 300 lines or so.
> (Also I need patch -R, but that's trivial.)
> 

Sorry for the -R, I was a bit hasty, it seems. About the problems with 
patching zle_tricky.c: I give up ;-)

> I did notice one thing: the functions rembslash() and quotename() live
> in zle_tricky.c but are called in compctl.c.  This is bad because they're
> in different libraries; common code should be in comp1.c.  (Quite a lot
> of the widget completion patch was simply trying to get round the use
> of different libraries.) If you move them you have to move instring as well.
> 

Thanks for the hint. I still didn't find the time to look deeper into
all this dynamic module stuff.

Bye
 Sven

diff -c Src/Zle/comp1.c ../Src/Zle/comp1.c
*** Src/Zle/comp1.c	Thu Aug  6 15:51:54 1998
--- ../Src/Zle/comp1.c	Fri Aug  7 08:41:07 1998
***************
*** 67,72 ****
--- 67,82 ----
  /**/
  int incompctlfunc;
  
+ 
+ /* This variable and the functions rembslash() and quotename() came from     *
+  * zle_tricky.c, but are now used in compctl.c, too.                         */
+ 
+ /* 1 if we are completing in a string */
+ 
+ /**/
+ int instring;
+ 
+ 
  /**/
  static void
  createcompctltable(void)
***************
*** 274,279 ****
--- 284,372 ----
  	setsparam(reply, buf);
      }
      return 0;
+ }
+ 
+ /* Copy the given string and remove backslashes from the copy and return it. */
+ 
+ /**/
+ char *
+ rembslash(char *s)
+ {
+     char *t = s = dupstring(s);
+ 
+     while (*s)
+ 	if (*s == '\\') {
+ 	    chuck(s);
+ 	    if (*s)
+ 		s++;
+ 	} else
+ 	    s++;
+ 
+     return t;
+ }
+ 
+ /* Quote the string s and return the result.  If e is non-zero, the        *
+  * pointer it points to may point to a position in s and in e the position *
+  * of the corresponding character in the quoted string is returned.  Like  *
+  * e, te may point to a position in the string and pl is used to return    *
+  * the position of the character pointed to by te in the quoted string.    *
+  * The string is metafied and may contain tokens.                          */
+ 
+ /**/
+ char *
+ quotename(const char *s, char **e, char *te, int *pl)
+ {
+     const char *u, *tt;
+     char *v, buf[PATH_MAX * 2];
+     int sf = 0;
+ 
+     tt = v = buf;
+     u = s;
+     for (; *u; u++) {
+ 	if (e && *e == u)
+ 	    *e = v, sf |= 1;
+ 	if (te == u)
+ 	    *pl = v - tt, sf |= 2;
+ 	if (ispecial(*u) &&
+ 	    (!instring || (isset(BANGHIST) &&
+ 			   *u == (char)bangchar) ||
+ 	     (instring == 2 &&
+ 	      (*u == '$' || *u == '`' || *u == '\"')) ||
+ 	     (instring == 1 && *u == '\''))) {
+ 	    if (*u == '\n' || (instring == 1 && *u == '\'')) {
+ 		if (unset(RCQUOTES)) {
+ 		    *v++ = '\'';
+ 		    if (*u == '\'')
+ 			*v++ = '\\';
+ 		    *v++ = *u;
+ 		    *v++ = '\'';
+ 		} else if (*u == '\n')
+ 		    *v++ = '"', *v++ = '\n', *v++ = '"';
+ 		else
+ 		    *v++ = '\'', *v++ = '\'';
+ 		continue;
+ 	    } else
+ 		*v++ = '\\';
+ 	}
+ 	if(*u == Meta)
+ 	    *v++ = *u++;
+ 	*v++ = *u;
+     }
+     *v = '\0';
+     if (strcmp(buf, s))
+ 	tt = dupstring(buf);
+     else
+ 	tt = s;
+     v += tt - buf;
+     if (e && (sf & 1))
+ 	*e += tt - buf;
+ 
+     if (e && *e == u)
+ 	*e = v;
+     if (te == u)
+ 	*pl = v - tt;
+ 
+     return (char *) tt;
  }
  
  /**/
diff -c Src/Zle/compctl.c ../Src/Zle/compctl.c
*** Src/Zle/compctl.c	Thu Aug  6 15:51:54 1998
--- ../Src/Zle/compctl.c	Fri Aug  7 08:42:16 1998
***************
*** 1132,1137 ****
--- 1132,1139 ----
      cclist = 0;
      showmask = 0;
  
+     instring = 0;
+ 
      /* Parse all the arguments */
      if (*argv) {
  	cc = (Compctl) zcalloc(sizeof(*cc));
diff -c Src/Zle/zle_tricky.c ../Src/Zle/zle_tricky.c
*** Src/Zle/zle_tricky.c	Thu Aug  6 15:51:56 1998
--- ../Src/Zle/zle_tricky.c	Fri Aug  7 08:43:23 1998
***************
*** 781,789 ****
      } LASTALLOC;
  }
  
- /* 1 if we are completing in a string */
- static int instring;
- 
  /* 1 if we are completing the prefix */
  static int comppref;
  
--- 781,786 ----
***************
*** 1406,1475 ****
  }
  
  
- /* Quote the string s and return the result.  If e is non-zero, the        *
-  * pointer it points to may point to a position in s and in e the position *
-  * of the corresponding character in the quoted string is returned.  Like  *
-  * e, te may point to a position in the string and pl is used to return    *
-  * the position of the character pointed to by te in the quoted string.    *
-  * The string is metafied and may contain tokens.                          */
- 
- /**/
- char *
- quotename(const char *s, char **e, char *te, int *pl)
- {
-     const char *u, *tt;
-     char *v, buf[PATH_MAX * 2];
-     int sf = 0;
- 
-     tt = v = buf;
-     u = s;
-     for (; *u; u++) {
- 	if (e && *e == u)
- 	    *e = v, sf |= 1;
- 	if (te == u)
- 	    *pl = v - tt, sf |= 2;
- 	if (ispecial(*u) &&
- 	    (!instring || (isset(BANGHIST) &&
- 			   *u == (char)bangchar) ||
- 	     (instring == 2 &&
- 	      (*u == '$' || *u == '`' || *u == '\"')) ||
- 	     (instring == 1 && *u == '\''))) {
- 	    if (*u == '\n' || (instring == 1 && *u == '\'')) {
- 		if (unset(RCQUOTES)) {
- 		    *v++ = '\'';
- 		    if (*u == '\'')
- 			*v++ = '\\';
- 		    *v++ = *u;
- 		    *v++ = '\'';
- 		} else if (*u == '\n')
- 		    *v++ = '"', *v++ = '\n', *v++ = '"';
- 		else
- 		    *v++ = '\'', *v++ = '\'';
- 		continue;
- 	    } else
- 		*v++ = '\\';
- 	}
- 	if(*u == Meta)
- 	    *v++ = *u++;
- 	*v++ = *u;
-     }
-     *v = '\0';
-     if (strcmp(buf, s))
- 	tt = dupstring(buf);
-     else
- 	tt = s;
-     v += tt - buf;
-     if (e && (sf & 1))
- 	*e += tt - buf;
- 
-     if (e && *e == u)
- 	*e = v;
-     if (te == u)
- 	*pl = v - tt;
- 
-     return (char *) tt;
- }
- 
  /* This adds a match to the list of matches.  The string to add is given   *
   * in s, the type of match is given in the global variable addwhat and     *
   * the parameter t (if not NULL) is a pointer to a hash node node which    *
--- 1403,1408 ----
***************
*** 1828,1852 ****
  
      scanhashtable(nameddirtab, 0, (addwhat==-1) ? 0 : ND_USERNAME, 0,
  	    addhnmatch, 0);
- }
- 
- /* Copy the given string and remove backslashes from the copy and return it. */
- 
- /**/
- char *
- rembslash(char *s)
- {
-     char *t = s = dupstring(s);
- 
-     while (*s)
- 	if (*s == '\\') {
- 	    chuck(s);
- 	    if (*s)
- 		s++;
- 	} else
- 	    s++;
- 
-     return t;
  }
  
  /* This does the check for compctl -x `n' and `N' patterns. */
--- 1761,1766 ----


--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

