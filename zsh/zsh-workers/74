From zsh-workers-request@math.gatech.edu  Tue Jun  6 02:11:08 1995
Received: from gatech.edu (gatech.edu [130.207.244.244]) by werple.mira.net.au (8.6.12/8.6.9) with SMTP id CAA03772 for <mason@werple.mira.net.au>; Tue, 6 Jun 1995 02:11:02 +1000
Received: from math (math.skiles.gatech.edu) by gatech.edu with SMTP id AA08343
  (5.65c/Gatech-10.0-IDA for <mason@werple.mira.net.au>); Mon, 5 Jun 1995 12:10:55 -0400
Received: by math (5.x/SMI-SVR4)
	id AA12344; Mon, 5 Jun 1995 12:08:06 -0400
Resent-Date: Mon, 05 Jun 95 17:02:55 +0100
Old-Return-Path: <P.Stephenson@swansea.ac.uk>
Message-Id: <12964.9506051602@pyro.swan.ac.uk>
Pp-Warning: Illegal Via field on preceding line
To: zsh-workers@math.gatech.edu (Zsh hackers list)
Subject: condition text clean up
Date: Mon, 05 Jun 95 17:02:55 +0100
From: P.Stephenson@swansea.ac.uk
X-Mts: smtp
Resent-Message-Id: <"oJGti3.0.k03.bloql"@math>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/74
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

While I'm waiting for some simulations to run, here's a minor
smartening up for the code you get back from conditions when zsh
disgorges some previously parsed code.  The main change is in the
parenthesising.

% fn () { [[ -t 0 && -t 1 && -t 2 || -t 3 || -t 4 && -t 5 || -t 6 ]] ; }
% which fn

Before:

fn () {
        [[ ( (  -t 0 && (  -t 1 &&  -t 2 ) ) || (  -t 3 || ( (  -t 4 &&  -t 5 ) ||  -t 6 ) ) ) ]]
}

After:

fn () {
        [[ ( -t 0 && -t 1 && -t 2 ) || -t 3 || ( -t 4 && -t 5 ) || -t 6 ]]
}

As you will see, I have retained some parentheses around && code which
are strictly unnecessary since that has a higher precedence than ||
anyway, just for clarity.  They are trivial to remove if that is
deemed preferable.

If you're interested, it's still not the same as what ksh does:  that
seems to remember all the parentheses whether they're necessary or
not.  I think this way's neater.

*** Src/text.c.cond	Wed May 31 05:10:41 1995
--- Src/text.c	Mon Jun  5 16:56:59 1995
***************
*** 158,164 ****
  gettext2(struct node *n)
  {
      Cmd nn;
-     Cond nm;
  
      if (!n || ((List) n) == &dummy_list)
  	return;
--- 158,163 ----
***************
*** 293,344 ****
  	getredirs(nn);
  	break;
      case N_COND:
! 	nm = _Cond(n);
! 	switch (nm->type) {
! 	case COND_NOT:
! 	    taddstr("! ");
! 	    gt2(nm->left);
! 	    break;
! 	case COND_AND:
! 	    taddstr("( ");
! 	    gt2(nm->left);
! 	    taddstr(" && ");
! 	    gt2(nm->right);
! 	    taddstr(" )");
! 	    break;
! 	case COND_OR:
! 	    taddstr("( ");
! 	    gt2(nm->left);
! 	    taddstr(" || ");
! 	    gt2(nm->right);
! 	    taddstr(" )");
! 	    break;
! 	default:
! 	    {
! 		static char *c1[] =
! 		{
! 		    " = ", " != ", " < ", " > ", " -nt ", " -ot ", " -ef ", " -eq ",
! 		    " -ne ", " -lt ", " -gt ", " -le ", " -ge "
! 		};
! 
! 		if (nm->right)
! 		    taddstr(nm->left);
! 		if (nm->type <= COND_GE)
! 		    taddstr(c1[nm->type - COND_STREQ]);
! 		else {
! 		    char c2[5];
! 
! 		    c2[0] = ' ';
! 		    c2[1] = '-';
! 		    c2[2] = nm->type;
! 		    c2[3] = ' ';
! 		    c2[4] = '\0';
! 		    taddstr(c2);
! 		}
! 		taddstr((nm->right) ? nm->right : nm->left);
! 	    }
! 	    break;
! 	}
  	break;
      case N_CASE:
  	{
--- 292,298 ----
  	getredirs(nn);
  	break;
      case N_COND:
! 	getcond(_Cond(n), 0);
  	break;
      case N_CASE:
  	{
***************
*** 407,412 ****
--- 361,427 ----
  	taddstr("done");
  	break;
      }
+ }
+ 
+ /* 
+  * Print a condition bracketed by [[ ... ]].
+  * With addpar non-zero, parenthesise the subexpression.
+  */
+ 
+ /**/
+ void
+ getcond(Cond nm, int addpar)
+ {
+     static char *c1[] =
+     {
+ 	"=", "!=", "<", ">", "-nt", "-ot", "-ef", "-eq",
+ 	"-ne", "-lt", "-gt", "-le", "-ge"
+     };
+ 
+     if (addpar)
+ 	taddstr("( ");
+     switch (nm->type) {
+     case COND_NOT:
+ 	taddstr("! ");
+ 	getcond(nm->left, _Cond(nm->left)->type <= COND_OR);
+ 	break;
+     case COND_AND:
+ 	getcond(nm->left, _Cond(nm->left)->type == COND_OR);
+ 	taddstr(" && ");
+ 	getcond(nm->right, _Cond(nm->right)->type == COND_OR);
+ 	break;
+     case COND_OR:
+ 	/*
+ 	 * This is deliberately over-generous with parentheses:
+ 	 * in fact omitting them gives correct precedence.
+ 	 */
+ 	getcond(nm->left, _Cond(nm->left)->type == COND_AND);
+ 	taddstr(" || ");
+ 	getcond(nm->right, _Cond(nm->right)->type == COND_AND);
+ 	break;
+     default:
+ 	if (nm->type <= COND_GE) {
+ 	    /* Binary test: `a = b' etc. */
+ 	    taddstr(nm->left);
+ 	    taddstr(" ");
+ 	    taddstr(c1[nm->type - COND_STREQ]);
+ 	    taddstr(" ");
+ 	    taddstr(nm->right);
+ 	} else {
+ 	    /* Unary test: `-f foo' etc. */ 
+ 	    char c2[4];
+ 
+ 	    c2[0] = '-';
+ 	    c2[1] = nm->type;
+ 	    c2[2] = ' ';
+ 	    c2[3] = '\0';
+ 	    taddstr(c2);
+ 	    taddstr(nm->left);
+ 	}
+ 	break;
+     }
+     if (addpar)
+ 	taddstr(" )");
  }
  
  /**/

-- 
Peter Stephenson <P.Stephenson@swansea.ac.uk>  Tel: +44 1792 205678 extn. 4461
WWW:  http://python.swan.ac.uk/~pypeters/      Fax: +44 1792 295324
Department of Physics, University of Wales, Swansea,
Singleton Park, Swansea, SA2 8PP, U.K.

