From zsh-workers-return-9835-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Feb 23 09:36:55 2000
Return-Path: <zsh-workers-return-9835-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 16870 invoked from network); 23 Feb 2000 09:36:53 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 23 Feb 2000 09:36:53 -0000
Received: (qmail 26125 invoked by alias); 23 Feb 2000 09:36:46 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 9835
Received: (qmail 26115 invoked from network); 23 Feb 2000 09:36:45 -0000
Date: Wed, 23 Feb 2000 10:36:41 +0100 (MET)
Message-Id: <200002230936.KAA18046@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
Subject: PATCH: warnings and misc


(I think this is going to be yet another zsh day...)


I wasn't happy with the way warnings (i.e.: no matches) were displayed 
any more. This makes a format style for warnings that does not contain 
`%d' be treated differently: the descriptions for the expected matches 
are simply listed like a completion list.

Then there is an attempt to document the single-ignored style.

BUT...

I'm currently thinking about changing that style or, more precisly,
extending it so that it also should be renamed. The problem I found
(while reading the guide, btw) is this:

If you set up the ignored-patterns style for functions as suggested in
the guide:

  zstyle ':completion:*:functions' ignored-patterns '_*'

and you have the _approximate completer in your list, you'll almost
certainly won't get functions beginning with an underscore after
`_<TAB>', but instead get corrections. Now one could fiddle with the
context for ignored-patterns and such, but I don't find any of the
results really good.

Maybe we should make someone test if $compstate[alternate_matches] is
non-zero somewhere, sometime. But who, where, when? Possibilities that 
come to mind are:

- in the completers, at the beginning (i.e. don't execute the
  completer if there are alternate matches); probably controlled by
  some common style
- but that would give is replicated code (although very simple one),
  so maybe we should just make _main_complete test a style (like
  `ignored' (there still must be a betetr name); this would then be
  the generalisation of single-ignored) after every completer with a
  context like the one used to look up matcher-list; that is probably
  configurable enough
- or maybe we should change that and some completely different place,
  namely: in _main_complete use a new style to set up the parameter
  $nmatches to either '$compstate[nmatches]' or '$compstate[nmatches]+
  $compstate[alternate_nmatches]' (I mean literal string here, not the 
  results of expanding those strings), and then change every use of
  $compstate[nmatches] to ${(e)nmatches}; this would make alternate
  matches be treated like normal ones in a certain sense

Hm. Opinions or suggestions?

Bye
 Sven

diff -ru ../z.old/Completion/Builtins/_zstyle Completion/Builtins/_zstyle
--- ../z.old/Completion/Builtins/_zstyle	Wed Feb 23 09:03:17 2000
+++ Completion/Builtins/_zstyle	Wed Feb 23 10:15:29 2000
@@ -54,6 +54,7 @@
   prefix-needed		 c:bool
   prompt		 c:
   remove-all-dups	 c:bool
+  single-ignored         c:single-ignored
   sort			 c:bool
   tag-order		 c:tag
   special-dirs		 c:sdirs
@@ -206,6 +207,11 @@
     ignorepar)
       _wanted values expl 'which parents to ignore' &&
         compadd "$expl[@]" parent pwd .. directory
+      ;;
+
+    single-ignored)
+      _wanted values expl 'how to handle single alternate match' &&
+          compadd "$expl[@]" - show menu
       ;;
 
     _*)
diff -ru ../z.old/Completion/Core/_main_complete Completion/Core/_main_complete
--- ../z.old/Completion/Core/_main_complete	Wed Feb 23 09:03:20 2000
+++ Completion/Core/_main_complete	Wed Feb 23 10:09:49 2000
@@ -97,7 +97,7 @@
   esac
 fi
 
-if [[ -n "$tmp" || $compstate[nmatches] -gt 1 ]]; then
+if [[ -n "$tmp" || $compstate[nmatches]+$compstate[alternate_nmatches] -gt 1 ]]; then
   [[ _last_nmatches -ge 0 && _last_nmatches -ne compstate[nmatches] ]] &&
       _menu_style=( "$_last_menu_style[@]" "$_menu_style[@]" )
 
@@ -146,27 +146,35 @@
 	  (( min )) || break
         done
 
+        zmodload -i zsh/complist
         SELECTMIN="$min"
       fi
     fi
   fi
-elif [[ $compstate[nmatches] -eq 0 && $#_lastdescr -ne 0 ]] &&
+elif [[ $compstate[nmatches]+$compstate[alternate_nmatches] -eq 0 &&
+        $#_lastdescr -ne 0 ]] &&
      zstyle -s ":completion:${curcontext}:warnings" format format; then
-  local str
-
-  _lastdescr=( "\`${(@)^_lastdescr:#}'" )
 
   compstate[list]='list force'
   compstate[insert]=''
 
-  case $#_lastdescr in
-  1) str="$_lastdescr[1]";;
-  2) str="$_lastdescr[1] or $_lastdescr[2]";;
-  *) str="${(j:, :)_lastdescr[1,-2]}, or $_lastdescr[-1]";;
-  esac
+  if [[ "$format" = *%d* ]]; then
+    local str mesg
+
+    _lastdescr=( "\`${(@)^_lastdescr:#}'" )
 
-  zformat -f format "$format" "d:$str"
-  compadd -UX "$format" -n ''
+    case $#_lastdescr in
+    1) str="$_lastdescr[1]";;
+    2) str="$_lastdescr[1] or $_lastdescr[2]";;
+    *) str="${(j:, :)_lastdescr[1,-2]}, or $_lastdescr[-1]";;
+    esac
+
+    zformat -f mesg "$format" "d:$str"
+    compadd -UX "$mesg" -n - ''
+  else
+    _setup warnings
+    compadd -UQX "$format" -V warnings - "${(@)_lastdescr:#}"
+  fi
 fi
 
 # Now call the post-functions.
diff -ru ../z.old/Doc/Zsh/compsys.yo Doc/Zsh/compsys.yo
--- ../z.old/Doc/Zsh/compsys.yo	Wed Feb 23 09:02:59 2000
+++ Doc/Zsh/compsys.yo	Wed Feb 23 10:20:17 2000
@@ -841,7 +841,12 @@
 
 Finally, for the tt(warnings) tag, it is printed when no matches could 
 be generated at all. In this case the `tt(%d)' is replaced with the
-descriptions for the matches that were expected.
+descriptions for the matches that were expected. If the value does not 
+contain a `tt(%d)', then those descriptions are added in the same way
+as matches are added, i.e. they appear below the value for the
+tt(format) style laid out in columns. The descriptions are added as if 
+for the tag tt(warnings) so that you can use the tt(list-colors) style 
+for that tag to highlight them.
 
 Here and in all other cases where the completion system uses `tt(%)'
 sequences, the `tt(%)' may be followed by field width specifications as 
@@ -1302,6 +1307,17 @@
 The tt(_history_complete_word) bindable command uses this to decide if 
 all duplicate matches should be removed, rather than just consecutive
 duplicates.
+)
+item(tt(single-ignored))(
+Using styles like tt(ignored-patterns) allows one to put some matches
+in the alternate set of matches which is only used if there are no
+`normal' matches. Having only one such normally ignored match is often 
+a special case because one probably doesn't want that match to be
+inserted immediatly. This style allows to configure what to do in such 
+a case. If its value is tt(show), the single match will only be shown, 
+not inserted. If the value is tt(menu), then the single match and the
+original string are both added as matches and menucompletion is
+started so that one can easily select either of them.
 )
 item(tt(sort))(
 If set to `true', completion functions that generate words from the

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

