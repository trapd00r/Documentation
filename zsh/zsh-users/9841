From zsh-users-return-9841-mason-zsh=primenet.com.au@sunsite.dk Fri Jan 20 02:11:56 2006
Return-Path: <zsh-users-return-9841-mason-zsh=primenet.com.au@sunsite.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 10085 invoked from network); 20 Jan 2006 02:11:53 -0000
X-Spam-Checker-Version: SpamAssassin 3.1.0 (2005-09-13) on f.primenet.com.au
X-Spam-Level: 
X-Spam-Status: No, score=-2.5 required=5.0 tests=AWL,BAYES_00,
	FORGED_RCVD_HELO autolearn=ham version=3.1.0
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by ns1.primenet.com.au with SMTP; 20 Jan 2006 02:11:53 -0000
Received: (qmail 99178 invoked from network); 20 Jan 2006 02:11:47 -0000
Received: from sunsite.dk (130.225.247.90)
  by a.mx.sunsite.dk with SMTP; 20 Jan 2006 02:11:47 -0000
Received: (qmail 20193 invoked by alias); 20 Jan 2006 02:11:40 -0000
Mailing-List: contact zsh-users-help@sunsite.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-users@sunsite.dk
X-Seq: 9841
Received: (qmail 20184 invoked from network); 20 Jan 2006 02:11:40 -0000
Received: from news.dotsrc.org (HELO a.mx.sunsite.dk) (130.225.247.88)
  by sunsite.dk with SMTP; 20 Jan 2006 02:11:40 -0000
Received: (qmail 98053 invoked from network); 20 Jan 2006 02:11:39 -0000
Received: from vms042pub.verizon.net (206.46.252.42)
  by a.mx.sunsite.dk with SMTP; 20 Jan 2006 02:11:38 -0000
Received: from candle.brasslantern.com ([71.116.81.225])
 by vms042.mailsrvcs.net
 (Sun Java System Messaging Server 6.2-4.02 (built Sep  9 2005))
 with ESMTPA id <0ITD0042MCRA63K1@vms042.mailsrvcs.net> for
 zsh-users@sunsite.dk; Thu, 19 Jan 2006 20:11:35 -0600 (CST)
Received: from candle.brasslantern.com (IDENT:schaefer@localhost [127.0.0.1])
	by candle.brasslantern.com (8.12.11/8.12.11) with ESMTP id k0K2BX3N018382	for
 <zsh-users@sunsite.dk>; Thu, 19 Jan 2006 18:11:33 -0800
Received: (from schaefer@localhost)	by candle.brasslantern.com
 (8.12.11/8.12.11/Submit) id k0K2BXrT018381	for zsh-users@sunsite.dk; Thu,
 19 Jan 2006 18:11:33 -0800
Date: Fri, 20 Jan 2006 02:11:32 +0000
From: Bart Schaefer <schaefer@brasslantern.com>
Subject: Re: Command Utility Belt
In-reply-to: <20060119193721.GA8560@namib.cs.utk.edu>
To: zsh-users@sunsite.dk
Message-id: <1060120021132.ZM18380@candle.brasslantern.com>
MIME-version: 1.0
X-Mailer: Z-Mail (5.0.0 30July97)
Content-type: text/plain; charset=us-ascii
References: <20060119193721.GA8560@namib.cs.utk.edu>
Comments: In reply to Chris Johnson <cjohnson@cs.utk.edu>
 "Command Utility Belt" (Jan 19,  2:37pm)

On Jan 19,  2:37pm, Chris Johnson wrote:
}
} I'm finding that I have a lot of semi-often used commands that aren't
} exactly appropriate for aliasing -- they need minor editing each time I
} call on them.
} 
} [...]
} 
} Has anyone else implemented such a "command utility belt" and have
} recommendations?

I do this with the completion system.

In a directory in my fpath I have a file whose name begins with an
underscore with contents like so:

---- 8< --- snip --- 8< ----
#compdef -k menu-select ^X:
(( CURRENT == 1 )) || return 1
local -a commands
commands=(${(f)"$(cat)"}) <<\EOF
 ... a list of commands here, one per line ...
EOF
compadd -Q "$commands[@]"
---- 8< --- snip --- 8< ----

This installs itself during "compinit" so when I type control-X colon
in "command position" I get a menu of the listed commands.

The reason this is restricted to command position is, completion does
not deal well with matches that contain multiple result words.  It
really wants to operate on a single IFS-delimited word only.  When an
entire command -- which might contain command separators, quotes, and
so on -- gets inserted into the command line by the first pass through
completion, all bets are off on the next iteration.  In the command
position, and with menu selection explicitly invoked, completion does
not have a chance to get confused until after you've committed to a
particular choice.

A potentially useful extension to this would be to store the list of
commands outside the actual function, and have another key binding
to append the current command to the file.  This could probably be
done with the push/pop history mechanism, which didn't exist at the
time I wrote this.

In fact, a possible alternative to using completion is a keybinding
that pushes a new history file and does a recursive edit until you
select a command, then restores the old history and calls accept-line.
I may even fool around with that ...

