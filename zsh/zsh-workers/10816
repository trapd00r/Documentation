From zsh-workers-return-10816-mason-zsh=primenet.com.au@sunsite.auc.dk Wed Apr 19 06:48:08 2000
Return-Path: <zsh-workers-return-10816-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 27250 invoked from network); 19 Apr 2000 06:48:04 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 19 Apr 2000 06:48:04 -0000
Received: (qmail 19579 invoked by alias); 19 Apr 2000 06:47:43 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10816
Received: (qmail 19471 invoked from network); 19 Apr 2000 06:47:42 -0000
Date: Wed, 19 Apr 2000 08:47:34 +0200 (MET DST)
Message-Id: <200004190647.IAA20551@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: Peter Stephenson's message of Tue, 18 Apr 2000 10:16:07 +0100
Subject: Re: PATCH: scrolling completion lists (was: Re: Questions)


Peter Stephenson wrote:

> Some other minor comments on scrolling, which I'm not suggesting any
> immediate action on:
> 
> - the %l in list-prompt adds some spaces after it, so a message like
>   `listing completions at %l, space to scroll'
>   looks a little messy

The patch adds %[MLP] as you suggested. To repeat: the uppercase forms 
used fixed widths, the lowercase ones don't

> - maybe it would be better if this one understood %p, too, just for
>   consistency

Done. Even %m is allowed.

> - maybe there should likewise by a (different) default prompt here, too

There is now a default in shell code. If one doesn't want to use
scrolling, one can set the list-prompt style to an empty string.

> - I understand the need for the difference between scrolling in listing and
>   in menu selection, but (this is basically what Zefram was saying) we need
>   to keep it as intuitive as possible.  So for example I'm not necessarily
>   yet convinced that it would be a bad thing to be able to scroll backwards
>   in the completion list form (given this is already in the code).

I have not done that yet, because I wasn't sure how to do this
best. Currently even scrolled lists use only very simple terminal
stuff, i.e. it should work everywhere and on an xterm one can use the
terminal's scrolling feature to scroll back.
If we want to support going back in a non-menu-selection list, this
would have to be changed one way or the other. The simplest solution
would be to just output the previous screenful (without moving the
cursor up before that). But that looks like doing it in a way we could 
do better.
So maybe we would want to make this much more like the way menu-select 
does it (that would also be easiest to implement). We could probably
use the current implementation as a fallback for dumb terminals.
If we do it like menu-select, should we also try to keep the prompt on 
the screen, so that alwayslastprompt puts the cursor back on it?
Or should we use alwayslastprompt to toggle between listing as in
menu-select (with going back to the prompt etc.) and the style we have 
now (with alwayslastprompt unset, obviously)? Hm, that actually seems
to make sense...

Bye
 Sven

Index: Completion/Core/_main_complete
===================================================================
RCS file: /cvsroot/zsh/zsh/Completion/Core/_main_complete,v
retrieving revision 1.7
diff -u -r1.7 _main_complete
--- Completion/Core/_main_complete	2000/04/18 07:36:56	1.7
+++ Completion/Core/_main_complete	2000/04/19 06:45:34
@@ -56,8 +56,9 @@
                 )
 _last_menu_style=()
 
-if zstyle -s ":completion:${curcontext}:default" list-prompt LISTPROMPT &&
-   [[ -n "$LISTPROMPT" ]]; then
+zstyle -s ":completion:${curcontext}:default" list-prompt LISTPROMPT ||
+    LISTPROMPT='Current position at %P    Continue? '
+if [[ -n "$LISTPROMPT" ]]; then
   zmodload -i zsh/complist
   compstate[list_max]=scroll
 fi
Index: Doc/Zsh/compsys.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/compsys.yo,v
retrieving revision 1.19
diff -u -r1.19 compsys.yo
--- Doc/Zsh/compsys.yo	2000/04/18 07:36:56	1.19
+++ Doc/Zsh/compsys.yo	2000/04/19 06:45:35
@@ -1274,11 +1274,21 @@
 ifzman(the description of the tt(zsh/complist) module in zmanref(zshmodules))\
 ifnzman(noderef(The zsh/complist Module))\
 ). The value will be displayed after every screenful, prompting for a
-key and may contain the escape `tt(%l)' which will be replaced by the
-number of the last line displayed and the total number of lines. As
+key press. It may contain the escape `tt(%l)' or `tt(%L)' which will be
+replaced by the number of the last line displayed and the total number
+of lines. A `tt(%m)' or `tt(%M)' will be replaced by the number of the 
+last match shown and the total number of matches and `tt(%p)' and
+`tt(%P)' will be replaced by `tt(Top)' when at the beginning of the
+list, `tt(Bottom)' when at the end and the position shown in percent
+of the total length. In each of these cases the form with the
+uppercase letter is replaced by a string of fixed width, padded to the 
+right with spaces. As
 usual, the `tt(%S)', `tt(%s)', `tt(%B)', `tt(%b)', `tt(%U)', `tt(%u)',
 and `tt(%{)...tt(%})' escapes for the terminal display modes are
 understood, too.
+
+Note that this style has a default value. If you don't want to use
+scrolling, set this style to an empty string.
 )
 kindex(list-rows-first, completion style)
 item(tt(list-rows-first))(
@@ -1578,11 +1588,7 @@
 value will be displayed during menu-selection (see the tt(menu) style
 above) when the completion list does not fit on the screen as a
 whole. The same escapes as for the tt(list-prompt) style are
-understood, plus `tt(%m)' which is replaced by the number of the
-currently selected match and the total number of matches and `tt(%p)'
-which is replaced by `tt(Top)' when the mark is on the first line,
-`tt(Bottom)' when it is on the last line and the relative position of
-the mark in the list given as a percentage.
+understood, but give the number of the match or line the mark is on.
 )
 kindex(select-scroll, completion style)
 item(tt(select-scroll))(
Index: Doc/Zsh/mod_complist.yo
===================================================================
RCS file: /cvsroot/zsh/zsh/Doc/Zsh/mod_complist.yo,v
retrieving revision 1.4
diff -u -r1.4 mod_complist.yo
--- Doc/Zsh/mod_complist.yo	2000/04/18 08:50:13	1.4
+++ Doc/Zsh/mod_complist.yo	2000/04/19 06:45:35
@@ -159,10 +159,16 @@
 If the parameter tt(LISTPROMPT) is set, its value will be used as the
 prompt.  The value may contain escapes of the form `tt(%x)'. It
 supports the escapes `tt(%B)', `tt(%b)', `tt(%S)', `tt(%s)', `tt(%U)',
-`tt(%u)' and `tt(%{...%})' known from the shell prompts and the
-additional sequence `tt(%l)' which is replaced by the number of the
-last line shown and the total number of lines in the form
-`var(number)tt(/)var(total)'.
+`tt(%u)' and `tt(%{...%})' known from the shell prompts and three
+pairs of additional sequences. A `tt(%l)' or `tt(%L)' is replaced by
+the number of the last line shown and the total number of lines in the form
+`var(number)tt(/)var(total)'. A `tt(%m)' or `tt(%M)' is replaced with
+the number of the last match shown and the total number of matches and 
+`tt(%p)' or `tt(%P)' is replaced with `tt(Top)', `tt(Bottom)' or the
+position of the first line shown in percent of the total number of
+lines, respectively. In each of these cases the one with the uppercase 
+letter will be replaced with a string of fixed width, padded to the
+right with spaces.
 
 As for the tt(ZLS_COLORS) and tt(ZLS_COLOURS) parameters,
 tt(LISTPROMPT) should not be set directly when using the shell
@@ -207,13 +213,9 @@
 
 If there are more matches than fit on the screen and the parameter
 tt(SELECTPROMPT) is set, its value will be shown below the
-matches. Next to the escape sequences understood for the
-tt(LISTPROMPT) parameter, a `tt(%m)' will be replaced by a string
-containing the number of the match the mark is on and the total number 
-of matches in the form `var(number)tt(/)var(total)' and the sequence
-`tt(%p)' will be replaced with `tt(Top)', `tt(Bottom)' or the position
-in percent of the total size when the mark is in the first line, in
-the last line or somewhere in between, respectively.
+matches. It supports the sames escape sequences as tt(LISTPROMPT), but 
+the number of the match or line shown will be that of the one where
+the mark is placed.
 
 The tt(SELECTSCROLL) parameter can be used to specify how the list is
 scrolled. If the parameter is unset, this is done line by line, if it
Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.3
diff -u -r1.3 complist.c
--- Src/Zle/complist.c	2000/04/18 07:36:56	1.3
+++ Src/Zle/complist.c	2000/04/19 06:45:35
@@ -383,7 +383,7 @@
 
 static int noselect, mselect, inselect, mcol, mline, mcols, mlines, mmlen;
 static int selected, mlbeg = -1, mlend = 9999999, mscroll, mrestlines;
-static int mnew, mlastcols, mlastlines, mhasstat;
+static int mnew, mlastcols, mlastlines, mhasstat, mfirstl, mlastm;
 static char *mstatus;
 static Cmatch **mtab, **mmtabp;
 static Cmgroup *mgtab, *mgtabp;
@@ -656,7 +656,7 @@
     Thingy cmd;
     int i, ret = 0;
 
-    compprintfmt(NULL, -1, 1, 1, ml, NULL);
+    compprintfmt(NULL, 1, 1, 1, ml, NULL);
 
     fflush(shout);
     zsetterm();
@@ -791,24 +791,38 @@
 			p--;
 		    break;
 		case 'm':
-		    if (stat && n >= 0) {
-			sprintf(nbuf, "%d/%d", mselect, listdat.nlist);
+		    if (stat) {
+			sprintf(nc, "%d/%d", (n ? mlastm : mselect),
+				listdat.nlist);
+			m = 2;
+		    }
+		    break;
+		case 'M':
+		    if (stat) {
+			sprintf(nbuf, "%d/%d", (n ? mlastm : mselect),
+				listdat.nlist);
 			sprintf(nc, "%-9s", nbuf);
 			m = 2;
 		    }
 		    break;
 		case 'l':
 		    if (stat) {
+			sprintf(nc, "%d/%d", ml + 1, listdat.nlines);
+			m = 2;
+		    }
+		    break;
+		case 'L':
+		    if (stat) {
 			sprintf(nbuf, "%d/%d", ml + 1, listdat.nlines);
 			sprintf(nc, "%-9s", nbuf);
 			m = 2;
 		    }
 		    break;
 		case 'p':
-		    if (stat && n >= 0) {
+		    if (stat) {
 			if (ml == listdat.nlines - 1)
 			    strcpy(nc, "Bottom");
-			else if (mlbeg || ml != n)
+			else if (n ? mfirstl : (mlbeg > 0 || ml != mfirstl))
 			    sprintf(nc, "%d%%",
 				    ((ml + 1) * 100) / listdat.nlines);
 			else
@@ -816,6 +830,18 @@
 			m = 2;
 		    }
 		    break;
+		case 'P':
+		    if (stat) {
+			if (ml == listdat.nlines - 1)
+			    strcpy(nc, "Bottom");
+			else if (n ? mfirstl : (mlbeg > 0 || ml != mfirstl))
+			    sprintf(nc, "%2d%%   ",
+				    ((ml + 1) * 100) / listdat.nlines);
+			else
+			    strcpy(nc, "Top   ");
+			m = 2;
+		    }
+		    break;
 		}
 		if (m == 2 && dopr == 1) {
 		    int l = strlen(nc);
@@ -853,6 +879,8 @@
 		    ml++;
 		if (mscroll && beg && !--mrestlines && (ask = asklistscroll(ml))) {
 		    *stop = 1;
+		    if (stat && n)
+			mfirstl = -1;
 		    return l + (cc / columns);
 		}
 	    }
@@ -861,6 +889,9 @@
     if (dopr && mlbeg >= 0 && tccan(TCCLEAREOL))
 	tcout(TCCLEAREOL);
 
+    if (stat && n)
+	mfirstl = -1;
+
     return l + (cc / columns);
 }
 
@@ -944,8 +975,9 @@
     Cmatch *p, m;
     Cexpl *e;
     int pnl = 0, cl, mc = 0, ml = 0, printed = 0, stop = 0, asked = 1;
-    int lastused = 0, fl = -1;
+    int lastused = 0;
 
+    mfirstl = -1;
     if (mnew || lastbeg != mlbeg || mlbeg < 0) {
 	lasttype = 0;
 	lastg = NULL;
@@ -988,6 +1020,8 @@
 				tcout(TCCLEAREOD);
 			}
 		    }
+		    if (mlbeg < 0 && mfirstl < 0)
+			mfirstl = ml;
 		    l = compprintfmt((*e)->str, (*e)->count, dolist(ml), 1,
 				     ml, &stop);
 		    if (stop)
@@ -1026,6 +1060,8 @@
 			tcout(TCCLEAREOD);
 		}
 	    }
+	    if (mlbeg < 0 && mfirstl < 0)
+		mfirstl = ml;
 	    if (g->flags & CGF_LINES) {
 		while (*pp) {
 		    if (compzputs(*pp, ml))
@@ -1112,8 +1148,8 @@
 				    tcout(TCCLEAREOD);
 			    }
 			}
-			if (fl < 0)
-			    fl = ml;
+			if (mfirstl < 0)
+			    mfirstl = ml;
 			if (dolist(ml))
 			    printed++;
 			if (clprintm(g, p, 0, ml, 1, 0, NULL, NULL))
@@ -1183,8 +1219,8 @@
 
 		    if (dolist(ml))
 			printed++;
-		    if (fl < 0)
-			fl = ml;
+		    if (mfirstl < 0)
+			mfirstl = ml;
 
 		    if (--n)
 			for (j = ((g->flags & CGF_ROWS) ? 1 : nc);
@@ -1233,7 +1269,7 @@
 	    if ((ml = listdat.nlines + nlnct) >= lines) {
 		if (mhasstat) {
 		    putc('\n', shout);
-		    compprintfmt(NULL, fl, 1, 1, mline, NULL);
+		    compprintfmt(NULL, 0, 1, 1, mline, NULL);
 		}
 		ml = lines - 1;
 	    } else
@@ -1287,6 +1323,7 @@
 	return 0;
     }
     m = *mp;
+    mlastm = m->gnum;
     if (m->disp && (m->flags & CMF_DISPLINE)) {
 	if (mselect >= 0) {
 	    int mm = (mcols * ml), i;

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

