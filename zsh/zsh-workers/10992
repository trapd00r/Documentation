From zsh-workers-return-10992-mason-zsh=primenet.com.au@sunsite.auc.dk Fri Apr 28 07:37:49 2000
Return-Path: <zsh-workers-return-10992-mason-zsh=primenet.com.au@sunsite.auc.dk>
Delivered-To: mason-zsh@primenet.com.au
Received: (qmail 7467 invoked from network); 28 Apr 2000 07:37:48 -0000
Received: from sunsite.auc.dk (130.225.51.30)
  by ns1.primenet.com.au with SMTP; 28 Apr 2000 07:37:48 -0000
Received: (qmail 12246 invoked by alias); 28 Apr 2000 07:37:37 -0000
Mailing-List: contact zsh-workers-help@sunsite.auc.dk; run by ezmlm
Precedence: bulk
X-No-Archive: yes
Delivered-To: mailing list zsh-workers@sunsite.auc.dk
X-Seq: 10992
Received: (qmail 12238 invoked from network); 28 Apr 2000 07:37:36 -0000
Date: Fri, 28 Apr 2000 09:37:01 +0200 (MET DST)
Message-Id: <200004280737.JAA20503@beta.informatik.hu-berlin.de>
From: Sven Wischnowsky <wischnow@informatik.hu-berlin.de>
To: zsh-workers@sunsite.auc.dk
In-reply-to: "Bart Schaefer"'s message of Thu, 27 Apr 2000 15:47:00 +0000
Subject: Re: PATCH: Re: Lots of flickering in menu-selection, and a send-break problem


Bart Schaefer wrote:

> On Apr 27,  3:27pm, Sven Wischnowsky wrote:
> } Subject: Re: PATCH: Re: Lots of flickering in menu-selection, and a send-b
> }
> } cursor-wrap-around suggested by Bart, which seemed even more sensible
> } after thinking about it. The only irritating effect is that moving
> } left when at the top-left match wraps you around to the bottom-right
> } match. Is that how pine works?
> 
> Pine doesn't work very consistently in this regard; it does one thing in
> some selection lists and another thing in others.  The most common rule
> for up/down seems to be not to wrap at all; and, left/right never go past
> the first/last item, so they change lines only in the middle of the list.
> 
> On one screen where pine has multiple selection lists, up/down can "fall
> off" the current list and take you up or down entire categories, but left/
> right still can't go past the first/last item in the current list.

I almost thought so, and I prefer it to, I think it's a case where a
bit of inconsistency reduces the number of surprises.

So this makes it wrap around in at most one dimension.

Bye
 Sven

Index: Src/Zle/complist.c
===================================================================
RCS file: /cvsroot/zsh/zsh/Src/Zle/complist.c,v
retrieving revision 1.11
diff -u -r1.11 complist.c
--- Src/Zle/complist.c	2000/04/27 13:40:52	1.11
+++ Src/Zle/complist.c	2000/04/28 07:35:23
@@ -1809,12 +1809,23 @@
 		   cmd == Th(z_downlineorhistory) ||
 		   cmd == Th(z_downlineorsearch) ||
 		   cmd == Th(z_vidownlineorhistory)) {
+	    int omline;
+	    Cmatch **op;
+
 	    wrap = 0;
 
 	down:
 
+	    omline = mline;
+	    op = p;
+
 	    do {
 		if (mline == mlines - 1) {
+		    if (wrap & 2) {
+			mline = omline; 
+			p = op;
+			break;
+		    }
 		    p -= mline * mcols;
 		    mline = 0;
 		    wrap |= 1;
@@ -1832,12 +1843,23 @@
 		   cmd == Th(z_uplineorhistory) ||
 		   cmd == Th(z_uplineorsearch) ||
 		   cmd == Th(z_viuplineorhistory)) {
+	    int omline;
+	    Cmatch **op;
+
 	    wrap = 0;
 
 	up:
 
+	    omline = mline;
+	    op = p;
+
 	    do {
 		if (!mline) {
+		    if (wrap & 2) {
+			mline = omline; 
+			p = op;
+			break;
+		    }
 		    mline = mlines - 1;
 		    p += mline * mcols;
 		    wrap |= 1;
@@ -1948,17 +1970,22 @@
 	    p = lp;
 	} else if (cmd == Th(z_forwardchar) || cmd == Th(z_viforwardchar)) {
 	    int omcol;
-	    Cmatch *op;
+	    Cmatch **op;
 
 	    wrap = 0;
 
 	right:
 
 	    omcol = mcol;
-	    op = *p;
+	    op = p;
 
 	    do {
 		if (mcol == mcols - 1) {
+		    if (wrap & 1) {
+			p = op;
+			mcol = omcol;
+			break;
+		    }
 		    p -= mcol;
 		    mcol = 0;
 		    wrap |= 2;
@@ -1966,24 +1993,29 @@
 		    mcol++;
 		    p++;
 		}
-	    } while (!*p || (mcol != omcol && *p == op));
+	    } while (!*p || (mcol != omcol && *p == *op));
 	    wishcol = mcol;
 
 	    if (wrap == 2)
 		goto down;
 	} else if (cmd == Th(z_backwardchar) || cmd == Th(z_vibackwardchar)) {
 	    int omcol;
-	    Cmatch *op;
+	    Cmatch **op;
 
 	    wrap = 0;
 
 	left:
 
 	    omcol = mcol;
-	    op = *p;
+	    op = p;
 
 	    do {
 		if (!mcol) {
+		    if (wrap & 1) {
+			p = op;
+			mcol = omcol;
+			break;
+		    }
 		    mcol = mcols - 1;
 		    p += mcol;
 		    wrap |= 2;
@@ -1991,7 +2023,7 @@
 		    mcol--;
 		    p--;
 		}
-	    } while (!*p || (mcol != omcol && *p == op));
+	    } while (!*p || (mcol != omcol && *p == *op));
 	    wishcol = mcol;
 
 	    if (wrap == 2)

--
Sven Wischnowsky                         wischnow@informatik.hu-berlin.de

