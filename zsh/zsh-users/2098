From: "Bart Schaefer" <schaefer@brasslantern.com>
Message-Id: <990204210755.ZM20448@candle.brasslantern.com>
Date: Thu, 4 Feb 1999 21:07:55 -0800
To: Sweth Chandramouli <sweth@astaroth.nit.gwu.edu>, zsh-users@math.gatech.edu
Subject: Re: globbing for links in pathnames
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Status: RO
X-Mailing-List: <zsh-users@sunsite.auc.dk> 2098

On Feb 4, 11:22pm, Sweth Chandramouli wrote:
} Subject: Re: globbing for links in pathnames
}
} On Thu, Feb 04, 1999 at 04:56:00PM -0800, Bart Schaefer wrote:
} > zsh% setopt globassign
} > zsh% x=*(@) eval 'ls $^x/man(/)'
} 
} 	according to the docs, globassign is deprecated, because
} globbing is done implicitly so long as the parameter is explicitly
} set to an array.

D'oh!  I was distracted by attempting to get globbing to happen in the
right-side of ${x::=*(@)}, discovered that glob_assign wouldn't do it,
and then just left it there and typed the other solution.

} so it should end up something like the following:
} 
} x=(pkgs/*(@)) ; ls -d ${^x}/man(/)

The reason I used the eval was to avoid having x remain set after the
command completes.  `x=(*(@)) eval ...` will unset x again at the end
of the eval, and won't destroy any existing value of x.

zsh% x=START ; x=NEXT eval 'echo $x' ; echo $x
NEXT
START

} 	-- sweth, who is now wondering if he could combine this
} with the earlier discussion about nested expansion to make a single
} inscrutable argument to ls -d to achieve this via (P).

The new (P) flag won't help with this; it only does an extra level of
variable name lookup.

There's no way to get globbing to happen inside the ${...} expression
without using a command substitution.  So you could do

	ls -d pkgs/${^$(echo *(@))}/man(/)

but that actually has to fork a subshell for the $(...) so it's not as
efficient as the eval.

-- 
Bart Schaefer                                 Brass Lantern Enterprises
http://www.well.com/user/barts              http://www.brasslantern.com

