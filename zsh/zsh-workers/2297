From zsh-workers-request@euclid.skiles.gatech.edu  Thu Oct 31 12:57:22 1996
Return-Path: zsh-workers-request@euclid.skiles.gatech.edu
Received: from euclid.skiles.gatech.edu (list@euclid.skiles.gatech.edu [130.207.146.50]) by coral.primenet.com.au (8.7.5/8.7.3) with ESMTP id MAA23812 for <mason@primenet.com.au>; Thu, 31 Oct 1996 12:57:18 +1100 (EST)
Received: (from list@localhost) by euclid.skiles.gatech.edu (8.7.3/8.7.3) id UAA15824; Wed, 30 Oct 1996 20:47:58 -0500 (EST)
Resent-Date: Wed, 30 Oct 1996 20:47:58 -0500 (EST)
From: Zoltan Hidvegi <hzoli@cs.elte.hu>
Message-Id: <199610310128.CAA10691@hzoli.ppp.cs.elte.hu>
Subject: Re: 4 bugs
To: gwing@primenet.com.au (Geoff Wing)
Date: Thu, 31 Oct 1996 02:28:02 +0100 (MET)
Cc: zsh-workers@math.gatech.edu
In-Reply-To: <199610300048.LAA17530@coral.primenet.com.au> from Geoff Wing at "Oct 30, 96 11:48:16 am"
X-Mailer: ELM [version 2.4ME+ PL17 (25)]
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Resent-Message-ID: <"XKLAW1.0.9t3.DL0Uo"@euclid>
Resent-From: zsh-workers@math.gatech.edu
X-Mailing-List: <zsh-workers@math.gatech.edu> archive/latest/2297
X-Loop: zsh-workers@math.gatech.edu
Precedence: list
Resent-Sender: zsh-workers-request@math.gatech.edu

> 3. Really long lines in your HISTFILE get chopped into 1K blocks and allocated
>   a history line each when you start a shell - probably also when you load at
>   other times.

That's fixed by the patch below together by an other bug: <-21> range glob
does not work.  That stopped working when I modified zstrtol to recognize
signed numbers.  I do hope that it did not break anything else.

Zoltan

*** Src/glob.c	1996/10/30 23:41:58	3.1.0.0
--- Src/glob.c	1996/10/31 00:34:57	3.1.0.1
***************
*** 1089,1101 ****
  	int cnt;
  
  	for (str4 = str, cnt = 0; cnt || (*str != Comma && *str !=
! 					  Outbrace); str++)
  	    if (*str == Inbrace)
  		cnt++;
  	    else if (*str == Outbrace)
  		cnt--;
! 	    else if (!*str)
! 		exit(10);	/* slightly overemphatic, perhaps??? */
  	/* Concatenate the string before the braces (str3), the section *
  	 * just found (str4) and the text after the braces (str2)       */
  	zz = (char *)ncalloc(prev + (str - str4) + strlen(str2) + 1);
--- 1089,1101 ----
  	int cnt;
  
  	for (str4 = str, cnt = 0; cnt || (*str != Comma && *str !=
! 					  Outbrace); str++) {
  	    if (*str == Inbrace)
  		cnt++;
  	    else if (*str == Outbrace)
  		cnt--;
! 	    DPUTS(!*str, "BUG: illegal brace expansion");
! 	}
  	/* Concatenate the string before the braces (str3), the section *
  	 * just found (str4) and the text after the braces (str2)       */
  	zz = (char *)ncalloc(prev + (str - str4) + strlen(str2) + 1);
***************
*** 1783,1795 ****
  	    unsigned long t1, t2, t3;
  	    char *ptr;
  
  	    if (*++pat == Outang || 
  		(*pat == '-' && pat[1] == Outang && ++pat)) {
  		/* <> or <->:  any number matches */
! 		(void)zstrtol(pptr, &ptr, 10);
! 		if (ptr == pptr)
! 		    break;
! 		pptr = ptr;
  		pat++;
  	    } else {
  		/* Flag that there is no upper limit */
--- 1783,1794 ----
  	    unsigned long t1, t2, t3;
  	    char *ptr;
  
+ 	    if (!idigit(*pptr))
+ 		break;
  	    if (*++pat == Outang || 
  		(*pat == '-' && pat[1] == Outang && ++pat)) {
  		/* <> or <->:  any number matches */
! 		while (idigit(*++pptr));
  		pat++;
  	    } else {
  		/* Flag that there is no upper limit */
***************
*** 1800,1817 ****
  		 * unsigned arithmetic.
  		 */
  		t1 = (unsigned long)zstrtol(pptr, &ptr, 10);
- 		if (ptr == pptr)
- 		    break;
  		pptr = ptr;
  		/* t2 = lower limit */
! 		t2 = (unsigned long)zstrtol(pat, &ptr, 10);
  		if (*ptr != '-' || (not3 = (ptr[1] == Outang)))
  				/* exact match or no upper limit */
  		    t3 = t2, pat = ptr + not3;
  		else		/* t3 = upper limit */
  		    t3 = (unsigned long)zstrtol(ptr + 1, &pat, 10);
! 		if (*pat++ != Outang)
! 		    exit(21);
  		if (t1 < t2 || (!not3 && t1 > t3))
  		    break;
  	    }
--- 1799,1817 ----
  		 * unsigned arithmetic.
  		 */
  		t1 = (unsigned long)zstrtol(pptr, &ptr, 10);
  		pptr = ptr;
  		/* t2 = lower limit */
! 		if (idigit(*pat))
! 		    t2 = (unsigned long)zstrtol(pat, &ptr, 10);
! 		else
! 		    t2 = 0, ptr = pat;
  		if (*ptr != '-' || (not3 = (ptr[1] == Outang)))
  				/* exact match or no upper limit */
  		    t3 = t2, pat = ptr + not3;
  		else		/* t3 = upper limit */
  		    t3 = (unsigned long)zstrtol(ptr + 1, &pat, 10);
! 		DPUTS(*pat != Outang, "BUG: wrong internal range pattern");
! 		pat++;
  		if (t1 < t2 || (!not3 && t1 > t3))
  		    break;
  	    }
*** Src/hist.c	1996/10/30 23:41:58	3.1.0.0
--- Src/hist.c	1996/10/31 01:21:15
***************
*** 1325,1352 ****
  void
  readhistfile(char *s, int err)
  {
!     char buf[1024];
      FILE *in;
      Histent ent;
      time_t tim = time(NULL);
      short *wordlist;
!     int nwordpos, nwordlist;
  
      if (!s)
  	return;
      if ((in = fopen(unmeta(s), "r"))) {
  	nwordlist = 16;
  	wordlist = (short *)zalloc(nwordlist*sizeof(short));
  
! 	while (fgets(buf, sizeof(buf), in)) {
  	    int l = strlen(buf);
  	    char *pt, *start;
  
! 	    while (l && buf[l - 1] == '\n') {
  		buf[l - 1] = '\0';
  		if (l > 1 && buf[l - 2] == '\\') {
  		    buf[l - 2] = '\n';
! 		    fgets(buf + l - 1, sizeof(buf) - (l - 1), in);
  		    l = strlen(buf);
  		} else
  		    break;
--- 1325,1363 ----
  void
  readhistfile(char *s, int err)
  {
!     char *buf;
      FILE *in;
      Histent ent;
      time_t tim = time(NULL);
      short *wordlist;
!     int nwordpos, nwordlist, bufsiz;
  
      if (!s)
  	return;
      if ((in = fopen(unmeta(s), "r"))) {
  	nwordlist = 16;
  	wordlist = (short *)zalloc(nwordlist*sizeof(short));
+ 	bufsiz = 1024;
+ 	buf = zalloc(bufsiz);
  
! 	while (fgets(buf, bufsiz, in)) {
  	    int l = strlen(buf);
  	    char *pt, *start;
  
! 	    while (l) {
! 		while (buf[l - 1] != '\n') {
! 		    buf = zrealloc(buf, 2 * bufsiz);
! 		    bufsiz = 2 * bufsiz;
! 		    if (!fgets(buf + l, bufsiz - l, in)) {
! 			l++;
! 			break;
! 		    }
! 		    l = strlen(buf);
! 		}
  		buf[l - 1] = '\0';
  		if (l > 1 && buf[l - 2] == '\\') {
  		    buf[l - 2] = '\n';
! 		    fgets(buf + l - 1, bufsiz - (l - 1), in);
  		    l = strlen(buf);
  		} else
  		    break;
***************
*** 1410,1415 ****
--- 1421,1427 ----
  	fclose(in);
  
  	zfree(wordlist, nwordlist*sizeof(short));
+ 	zfree(buf, bufsiz);
      } else if (err)
  	zerr("can't read history file", s, 0);
  }

